
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

000001c0 <Reset_Handler>:
     1c0:	b672      	cpsid	i
     1c2:	4821      	ldr	r0, [pc, #132]	; (248 <endfiniloop+0x4>)
     1c4:	f380 8809 	msr	PSP, r0
     1c8:	2002      	movs	r0, #2
     1ca:	f380 8814 	msr	CONTROL, r0
     1ce:	f3bf 8f6f 	isb	sy
     1d2:	f000 f875 	bl	2c0 <__core_init>
     1d6:	f003 fc1b 	bl	3a10 <__early_init>
     1da:	481c      	ldr	r0, [pc, #112]	; (24c <endfiniloop+0x8>)
     1dc:	491c      	ldr	r1, [pc, #112]	; (250 <endfiniloop+0xc>)
     1de:	4a1d      	ldr	r2, [pc, #116]	; (254 <endfiniloop+0x10>)

000001e0 <msloop>:
     1e0:	4291      	cmp	r1, r2
     1e2:	bf3c      	itt	cc
     1e4:	f841 0b04 	strcc.w	r0, [r1], #4
     1e8:	e7fa      	bcc.n	1e0 <msloop>
     1ea:	491b      	ldr	r1, [pc, #108]	; (258 <endfiniloop+0x14>)
     1ec:	4a16      	ldr	r2, [pc, #88]	; (248 <endfiniloop+0x4>)

000001ee <psloop>:
     1ee:	4291      	cmp	r1, r2
     1f0:	bf3c      	itt	cc
     1f2:	f841 0b04 	strcc.w	r0, [r1], #4
     1f6:	e7fa      	bcc.n	1ee <psloop>
     1f8:	4918      	ldr	r1, [pc, #96]	; (25c <endfiniloop+0x18>)
     1fa:	4a19      	ldr	r2, [pc, #100]	; (260 <endfiniloop+0x1c>)
     1fc:	4b19      	ldr	r3, [pc, #100]	; (264 <endfiniloop+0x20>)

000001fe <dloop>:
     1fe:	429a      	cmp	r2, r3
     200:	bf3e      	ittt	cc
     202:	f851 0b04 	ldrcc.w	r0, [r1], #4
     206:	f842 0b04 	strcc.w	r0, [r2], #4
     20a:	e7f8      	bcc.n	1fe <dloop>
     20c:	2000      	movs	r0, #0
     20e:	4916      	ldr	r1, [pc, #88]	; (268 <endfiniloop+0x24>)
     210:	4a16      	ldr	r2, [pc, #88]	; (26c <endfiniloop+0x28>)

00000212 <bloop>:
     212:	4291      	cmp	r1, r2
     214:	bf3c      	itt	cc
     216:	f841 0b04 	strcc.w	r0, [r1], #4
     21a:	e7fa      	bcc.n	212 <bloop>
     21c:	f000 f858 	bl	2d0 <__late_init>
     220:	4c13      	ldr	r4, [pc, #76]	; (270 <endfiniloop+0x2c>)
     222:	4d14      	ldr	r5, [pc, #80]	; (274 <endfiniloop+0x30>)

00000224 <initloop>:
     224:	42ac      	cmp	r4, r5
     226:	da03      	bge.n	230 <endinitloop>
     228:	f854 1b04 	ldr.w	r1, [r4], #4
     22c:	4788      	blx	r1
     22e:	e7f9      	b.n	224 <initloop>

00000230 <endinitloop>:
     230:	f003 fbfe 	bl	3a30 <main>
     234:	4c10      	ldr	r4, [pc, #64]	; (278 <endfiniloop+0x34>)
     236:	4d11      	ldr	r5, [pc, #68]	; (27c <endfiniloop+0x38>)

00000238 <finiloop>:
     238:	42ac      	cmp	r4, r5
     23a:	da03      	bge.n	244 <endfiniloop>
     23c:	f854 1b04 	ldr.w	r1, [r4], #4
     240:	4788      	blx	r1
     242:	e7f9      	b.n	238 <finiloop>

00000244 <endfiniloop>:
     244:	f000 b84c 	b.w	2e0 <__default_exit>
     248:	20000800 	.word	0x20000800
     24c:	55555555 	.word	0x55555555
     250:	20000000 	.word	0x20000000
     254:	20000400 	.word	0x20000400
     258:	20000400 	.word	0x20000400
     25c:	00004000 	.word	0x00004000
     260:	20000800 	.word	0x20000800
     264:	20000800 	.word	0x20000800
     268:	20000800 	.word	0x20000800
     26c:	20001150 	.word	0x20001150
     270:	000001c0 	.word	0x000001c0
     274:	000001c0 	.word	0x000001c0
     278:	000001c0 	.word	0x000001c0
     27c:	000001c0 	.word	0x000001c0

00000280 <_port_switch>:
     280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     284:	f8c1 d00c 	str.w	sp, [r1, #12]
     288:	f8d0 d00c 	ldr.w	sp, [r0, #12]
     28c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00000290 <_port_thread_start>:
     290:	f000 fa8e 	bl	7b0 <_dbg_check_unlock>
     294:	f001 fb24 	bl	18e0 <_stats_stop_measure_crit_thd>
     298:	2300      	movs	r3, #0
     29a:	f383 8811 	msr	BASEPRI, r3
     29e:	4628      	mov	r0, r5
     2a0:	47a0      	blx	r4
     2a2:	2000      	movs	r0, #0
     2a4:	f001 f964 	bl	1570 <chThdExit>

000002a8 <_port_switch_from_isr>:
     2a8:	f001 fb12 	bl	18d0 <_stats_start_measure_crit_thd>
     2ac:	f000 fa68 	bl	780 <_dbg_check_lock>
     2b0:	f000 ff4e 	bl	1150 <chSchDoReschedule>
     2b4:	f000 fa7c 	bl	7b0 <_dbg_check_unlock>
     2b8:	f001 fb12 	bl	18e0 <_stats_stop_measure_crit_thd>

000002bc <_port_exit_from_isr>:
     2bc:	df00      	svc	0
     2be:	e7fe      	b.n	2be <_port_exit_from_isr+0x2>

000002c0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
     2c0:	4770      	bx	lr
     2c2:	bf00      	nop
     2c4:	f3af 8000 	nop.w
     2c8:	f3af 8000 	nop.w
     2cc:	f3af 8000 	nop.w

000002d0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
     2d0:	4770      	bx	lr
     2d2:	bf00      	nop
     2d4:	f3af 8000 	nop.w
     2d8:	f3af 8000 	nop.w
     2dc:	f3af 8000 	nop.w

000002e0 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
     2e0:	e7fe      	b.n	2e0 <__default_exit>
     2e2:	bf00      	nop
     2e4:	f3af 8000 	nop.w
     2e8:	f3af 8000 	nop.w
     2ec:	f3af 8000 	nop.w

000002f0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
     2f0:	e7fe      	b.n	2f0 <_unhandled_exception>
     2f2:	bf00      	nop
     2f4:	f3af 8000 	nop.w
     2f8:	f3af 8000 	nop.w
     2fc:	f3af 8000 	nop.w

00000300 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
     300:	b084      	sub	sp, #16
     302:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
     304:	9b01      	ldr	r3, [sp, #4]
     306:	f003 0307 	and.w	r3, r3, #7
     30a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
     30c:	4b0a      	ldr	r3, [pc, #40]	; (338 <NVIC_SetPriorityGrouping+0x38>)
     30e:	68db      	ldr	r3, [r3, #12]
     310:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
     312:	9a02      	ldr	r2, [sp, #8]
     314:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
     318:	4013      	ands	r3, r2
     31a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
     31c:	9b03      	ldr	r3, [sp, #12]
     31e:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
     320:	9b02      	ldr	r3, [sp, #8]
     322:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
     324:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
     328:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     32c:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
     32e:	4b02      	ldr	r3, [pc, #8]	; (338 <NVIC_SetPriorityGrouping+0x38>)
     330:	9a02      	ldr	r2, [sp, #8]
     332:	60da      	str	r2, [r3, #12]
}
     334:	b004      	add	sp, #16
     336:	4770      	bx	lr
     338:	e000ed00 	.word	0xe000ed00
     33c:	f3af 8000 	nop.w

00000340 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
     340:	b082      	sub	sp, #8
     342:	4603      	mov	r3, r0
     344:	9100      	str	r1, [sp, #0]
     346:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
     34a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
     34e:	2b00      	cmp	r3, #0
     350:	da0c      	bge.n	36c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     352:	490c      	ldr	r1, [pc, #48]	; (384 <NVIC_SetPriority+0x44>)
     354:	f89d 3007 	ldrb.w	r3, [sp, #7]
     358:	f003 030f 	and.w	r3, r3, #15
     35c:	3b04      	subs	r3, #4
     35e:	9a00      	ldr	r2, [sp, #0]
     360:	b2d2      	uxtb	r2, r2
     362:	0112      	lsls	r2, r2, #4
     364:	b2d2      	uxtb	r2, r2
     366:	440b      	add	r3, r1
     368:	761a      	strb	r2, [r3, #24]
     36a:	e009      	b.n	380 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     36c:	4906      	ldr	r1, [pc, #24]	; (388 <NVIC_SetPriority+0x48>)
     36e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
     372:	9a00      	ldr	r2, [sp, #0]
     374:	b2d2      	uxtb	r2, r2
     376:	0112      	lsls	r2, r2, #4
     378:	b2d2      	uxtb	r2, r2
     37a:	440b      	add	r3, r1
     37c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
     380:	b002      	add	sp, #8
     382:	4770      	bx	lr
     384:	e000ed00 	.word	0xe000ed00
     388:	e000e100 	.word	0xe000e100
     38c:	f3af 8000 	nop.w

00000390 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
     390:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
     392:	4b0e      	ldr	r3, [pc, #56]	; (3cc <port_init+0x3c>)
     394:	2200      	movs	r2, #0
     396:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
     398:	2003      	movs	r0, #3
     39a:	f7ff ffb1 	bl	300 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
     39e:	4b0c      	ldr	r3, [pc, #48]	; (3d0 <port_init+0x40>)
     3a0:	4a0b      	ldr	r2, [pc, #44]	; (3d0 <port_init+0x40>)
     3a2:	68d2      	ldr	r2, [r2, #12]
     3a4:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
     3a8:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
     3aa:	4b0a      	ldr	r3, [pc, #40]	; (3d4 <port_init+0x44>)
     3ac:	4a09      	ldr	r2, [pc, #36]	; (3d4 <port_init+0x44>)
     3ae:	6812      	ldr	r2, [r2, #0]
     3b0:	f042 0201 	orr.w	r2, r2, #1
     3b4:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
     3b6:	f06f 0004 	mvn.w	r0, #4
     3ba:	2101      	movs	r1, #1
     3bc:	f7ff ffc0 	bl	340 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
     3c0:	f06f 0001 	mvn.w	r0, #1
     3c4:	2102      	movs	r1, #2
     3c6:	f7ff ffbb 	bl	340 <NVIC_SetPriority>
}
     3ca:	bd08      	pop	{r3, pc}
     3cc:	e000ed00 	.word	0xe000ed00
     3d0:	e000edf0 	.word	0xe000edf0
     3d4:	e0001000 	.word	0xe0001000
     3d8:	f3af 8000 	nop.w
     3dc:	f3af 8000 	nop.w

000003e0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     3e0:	b082      	sub	sp, #8
     3e2:	2320      	movs	r3, #32
     3e4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     3e6:	9b01      	ldr	r3, [sp, #4]
     3e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     3ec:	b002      	add	sp, #8
     3ee:	4770      	bx	lr

000003f0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     3f0:	b082      	sub	sp, #8
     3f2:	2300      	movs	r3, #0
     3f4:	9301      	str	r3, [sp, #4]
     3f6:	9b01      	ldr	r3, [sp, #4]
     3f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     3fc:	b002      	add	sp, #8
     3fe:	4770      	bx	lr

00000400 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     400:	b508      	push	{r3, lr}

  port_lock();
     402:	f7ff ffed 	bl	3e0 <port_lock>
}
     406:	bd08      	pop	{r3, pc}
     408:	f3af 8000 	nop.w
     40c:	f3af 8000 	nop.w

00000410 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     410:	b508      	push	{r3, lr}

  port_unlock();
     412:	f7ff ffed 	bl	3f0 <port_unlock>
}
     416:	bd08      	pop	{r3, pc}
     418:	f3af 8000 	nop.w
     41c:	f3af 8000 	nop.w

00000420 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
     420:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
     422:	4770      	bx	lr
     424:	f3af 8000 	nop.w
     428:	f3af 8000 	nop.w
     42c:	f3af 8000 	nop.w

00000430 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
     430:	b082      	sub	sp, #8
     432:	2300      	movs	r3, #0
     434:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     436:	9b01      	ldr	r3, [sp, #4]
     438:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
     43c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
     43e:	b002      	add	sp, #8
     440:	4770      	bx	lr
     442:	bf00      	nop
     444:	f3af 8000 	nop.w
     448:	f3af 8000 	nop.w
     44c:	f3af 8000 	nop.w

00000450 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
     450:	4770      	bx	lr
     452:	bf00      	nop
     454:	f3af 8000 	nop.w
     458:	f3af 8000 	nop.w
     45c:	f3af 8000 	nop.w

00000460 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     460:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     464:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     466:	4618      	mov	r0, r3
     468:	4770      	bx	lr
     46a:	bf00      	nop
     46c:	f3af 8000 	nop.w

00000470 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
     470:	b508      	push	{r3, lr}

  stStopAlarm();
     472:	f001 ff8d 	bl	2390 <stStopAlarm>
}
     476:	bd08      	pop	{r3, pc}
     478:	f3af 8000 	nop.w
     47c:	f3af 8000 	nop.w

00000480 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
     480:	b500      	push	{lr}
     482:	b083      	sub	sp, #12
     484:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
     486:	9801      	ldr	r0, [sp, #4]
     488:	f001 ff8a 	bl	23a0 <stSetAlarm>
}
     48c:	b003      	add	sp, #12
     48e:	f85d fb04 	ldr.w	pc, [sp], #4
     492:	bf00      	nop
     494:	f3af 8000 	nop.w
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w

000004a0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     4a0:	b508      	push	{r3, lr}

  return stGetCounter();
     4a2:	f7ff ffdd 	bl	460 <st_lld_get_counter>
     4a6:	4603      	mov	r3, r0
}
     4a8:	4618      	mov	r0, r3
     4aa:	bd08      	pop	{r3, pc}
     4ac:	f3af 8000 	nop.w

000004b0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
     4b0:	b508      	push	{r3, lr}

  _dbg_check_enable();
     4b2:	f000 f94d 	bl	750 <_dbg_check_enable>
  port_enable();
     4b6:	f7ff ffbb 	bl	430 <port_enable>
}
     4ba:	bd08      	pop	{r3, pc}
     4bc:	f3af 8000 	nop.w

000004c0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
     4c0:	b508      	push	{r3, lr}

  port_lock_from_isr();
     4c2:	f7ff ff9d 	bl	400 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
     4c6:	f001 fa13 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
     4ca:	f000 f989 	bl	7e0 <_dbg_check_lock_from_isr>
}
     4ce:	bd08      	pop	{r3, pc}

000004d0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
     4d0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
     4d2:	f000 f99d 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
     4d6:	f001 fa13 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
     4da:	f7ff ff99 	bl	410 <port_unlock_from_isr>
}
     4de:	bd08      	pop	{r3, pc}

000004e0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     4e0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     4e2:	f7ff ffdd 	bl	4a0 <port_timer_get_time>
     4e6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     4e8:	4618      	mov	r0, r3
     4ea:	bd08      	pop	{r3, pc}
     4ec:	f3af 8000 	nop.w

000004f0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
     4f0:	b500      	push	{lr}
     4f2:	b085      	sub	sp, #20

  chDbgCheckClassI();
     4f4:	f000 f9e4 	bl	8c0 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
     4f8:	4b33      	ldr	r3, [pc, #204]	; (5c8 <chVTDoTickI+0xd8>)
     4fa:	69db      	ldr	r3, [r3, #28]
     4fc:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
     4fe:	f7ff ffef 	bl	4e0 <chVTGetSystemTimeX>
     502:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
     504:	e02a      	b.n	55c <chVTDoTickI+0x6c>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
     506:	4b30      	ldr	r3, [pc, #192]	; (5c8 <chVTDoTickI+0xd8>)
     508:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     50a:	9b03      	ldr	r3, [sp, #12]
     50c:	689b      	ldr	r3, [r3, #8]
     50e:	441a      	add	r2, r3
     510:	4b2d      	ldr	r3, [pc, #180]	; (5c8 <chVTDoTickI+0xd8>)
     512:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     514:	9b03      	ldr	r3, [sp, #12]
     516:	681b      	ldr	r3, [r3, #0]
     518:	4a2c      	ldr	r2, [pc, #176]	; (5cc <chVTDoTickI+0xdc>)
     51a:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
     51c:	9b03      	ldr	r3, [sp, #12]
     51e:	681a      	ldr	r2, [r3, #0]
     520:	4b29      	ldr	r3, [pc, #164]	; (5c8 <chVTDoTickI+0xd8>)
     522:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
     524:	9b03      	ldr	r3, [sp, #12]
     526:	68db      	ldr	r3, [r3, #12]
     528:	9300      	str	r3, [sp, #0]
    vtp->vt_func = NULL;
     52a:	9b03      	ldr	r3, [sp, #12]
     52c:	2200      	movs	r2, #0
     52e:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
     530:	4b25      	ldr	r3, [pc, #148]	; (5c8 <chVTDoTickI+0xd8>)
     532:	69da      	ldr	r2, [r3, #28]
     534:	4b25      	ldr	r3, [pc, #148]	; (5cc <chVTDoTickI+0xdc>)
     536:	429a      	cmp	r2, r3
     538:	d101      	bne.n	53e <chVTDoTickI+0x4e>
      port_timer_stop_alarm();
     53a:	f7ff ff99 	bl	470 <port_timer_stop_alarm>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
     53e:	f7ff ffc7 	bl	4d0 <chSysUnlockFromISR>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
     542:	9b03      	ldr	r3, [sp, #12]
     544:	691a      	ldr	r2, [r3, #16]
     546:	9b00      	ldr	r3, [sp, #0]
     548:	4610      	mov	r0, r2
     54a:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
     54c:	f7ff ffb8 	bl	4c0 <chSysLockFromISR>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
     550:	4b1d      	ldr	r3, [pc, #116]	; (5c8 <chVTDoTickI+0xd8>)
     552:	69db      	ldr	r3, [r3, #28]
     554:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
     556:	f7ff ffc3 	bl	4e0 <chVTGetSystemTimeX>
     55a:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
     55c:	9b03      	ldr	r3, [sp, #12]
     55e:	689a      	ldr	r2, [r3, #8]
     560:	4b19      	ldr	r3, [pc, #100]	; (5c8 <chVTDoTickI+0xd8>)
     562:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     564:	9902      	ldr	r1, [sp, #8]
     566:	1acb      	subs	r3, r1, r3
     568:	429a      	cmp	r2, r3
     56a:	d9cc      	bls.n	506 <chVTDoTickI+0x16>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
     56c:	4b16      	ldr	r3, [pc, #88]	; (5c8 <chVTDoTickI+0xd8>)
     56e:	69da      	ldr	r2, [r3, #28]
     570:	4b16      	ldr	r3, [pc, #88]	; (5cc <chVTDoTickI+0xdc>)
     572:	429a      	cmp	r2, r3
     574:	d100      	bne.n	578 <chVTDoTickI+0x88>
    return;
     576:	e023      	b.n	5c0 <chVTDoTickI+0xd0>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
     578:	4b13      	ldr	r3, [pc, #76]	; (5c8 <chVTDoTickI+0xd8>)
     57a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     57c:	9b03      	ldr	r3, [sp, #12]
     57e:	689b      	ldr	r3, [r3, #8]
     580:	441a      	add	r2, r3
     582:	9b02      	ldr	r3, [sp, #8]
     584:	1ad3      	subs	r3, r2, r3
     586:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
     588:	9b01      	ldr	r3, [sp, #4]
     58a:	2b01      	cmp	r3, #1
     58c:	d801      	bhi.n	592 <chVTDoTickI+0xa2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
     58e:	2302      	movs	r3, #2
     590:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
     592:	9a02      	ldr	r2, [sp, #8]
     594:	9b01      	ldr	r3, [sp, #4]
     596:	4413      	add	r3, r2
     598:	4618      	mov	r0, r3
     59a:	f7ff ff71 	bl	480 <port_timer_set_alarm>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
     59e:	f7ff ff9f 	bl	4e0 <chVTGetSystemTimeX>
     5a2:	4602      	mov	r2, r0
     5a4:	4b08      	ldr	r3, [pc, #32]	; (5c8 <chVTDoTickI+0xd8>)
     5a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     5a8:	1ad2      	subs	r2, r2, r3
     5aa:	9902      	ldr	r1, [sp, #8]
     5ac:	9b01      	ldr	r3, [sp, #4]
     5ae:	4419      	add	r1, r3
     5b0:	4b05      	ldr	r3, [pc, #20]	; (5c8 <chVTDoTickI+0xd8>)
     5b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     5b4:	1acb      	subs	r3, r1, r3
     5b6:	429a      	cmp	r2, r3
     5b8:	d902      	bls.n	5c0 <chVTDoTickI+0xd0>
     5ba:	4805      	ldr	r0, [pc, #20]	; (5d0 <chVTDoTickI+0xe0>)
     5bc:	f000 f878 	bl	6b0 <chSysHalt>
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     5c0:	b005      	add	sp, #20
     5c2:	f85d fb04 	ldr.w	pc, [sp], #4
     5c6:	bf00      	nop
     5c8:	20000800 	.word	0x20000800
     5cc:	2000081c 	.word	0x2000081c
     5d0:	00003c20 	.word	0x00003c20
     5d4:	f3af 8000 	nop.w
     5d8:	f3af 8000 	nop.w
     5dc:	f3af 8000 	nop.w

000005e0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
     5e0:	b082      	sub	sp, #8
     5e2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
     5e4:	4b02      	ldr	r3, [pc, #8]	; (5f0 <chRegSetThreadName+0x10>)
     5e6:	699b      	ldr	r3, [r3, #24]
     5e8:	9a01      	ldr	r2, [sp, #4]
     5ea:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
     5ec:	b002      	add	sp, #8
     5ee:	4770      	bx	lr
     5f0:	20000800 	.word	0x20000800
     5f4:	f3af 8000 	nop.w
     5f8:	f3af 8000 	nop.w
     5fc:	f3af 8000 	nop.w

00000600 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
     600:	b082      	sub	sp, #8
     602:	9001      	str	r0, [sp, #4]
     604:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
     606:	9b01      	ldr	r3, [sp, #4]
     608:	9a00      	ldr	r2, [sp, #0]
     60a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
     60c:	b002      	add	sp, #8
     60e:	4770      	bx	lr

00000610 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
     610:	b500      	push	{lr}
     612:	b083      	sub	sp, #12
     614:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
     616:	f7ff ff1b 	bl	450 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
  }
     61a:	e7fc      	b.n	616 <_idle_thread+0x6>
     61c:	f3af 8000 	nop.w

00000620 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
     620:	b500      	push	{lr}
     622:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
     624:	f7ff feb4 	bl	390 <port_init>
  _scheduler_init();
     628:	f000 fbc2 	bl	db0 <_scheduler_init>
  _vt_init();
     62c:	f000 f9f8 	bl	a20 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
     630:	f001 f88e 	bl	1750 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
     634:	f001 fd64 	bl	2100 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
     638:	f001 fdb2 	bl	21a0 <_heap_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  _stats_init();
     63c:	f001 f900 	bl	1840 <_stats_init>
#endif
#if CH_DBG_ENABLE_TRACE == TRUE
  _dbg_trace_init();
     640:	f000 f96e 	bl	920 <_dbg_trace_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
     644:	4812      	ldr	r0, [pc, #72]	; (690 <chSysInit+0x70>)
     646:	2140      	movs	r1, #64	; 0x40
     648:	f000 fe7a 	bl	1340 <_thread_init>
     64c:	4602      	mov	r2, r0
     64e:	4b11      	ldr	r3, [pc, #68]	; (694 <chSysInit+0x74>)
     650:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
     652:	4b10      	ldr	r3, [pc, #64]	; (694 <chSysInit+0x74>)
     654:	699b      	ldr	r3, [r3, #24]
     656:	2201      	movs	r2, #1
     658:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
     65c:	4b0d      	ldr	r3, [pc, #52]	; (694 <chSysInit+0x74>)
     65e:	699b      	ldr	r3, [r3, #24]
     660:	4a0d      	ldr	r2, [pc, #52]	; (698 <chSysInit+0x78>)
     662:	61da      	str	r2, [r3, #28]
#endif
  chSysEnable();
     664:	f7ff ff24 	bl	4b0 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
     668:	480c      	ldr	r0, [pc, #48]	; (69c <chSysInit+0x7c>)
     66a:	f7ff ffb9 	bl	5e0 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
     66e:	2300      	movs	r3, #0
     670:	9300      	str	r3, [sp, #0]
     672:	480b      	ldr	r0, [pc, #44]	; (6a0 <chSysInit+0x80>)
     674:	21f8      	movs	r1, #248	; 0xf8
     676:	2201      	movs	r2, #1
     678:	4b0a      	ldr	r3, [pc, #40]	; (6a4 <chSysInit+0x84>)
     67a:	f000 ff01 	bl	1480 <chThdCreateStatic>
     67e:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
     680:	9803      	ldr	r0, [sp, #12]
     682:	4909      	ldr	r1, [pc, #36]	; (6a8 <chSysInit+0x88>)
     684:	f7ff ffbc 	bl	600 <chRegSetThreadNameX>
  }
#endif
}
     688:	b005      	add	sp, #20
     68a:	f85d fb04 	ldr.w	pc, [sp], #4
     68e:	bf00      	nop
     690:	20000c40 	.word	0x20000c40
     694:	20000800 	.word	0x20000800
     698:	20000400 	.word	0x20000400
     69c:	00003cf0 	.word	0x00003cf0
     6a0:	20000ce0 	.word	0x20000ce0
     6a4:	00000611 	.word	0x00000611
     6a8:	00003ba0 	.word	0x00003ba0
     6ac:	f3af 8000 	nop.w

000006b0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
     6b0:	b500      	push	{lr}
     6b2:	b083      	sub	sp, #12
     6b4:	9001      	str	r0, [sp, #4]

  port_disable();
     6b6:	f7ff feb3 	bl	420 <port_disable>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
     6ba:	4b02      	ldr	r3, [pc, #8]	; (6c4 <chSysHalt+0x14>)
     6bc:	9a01      	ldr	r2, [sp, #4]
     6be:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
     6c0:	e7fe      	b.n	6c0 <chSysHalt+0x10>
     6c2:	bf00      	nop
     6c4:	20000800 	.word	0x20000800
     6c8:	f3af 8000 	nop.w
     6cc:	f3af 8000 	nop.w

000006d0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     6d0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
     6d2:	f000 f8f5 	bl	8c0 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
     6d6:	f7ff ff0b 	bl	4f0 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
     6da:	bd08      	pop	{r3, pc}
     6dc:	f3af 8000 	nop.w

000006e0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     6e0:	b082      	sub	sp, #8
     6e2:	2320      	movs	r3, #32
     6e4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     6e6:	9b01      	ldr	r3, [sp, #4]
     6e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     6ec:	b002      	add	sp, #8
     6ee:	4770      	bx	lr

000006f0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     6f0:	b082      	sub	sp, #8
     6f2:	2300      	movs	r3, #0
     6f4:	9301      	str	r3, [sp, #4]
     6f6:	9b01      	ldr	r3, [sp, #4]
     6f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     6fc:	b002      	add	sp, #8
     6fe:	4770      	bx	lr

00000700 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     700:	b508      	push	{r3, lr}

  port_lock();
     702:	f7ff ffed 	bl	6e0 <port_lock>
}
     706:	bd08      	pop	{r3, pc}
     708:	f3af 8000 	nop.w
     70c:	f3af 8000 	nop.w

00000710 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     710:	b508      	push	{r3, lr}

  port_unlock();
     712:	f7ff ffed 	bl	6f0 <port_unlock>
}
     716:	bd08      	pop	{r3, pc}
     718:	f3af 8000 	nop.w
     71c:	f3af 8000 	nop.w

00000720 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     720:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     724:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     726:	4618      	mov	r0, r3
     728:	4770      	bx	lr
     72a:	bf00      	nop
     72c:	f3af 8000 	nop.w

00000730 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     730:	b508      	push	{r3, lr}

  return stGetCounter();
     732:	f7ff fff5 	bl	720 <st_lld_get_counter>
     736:	4603      	mov	r3, r0
}
     738:	4618      	mov	r0, r3
     73a:	bd08      	pop	{r3, pc}
     73c:	f3af 8000 	nop.w

00000740 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     740:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     742:	f7ff fff5 	bl	730 <port_timer_get_time>
     746:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     748:	4618      	mov	r0, r3
     74a:	bd08      	pop	{r3, pc}
     74c:	f3af 8000 	nop.w

00000750 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
     750:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     752:	4b06      	ldr	r3, [pc, #24]	; (76c <_dbg_check_enable+0x1c>)
     754:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     756:	2b00      	cmp	r3, #0
     758:	d103      	bne.n	762 <_dbg_check_enable+0x12>
     75a:	4b04      	ldr	r3, [pc, #16]	; (76c <_dbg_check_enable+0x1c>)
     75c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     75e:	2b00      	cmp	r3, #0
     760:	d002      	beq.n	768 <_dbg_check_enable+0x18>
    chSysHalt("SV#3");
     762:	4803      	ldr	r0, [pc, #12]	; (770 <_dbg_check_enable+0x20>)
     764:	f7ff ffa4 	bl	6b0 <chSysHalt>
  }
}
     768:	bd08      	pop	{r3, pc}
     76a:	bf00      	nop
     76c:	20000800 	.word	0x20000800
     770:	00003bc0 	.word	0x00003bc0
     774:	f3af 8000 	nop.w
     778:	f3af 8000 	nop.w
     77c:	f3af 8000 	nop.w

00000780 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
     780:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     782:	4b07      	ldr	r3, [pc, #28]	; (7a0 <_dbg_check_lock+0x20>)
     784:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     786:	2b00      	cmp	r3, #0
     788:	d103      	bne.n	792 <_dbg_check_lock+0x12>
     78a:	4b05      	ldr	r3, [pc, #20]	; (7a0 <_dbg_check_lock+0x20>)
     78c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     78e:	2b00      	cmp	r3, #0
     790:	d002      	beq.n	798 <_dbg_check_lock+0x18>
    chSysHalt("SV#4");
     792:	4804      	ldr	r0, [pc, #16]	; (7a4 <_dbg_check_lock+0x24>)
     794:	f7ff ff8c 	bl	6b0 <chSysHalt>
  }
  _dbg_enter_lock();
     798:	4b01      	ldr	r3, [pc, #4]	; (7a0 <_dbg_check_lock+0x20>)
     79a:	2201      	movs	r2, #1
     79c:	635a      	str	r2, [r3, #52]	; 0x34
}
     79e:	bd08      	pop	{r3, pc}
     7a0:	20000800 	.word	0x20000800
     7a4:	00003bc8 	.word	0x00003bc8
     7a8:	f3af 8000 	nop.w
     7ac:	f3af 8000 	nop.w

000007b0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
     7b0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     7b2:	4b07      	ldr	r3, [pc, #28]	; (7d0 <_dbg_check_unlock+0x20>)
     7b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     7b6:	2b00      	cmp	r3, #0
     7b8:	d103      	bne.n	7c2 <_dbg_check_unlock+0x12>
     7ba:	4b05      	ldr	r3, [pc, #20]	; (7d0 <_dbg_check_unlock+0x20>)
     7bc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     7be:	2b00      	cmp	r3, #0
     7c0:	dc02      	bgt.n	7c8 <_dbg_check_unlock+0x18>
    chSysHalt("SV#5");
     7c2:	4804      	ldr	r0, [pc, #16]	; (7d4 <_dbg_check_unlock+0x24>)
     7c4:	f7ff ff74 	bl	6b0 <chSysHalt>
  }
  _dbg_leave_lock();
     7c8:	4b01      	ldr	r3, [pc, #4]	; (7d0 <_dbg_check_unlock+0x20>)
     7ca:	2200      	movs	r2, #0
     7cc:	635a      	str	r2, [r3, #52]	; 0x34
}
     7ce:	bd08      	pop	{r3, pc}
     7d0:	20000800 	.word	0x20000800
     7d4:	00003bd0 	.word	0x00003bd0
     7d8:	f3af 8000 	nop.w
     7dc:	f3af 8000 	nop.w

000007e0 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
     7e0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     7e2:	4b07      	ldr	r3, [pc, #28]	; (800 <_dbg_check_lock_from_isr+0x20>)
     7e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     7e6:	2b00      	cmp	r3, #0
     7e8:	dd03      	ble.n	7f2 <_dbg_check_lock_from_isr+0x12>
     7ea:	4b05      	ldr	r3, [pc, #20]	; (800 <_dbg_check_lock_from_isr+0x20>)
     7ec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     7ee:	2b00      	cmp	r3, #0
     7f0:	d002      	beq.n	7f8 <_dbg_check_lock_from_isr+0x18>
    chSysHalt("SV#6");
     7f2:	4804      	ldr	r0, [pc, #16]	; (804 <_dbg_check_lock_from_isr+0x24>)
     7f4:	f7ff ff5c 	bl	6b0 <chSysHalt>
  }
  _dbg_enter_lock();
     7f8:	4b01      	ldr	r3, [pc, #4]	; (800 <_dbg_check_lock_from_isr+0x20>)
     7fa:	2201      	movs	r2, #1
     7fc:	635a      	str	r2, [r3, #52]	; 0x34
}
     7fe:	bd08      	pop	{r3, pc}
     800:	20000800 	.word	0x20000800
     804:	00003bd8 	.word	0x00003bd8
     808:	f3af 8000 	nop.w
     80c:	f3af 8000 	nop.w

00000810 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
     810:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     812:	4b07      	ldr	r3, [pc, #28]	; (830 <_dbg_check_unlock_from_isr+0x20>)
     814:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     816:	2b00      	cmp	r3, #0
     818:	dd03      	ble.n	822 <_dbg_check_unlock_from_isr+0x12>
     81a:	4b05      	ldr	r3, [pc, #20]	; (830 <_dbg_check_unlock_from_isr+0x20>)
     81c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     81e:	2b00      	cmp	r3, #0
     820:	dc02      	bgt.n	828 <_dbg_check_unlock_from_isr+0x18>
    chSysHalt("SV#7");
     822:	4804      	ldr	r0, [pc, #16]	; (834 <_dbg_check_unlock_from_isr+0x24>)
     824:	f7ff ff44 	bl	6b0 <chSysHalt>
  }
  _dbg_leave_lock();
     828:	4b01      	ldr	r3, [pc, #4]	; (830 <_dbg_check_unlock_from_isr+0x20>)
     82a:	2200      	movs	r2, #0
     82c:	635a      	str	r2, [r3, #52]	; 0x34
}
     82e:	bd08      	pop	{r3, pc}
     830:	20000800 	.word	0x20000800
     834:	00003be0 	.word	0x00003be0
     838:	f3af 8000 	nop.w
     83c:	f3af 8000 	nop.w

00000840 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
     840:	b508      	push	{r3, lr}

  port_lock_from_isr();
     842:	f7ff ff5d 	bl	700 <port_lock_from_isr>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     846:	4b09      	ldr	r3, [pc, #36]	; (86c <_dbg_check_enter_isr+0x2c>)
     848:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     84a:	2b00      	cmp	r3, #0
     84c:	db03      	blt.n	856 <_dbg_check_enter_isr+0x16>
     84e:	4b07      	ldr	r3, [pc, #28]	; (86c <_dbg_check_enter_isr+0x2c>)
     850:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     852:	2b00      	cmp	r3, #0
     854:	d002      	beq.n	85c <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
     856:	4806      	ldr	r0, [pc, #24]	; (870 <_dbg_check_enter_isr+0x30>)
     858:	f7ff ff2a 	bl	6b0 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
     85c:	4b03      	ldr	r3, [pc, #12]	; (86c <_dbg_check_enter_isr+0x2c>)
     85e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     860:	1c5a      	adds	r2, r3, #1
     862:	4b02      	ldr	r3, [pc, #8]	; (86c <_dbg_check_enter_isr+0x2c>)
     864:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
     866:	f7ff ff53 	bl	710 <port_unlock_from_isr>
}
     86a:	bd08      	pop	{r3, pc}
     86c:	20000800 	.word	0x20000800
     870:	00003be8 	.word	0x00003be8
     874:	f3af 8000 	nop.w
     878:	f3af 8000 	nop.w
     87c:	f3af 8000 	nop.w

00000880 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
     880:	b508      	push	{r3, lr}

  port_lock_from_isr();
     882:	f7ff ff3d 	bl	700 <port_lock_from_isr>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     886:	4b09      	ldr	r3, [pc, #36]	; (8ac <_dbg_check_leave_isr+0x2c>)
     888:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     88a:	2b00      	cmp	r3, #0
     88c:	dd03      	ble.n	896 <_dbg_check_leave_isr+0x16>
     88e:	4b07      	ldr	r3, [pc, #28]	; (8ac <_dbg_check_leave_isr+0x2c>)
     890:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     892:	2b00      	cmp	r3, #0
     894:	d002      	beq.n	89c <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
     896:	4806      	ldr	r0, [pc, #24]	; (8b0 <_dbg_check_leave_isr+0x30>)
     898:	f7ff ff0a 	bl	6b0 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
     89c:	4b03      	ldr	r3, [pc, #12]	; (8ac <_dbg_check_leave_isr+0x2c>)
     89e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     8a0:	1e5a      	subs	r2, r3, #1
     8a2:	4b02      	ldr	r3, [pc, #8]	; (8ac <_dbg_check_leave_isr+0x2c>)
     8a4:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
     8a6:	f7ff ff33 	bl	710 <port_unlock_from_isr>
}
     8aa:	bd08      	pop	{r3, pc}
     8ac:	20000800 	.word	0x20000800
     8b0:	00003bf0 	.word	0x00003bf0
     8b4:	f3af 8000 	nop.w
     8b8:	f3af 8000 	nop.w
     8bc:	f3af 8000 	nop.w

000008c0 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
     8c0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     8c2:	4b06      	ldr	r3, [pc, #24]	; (8dc <chDbgCheckClassI+0x1c>)
     8c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     8c6:	2b00      	cmp	r3, #0
     8c8:	db03      	blt.n	8d2 <chDbgCheckClassI+0x12>
     8ca:	4b04      	ldr	r3, [pc, #16]	; (8dc <chDbgCheckClassI+0x1c>)
     8cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     8ce:	2b00      	cmp	r3, #0
     8d0:	dc02      	bgt.n	8d8 <chDbgCheckClassI+0x18>
    chSysHalt("SV#10");
     8d2:	4803      	ldr	r0, [pc, #12]	; (8e0 <chDbgCheckClassI+0x20>)
     8d4:	f7ff feec 	bl	6b0 <chSysHalt>
  }
}
     8d8:	bd08      	pop	{r3, pc}
     8da:	bf00      	nop
     8dc:	20000800 	.word	0x20000800
     8e0:	00003bf8 	.word	0x00003bf8
     8e4:	f3af 8000 	nop.w
     8e8:	f3af 8000 	nop.w
     8ec:	f3af 8000 	nop.w

000008f0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
     8f0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     8f2:	4b06      	ldr	r3, [pc, #24]	; (90c <chDbgCheckClassS+0x1c>)
     8f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     8f6:	2b00      	cmp	r3, #0
     8f8:	d103      	bne.n	902 <chDbgCheckClassS+0x12>
     8fa:	4b04      	ldr	r3, [pc, #16]	; (90c <chDbgCheckClassS+0x1c>)
     8fc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     8fe:	2b00      	cmp	r3, #0
     900:	dc02      	bgt.n	908 <chDbgCheckClassS+0x18>
    chSysHalt("SV#11");
     902:	4803      	ldr	r0, [pc, #12]	; (910 <chDbgCheckClassS+0x20>)
     904:	f7ff fed4 	bl	6b0 <chSysHalt>
  }
}
     908:	bd08      	pop	{r3, pc}
     90a:	bf00      	nop
     90c:	20000800 	.word	0x20000800
     910:	00003c00 	.word	0x00003c00
     914:	f3af 8000 	nop.w
     918:	f3af 8000 	nop.w
     91c:	f3af 8000 	nop.w

00000920 <_dbg_trace_init>:
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
     920:	4b03      	ldr	r3, [pc, #12]	; (930 <_dbg_trace_init+0x10>)
     922:	2240      	movs	r2, #64	; 0x40
     924:	639a      	str	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
     926:	4b02      	ldr	r3, [pc, #8]	; (930 <_dbg_trace_init+0x10>)
     928:	4a02      	ldr	r2, [pc, #8]	; (934 <_dbg_trace_init+0x14>)
     92a:	63da      	str	r2, [r3, #60]	; 0x3c
}
     92c:	4770      	bx	lr
     92e:	bf00      	nop
     930:	20000800 	.word	0x20000800
     934:	20000840 	.word	0x20000840
     938:	f3af 8000 	nop.w
     93c:	f3af 8000 	nop.w

00000940 <_dbg_trace>:
 *
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {
     940:	b510      	push	{r4, lr}
     942:	b082      	sub	sp, #8
     944:	9001      	str	r0, [sp, #4]

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
     946:	4b13      	ldr	r3, [pc, #76]	; (994 <_dbg_trace+0x54>)
     948:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
     94a:	f7ff fef9 	bl	740 <chVTGetSystemTimeX>
     94e:	4603      	mov	r3, r0
     950:	6023      	str	r3, [r4, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
     952:	4b10      	ldr	r3, [pc, #64]	; (994 <_dbg_trace+0x54>)
     954:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     956:	4a0f      	ldr	r2, [pc, #60]	; (994 <_dbg_trace+0x54>)
     958:	6992      	ldr	r2, [r2, #24]
     95a:	605a      	str	r2, [r3, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
     95c:	4b0d      	ldr	r3, [pc, #52]	; (994 <_dbg_trace+0x54>)
     95e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     960:	9a01      	ldr	r2, [sp, #4]
     962:	6a52      	ldr	r2, [r2, #36]	; 0x24
     964:	609a      	str	r2, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
     966:	4b0b      	ldr	r3, [pc, #44]	; (994 <_dbg_trace+0x54>)
     968:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     96a:	9a01      	ldr	r2, [sp, #4]
     96c:	f892 2020 	ldrb.w	r2, [r2, #32]
     970:	731a      	strb	r2, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
     972:	4b08      	ldr	r3, [pc, #32]	; (994 <_dbg_trace+0x54>)
     974:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     976:	f103 0210 	add.w	r2, r3, #16
     97a:	4b06      	ldr	r3, [pc, #24]	; (994 <_dbg_trace+0x54>)
     97c:	63da      	str	r2, [r3, #60]	; 0x3c
     97e:	4b05      	ldr	r3, [pc, #20]	; (994 <_dbg_trace+0x54>)
     980:	6bda      	ldr	r2, [r3, #60]	; 0x3c
     982:	4b05      	ldr	r3, [pc, #20]	; (998 <_dbg_trace+0x58>)
     984:	429a      	cmp	r2, r3
     986:	d302      	bcc.n	98e <_dbg_trace+0x4e>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
     988:	4b02      	ldr	r3, [pc, #8]	; (994 <_dbg_trace+0x54>)
     98a:	4a04      	ldr	r2, [pc, #16]	; (99c <_dbg_trace+0x5c>)
     98c:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
     98e:	b002      	add	sp, #8
     990:	bd10      	pop	{r4, pc}
     992:	bf00      	nop
     994:	20000800 	.word	0x20000800
     998:	20000c40 	.word	0x20000c40
     99c:	20000840 	.word	0x20000840

000009a0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     9a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     9a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     9a6:	4618      	mov	r0, r3
     9a8:	4770      	bx	lr
     9aa:	bf00      	nop
     9ac:	f3af 8000 	nop.w

000009b0 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
     9b0:	b500      	push	{lr}
     9b2:	b083      	sub	sp, #12
     9b4:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
     9b6:	9801      	ldr	r0, [sp, #4]
     9b8:	f001 fcd2 	bl	2360 <stStartAlarm>
}
     9bc:	b003      	add	sp, #12
     9be:	f85d fb04 	ldr.w	pc, [sp], #4
     9c2:	bf00      	nop
     9c4:	f3af 8000 	nop.w
     9c8:	f3af 8000 	nop.w
     9cc:	f3af 8000 	nop.w

000009d0 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
     9d0:	b508      	push	{r3, lr}

  stStopAlarm();
     9d2:	f001 fcdd 	bl	2390 <stStopAlarm>
}
     9d6:	bd08      	pop	{r3, pc}
     9d8:	f3af 8000 	nop.w
     9dc:	f3af 8000 	nop.w

000009e0 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
     9e0:	b500      	push	{lr}
     9e2:	b083      	sub	sp, #12
     9e4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
     9e6:	9801      	ldr	r0, [sp, #4]
     9e8:	f001 fcda 	bl	23a0 <stSetAlarm>
}
     9ec:	b003      	add	sp, #12
     9ee:	f85d fb04 	ldr.w	pc, [sp], #4
     9f2:	bf00      	nop
     9f4:	f3af 8000 	nop.w
     9f8:	f3af 8000 	nop.w
     9fc:	f3af 8000 	nop.w

00000a00 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     a00:	b508      	push	{r3, lr}

  return stGetCounter();
     a02:	f7ff ffcd 	bl	9a0 <st_lld_get_counter>
     a06:	4603      	mov	r3, r0
}
     a08:	4618      	mov	r0, r3
     a0a:	bd08      	pop	{r3, pc}
     a0c:	f3af 8000 	nop.w

00000a10 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     a10:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     a12:	f7ff fff5 	bl	a00 <port_timer_get_time>
     a16:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     a18:	4618      	mov	r0, r3
     a1a:	bd08      	pop	{r3, pc}
     a1c:	f3af 8000 	nop.w

00000a20 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
     a20:	4b06      	ldr	r3, [pc, #24]	; (a3c <_vt_init+0x1c>)
     a22:	4a07      	ldr	r2, [pc, #28]	; (a40 <_vt_init+0x20>)
     a24:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
     a26:	4b05      	ldr	r3, [pc, #20]	; (a3c <_vt_init+0x1c>)
     a28:	4a05      	ldr	r2, [pc, #20]	; (a40 <_vt_init+0x20>)
     a2a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
     a2c:	4b03      	ldr	r3, [pc, #12]	; (a3c <_vt_init+0x1c>)
     a2e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     a32:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
     a34:	4b01      	ldr	r3, [pc, #4]	; (a3c <_vt_init+0x1c>)
     a36:	2200      	movs	r2, #0
     a38:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     a3a:	4770      	bx	lr
     a3c:	20000800 	.word	0x20000800
     a40:	2000081c 	.word	0x2000081c
     a44:	f3af 8000 	nop.w
     a48:	f3af 8000 	nop.w
     a4c:	f3af 8000 	nop.w

00000a50 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
     a50:	b500      	push	{lr}
     a52:	b089      	sub	sp, #36	; 0x24
     a54:	9003      	str	r0, [sp, #12]
     a56:	9102      	str	r1, [sp, #8]
     a58:	9201      	str	r2, [sp, #4]
     a5a:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
     a5c:	f7ff ff30 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
     a60:	9b03      	ldr	r3, [sp, #12]
     a62:	2b00      	cmp	r3, #0
     a64:	d005      	beq.n	a72 <chVTDoSetI+0x22>
     a66:	9b01      	ldr	r3, [sp, #4]
     a68:	2b00      	cmp	r3, #0
     a6a:	d002      	beq.n	a72 <chVTDoSetI+0x22>
     a6c:	9b02      	ldr	r3, [sp, #8]
     a6e:	2b00      	cmp	r3, #0
     a70:	d102      	bne.n	a78 <chVTDoSetI+0x28>
     a72:	483a      	ldr	r0, [pc, #232]	; (b5c <chVTDoSetI+0x10c>)
     a74:	f7ff fe1c 	bl	6b0 <chSysHalt>

  vtp->vt_par = par;
     a78:	9b03      	ldr	r3, [sp, #12]
     a7a:	9a00      	ldr	r2, [sp, #0]
     a7c:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
     a7e:	9b03      	ldr	r3, [sp, #12]
     a80:	9a01      	ldr	r2, [sp, #4]
     a82:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
     a84:	f7ff ffc4 	bl	a10 <chVTGetSystemTimeX>
     a88:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
     a8a:	9b02      	ldr	r3, [sp, #8]
     a8c:	2b01      	cmp	r3, #1
     a8e:	d801      	bhi.n	a94 <chVTDoSetI+0x44>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
     a90:	2302      	movs	r3, #2
     a92:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
     a94:	4b32      	ldr	r3, [pc, #200]	; (b60 <chVTDoSetI+0x110>)
     a96:	69da      	ldr	r2, [r3, #28]
     a98:	4b32      	ldr	r3, [pc, #200]	; (b64 <chVTDoSetI+0x114>)
     a9a:	429a      	cmp	r2, r3
     a9c:	d119      	bne.n	ad2 <chVTDoSetI+0x82>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
     a9e:	4b30      	ldr	r3, [pc, #192]	; (b60 <chVTDoSetI+0x110>)
     aa0:	9a05      	ldr	r2, [sp, #20]
     aa2:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
     aa4:	4b2e      	ldr	r3, [pc, #184]	; (b60 <chVTDoSetI+0x110>)
     aa6:	9a03      	ldr	r2, [sp, #12]
     aa8:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
     aaa:	4b2d      	ldr	r3, [pc, #180]	; (b60 <chVTDoSetI+0x110>)
     aac:	9a03      	ldr	r2, [sp, #12]
     aae:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
     ab0:	9b03      	ldr	r3, [sp, #12]
     ab2:	4a2c      	ldr	r2, [pc, #176]	; (b64 <chVTDoSetI+0x114>)
     ab4:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
     ab6:	9b03      	ldr	r3, [sp, #12]
     ab8:	4a2a      	ldr	r2, [pc, #168]	; (b64 <chVTDoSetI+0x114>)
     aba:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
     abc:	9b03      	ldr	r3, [sp, #12]
     abe:	9a02      	ldr	r2, [sp, #8]
     ac0:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
     ac2:	4b27      	ldr	r3, [pc, #156]	; (b60 <chVTDoSetI+0x110>)
     ac4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     ac6:	9b02      	ldr	r3, [sp, #8]
     ac8:	4413      	add	r3, r2
     aca:	4618      	mov	r0, r3
     acc:	f7ff ff70 	bl	9b0 <port_timer_start_alarm>

      return;
     ad0:	e040      	b.n	b54 <chVTDoSetI+0x104>
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
     ad2:	9a05      	ldr	r2, [sp, #20]
     ad4:	9b02      	ldr	r3, [sp, #8]
     ad6:	441a      	add	r2, r3
     ad8:	4b21      	ldr	r3, [pc, #132]	; (b60 <chVTDoSetI+0x110>)
     ada:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     adc:	1ad3      	subs	r3, r2, r3
     ade:	9306      	str	r3, [sp, #24]
    if (delta < ch.vtlist.vt_next->vt_delta) {
     ae0:	4b1f      	ldr	r3, [pc, #124]	; (b60 <chVTDoSetI+0x110>)
     ae2:	69db      	ldr	r3, [r3, #28]
     ae4:	689a      	ldr	r2, [r3, #8]
     ae6:	9b06      	ldr	r3, [sp, #24]
     ae8:	429a      	cmp	r2, r3
     aea:	d906      	bls.n	afa <chVTDoSetI+0xaa>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
     aec:	4b1c      	ldr	r3, [pc, #112]	; (b60 <chVTDoSetI+0x110>)
     aee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     af0:	9b06      	ldr	r3, [sp, #24]
     af2:	4413      	add	r3, r2
     af4:	4618      	mov	r0, r3
     af6:	f7ff ff73 	bl	9e0 <port_timer_set_alarm>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
     afa:	4b19      	ldr	r3, [pc, #100]	; (b60 <chVTDoSetI+0x110>)
     afc:	69db      	ldr	r3, [r3, #28]
     afe:	9307      	str	r3, [sp, #28]
  while (p->vt_delta < delta) {
     b00:	e007      	b.n	b12 <chVTDoSetI+0xc2>
    delta -= p->vt_delta;
     b02:	9b07      	ldr	r3, [sp, #28]
     b04:	689b      	ldr	r3, [r3, #8]
     b06:	9a06      	ldr	r2, [sp, #24]
     b08:	1ad3      	subs	r3, r2, r3
     b0a:	9306      	str	r3, [sp, #24]
    p = p->vt_next;
     b0c:	9b07      	ldr	r3, [sp, #28]
     b0e:	681b      	ldr	r3, [r3, #0]
     b10:	9307      	str	r3, [sp, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
     b12:	9b07      	ldr	r3, [sp, #28]
     b14:	689a      	ldr	r2, [r3, #8]
     b16:	9b06      	ldr	r3, [sp, #24]
     b18:	429a      	cmp	r2, r3
     b1a:	d3f2      	bcc.n	b02 <chVTDoSetI+0xb2>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
     b1c:	9b03      	ldr	r3, [sp, #12]
     b1e:	9a07      	ldr	r2, [sp, #28]
     b20:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
     b22:	9b03      	ldr	r3, [sp, #12]
     b24:	681b      	ldr	r3, [r3, #0]
     b26:	685a      	ldr	r2, [r3, #4]
     b28:	9b03      	ldr	r3, [sp, #12]
     b2a:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
     b2c:	9b03      	ldr	r3, [sp, #12]
     b2e:	685b      	ldr	r3, [r3, #4]
     b30:	9a03      	ldr	r2, [sp, #12]
     b32:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
     b34:	9b07      	ldr	r3, [sp, #28]
     b36:	9a03      	ldr	r2, [sp, #12]
     b38:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
     b3a:	9b03      	ldr	r3, [sp, #12]
     b3c:	9a06      	ldr	r2, [sp, #24]
     b3e:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
     b40:	9b07      	ldr	r3, [sp, #28]
     b42:	689a      	ldr	r2, [r3, #8]
     b44:	9b06      	ldr	r3, [sp, #24]
     b46:	1ad2      	subs	r2, r2, r3
     b48:	9b07      	ldr	r3, [sp, #28]
     b4a:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
     b4c:	4b04      	ldr	r3, [pc, #16]	; (b60 <chVTDoSetI+0x110>)
     b4e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     b52:	625a      	str	r2, [r3, #36]	; 0x24
}
     b54:	b009      	add	sp, #36	; 0x24
     b56:	f85d fb04 	ldr.w	pc, [sp], #4
     b5a:	bf00      	nop
     b5c:	00003c30 	.word	0x00003c30
     b60:	20000800 	.word	0x20000800
     b64:	2000081c 	.word	0x2000081c
     b68:	f3af 8000 	nop.w
     b6c:	f3af 8000 	nop.w

00000b70 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
     b70:	b500      	push	{lr}
     b72:	b085      	sub	sp, #20
     b74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     b76:	f7ff fea3 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
     b7a:	9b01      	ldr	r3, [sp, #4]
     b7c:	2b00      	cmp	r3, #0
     b7e:	d102      	bne.n	b86 <chVTDoResetI+0x16>
     b80:	4836      	ldr	r0, [pc, #216]	; (c5c <chVTDoResetI+0xec>)
     b82:	f7ff fd95 	bl	6b0 <chSysHalt>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
     b86:	9b01      	ldr	r3, [sp, #4]
     b88:	68db      	ldr	r3, [r3, #12]
     b8a:	2b00      	cmp	r3, #0
     b8c:	d102      	bne.n	b94 <chVTDoResetI+0x24>
     b8e:	4833      	ldr	r0, [pc, #204]	; (c5c <chVTDoResetI+0xec>)
     b90:	f7ff fd8e 	bl	6b0 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
     b94:	4b32      	ldr	r3, [pc, #200]	; (c60 <chVTDoResetI+0xf0>)
     b96:	69da      	ldr	r2, [r3, #28]
     b98:	9b01      	ldr	r3, [sp, #4]
     b9a:	429a      	cmp	r2, r3
     b9c:	d01c      	beq.n	bd8 <chVTDoResetI+0x68>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
     b9e:	9b01      	ldr	r3, [sp, #4]
     ba0:	685b      	ldr	r3, [r3, #4]
     ba2:	9a01      	ldr	r2, [sp, #4]
     ba4:	6812      	ldr	r2, [r2, #0]
     ba6:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
     ba8:	9b01      	ldr	r3, [sp, #4]
     baa:	681b      	ldr	r3, [r3, #0]
     bac:	9a01      	ldr	r2, [sp, #4]
     bae:	6852      	ldr	r2, [r2, #4]
     bb0:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
     bb2:	9b01      	ldr	r3, [sp, #4]
     bb4:	2200      	movs	r2, #0
     bb6:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
     bb8:	9b01      	ldr	r3, [sp, #4]
     bba:	681a      	ldr	r2, [r3, #0]
     bbc:	4b29      	ldr	r3, [pc, #164]	; (c64 <chVTDoResetI+0xf4>)
     bbe:	429a      	cmp	r2, r3
     bc0:	d009      	beq.n	bd6 <chVTDoResetI+0x66>
      vtp->vt_next->vt_delta += vtp->vt_delta;
     bc2:	9b01      	ldr	r3, [sp, #4]
     bc4:	681b      	ldr	r3, [r3, #0]
     bc6:	9a01      	ldr	r2, [sp, #4]
     bc8:	6812      	ldr	r2, [r2, #0]
     bca:	6891      	ldr	r1, [r2, #8]
     bcc:	9a01      	ldr	r2, [sp, #4]
     bce:	6892      	ldr	r2, [r2, #8]
     bd0:	440a      	add	r2, r1
     bd2:	609a      	str	r2, [r3, #8]

    return;
     bd4:	e03e      	b.n	c54 <chVTDoResetI+0xe4>
     bd6:	e03d      	b.n	c54 <chVTDoResetI+0xe4>
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
     bd8:	9b01      	ldr	r3, [sp, #4]
     bda:	681a      	ldr	r2, [r3, #0]
     bdc:	4b20      	ldr	r3, [pc, #128]	; (c60 <chVTDoResetI+0xf0>)
     bde:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     be0:	4b1f      	ldr	r3, [pc, #124]	; (c60 <chVTDoResetI+0xf0>)
     be2:	69db      	ldr	r3, [r3, #28]
     be4:	4a1f      	ldr	r2, [pc, #124]	; (c64 <chVTDoResetI+0xf4>)
     be6:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
     be8:	9b01      	ldr	r3, [sp, #4]
     bea:	2200      	movs	r2, #0
     bec:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
     bee:	4b1c      	ldr	r3, [pc, #112]	; (c60 <chVTDoResetI+0xf0>)
     bf0:	69da      	ldr	r2, [r3, #28]
     bf2:	4b1c      	ldr	r3, [pc, #112]	; (c64 <chVTDoResetI+0xf4>)
     bf4:	429a      	cmp	r2, r3
     bf6:	d102      	bne.n	bfe <chVTDoResetI+0x8e>
    port_timer_stop_alarm();
     bf8:	f7ff feea 	bl	9d0 <port_timer_stop_alarm>

    return;
     bfc:	e02a      	b.n	c54 <chVTDoResetI+0xe4>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
     bfe:	4b18      	ldr	r3, [pc, #96]	; (c60 <chVTDoResetI+0xf0>)
     c00:	69db      	ldr	r3, [r3, #28]
     c02:	4a17      	ldr	r2, [pc, #92]	; (c60 <chVTDoResetI+0xf0>)
     c04:	69d2      	ldr	r2, [r2, #28]
     c06:	6891      	ldr	r1, [r2, #8]
     c08:	9a01      	ldr	r2, [sp, #4]
     c0a:	6892      	ldr	r2, [r2, #8]
     c0c:	440a      	add	r2, r1
     c0e:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
     c10:	f7ff fefe 	bl	a10 <chVTGetSystemTimeX>
     c14:	4602      	mov	r2, r0
     c16:	4b12      	ldr	r3, [pc, #72]	; (c60 <chVTDoResetI+0xf0>)
     c18:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     c1a:	1ad3      	subs	r3, r2, r3
     c1c:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
     c1e:	4b10      	ldr	r3, [pc, #64]	; (c60 <chVTDoResetI+0xf0>)
     c20:	69db      	ldr	r3, [r3, #28]
     c22:	689a      	ldr	r2, [r3, #8]
     c24:	9b02      	ldr	r3, [sp, #8]
     c26:	429a      	cmp	r2, r3
     c28:	d800      	bhi.n	c2c <chVTDoResetI+0xbc>
    return;
     c2a:	e013      	b.n	c54 <chVTDoResetI+0xe4>
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
     c2c:	4b0c      	ldr	r3, [pc, #48]	; (c60 <chVTDoResetI+0xf0>)
     c2e:	69db      	ldr	r3, [r3, #28]
     c30:	689a      	ldr	r2, [r3, #8]
     c32:	9b02      	ldr	r3, [sp, #8]
     c34:	1ad3      	subs	r3, r2, r3
     c36:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
     c38:	9b03      	ldr	r3, [sp, #12]
     c3a:	2b01      	cmp	r3, #1
     c3c:	d801      	bhi.n	c42 <chVTDoResetI+0xd2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
     c3e:	2302      	movs	r3, #2
     c40:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
     c42:	4b07      	ldr	r3, [pc, #28]	; (c60 <chVTDoResetI+0xf0>)
     c44:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     c46:	9b02      	ldr	r3, [sp, #8]
     c48:	441a      	add	r2, r3
     c4a:	9b03      	ldr	r3, [sp, #12]
     c4c:	4413      	add	r3, r2
     c4e:	4618      	mov	r0, r3
     c50:	f7ff fec6 	bl	9e0 <port_timer_set_alarm>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     c54:	b005      	add	sp, #20
     c56:	f85d fb04 	ldr.w	pc, [sp], #4
     c5a:	bf00      	nop
     c5c:	00003c40 	.word	0x00003c40
     c60:	20000800 	.word	0x20000800
     c64:	2000081c 	.word	0x2000081c
     c68:	f3af 8000 	nop.w
     c6c:	f3af 8000 	nop.w

00000c70 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     c70:	b082      	sub	sp, #8
     c72:	2320      	movs	r3, #32
     c74:	9301      	str	r3, [sp, #4]
     c76:	9b01      	ldr	r3, [sp, #4]
     c78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     c7c:	b002      	add	sp, #8
     c7e:	4770      	bx	lr

00000c80 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     c80:	b082      	sub	sp, #8
     c82:	2300      	movs	r3, #0
     c84:	9301      	str	r3, [sp, #4]
     c86:	9b01      	ldr	r3, [sp, #4]
     c88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     c8c:	b002      	add	sp, #8
     c8e:	4770      	bx	lr

00000c90 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     c90:	b508      	push	{r3, lr}

  port_lock();
     c92:	f7ff ffed 	bl	c70 <port_lock>
}
     c96:	bd08      	pop	{r3, pc}
     c98:	f3af 8000 	nop.w
     c9c:	f3af 8000 	nop.w

00000ca0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     ca0:	b508      	push	{r3, lr}

  port_unlock();
     ca2:	f7ff ffed 	bl	c80 <port_unlock>
}
     ca6:	bd08      	pop	{r3, pc}
     ca8:	f3af 8000 	nop.w
     cac:	f3af 8000 	nop.w

00000cb0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
     cb0:	b082      	sub	sp, #8
     cb2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
     cb4:	9b01      	ldr	r3, [sp, #4]
     cb6:	9a01      	ldr	r2, [sp, #4]
     cb8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
     cba:	9b01      	ldr	r3, [sp, #4]
     cbc:	9a01      	ldr	r2, [sp, #4]
     cbe:	605a      	str	r2, [r3, #4]
}
     cc0:	b002      	add	sp, #8
     cc2:	4770      	bx	lr
     cc4:	f3af 8000 	nop.w
     cc8:	f3af 8000 	nop.w
     ccc:	f3af 8000 	nop.w

00000cd0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
     cd0:	b084      	sub	sp, #16
     cd2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
     cd4:	9b01      	ldr	r3, [sp, #4]
     cd6:	681b      	ldr	r3, [r3, #0]
     cd8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
     cda:	9b03      	ldr	r3, [sp, #12]
     cdc:	681a      	ldr	r2, [r3, #0]
     cde:	9b01      	ldr	r3, [sp, #4]
     ce0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
     ce2:	9b01      	ldr	r3, [sp, #4]
     ce4:	681b      	ldr	r3, [r3, #0]
     ce6:	9a01      	ldr	r2, [sp, #4]
     ce8:	605a      	str	r2, [r3, #4]

  return tp;
     cea:	9b03      	ldr	r3, [sp, #12]
}
     cec:	4618      	mov	r0, r3
     cee:	b004      	add	sp, #16
     cf0:	4770      	bx	lr
     cf2:	bf00      	nop
     cf4:	f3af 8000 	nop.w
     cf8:	f3af 8000 	nop.w
     cfc:	f3af 8000 	nop.w

00000d00 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
     d00:	b082      	sub	sp, #8
     d02:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
     d04:	9b01      	ldr	r3, [sp, #4]
     d06:	685b      	ldr	r3, [r3, #4]
     d08:	9a01      	ldr	r2, [sp, #4]
     d0a:	6812      	ldr	r2, [r2, #0]
     d0c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
     d0e:	9b01      	ldr	r3, [sp, #4]
     d10:	681b      	ldr	r3, [r3, #0]
     d12:	9a01      	ldr	r2, [sp, #4]
     d14:	6852      	ldr	r2, [r2, #4]
     d16:	605a      	str	r2, [r3, #4]

  return tp;
     d18:	9b01      	ldr	r3, [sp, #4]
}
     d1a:	4618      	mov	r0, r3
     d1c:	b002      	add	sp, #8
     d1e:	4770      	bx	lr

00000d20 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
     d20:	b508      	push	{r3, lr}

  chDbgCheckClassI();
     d22:	f7ff fdcd 	bl	8c0 <chDbgCheckClassI>

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
     d26:	4b06      	ldr	r3, [pc, #24]	; (d40 <chSchIsRescRequiredI+0x20>)
     d28:	681b      	ldr	r3, [r3, #0]
     d2a:	689a      	ldr	r2, [r3, #8]
     d2c:	4b04      	ldr	r3, [pc, #16]	; (d40 <chSchIsRescRequiredI+0x20>)
     d2e:	699b      	ldr	r3, [r3, #24]
     d30:	689b      	ldr	r3, [r3, #8]
     d32:	429a      	cmp	r2, r3
     d34:	bf94      	ite	ls
     d36:	2300      	movls	r3, #0
     d38:	2301      	movhi	r3, #1
     d3a:	b2db      	uxtb	r3, r3
}
     d3c:	4618      	mov	r0, r3
     d3e:	bd08      	pop	{r3, pc}
     d40:	20000800 	.word	0x20000800
     d44:	f3af 8000 	nop.w
     d48:	f3af 8000 	nop.w
     d4c:	f3af 8000 	nop.w

00000d50 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
     d50:	b508      	push	{r3, lr}

  port_lock_from_isr();
     d52:	f7ff ff9d 	bl	c90 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
     d56:	f000 fdcb 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
     d5a:	f7ff fd41 	bl	7e0 <_dbg_check_lock_from_isr>
}
     d5e:	bd08      	pop	{r3, pc}

00000d60 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
     d60:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
     d62:	f7ff fd55 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
     d66:	f000 fdcb 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
     d6a:	f7ff ff99 	bl	ca0 <port_unlock_from_isr>
}
     d6e:	bd08      	pop	{r3, pc}

00000d70 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
     d70:	b500      	push	{lr}
     d72:	b083      	sub	sp, #12
     d74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     d76:	f7ff fda3 	bl	8c0 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
     d7a:	9b01      	ldr	r3, [sp, #4]
     d7c:	68db      	ldr	r3, [r3, #12]
     d7e:	2b00      	cmp	r3, #0
     d80:	bf0c      	ite	eq
     d82:	2300      	moveq	r3, #0
     d84:	2301      	movne	r3, #1
     d86:	b2db      	uxtb	r3, r3
}
     d88:	4618      	mov	r0, r3
     d8a:	b003      	add	sp, #12
     d8c:	f85d fb04 	ldr.w	pc, [sp], #4

00000d90 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
     d90:	b500      	push	{lr}
     d92:	b083      	sub	sp, #12
     d94:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     d96:	f7ff fd93 	bl	8c0 <chDbgCheckClassI>

  sp->s_cnt++;
     d9a:	9b01      	ldr	r3, [sp, #4]
     d9c:	689b      	ldr	r3, [r3, #8]
     d9e:	1c5a      	adds	r2, r3, #1
     da0:	9b01      	ldr	r3, [sp, #4]
     da2:	609a      	str	r2, [r3, #8]
}
     da4:	b003      	add	sp, #12
     da6:	f85d fb04 	ldr.w	pc, [sp], #4
     daa:	bf00      	nop
     dac:	f3af 8000 	nop.w

00000db0 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
     db0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
     db2:	4806      	ldr	r0, [pc, #24]	; (dcc <_scheduler_init+0x1c>)
     db4:	f7ff ff7c 	bl	cb0 <queue_init>
  ch.rlist.r_prio = NOPRIO;
     db8:	4b04      	ldr	r3, [pc, #16]	; (dcc <_scheduler_init+0x1c>)
     dba:	2200      	movs	r2, #0
     dbc:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
     dbe:	4b03      	ldr	r3, [pc, #12]	; (dcc <_scheduler_init+0x1c>)
     dc0:	4a02      	ldr	r2, [pc, #8]	; (dcc <_scheduler_init+0x1c>)
     dc2:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
     dc4:	4b01      	ldr	r3, [pc, #4]	; (dcc <_scheduler_init+0x1c>)
     dc6:	4a01      	ldr	r2, [pc, #4]	; (dcc <_scheduler_init+0x1c>)
     dc8:	615a      	str	r2, [r3, #20]
#endif
}
     dca:	bd08      	pop	{r3, pc}
     dcc:	20000800 	.word	0x20000800

00000dd0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     dd0:	b500      	push	{lr}
     dd2:	b085      	sub	sp, #20
     dd4:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
     dd6:	f7ff fd73 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
     dda:	9b01      	ldr	r3, [sp, #4]
     ddc:	2b00      	cmp	r3, #0
     dde:	d102      	bne.n	de6 <chSchReadyI+0x16>
     de0:	4818      	ldr	r0, [pc, #96]	; (e44 <chSchReadyI+0x74>)
     de2:	f7ff fc65 	bl	6b0 <chSysHalt>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
     de6:	9b01      	ldr	r3, [sp, #4]
     de8:	f893 3020 	ldrb.w	r3, [r3, #32]
     dec:	2b00      	cmp	r3, #0
     dee:	d004      	beq.n	dfa <chSchReadyI+0x2a>
     df0:	9b01      	ldr	r3, [sp, #4]
     df2:	f893 3020 	ldrb.w	r3, [r3, #32]
     df6:	2b0f      	cmp	r3, #15
     df8:	d102      	bne.n	e00 <chSchReadyI+0x30>
     dfa:	4812      	ldr	r0, [pc, #72]	; (e44 <chSchReadyI+0x74>)
     dfc:	f7ff fc58 	bl	6b0 <chSysHalt>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     e00:	9b01      	ldr	r3, [sp, #4]
     e02:	2200      	movs	r2, #0
     e04:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
     e08:	4b0f      	ldr	r3, [pc, #60]	; (e48 <chSchReadyI+0x78>)
     e0a:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
     e0c:	9b03      	ldr	r3, [sp, #12]
     e0e:	681b      	ldr	r3, [r3, #0]
     e10:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
     e12:	9b03      	ldr	r3, [sp, #12]
     e14:	689a      	ldr	r2, [r3, #8]
     e16:	9b01      	ldr	r3, [sp, #4]
     e18:	689b      	ldr	r3, [r3, #8]
     e1a:	429a      	cmp	r2, r3
     e1c:	d2f6      	bcs.n	e0c <chSchReadyI+0x3c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     e1e:	9b01      	ldr	r3, [sp, #4]
     e20:	9a03      	ldr	r2, [sp, #12]
     e22:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
     e24:	9b03      	ldr	r3, [sp, #12]
     e26:	685a      	ldr	r2, [r3, #4]
     e28:	9b01      	ldr	r3, [sp, #4]
     e2a:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
     e2c:	9b01      	ldr	r3, [sp, #4]
     e2e:	685b      	ldr	r3, [r3, #4]
     e30:	9a01      	ldr	r2, [sp, #4]
     e32:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
     e34:	9b03      	ldr	r3, [sp, #12]
     e36:	9a01      	ldr	r2, [sp, #4]
     e38:	605a      	str	r2, [r3, #4]

  return tp;
     e3a:	9b01      	ldr	r3, [sp, #4]
}
     e3c:	4618      	mov	r0, r3
     e3e:	b005      	add	sp, #20
     e40:	f85d fb04 	ldr.w	pc, [sp], #4
     e44:	00003c50 	.word	0x00003c50
     e48:	20000800 	.word	0x20000800
     e4c:	f3af 8000 	nop.w

00000e50 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
     e50:	b510      	push	{r4, lr}
     e52:	b084      	sub	sp, #16
     e54:	4603      	mov	r3, r0
     e56:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();
     e5a:	f7ff fd49 	bl	8f0 <chDbgCheckClassS>

  otp = currp;
     e5e:	4b19      	ldr	r3, [pc, #100]	; (ec4 <chSchGoSleepS+0x74>)
     e60:	699b      	ldr	r3, [r3, #24]
     e62:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
     e64:	9b03      	ldr	r3, [sp, #12]
     e66:	f89d 2007 	ldrb.w	r2, [sp, #7]
     e6a:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
     e6e:	4815      	ldr	r0, [pc, #84]	; (ec4 <chSchGoSleepS+0x74>)
     e70:	f7ff ff2e 	bl	cd0 <queue_fifo_remove>
     e74:	4602      	mov	r2, r0
     e76:	4b13      	ldr	r3, [pc, #76]	; (ec4 <chSchGoSleepS+0x74>)
     e78:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
     e7a:	4b12      	ldr	r3, [pc, #72]	; (ec4 <chSchGoSleepS+0x74>)
     e7c:	699b      	ldr	r3, [r3, #24]
     e7e:	2201      	movs	r2, #1
     e80:	f883 2020 	strb.w	r2, [r3, #32]
  chSysSwitch(currp, otp);
     e84:	9803      	ldr	r0, [sp, #12]
     e86:	f7ff fd5b 	bl	940 <_dbg_trace>
     e8a:	4b0e      	ldr	r3, [pc, #56]	; (ec4 <chSchGoSleepS+0x74>)
     e8c:	699b      	ldr	r3, [r3, #24]
     e8e:	4618      	mov	r0, r3
     e90:	9903      	ldr	r1, [sp, #12]
     e92:	f000 fcfd 	bl	1890 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
     e96:	f3ef 8309 	mrs	r3, PSP
     e9a:	461c      	mov	r4, r3
  return(result);
     e9c:	4623      	mov	r3, r4
     e9e:	9302      	str	r3, [sp, #8]
     ea0:	9b02      	ldr	r3, [sp, #8]
     ea2:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
     ea6:	9b03      	ldr	r3, [sp, #12]
     ea8:	69db      	ldr	r3, [r3, #28]
     eaa:	429a      	cmp	r2, r3
     eac:	d202      	bcs.n	eb4 <chSchGoSleepS+0x64>
     eae:	4806      	ldr	r0, [pc, #24]	; (ec8 <chSchGoSleepS+0x78>)
     eb0:	f7ff fbfe 	bl	6b0 <chSysHalt>
     eb4:	4b03      	ldr	r3, [pc, #12]	; (ec4 <chSchGoSleepS+0x74>)
     eb6:	699b      	ldr	r3, [r3, #24]
     eb8:	4618      	mov	r0, r3
     eba:	9903      	ldr	r1, [sp, #12]
     ebc:	f7ff f9e0 	bl	280 <_port_switch>
}
     ec0:	b004      	add	sp, #16
     ec2:	bd10      	pop	{r4, pc}
     ec4:	20000800 	.word	0x20000800
     ec8:	00003c10 	.word	0x00003c10
     ecc:	f3af 8000 	nop.w

00000ed0 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
     ed0:	b500      	push	{lr}
     ed2:	b085      	sub	sp, #20
     ed4:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
     ed6:	9b01      	ldr	r3, [sp, #4]
     ed8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
     eda:	f7ff ff39 	bl	d50 <chSysLockFromISR>
  switch (tp->p_state) {
     ede:	9b03      	ldr	r3, [sp, #12]
     ee0:	f893 3020 	ldrb.w	r3, [r3, #32]
     ee4:	2b07      	cmp	r3, #7
     ee6:	d824      	bhi.n	f32 <wakeup+0x62>
     ee8:	a201      	add	r2, pc, #4	; (adr r2, ef0 <wakeup+0x20>)
     eea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     eee:	bf00      	nop
     ef0:	00000f11 	.word	0x00000f11
     ef4:	00000f33 	.word	0x00000f33
     ef8:	00000f33 	.word	0x00000f33
     efc:	00000f17 	.word	0x00000f17
     f00:	00000f2b 	.word	0x00000f2b
     f04:	00000f21 	.word	0x00000f21
     f08:	00000f33 	.word	0x00000f33
     f0c:	00000f2b 	.word	0x00000f2b
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
     f10:	f7ff ff26 	bl	d60 <chSysUnlockFromISR>
    return;
     f14:	e017      	b.n	f46 <wakeup+0x76>
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
     f16:	9b03      	ldr	r3, [sp, #12]
     f18:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     f1a:	2200      	movs	r2, #0
     f1c:	601a      	str	r2, [r3, #0]
    break;
     f1e:	e009      	b.n	f34 <wakeup+0x64>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
     f20:	9b03      	ldr	r3, [sp, #12]
     f22:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     f24:	4618      	mov	r0, r3
     f26:	f7ff ff33 	bl	d90 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
     f2a:	9803      	ldr	r0, [sp, #12]
     f2c:	f7ff fee8 	bl	d00 <queue_dequeue>
    break;
     f30:	e000      	b.n	f34 <wakeup+0x64>
  default:
    /* Any other state, nothing to do.*/
    break;
     f32:	bf00      	nop
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
     f34:	9b03      	ldr	r3, [sp, #12]
     f36:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     f3a:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
     f3c:	9803      	ldr	r0, [sp, #12]
     f3e:	f7ff ff47 	bl	dd0 <chSchReadyI>
  chSysUnlockFromISR();
     f42:	f7ff ff0d 	bl	d60 <chSysUnlockFromISR>
}
     f46:	b005      	add	sp, #20
     f48:	f85d fb04 	ldr.w	pc, [sp], #4
     f4c:	f3af 8000 	nop.w

00000f50 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
     f50:	b500      	push	{lr}
     f52:	b089      	sub	sp, #36	; 0x24
     f54:	4603      	mov	r3, r0
     f56:	9100      	str	r1, [sp, #0]
     f58:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
     f5c:	f7ff fcc8 	bl	8f0 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
     f60:	9b00      	ldr	r3, [sp, #0]
     f62:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
     f66:	d019      	beq.n	f9c <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
     f68:	4b12      	ldr	r3, [pc, #72]	; (fb4 <chSchGoSleepTimeoutS+0x64>)
     f6a:	699b      	ldr	r3, [r3, #24]
     f6c:	aa03      	add	r2, sp, #12
     f6e:	4610      	mov	r0, r2
     f70:	9900      	ldr	r1, [sp, #0]
     f72:	4a11      	ldr	r2, [pc, #68]	; (fb8 <chSchGoSleepTimeoutS+0x68>)
     f74:	f7ff fd6c 	bl	a50 <chVTDoSetI>
    chSchGoSleepS(newstate);
     f78:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f7c:	4618      	mov	r0, r3
     f7e:	f7ff ff67 	bl	e50 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     f82:	ab03      	add	r3, sp, #12
     f84:	4618      	mov	r0, r3
     f86:	f7ff fef3 	bl	d70 <chVTIsArmedI>
     f8a:	4603      	mov	r3, r0
     f8c:	2b00      	cmp	r3, #0
     f8e:	d004      	beq.n	f9a <chSchGoSleepTimeoutS+0x4a>
      chVTDoResetI(&vt);
     f90:	ab03      	add	r3, sp, #12
     f92:	4618      	mov	r0, r3
     f94:	f7ff fdec 	bl	b70 <chVTDoResetI>
     f98:	e005      	b.n	fa6 <chSchGoSleepTimeoutS+0x56>
     f9a:	e004      	b.n	fa6 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
     f9c:	f89d 3007 	ldrb.w	r3, [sp, #7]
     fa0:	4618      	mov	r0, r3
     fa2:	f7ff ff55 	bl	e50 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
     fa6:	4b03      	ldr	r3, [pc, #12]	; (fb4 <chSchGoSleepTimeoutS+0x64>)
     fa8:	699b      	ldr	r3, [r3, #24]
     faa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     fac:	4618      	mov	r0, r3
     fae:	b009      	add	sp, #36	; 0x24
     fb0:	f85d fb04 	ldr.w	pc, [sp], #4
     fb4:	20000800 	.word	0x20000800
     fb8:	00000ed1 	.word	0x00000ed1
     fbc:	f3af 8000 	nop.w

00000fc0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     fc0:	b510      	push	{r4, lr}
     fc2:	b084      	sub	sp, #16
     fc4:	9001      	str	r0, [sp, #4]
     fc6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
     fc8:	f7ff fc92 	bl	8f0 <chDbgCheckClassS>

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
     fcc:	9b01      	ldr	r3, [sp, #4]
     fce:	9a00      	ldr	r2, [sp, #0]
     fd0:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
     fd2:	9b01      	ldr	r3, [sp, #4]
     fd4:	689a      	ldr	r2, [r3, #8]
     fd6:	4b19      	ldr	r3, [pc, #100]	; (103c <__ram5_size__+0x3c>)
     fd8:	699b      	ldr	r3, [r3, #24]
     fda:	689b      	ldr	r3, [r3, #8]
     fdc:	429a      	cmp	r2, r3
     fde:	d803      	bhi.n	fe8 <chSchWakeupS+0x28>
    (void) chSchReadyI(ntp);
     fe0:	9801      	ldr	r0, [sp, #4]
     fe2:	f7ff fef5 	bl	dd0 <chSchReadyI>
     fe6:	e026      	b.n	1036 <__ram5_size__+0x36>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
     fe8:	4b14      	ldr	r3, [pc, #80]	; (103c <__ram5_size__+0x3c>)
     fea:	699b      	ldr	r3, [r3, #24]
     fec:	4618      	mov	r0, r3
     fee:	f7ff feef 	bl	dd0 <chSchReadyI>
     ff2:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
     ff4:	4b11      	ldr	r3, [pc, #68]	; (103c <__ram5_size__+0x3c>)
     ff6:	9a01      	ldr	r2, [sp, #4]
     ff8:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
     ffa:	9b01      	ldr	r3, [sp, #4]
     ffc:	2201      	movs	r2, #1
     ffe:	f883 2020 	strb.w	r2, [r3, #32]
    chSysSwitch(ntp, otp);
    1002:	9803      	ldr	r0, [sp, #12]
    1004:	f7ff fc9c 	bl	940 <_dbg_trace>
    1008:	9801      	ldr	r0, [sp, #4]
    100a:	9903      	ldr	r1, [sp, #12]
    100c:	f000 fc40 	bl	1890 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    1010:	f3ef 8309 	mrs	r3, PSP
    1014:	461c      	mov	r4, r3
  return(result);
    1016:	4623      	mov	r3, r4
    1018:	9302      	str	r3, [sp, #8]
    101a:	9b02      	ldr	r3, [sp, #8]
    101c:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    1020:	9b03      	ldr	r3, [sp, #12]
    1022:	69db      	ldr	r3, [r3, #28]
    1024:	429a      	cmp	r2, r3
    1026:	d202      	bcs.n	102e <__ram5_size__+0x2e>
    1028:	4805      	ldr	r0, [pc, #20]	; (1040 <__ram5_size__+0x40>)
    102a:	f7ff fb41 	bl	6b0 <chSysHalt>
    102e:	9801      	ldr	r0, [sp, #4]
    1030:	9903      	ldr	r1, [sp, #12]
    1032:	f7ff f925 	bl	280 <_port_switch>
  }
}
    1036:	b004      	add	sp, #16
    1038:	bd10      	pop	{r4, pc}
    103a:	bf00      	nop
    103c:	20000800 	.word	0x20000800
    1040:	00003c10 	.word	0x00003c10
    1044:	f3af 8000 	nop.w
    1048:	f3af 8000 	nop.w
    104c:	f3af 8000 	nop.w

00001050 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
    1050:	b508      	push	{r3, lr}

  chDbgCheckClassS();
    1052:	f7ff fc4d 	bl	8f0 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
    1056:	f7ff fe63 	bl	d20 <chSchIsRescRequiredI>
    105a:	4603      	mov	r3, r0
    105c:	2b00      	cmp	r3, #0
    105e:	d001      	beq.n	1064 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
    1060:	f000 f81e 	bl	10a0 <chSchDoRescheduleAhead>
  }
}
    1064:	bd08      	pop	{r3, pc}
    1066:	bf00      	nop
    1068:	f3af 8000 	nop.w
    106c:	f3af 8000 	nop.w

00001070 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
    1070:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
    1072:	4b09      	ldr	r3, [pc, #36]	; (1098 <chSchIsPreemptionRequired+0x28>)
    1074:	681b      	ldr	r3, [r3, #0]
    1076:	689b      	ldr	r3, [r3, #8]
    1078:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
    107a:	4b07      	ldr	r3, [pc, #28]	; (1098 <chSchIsPreemptionRequired+0x28>)
    107c:	699b      	ldr	r3, [r3, #24]
    107e:	689b      	ldr	r3, [r3, #8]
    1080:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
    1082:	9a01      	ldr	r2, [sp, #4]
    1084:	9b00      	ldr	r3, [sp, #0]
    1086:	429a      	cmp	r2, r3
    1088:	bf94      	ite	ls
    108a:	2300      	movls	r3, #0
    108c:	2301      	movhi	r3, #1
    108e:	b2db      	uxtb	r3, r3
#endif
}
    1090:	4618      	mov	r0, r3
    1092:	b002      	add	sp, #8
    1094:	4770      	bx	lr
    1096:	bf00      	nop
    1098:	20000800 	.word	0x20000800
    109c:	f3af 8000 	nop.w

000010a0 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
    10a0:	b510      	push	{r4, lr}
    10a2:	b084      	sub	sp, #16
  thread_t *otp, *cp;

  otp = currp;
    10a4:	4b25      	ldr	r3, [pc, #148]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10a6:	699b      	ldr	r3, [r3, #24]
    10a8:	9302      	str	r3, [sp, #8]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
    10aa:	4824      	ldr	r0, [pc, #144]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10ac:	f7ff fe10 	bl	cd0 <queue_fifo_remove>
    10b0:	4602      	mov	r2, r0
    10b2:	4b22      	ldr	r3, [pc, #136]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10b4:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
    10b6:	4b21      	ldr	r3, [pc, #132]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10b8:	699b      	ldr	r3, [r3, #24]
    10ba:	2201      	movs	r2, #1
    10bc:	f883 2020 	strb.w	r2, [r3, #32]

  otp->p_state = CH_STATE_READY;
    10c0:	9b02      	ldr	r3, [sp, #8]
    10c2:	2200      	movs	r2, #0
    10c4:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
    10c8:	4b1c      	ldr	r3, [pc, #112]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10ca:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
    10cc:	9b03      	ldr	r3, [sp, #12]
    10ce:	681b      	ldr	r3, [r3, #0]
    10d0:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio > otp->p_prio);
    10d2:	9b03      	ldr	r3, [sp, #12]
    10d4:	689a      	ldr	r2, [r3, #8]
    10d6:	9b02      	ldr	r3, [sp, #8]
    10d8:	689b      	ldr	r3, [r3, #8]
    10da:	429a      	cmp	r2, r3
    10dc:	d8f6      	bhi.n	10cc <chSchDoRescheduleAhead+0x2c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
    10de:	9b02      	ldr	r3, [sp, #8]
    10e0:	9a03      	ldr	r2, [sp, #12]
    10e2:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
    10e4:	9b03      	ldr	r3, [sp, #12]
    10e6:	685a      	ldr	r2, [r3, #4]
    10e8:	9b02      	ldr	r3, [sp, #8]
    10ea:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
    10ec:	9b02      	ldr	r3, [sp, #8]
    10ee:	685b      	ldr	r3, [r3, #4]
    10f0:	9a02      	ldr	r2, [sp, #8]
    10f2:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
    10f4:	9b03      	ldr	r3, [sp, #12]
    10f6:	9a02      	ldr	r2, [sp, #8]
    10f8:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
    10fa:	9802      	ldr	r0, [sp, #8]
    10fc:	f7ff fc20 	bl	940 <_dbg_trace>
    1100:	4b0e      	ldr	r3, [pc, #56]	; (113c <chSchDoRescheduleAhead+0x9c>)
    1102:	699b      	ldr	r3, [r3, #24]
    1104:	4618      	mov	r0, r3
    1106:	9902      	ldr	r1, [sp, #8]
    1108:	f000 fbc2 	bl	1890 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    110c:	f3ef 8309 	mrs	r3, PSP
    1110:	461c      	mov	r4, r3
  return(result);
    1112:	4623      	mov	r3, r4
    1114:	9301      	str	r3, [sp, #4]
    1116:	9b01      	ldr	r3, [sp, #4]
    1118:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    111c:	9b02      	ldr	r3, [sp, #8]
    111e:	69db      	ldr	r3, [r3, #28]
    1120:	429a      	cmp	r2, r3
    1122:	d202      	bcs.n	112a <chSchDoRescheduleAhead+0x8a>
    1124:	4806      	ldr	r0, [pc, #24]	; (1140 <chSchDoRescheduleAhead+0xa0>)
    1126:	f7ff fac3 	bl	6b0 <chSysHalt>
    112a:	4b04      	ldr	r3, [pc, #16]	; (113c <chSchDoRescheduleAhead+0x9c>)
    112c:	699b      	ldr	r3, [r3, #24]
    112e:	4618      	mov	r0, r3
    1130:	9902      	ldr	r1, [sp, #8]
    1132:	f7ff f8a5 	bl	280 <_port_switch>
}
    1136:	b004      	add	sp, #16
    1138:	bd10      	pop	{r4, pc}
    113a:	bf00      	nop
    113c:	20000800 	.word	0x20000800
    1140:	00003c10 	.word	0x00003c10
    1144:	f3af 8000 	nop.w
    1148:	f3af 8000 	nop.w
    114c:	f3af 8000 	nop.w

00001150 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    1150:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
    1152:	f7ff ffa5 	bl	10a0 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
    1156:	bd08      	pop	{r3, pc}
    1158:	f3af 8000 	nop.w
    115c:	f3af 8000 	nop.w

00001160 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1160:	b082      	sub	sp, #8
    1162:	2320      	movs	r3, #32
    1164:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    1166:	9b01      	ldr	r3, [sp, #4]
    1168:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    116c:	b002      	add	sp, #8
    116e:	4770      	bx	lr

00001170 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1170:	b082      	sub	sp, #8
    1172:	2300      	movs	r3, #0
    1174:	9301      	str	r3, [sp, #4]
    1176:	9b01      	ldr	r3, [sp, #4]
    1178:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    117c:	b002      	add	sp, #8
    117e:	4770      	bx	lr

00001180 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
    1180:	b082      	sub	sp, #8
    1182:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
    1184:	9b01      	ldr	r3, [sp, #4]
    1186:	9a01      	ldr	r2, [sp, #4]
    1188:	601a      	str	r2, [r3, #0]
}
    118a:	b002      	add	sp, #8
    118c:	4770      	bx	lr
    118e:	bf00      	nop

00001190 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
    1190:	b082      	sub	sp, #8
    1192:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
    1194:	9b01      	ldr	r3, [sp, #4]
    1196:	681a      	ldr	r2, [r3, #0]
    1198:	9b01      	ldr	r3, [sp, #4]
    119a:	429a      	cmp	r2, r3
    119c:	bf0c      	ite	eq
    119e:	2300      	moveq	r3, #0
    11a0:	2301      	movne	r3, #1
    11a2:	b2db      	uxtb	r3, r3
}
    11a4:	4618      	mov	r0, r3
    11a6:	b002      	add	sp, #8
    11a8:	4770      	bx	lr
    11aa:	bf00      	nop
    11ac:	f3af 8000 	nop.w

000011b0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    11b0:	b082      	sub	sp, #8
    11b2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    11b4:	9b01      	ldr	r3, [sp, #4]
    11b6:	9a01      	ldr	r2, [sp, #4]
    11b8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    11ba:	9b01      	ldr	r3, [sp, #4]
    11bc:	9a01      	ldr	r2, [sp, #4]
    11be:	605a      	str	r2, [r3, #4]
}
    11c0:	b002      	add	sp, #8
    11c2:	4770      	bx	lr
    11c4:	f3af 8000 	nop.w
    11c8:	f3af 8000 	nop.w
    11cc:	f3af 8000 	nop.w

000011d0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
    11d0:	b082      	sub	sp, #8
    11d2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
    11d4:	9b01      	ldr	r3, [sp, #4]
    11d6:	681a      	ldr	r2, [r3, #0]
    11d8:	9b01      	ldr	r3, [sp, #4]
    11da:	429a      	cmp	r2, r3
    11dc:	bf0c      	ite	eq
    11de:	2300      	moveq	r3, #0
    11e0:	2301      	movne	r3, #1
    11e2:	b2db      	uxtb	r3, r3
}
    11e4:	4618      	mov	r0, r3
    11e6:	b002      	add	sp, #8
    11e8:	4770      	bx	lr
    11ea:	bf00      	nop
    11ec:	f3af 8000 	nop.w

000011f0 <list_remove>:

  tp->p_next = tlp->p_next;
  tlp->p_next = tp;
}

static inline thread_t *list_remove(threads_list_t *tlp) {
    11f0:	b084      	sub	sp, #16
    11f2:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
    11f4:	9b01      	ldr	r3, [sp, #4]
    11f6:	681b      	ldr	r3, [r3, #0]
    11f8:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
    11fa:	9b03      	ldr	r3, [sp, #12]
    11fc:	681a      	ldr	r2, [r3, #0]
    11fe:	9b01      	ldr	r3, [sp, #4]
    1200:	601a      	str	r2, [r3, #0]

  return tp;
    1202:	9b03      	ldr	r3, [sp, #12]
}
    1204:	4618      	mov	r0, r3
    1206:	b004      	add	sp, #16
    1208:	4770      	bx	lr
    120a:	bf00      	nop
    120c:	f3af 8000 	nop.w

00001210 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
    1210:	b082      	sub	sp, #8
    1212:	9001      	str	r0, [sp, #4]
    1214:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
    1216:	9b01      	ldr	r3, [sp, #4]
    1218:	9a00      	ldr	r2, [sp, #0]
    121a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
    121c:	9b00      	ldr	r3, [sp, #0]
    121e:	685a      	ldr	r2, [r3, #4]
    1220:	9b01      	ldr	r3, [sp, #4]
    1222:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    1224:	9b01      	ldr	r3, [sp, #4]
    1226:	685b      	ldr	r3, [r3, #4]
    1228:	9a01      	ldr	r2, [sp, #4]
    122a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
    122c:	9b00      	ldr	r3, [sp, #0]
    122e:	9a01      	ldr	r2, [sp, #4]
    1230:	605a      	str	r2, [r3, #4]
}
    1232:	b002      	add	sp, #8
    1234:	4770      	bx	lr
    1236:	bf00      	nop
    1238:	f3af 8000 	nop.w
    123c:	f3af 8000 	nop.w

00001240 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
    1240:	b084      	sub	sp, #16
    1242:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
    1244:	9b01      	ldr	r3, [sp, #4]
    1246:	681b      	ldr	r3, [r3, #0]
    1248:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
    124a:	9b03      	ldr	r3, [sp, #12]
    124c:	681a      	ldr	r2, [r3, #0]
    124e:	9b01      	ldr	r3, [sp, #4]
    1250:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1252:	9b01      	ldr	r3, [sp, #4]
    1254:	681b      	ldr	r3, [r3, #0]
    1256:	9a01      	ldr	r2, [sp, #4]
    1258:	605a      	str	r2, [r3, #4]

  return tp;
    125a:	9b03      	ldr	r3, [sp, #12]
}
    125c:	4618      	mov	r0, r3
    125e:	b004      	add	sp, #16
    1260:	4770      	bx	lr
    1262:	bf00      	nop
    1264:	f3af 8000 	nop.w
    1268:	f3af 8000 	nop.w
    126c:	f3af 8000 	nop.w

00001270 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1270:	b508      	push	{r3, lr}

  port_lock();
    1272:	f7ff ff75 	bl	1160 <port_lock>
  _stats_start_measure_crit_thd();
    1276:	f000 fb2b 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    127a:	f7ff fa81 	bl	780 <_dbg_check_lock>
}
    127e:	bd08      	pop	{r3, pc}

00001280 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1280:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1282:	f7ff fa95 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1286:	f000 fb2b 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    128a:	4b09      	ldr	r3, [pc, #36]	; (12b0 <chSysUnlock+0x30>)
    128c:	681a      	ldr	r2, [r3, #0]
    128e:	4b08      	ldr	r3, [pc, #32]	; (12b0 <chSysUnlock+0x30>)
    1290:	429a      	cmp	r2, r3
    1292:	d00a      	beq.n	12aa <chSysUnlock+0x2a>
    1294:	4b06      	ldr	r3, [pc, #24]	; (12b0 <chSysUnlock+0x30>)
    1296:	699b      	ldr	r3, [r3, #24]
    1298:	689a      	ldr	r2, [r3, #8]
    129a:	4b05      	ldr	r3, [pc, #20]	; (12b0 <chSysUnlock+0x30>)
    129c:	681b      	ldr	r3, [r3, #0]
    129e:	689b      	ldr	r3, [r3, #8]
    12a0:	429a      	cmp	r2, r3
    12a2:	d202      	bcs.n	12aa <chSysUnlock+0x2a>
    12a4:	4803      	ldr	r0, [pc, #12]	; (12b4 <chSysUnlock+0x34>)
    12a6:	f7ff fa03 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    12aa:	f7ff ff61 	bl	1170 <port_unlock>
}
    12ae:	bd08      	pop	{r3, pc}
    12b0:	20000800 	.word	0x20000800
    12b4:	00003c70 	.word	0x00003c70
    12b8:	f3af 8000 	nop.w
    12bc:	f3af 8000 	nop.w

000012c0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
    12c0:	b500      	push	{lr}
    12c2:	b083      	sub	sp, #12
    12c4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
    12c6:	9b01      	ldr	r3, [sp, #4]
    12c8:	2b00      	cmp	r3, #0
    12ca:	d102      	bne.n	12d2 <chThdSleepS+0x12>
    12cc:	4804      	ldr	r0, [pc, #16]	; (12e0 <chThdSleepS+0x20>)
    12ce:	f7ff f9ef 	bl	6b0 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
    12d2:	2008      	movs	r0, #8
    12d4:	9901      	ldr	r1, [sp, #4]
    12d6:	f7ff fe3b 	bl	f50 <chSchGoSleepTimeoutS>
}
    12da:	b003      	add	sp, #12
    12dc:	f85d fb04 	ldr.w	pc, [sp], #4
    12e0:	00003ca0 	.word	0x00003ca0
    12e4:	f3af 8000 	nop.w
    12e8:	f3af 8000 	nop.w
    12ec:	f3af 8000 	nop.w

000012f0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    12f0:	b500      	push	{lr}
    12f2:	b085      	sub	sp, #20
    12f4:	9001      	str	r0, [sp, #4]
    12f6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
    12f8:	9801      	ldr	r0, [sp, #4]
    12fa:	f7ff ff69 	bl	11d0 <queue_notempty>
    12fe:	4603      	mov	r3, r0
    1300:	f083 0301 	eor.w	r3, r3, #1
    1304:	b2db      	uxtb	r3, r3
    1306:	2b00      	cmp	r3, #0
    1308:	d002      	beq.n	1310 <chThdDoDequeueNextI+0x20>
    130a:	480c      	ldr	r0, [pc, #48]	; (133c <chThdDoDequeueNextI+0x4c>)
    130c:	f7ff f9d0 	bl	6b0 <chSysHalt>

  tp = queue_fifo_remove(tqp);
    1310:	9801      	ldr	r0, [sp, #4]
    1312:	f7ff ff95 	bl	1240 <queue_fifo_remove>
    1316:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
    1318:	9b03      	ldr	r3, [sp, #12]
    131a:	f893 3020 	ldrb.w	r3, [r3, #32]
    131e:	2b04      	cmp	r3, #4
    1320:	d002      	beq.n	1328 <chThdDoDequeueNextI+0x38>
    1322:	4806      	ldr	r0, [pc, #24]	; (133c <chThdDoDequeueNextI+0x4c>)
    1324:	f7ff f9c4 	bl	6b0 <chSysHalt>

  tp->p_u.rdymsg = msg;
    1328:	9b03      	ldr	r3, [sp, #12]
    132a:	9a00      	ldr	r2, [sp, #0]
    132c:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
    132e:	9803      	ldr	r0, [sp, #12]
    1330:	f7ff fd4e 	bl	dd0 <chSchReadyI>
}
    1334:	b005      	add	sp, #20
    1336:	f85d fb04 	ldr.w	pc, [sp], #4
    133a:	bf00      	nop
    133c:	00003cd0 	.word	0x00003cd0

00001340 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
    1340:	b500      	push	{lr}
    1342:	b083      	sub	sp, #12
    1344:	9001      	str	r0, [sp, #4]
    1346:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
    1348:	9b01      	ldr	r3, [sp, #4]
    134a:	9a00      	ldr	r2, [sp, #0]
    134c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
    134e:	9b01      	ldr	r3, [sp, #4]
    1350:	2202      	movs	r2, #2
    1352:	f883 2020 	strb.w	r2, [r3, #32]
  tp->p_flags = CH_FLAG_MODE_STATIC;
    1356:	9b01      	ldr	r3, [sp, #4]
    1358:	2200      	movs	r2, #0
    135a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
    135e:	9b01      	ldr	r3, [sp, #4]
    1360:	9a00      	ldr	r2, [sp, #0]
    1362:	641a      	str	r2, [r3, #64]	; 0x40
  tp->p_mtxlist = NULL;
    1364:	9b01      	ldr	r3, [sp, #4]
    1366:	2200      	movs	r2, #0
    1368:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
    136a:	9b01      	ldr	r3, [sp, #4]
    136c:	2200      	movs	r2, #0
    136e:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
    1370:	9b01      	ldr	r3, [sp, #4]
    1372:	2201      	movs	r2, #1
    1374:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
    1378:	9b01      	ldr	r3, [sp, #4]
    137a:	2200      	movs	r2, #0
    137c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
    137e:	9b01      	ldr	r3, [sp, #4]
    1380:	4a15      	ldr	r2, [pc, #84]	; (13d8 <_thread_init+0x98>)
    1382:	611a      	str	r2, [r3, #16]
    1384:	4b14      	ldr	r3, [pc, #80]	; (13d8 <_thread_init+0x98>)
    1386:	695a      	ldr	r2, [r3, #20]
    1388:	9b01      	ldr	r3, [sp, #4]
    138a:	615a      	str	r2, [r3, #20]
    138c:	9b01      	ldr	r3, [sp, #4]
    138e:	695b      	ldr	r3, [r3, #20]
    1390:	9a01      	ldr	r2, [sp, #4]
    1392:	611a      	str	r2, [r3, #16]
    1394:	4b10      	ldr	r3, [pc, #64]	; (13d8 <_thread_init+0x98>)
    1396:	9a01      	ldr	r2, [sp, #4]
    1398:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
    139a:	9b01      	ldr	r3, [sp, #4]
    139c:	3328      	adds	r3, #40	; 0x28
    139e:	4618      	mov	r0, r3
    13a0:	f7ff feee 	bl	1180 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
    13a4:	9b01      	ldr	r3, [sp, #4]
    13a6:	332c      	adds	r3, #44	; 0x2c
    13a8:	4618      	mov	r0, r3
    13aa:	f7ff ff01 	bl	11b0 <queue_init>
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
    13ae:	9b01      	ldr	r3, [sp, #4]
    13b0:	f103 0260 	add.w	r2, r3, #96	; 0x60
    13b4:	9b01      	ldr	r3, [sp, #4]
    13b6:	61da      	str	r2, [r3, #28]
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->p_stats);
    13b8:	9b01      	ldr	r3, [sp, #4]
    13ba:	3348      	adds	r3, #72	; 0x48
    13bc:	4618      	mov	r0, r3
    13be:	f000 f9e7 	bl	1790 <chTMObjectInit>
  chTMStartMeasurementX(&tp->p_stats);
    13c2:	9b01      	ldr	r3, [sp, #4]
    13c4:	3348      	adds	r3, #72	; 0x48
    13c6:	4618      	mov	r0, r3
    13c8:	f000 f9fa 	bl	17c0 <chTMStartMeasurementX>
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
    13cc:	9b01      	ldr	r3, [sp, #4]
}
    13ce:	4618      	mov	r0, r3
    13d0:	b003      	add	sp, #12
    13d2:	f85d fb04 	ldr.w	pc, [sp], #4
    13d6:	bf00      	nop
    13d8:	20000800 	.word	0x20000800
    13dc:	f3af 8000 	nop.w

000013e0 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
    13e0:	b084      	sub	sp, #16
    13e2:	9003      	str	r0, [sp, #12]
    13e4:	9102      	str	r1, [sp, #8]
    13e6:	4613      	mov	r3, r2
    13e8:	f88d 3007 	strb.w	r3, [sp, #7]

  while (startp < endp) {
    13ec:	e005      	b.n	13fa <_thread_memfill+0x1a>
    *startp++ = v;
    13ee:	9b03      	ldr	r3, [sp, #12]
    13f0:	1c5a      	adds	r2, r3, #1
    13f2:	9203      	str	r2, [sp, #12]
    13f4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    13f8:	701a      	strb	r2, [r3, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    13fa:	9a03      	ldr	r2, [sp, #12]
    13fc:	9b02      	ldr	r3, [sp, #8]
    13fe:	429a      	cmp	r2, r3
    1400:	d3f5      	bcc.n	13ee <_thread_memfill+0xe>
    *startp++ = v;
  }
}
    1402:	b004      	add	sp, #16
    1404:	4770      	bx	lr
    1406:	bf00      	nop
    1408:	f3af 8000 	nop.w
    140c:	f3af 8000 	nop.w

00001410 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
    1410:	b500      	push	{lr}
    1412:	b087      	sub	sp, #28
    1414:	9003      	str	r0, [sp, #12]
    1416:	9102      	str	r1, [sp, #8]
    1418:	9201      	str	r2, [sp, #4]
    141a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
    141c:	9b03      	ldr	r3, [sp, #12]
    141e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
    1420:	f7ff fa4e 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
    1424:	9b03      	ldr	r3, [sp, #12]
    1426:	2b00      	cmp	r3, #0
    1428:	d008      	beq.n	143c <chThdCreateI+0x2c>
    142a:	9b02      	ldr	r3, [sp, #8]
    142c:	2be7      	cmp	r3, #231	; 0xe7
    142e:	d905      	bls.n	143c <chThdCreateI+0x2c>
    1430:	9b01      	ldr	r3, [sp, #4]
    1432:	2b7f      	cmp	r3, #127	; 0x7f
    1434:	d802      	bhi.n	143c <chThdCreateI+0x2c>
    1436:	9b00      	ldr	r3, [sp, #0]
    1438:	2b00      	cmp	r3, #0
    143a:	d102      	bne.n	1442 <chThdCreateI+0x32>
    143c:	480e      	ldr	r0, [pc, #56]	; (1478 <chThdCreateI+0x68>)
    143e:	f7ff f937 	bl	6b0 <chSysHalt>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    1442:	9b02      	ldr	r3, [sp, #8]
    1444:	3b24      	subs	r3, #36	; 0x24
    1446:	9a03      	ldr	r2, [sp, #12]
    1448:	441a      	add	r2, r3
    144a:	9b05      	ldr	r3, [sp, #20]
    144c:	60da      	str	r2, [r3, #12]
    144e:	9b05      	ldr	r3, [sp, #20]
    1450:	68db      	ldr	r3, [r3, #12]
    1452:	9a00      	ldr	r2, [sp, #0]
    1454:	601a      	str	r2, [r3, #0]
    1456:	9b05      	ldr	r3, [sp, #20]
    1458:	68db      	ldr	r3, [r3, #12]
    145a:	9a08      	ldr	r2, [sp, #32]
    145c:	605a      	str	r2, [r3, #4]
    145e:	9b05      	ldr	r3, [sp, #20]
    1460:	68db      	ldr	r3, [r3, #12]
    1462:	4a06      	ldr	r2, [pc, #24]	; (147c <chThdCreateI+0x6c>)
    1464:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
    1466:	9805      	ldr	r0, [sp, #20]
    1468:	9901      	ldr	r1, [sp, #4]
    146a:	f7ff ff69 	bl	1340 <_thread_init>
    146e:	4603      	mov	r3, r0
}
    1470:	4618      	mov	r0, r3
    1472:	b007      	add	sp, #28
    1474:	f85d fb04 	ldr.w	pc, [sp], #4
    1478:	00003c60 	.word	0x00003c60
    147c:	00000291 	.word	0x00000291

00001480 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
    1480:	b500      	push	{lr}
    1482:	b089      	sub	sp, #36	; 0x24
    1484:	9005      	str	r0, [sp, #20]
    1486:	9104      	str	r1, [sp, #16]
    1488:	9203      	str	r2, [sp, #12]
    148a:	9302      	str	r3, [sp, #8]
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
    148c:	9b05      	ldr	r3, [sp, #20]
    148e:	3360      	adds	r3, #96	; 0x60
    1490:	9805      	ldr	r0, [sp, #20]
    1492:	4619      	mov	r1, r3
    1494:	22ff      	movs	r2, #255	; 0xff
    1496:	f7ff ffa3 	bl	13e0 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
    149a:	9b05      	ldr	r3, [sp, #20]
    149c:	f103 0260 	add.w	r2, r3, #96	; 0x60
    14a0:	9905      	ldr	r1, [sp, #20]
    14a2:	9b04      	ldr	r3, [sp, #16]
    14a4:	440b      	add	r3, r1
    14a6:	4610      	mov	r0, r2
    14a8:	4619      	mov	r1, r3
    14aa:	2255      	movs	r2, #85	; 0x55
    14ac:	f7ff ff98 	bl	13e0 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
    14b0:	f7ff fede 	bl	1270 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
    14b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    14b6:	9300      	str	r3, [sp, #0]
    14b8:	9805      	ldr	r0, [sp, #20]
    14ba:	9904      	ldr	r1, [sp, #16]
    14bc:	9a03      	ldr	r2, [sp, #12]
    14be:	9b02      	ldr	r3, [sp, #8]
    14c0:	f7ff ffa6 	bl	1410 <chThdCreateI>
    14c4:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
    14c6:	9807      	ldr	r0, [sp, #28]
    14c8:	2100      	movs	r1, #0
    14ca:	f7ff fd79 	bl	fc0 <chSchWakeupS>
  chSysUnlock();
    14ce:	f7ff fed7 	bl	1280 <chSysUnlock>

  return tp;
    14d2:	9b07      	ldr	r3, [sp, #28]
}
    14d4:	4618      	mov	r0, r3
    14d6:	b009      	add	sp, #36	; 0x24
    14d8:	f85d fb04 	ldr.w	pc, [sp], #4
    14dc:	f3af 8000 	nop.w

000014e0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
    14e0:	b500      	push	{lr}
    14e2:	b085      	sub	sp, #20
    14e4:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
    14e6:	9b01      	ldr	r3, [sp, #4]
    14e8:	2b7f      	cmp	r3, #127	; 0x7f
    14ea:	d902      	bls.n	14f2 <chThdSetPriority+0x12>
    14ec:	4813      	ldr	r0, [pc, #76]	; (153c <chThdSetPriority+0x5c>)
    14ee:	f7ff f8df 	bl	6b0 <chSysHalt>

  chSysLock();
    14f2:	f7ff febd 	bl	1270 <chSysLock>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
    14f6:	4b12      	ldr	r3, [pc, #72]	; (1540 <chThdSetPriority+0x60>)
    14f8:	699b      	ldr	r3, [r3, #24]
    14fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    14fc:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
    14fe:	4b10      	ldr	r3, [pc, #64]	; (1540 <chThdSetPriority+0x60>)
    1500:	699b      	ldr	r3, [r3, #24]
    1502:	689a      	ldr	r2, [r3, #8]
    1504:	4b0e      	ldr	r3, [pc, #56]	; (1540 <chThdSetPriority+0x60>)
    1506:	699b      	ldr	r3, [r3, #24]
    1508:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    150a:	429a      	cmp	r2, r3
    150c:	d005      	beq.n	151a <chThdSetPriority+0x3a>
    150e:	4b0c      	ldr	r3, [pc, #48]	; (1540 <chThdSetPriority+0x60>)
    1510:	699b      	ldr	r3, [r3, #24]
    1512:	689a      	ldr	r2, [r3, #8]
    1514:	9b01      	ldr	r3, [sp, #4]
    1516:	429a      	cmp	r2, r3
    1518:	d203      	bcs.n	1522 <chThdSetPriority+0x42>
    currp->p_prio = newprio;
    151a:	4b09      	ldr	r3, [pc, #36]	; (1540 <chThdSetPriority+0x60>)
    151c:	699b      	ldr	r3, [r3, #24]
    151e:	9a01      	ldr	r2, [sp, #4]
    1520:	609a      	str	r2, [r3, #8]
  }
  currp->p_realprio = newprio;
    1522:	4b07      	ldr	r3, [pc, #28]	; (1540 <chThdSetPriority+0x60>)
    1524:	699b      	ldr	r3, [r3, #24]
    1526:	9a01      	ldr	r2, [sp, #4]
    1528:	641a      	str	r2, [r3, #64]	; 0x40
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
    152a:	f7ff fd91 	bl	1050 <chSchRescheduleS>
  chSysUnlock();
    152e:	f7ff fea7 	bl	1280 <chSysUnlock>

  return oldprio;
    1532:	9b03      	ldr	r3, [sp, #12]
}
    1534:	4618      	mov	r0, r3
    1536:	b005      	add	sp, #20
    1538:	f85d fb04 	ldr.w	pc, [sp], #4
    153c:	00003c80 	.word	0x00003c80
    1540:	20000800 	.word	0x20000800
    1544:	f3af 8000 	nop.w
    1548:	f3af 8000 	nop.w
    154c:	f3af 8000 	nop.w

00001550 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
    1550:	b500      	push	{lr}
    1552:	b083      	sub	sp, #12
    1554:	9001      	str	r0, [sp, #4]

  chSysLock();
    1556:	f7ff fe8b 	bl	1270 <chSysLock>
  chThdSleepS(time);
    155a:	9801      	ldr	r0, [sp, #4]
    155c:	f7ff feb0 	bl	12c0 <chThdSleepS>
  chSysUnlock();
    1560:	f7ff fe8e 	bl	1280 <chSysUnlock>
}
    1564:	b003      	add	sp, #12
    1566:	f85d fb04 	ldr.w	pc, [sp], #4
    156a:	bf00      	nop
    156c:	f3af 8000 	nop.w

00001570 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
    1570:	b500      	push	{lr}
    1572:	b083      	sub	sp, #12
    1574:	9001      	str	r0, [sp, #4]

  chSysLock();
    1576:	f7ff fe7b 	bl	1270 <chSysLock>
  chThdExitS(msg);
    157a:	9801      	ldr	r0, [sp, #4]
    157c:	f000 f808 	bl	1590 <chThdExitS>
  /* The thread never returns here.*/
}
    1580:	b003      	add	sp, #12
    1582:	f85d fb04 	ldr.w	pc, [sp], #4
    1586:	bf00      	nop
    1588:	f3af 8000 	nop.w
    158c:	f3af 8000 	nop.w

00001590 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
    1590:	b500      	push	{lr}
    1592:	b085      	sub	sp, #20
    1594:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
    1596:	4b19      	ldr	r3, [pc, #100]	; (15fc <chThdExitS+0x6c>)
    1598:	699b      	ldr	r3, [r3, #24]
    159a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
    159c:	9b03      	ldr	r3, [sp, #12]
    159e:	9a01      	ldr	r2, [sp, #4]
    15a0:	625a      	str	r2, [r3, #36]	; 0x24
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    15a2:	e008      	b.n	15b6 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->p_waiting));
    15a4:	9b03      	ldr	r3, [sp, #12]
    15a6:	3328      	adds	r3, #40	; 0x28
    15a8:	4618      	mov	r0, r3
    15aa:	f7ff fe21 	bl	11f0 <list_remove>
    15ae:	4603      	mov	r3, r0
    15b0:	4618      	mov	r0, r3
    15b2:	f7ff fc0d 	bl	dd0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    15b6:	9b03      	ldr	r3, [sp, #12]
    15b8:	3328      	adds	r3, #40	; 0x28
    15ba:	4618      	mov	r0, r3
    15bc:	f7ff fde8 	bl	1190 <list_notempty>
    15c0:	4603      	mov	r3, r0
    15c2:	2b00      	cmp	r3, #0
    15c4:	d1ee      	bne.n	15a4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    15c6:	9b03      	ldr	r3, [sp, #12]
    15c8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    15cc:	f003 0303 	and.w	r3, r3, #3
    15d0:	2b00      	cmp	r3, #0
    15d2:	d109      	bne.n	15e8 <chThdExitS+0x58>
    REG_REMOVE(tp);
    15d4:	9b03      	ldr	r3, [sp, #12]
    15d6:	695b      	ldr	r3, [r3, #20]
    15d8:	9a03      	ldr	r2, [sp, #12]
    15da:	6912      	ldr	r2, [r2, #16]
    15dc:	611a      	str	r2, [r3, #16]
    15de:	9b03      	ldr	r3, [sp, #12]
    15e0:	691b      	ldr	r3, [r3, #16]
    15e2:	9a03      	ldr	r2, [sp, #12]
    15e4:	6952      	ldr	r2, [r2, #20]
    15e6:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
    15e8:	200f      	movs	r0, #15
    15ea:	f7ff fc31 	bl	e50 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
    15ee:	4804      	ldr	r0, [pc, #16]	; (1600 <chThdExitS+0x70>)
    15f0:	f7ff f85e 	bl	6b0 <chSysHalt>
}
    15f4:	b005      	add	sp, #20
    15f6:	f85d fb04 	ldr.w	pc, [sp], #4
    15fa:	bf00      	nop
    15fc:	20000800 	.word	0x20000800
    1600:	00003cb0 	.word	0x00003cb0
    1604:	f3af 8000 	nop.w
    1608:	f3af 8000 	nop.w
    160c:	f3af 8000 	nop.w

00001610 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    1610:	b500      	push	{lr}
    1612:	b085      	sub	sp, #20
    1614:	9001      	str	r0, [sp, #4]
    1616:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
    1618:	9b01      	ldr	r3, [sp, #4]
    161a:	681b      	ldr	r3, [r3, #0]
    161c:	2b00      	cmp	r3, #0
    161e:	d013      	beq.n	1648 <chThdResumeI+0x38>
    thread_t *tp = *trp;
    1620:	9b01      	ldr	r3, [sp, #4]
    1622:	681b      	ldr	r3, [r3, #0]
    1624:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
    1626:	9b03      	ldr	r3, [sp, #12]
    1628:	f893 3020 	ldrb.w	r3, [r3, #32]
    162c:	2b03      	cmp	r3, #3
    162e:	d002      	beq.n	1636 <chThdResumeI+0x26>
    1630:	4807      	ldr	r0, [pc, #28]	; (1650 <chThdResumeI+0x40>)
    1632:	f7ff f83d 	bl	6b0 <chSysHalt>
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    1636:	9b01      	ldr	r3, [sp, #4]
    1638:	2200      	movs	r2, #0
    163a:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
    163c:	9b03      	ldr	r3, [sp, #12]
    163e:	9a00      	ldr	r2, [sp, #0]
    1640:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    1642:	9803      	ldr	r0, [sp, #12]
    1644:	f7ff fbc4 	bl	dd0 <chSchReadyI>
  }
}
    1648:	b005      	add	sp, #20
    164a:	f85d fb04 	ldr.w	pc, [sp], #4
    164e:	bf00      	nop
    1650:	00003cc0 	.word	0x00003cc0
    1654:	f3af 8000 	nop.w
    1658:	f3af 8000 	nop.w
    165c:	f3af 8000 	nop.w

00001660 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
    1660:	b500      	push	{lr}
    1662:	b083      	sub	sp, #12
    1664:	9001      	str	r0, [sp, #4]
    1666:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
    1668:	9b00      	ldr	r3, [sp, #0]
    166a:	2b00      	cmp	r3, #0
    166c:	d102      	bne.n	1674 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
    166e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1672:	e00a      	b.n	168a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
    1674:	4b07      	ldr	r3, [pc, #28]	; (1694 <chThdEnqueueTimeoutS+0x34>)
    1676:	699b      	ldr	r3, [r3, #24]
    1678:	4618      	mov	r0, r3
    167a:	9901      	ldr	r1, [sp, #4]
    167c:	f7ff fdc8 	bl	1210 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1680:	2004      	movs	r0, #4
    1682:	9900      	ldr	r1, [sp, #0]
    1684:	f7ff fc64 	bl	f50 <chSchGoSleepTimeoutS>
    1688:	4603      	mov	r3, r0
}
    168a:	4618      	mov	r0, r3
    168c:	b003      	add	sp, #12
    168e:	f85d fb04 	ldr.w	pc, [sp], #4
    1692:	bf00      	nop
    1694:	20000800 	.word	0x20000800
    1698:	f3af 8000 	nop.w
    169c:	f3af 8000 	nop.w

000016a0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    16a0:	b500      	push	{lr}
    16a2:	b083      	sub	sp, #12
    16a4:	9001      	str	r0, [sp, #4]
    16a6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
    16a8:	9801      	ldr	r0, [sp, #4]
    16aa:	f7ff fd91 	bl	11d0 <queue_notempty>
    16ae:	4603      	mov	r3, r0
    16b0:	2b00      	cmp	r3, #0
    16b2:	d003      	beq.n	16bc <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
    16b4:	9801      	ldr	r0, [sp, #4]
    16b6:	9900      	ldr	r1, [sp, #0]
    16b8:	f7ff fe1a 	bl	12f0 <chThdDoDequeueNextI>
  }
}
    16bc:	b003      	add	sp, #12
    16be:	f85d fb04 	ldr.w	pc, [sp], #4
    16c2:	bf00      	nop
    16c4:	f3af 8000 	nop.w
    16c8:	f3af 8000 	nop.w
    16cc:	f3af 8000 	nop.w

000016d0 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
    16d0:	4b01      	ldr	r3, [pc, #4]	; (16d8 <port_rt_get_counter_value+0x8>)
    16d2:	685b      	ldr	r3, [r3, #4]
}
    16d4:	4618      	mov	r0, r3
    16d6:	4770      	bx	lr
    16d8:	e0001000 	.word	0xe0001000
    16dc:	f3af 8000 	nop.w

000016e0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
    16e0:	b084      	sub	sp, #16
    16e2:	9003      	str	r0, [sp, #12]
    16e4:	9102      	str	r1, [sp, #8]
    16e6:	9201      	str	r2, [sp, #4]

  tmp->n++;
    16e8:	9b03      	ldr	r3, [sp, #12]
    16ea:	68db      	ldr	r3, [r3, #12]
    16ec:	1c5a      	adds	r2, r3, #1
    16ee:	9b03      	ldr	r3, [sp, #12]
    16f0:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
    16f2:	9b03      	ldr	r3, [sp, #12]
    16f4:	689b      	ldr	r3, [r3, #8]
    16f6:	9a02      	ldr	r2, [sp, #8]
    16f8:	1ad2      	subs	r2, r2, r3
    16fa:	9b01      	ldr	r3, [sp, #4]
    16fc:	1ad2      	subs	r2, r2, r3
    16fe:	9b03      	ldr	r3, [sp, #12]
    1700:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
    1702:	9b03      	ldr	r3, [sp, #12]
    1704:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
    1708:	9b03      	ldr	r3, [sp, #12]
    170a:	689b      	ldr	r3, [r3, #8]
    170c:	461a      	mov	r2, r3
    170e:	f04f 0300 	mov.w	r3, #0
    1712:	1812      	adds	r2, r2, r0
    1714:	eb43 0301 	adc.w	r3, r3, r1
    1718:	9903      	ldr	r1, [sp, #12]
    171a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
    171e:	9b03      	ldr	r3, [sp, #12]
    1720:	689a      	ldr	r2, [r3, #8]
    1722:	9b03      	ldr	r3, [sp, #12]
    1724:	685b      	ldr	r3, [r3, #4]
    1726:	429a      	cmp	r2, r3
    1728:	d904      	bls.n	1734 <tm_stop+0x54>
    tmp->worst = tmp->last;
    172a:	9b03      	ldr	r3, [sp, #12]
    172c:	689a      	ldr	r2, [r3, #8]
    172e:	9b03      	ldr	r3, [sp, #12]
    1730:	605a      	str	r2, [r3, #4]
    1732:	e009      	b.n	1748 <tm_stop+0x68>
  }
  else if (tmp->last < tmp->best) {
    1734:	9b03      	ldr	r3, [sp, #12]
    1736:	689a      	ldr	r2, [r3, #8]
    1738:	9b03      	ldr	r3, [sp, #12]
    173a:	681b      	ldr	r3, [r3, #0]
    173c:	429a      	cmp	r2, r3
    173e:	d203      	bcs.n	1748 <tm_stop+0x68>
    tmp->best = tmp->last;
    1740:	9b03      	ldr	r3, [sp, #12]
    1742:	689a      	ldr	r2, [r3, #8]
    1744:	9b03      	ldr	r3, [sp, #12]
    1746:	601a      	str	r2, [r3, #0]
  }
  /*lint -restore*/
}
    1748:	b004      	add	sp, #16
    174a:	4770      	bx	lr
    174c:	f3af 8000 	nop.w

00001750 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
    1750:	b500      	push	{lr}
    1752:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
    1754:	4b0b      	ldr	r3, [pc, #44]	; (1784 <_tm_init+0x34>)
    1756:	2200      	movs	r2, #0
    1758:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
  chTMObjectInit(&tm);
    175c:	466b      	mov	r3, sp
    175e:	4618      	mov	r0, r3
    1760:	f000 f816 	bl	1790 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
    1764:	466b      	mov	r3, sp
    1766:	4618      	mov	r0, r3
    1768:	f000 f82a 	bl	17c0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
    176c:	466b      	mov	r3, sp
    176e:	4618      	mov	r0, r3
    1770:	f000 f836 	bl	17e0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
    1774:	9a02      	ldr	r2, [sp, #8]
    1776:	4b03      	ldr	r3, [pc, #12]	; (1784 <_tm_init+0x34>)
    1778:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
}
    177c:	b007      	add	sp, #28
    177e:	f85d fb04 	ldr.w	pc, [sp], #4
    1782:	bf00      	nop
    1784:	20000800 	.word	0x20000800
    1788:	f3af 8000 	nop.w
    178c:	f3af 8000 	nop.w

00001790 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
    1790:	b082      	sub	sp, #8
    1792:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
    1794:	9b01      	ldr	r3, [sp, #4]
    1796:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    179a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
    179c:	9b01      	ldr	r3, [sp, #4]
    179e:	2200      	movs	r2, #0
    17a0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
    17a2:	9b01      	ldr	r3, [sp, #4]
    17a4:	2200      	movs	r2, #0
    17a6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
    17a8:	9b01      	ldr	r3, [sp, #4]
    17aa:	2200      	movs	r2, #0
    17ac:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
    17ae:	9901      	ldr	r1, [sp, #4]
    17b0:	f04f 0200 	mov.w	r2, #0
    17b4:	f04f 0300 	mov.w	r3, #0
    17b8:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
    17bc:	b002      	add	sp, #8
    17be:	4770      	bx	lr

000017c0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
    17c0:	b500      	push	{lr}
    17c2:	b083      	sub	sp, #12
    17c4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
    17c6:	f7ff ff83 	bl	16d0 <port_rt_get_counter_value>
    17ca:	4602      	mov	r2, r0
    17cc:	9b01      	ldr	r3, [sp, #4]
    17ce:	609a      	str	r2, [r3, #8]
}
    17d0:	b003      	add	sp, #12
    17d2:	f85d fb04 	ldr.w	pc, [sp], #4
    17d6:	bf00      	nop
    17d8:	f3af 8000 	nop.w
    17dc:	f3af 8000 	nop.w

000017e0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
    17e0:	b500      	push	{lr}
    17e2:	b083      	sub	sp, #12
    17e4:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
    17e6:	f7ff ff73 	bl	16d0 <port_rt_get_counter_value>
    17ea:	4602      	mov	r2, r0
    17ec:	4b05      	ldr	r3, [pc, #20]	; (1804 <chTMStopMeasurementX+0x24>)
    17ee:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
    17f2:	9801      	ldr	r0, [sp, #4]
    17f4:	4611      	mov	r1, r2
    17f6:	461a      	mov	r2, r3
    17f8:	f7ff ff72 	bl	16e0 <tm_stop>
}
    17fc:	b003      	add	sp, #12
    17fe:	f85d fb04 	ldr.w	pc, [sp], #4
    1802:	bf00      	nop
    1804:	20000800 	.word	0x20000800
    1808:	f3af 8000 	nop.w
    180c:	f3af 8000 	nop.w

00001810 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
    1810:	b500      	push	{lr}
    1812:	b083      	sub	sp, #12
    1814:	9001      	str	r0, [sp, #4]
    1816:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
    1818:	f7ff ff5a 	bl	16d0 <port_rt_get_counter_value>
    181c:	4602      	mov	r2, r0
    181e:	9b00      	ldr	r3, [sp, #0]
    1820:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
    1822:	9b00      	ldr	r3, [sp, #0]
    1824:	689b      	ldr	r3, [r3, #8]
    1826:	9801      	ldr	r0, [sp, #4]
    1828:	4619      	mov	r1, r3
    182a:	2200      	movs	r2, #0
    182c:	f7ff ff58 	bl	16e0 <tm_stop>
}
    1830:	b003      	add	sp, #12
    1832:	f85d fb04 	ldr.w	pc, [sp], #4
    1836:	bf00      	nop
    1838:	f3af 8000 	nop.w
    183c:	f3af 8000 	nop.w

00001840 <_stats_init>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
    1840:	b508      	push	{r3, lr}

  ch.kernel_stats.n_irq = (ucnt_t)0;
    1842:	4b07      	ldr	r3, [pc, #28]	; (1860 <_stats_init+0x20>)
    1844:	2200      	movs	r2, #0
    1846:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
    184a:	4b05      	ldr	r3, [pc, #20]	; (1860 <_stats_init+0x20>)
    184c:	2200      	movs	r2, #0
    184e:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
    1852:	4804      	ldr	r0, [pc, #16]	; (1864 <_stats_init+0x24>)
    1854:	f7ff ff9c 	bl	1790 <chTMObjectInit>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
    1858:	4803      	ldr	r0, [pc, #12]	; (1868 <_stats_init+0x28>)
    185a:	f7ff ff99 	bl	1790 <chTMObjectInit>
}
    185e:	bd08      	pop	{r3, pc}
    1860:	20000800 	.word	0x20000800
    1864:	20000cb0 	.word	0x20000cb0
    1868:	20000cc8 	.word	0x20000cc8
    186c:	f3af 8000 	nop.w

00001870 <_stats_increase_irq>:
/**
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {

  ch.kernel_stats.n_irq++;
    1870:	4b03      	ldr	r3, [pc, #12]	; (1880 <_stats_increase_irq+0x10>)
    1872:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
    1876:	1c5a      	adds	r2, r3, #1
    1878:	4b01      	ldr	r3, [pc, #4]	; (1880 <_stats_increase_irq+0x10>)
    187a:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
}
    187e:	4770      	bx	lr
    1880:	20000800 	.word	0x20000800
    1884:	f3af 8000 	nop.w
    1888:	f3af 8000 	nop.w
    188c:	f3af 8000 	nop.w

00001890 <_stats_ctxswc>:
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
    1890:	b500      	push	{lr}
    1892:	b083      	sub	sp, #12
    1894:	9001      	str	r0, [sp, #4]
    1896:	9100      	str	r1, [sp, #0]

  ch.kernel_stats.n_ctxswc++;
    1898:	4b09      	ldr	r3, [pc, #36]	; (18c0 <_stats_ctxswc+0x30>)
    189a:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
    189e:	1c5a      	adds	r2, r3, #1
    18a0:	4b07      	ldr	r3, [pc, #28]	; (18c0 <_stats_ctxswc+0x30>)
    18a2:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
    18a6:	9b00      	ldr	r3, [sp, #0]
    18a8:	f103 0248 	add.w	r2, r3, #72	; 0x48
    18ac:	9b01      	ldr	r3, [sp, #4]
    18ae:	3348      	adds	r3, #72	; 0x48
    18b0:	4610      	mov	r0, r2
    18b2:	4619      	mov	r1, r3
    18b4:	f7ff ffac 	bl	1810 <chTMChainMeasurementToX>
}
    18b8:	b003      	add	sp, #12
    18ba:	f85d fb04 	ldr.w	pc, [sp], #4
    18be:	bf00      	nop
    18c0:	20000800 	.word	0x20000800
    18c4:	f3af 8000 	nop.w
    18c8:	f3af 8000 	nop.w
    18cc:	f3af 8000 	nop.w

000018d0 <_stats_start_measure_crit_thd>:

/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {
    18d0:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
    18d2:	4802      	ldr	r0, [pc, #8]	; (18dc <_stats_start_measure_crit_thd+0xc>)
    18d4:	f7ff ff74 	bl	17c0 <chTMStartMeasurementX>
}
    18d8:	bd08      	pop	{r3, pc}
    18da:	bf00      	nop
    18dc:	20000cb0 	.word	0x20000cb0

000018e0 <_stats_stop_measure_crit_thd>:

/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {
    18e0:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
    18e2:	4802      	ldr	r0, [pc, #8]	; (18ec <_stats_stop_measure_crit_thd+0xc>)
    18e4:	f7ff ff7c 	bl	17e0 <chTMStopMeasurementX>
}
    18e8:	bd08      	pop	{r3, pc}
    18ea:	bf00      	nop
    18ec:	20000cb0 	.word	0x20000cb0

000018f0 <_stats_start_measure_crit_isr>:

/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {
    18f0:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
    18f2:	4802      	ldr	r0, [pc, #8]	; (18fc <_stats_start_measure_crit_isr+0xc>)
    18f4:	f7ff ff64 	bl	17c0 <chTMStartMeasurementX>
}
    18f8:	bd08      	pop	{r3, pc}
    18fa:	bf00      	nop
    18fc:	20000cc8 	.word	0x20000cc8

00001900 <_stats_stop_measure_crit_isr>:

/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {
    1900:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
    1902:	4802      	ldr	r0, [pc, #8]	; (190c <_stats_stop_measure_crit_isr+0xc>)
    1904:	f7ff ff6c 	bl	17e0 <chTMStopMeasurementX>
}
    1908:	bd08      	pop	{r3, pc}
    190a:	bf00      	nop
    190c:	20000cc8 	.word	0x20000cc8

00001910 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1910:	b082      	sub	sp, #8
    1912:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1914:	9b01      	ldr	r3, [sp, #4]
    1916:	9a01      	ldr	r2, [sp, #4]
    1918:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    191a:	9b01      	ldr	r3, [sp, #4]
    191c:	9a01      	ldr	r2, [sp, #4]
    191e:	605a      	str	r2, [r3, #4]
}
    1920:	b002      	add	sp, #8
    1922:	4770      	bx	lr
    1924:	f3af 8000 	nop.w
    1928:	f3af 8000 	nop.w
    192c:	f3af 8000 	nop.w

00001930 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
    1930:	b500      	push	{lr}
    1932:	b083      	sub	sp, #12
    1934:	9001      	str	r0, [sp, #4]
    1936:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
    1938:	9b01      	ldr	r3, [sp, #4]
    193a:	2b00      	cmp	r3, #0
    193c:	d002      	beq.n	1944 <chSemObjectInit+0x14>
    193e:	9b00      	ldr	r3, [sp, #0]
    1940:	2b00      	cmp	r3, #0
    1942:	da02      	bge.n	194a <chSemObjectInit+0x1a>
    1944:	4806      	ldr	r0, [pc, #24]	; (1960 <chSemObjectInit+0x30>)
    1946:	f7fe feb3 	bl	6b0 <chSysHalt>

  queue_init(&sp->s_queue);
    194a:	9b01      	ldr	r3, [sp, #4]
    194c:	4618      	mov	r0, r3
    194e:	f7ff ffdf 	bl	1910 <queue_init>
  sp->s_cnt = n;
    1952:	9b01      	ldr	r3, [sp, #4]
    1954:	9a00      	ldr	r2, [sp, #0]
    1956:	609a      	str	r2, [r3, #8]
}
    1958:	b003      	add	sp, #12
    195a:	f85d fb04 	ldr.w	pc, [sp], #4
    195e:	bf00      	nop
    1960:	00003d10 	.word	0x00003d10
    1964:	f3af 8000 	nop.w
    1968:	f3af 8000 	nop.w
    196c:	f3af 8000 	nop.w

00001970 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1970:	b082      	sub	sp, #8
    1972:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1974:	9b01      	ldr	r3, [sp, #4]
    1976:	9a01      	ldr	r2, [sp, #4]
    1978:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    197a:	9b01      	ldr	r3, [sp, #4]
    197c:	9a01      	ldr	r2, [sp, #4]
    197e:	605a      	str	r2, [r3, #4]
}
    1980:	b002      	add	sp, #8
    1982:	4770      	bx	lr
    1984:	f3af 8000 	nop.w
    1988:	f3af 8000 	nop.w
    198c:	f3af 8000 	nop.w

00001990 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
    1990:	b500      	push	{lr}
    1992:	b083      	sub	sp, #12
    1994:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
    1996:	9b01      	ldr	r3, [sp, #4]
    1998:	2b00      	cmp	r3, #0
    199a:	d102      	bne.n	19a2 <chMtxObjectInit+0x12>
    199c:	4806      	ldr	r0, [pc, #24]	; (19b8 <chMtxObjectInit+0x28>)
    199e:	f7fe fe87 	bl	6b0 <chSysHalt>

  queue_init(&mp->m_queue);
    19a2:	9b01      	ldr	r3, [sp, #4]
    19a4:	4618      	mov	r0, r3
    19a6:	f7ff ffe3 	bl	1970 <queue_init>
  mp->m_owner = NULL;
    19aa:	9b01      	ldr	r3, [sp, #4]
    19ac:	2200      	movs	r2, #0
    19ae:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
    19b0:	b003      	add	sp, #12
    19b2:	f85d fb04 	ldr.w	pc, [sp], #4
    19b6:	bf00      	nop
    19b8:	00003d20 	.word	0x00003d20
    19bc:	f3af 8000 	nop.w

000019c0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    19c0:	b500      	push	{lr}
    19c2:	b085      	sub	sp, #20
    19c4:	9001      	str	r0, [sp, #4]
    19c6:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
    19c8:	f7fe ff7a 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
    19cc:	9b01      	ldr	r3, [sp, #4]
    19ce:	2b00      	cmp	r3, #0
    19d0:	d102      	bne.n	19d8 <chEvtBroadcastFlagsI+0x18>
    19d2:	4814      	ldr	r0, [pc, #80]	; (1a24 <chEvtBroadcastFlagsI+0x64>)
    19d4:	f7fe fe6c 	bl	6b0 <chSysHalt>

  elp = esp->es_next;
    19d8:	9b01      	ldr	r3, [sp, #4]
    19da:	681b      	ldr	r3, [r3, #0]
    19dc:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    19de:	e01a      	b.n	1a16 <chEvtBroadcastFlagsI+0x56>
  /*lint -restore*/
    elp->el_flags |= flags;
    19e0:	9b03      	ldr	r3, [sp, #12]
    19e2:	68da      	ldr	r2, [r3, #12]
    19e4:	9b00      	ldr	r3, [sp, #0]
    19e6:	431a      	orrs	r2, r3
    19e8:	9b03      	ldr	r3, [sp, #12]
    19ea:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    19ec:	9b00      	ldr	r3, [sp, #0]
    19ee:	2b00      	cmp	r3, #0
    19f0:	d006      	beq.n	1a00 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
    19f2:	9b03      	ldr	r3, [sp, #12]
    19f4:	68da      	ldr	r2, [r3, #12]
    19f6:	9b03      	ldr	r3, [sp, #12]
    19f8:	691b      	ldr	r3, [r3, #16]
    19fa:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    19fc:	2b00      	cmp	r3, #0
    19fe:	d007      	beq.n	1a10 <chEvtBroadcastFlagsI+0x50>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    1a00:	9b03      	ldr	r3, [sp, #12]
    1a02:	685a      	ldr	r2, [r3, #4]
    1a04:	9b03      	ldr	r3, [sp, #12]
    1a06:	689b      	ldr	r3, [r3, #8]
    1a08:	4610      	mov	r0, r2
    1a0a:	4619      	mov	r1, r3
    1a0c:	f000 f810 	bl	1a30 <chEvtSignalI>
    }
    elp = elp->el_next;
    1a10:	9b03      	ldr	r3, [sp, #12]
    1a12:	681b      	ldr	r3, [r3, #0]
    1a14:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    1a16:	9a03      	ldr	r2, [sp, #12]
    1a18:	9b01      	ldr	r3, [sp, #4]
    1a1a:	429a      	cmp	r2, r3
    1a1c:	d1e0      	bne.n	19e0 <chEvtBroadcastFlagsI+0x20>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
    1a1e:	b005      	add	sp, #20
    1a20:	f85d fb04 	ldr.w	pc, [sp], #4
    1a24:	00003d30 	.word	0x00003d30
    1a28:	f3af 8000 	nop.w
    1a2c:	f3af 8000 	nop.w

00001a30 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
    1a30:	b500      	push	{lr}
    1a32:	b083      	sub	sp, #12
    1a34:	9001      	str	r0, [sp, #4]
    1a36:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
    1a38:	f7fe ff42 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
    1a3c:	9b01      	ldr	r3, [sp, #4]
    1a3e:	2b00      	cmp	r3, #0
    1a40:	d102      	bne.n	1a48 <chEvtSignalI+0x18>
    1a42:	4816      	ldr	r0, [pc, #88]	; (1a9c <chEvtSignalI+0x6c>)
    1a44:	f7fe fe34 	bl	6b0 <chSysHalt>

  tp->p_epending |= events;
    1a48:	9b01      	ldr	r3, [sp, #4]
    1a4a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1a4c:	9b00      	ldr	r3, [sp, #0]
    1a4e:	431a      	orrs	r2, r3
    1a50:	9b01      	ldr	r3, [sp, #4]
    1a52:	639a      	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    1a54:	9b01      	ldr	r3, [sp, #4]
    1a56:	f893 3020 	ldrb.w	r3, [r3, #32]
    1a5a:	2b0a      	cmp	r3, #10
    1a5c:	d106      	bne.n	1a6c <chEvtSignalI+0x3c>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    1a5e:	9b01      	ldr	r3, [sp, #4]
    1a60:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1a62:	9b01      	ldr	r3, [sp, #4]
    1a64:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1a66:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    1a68:	2b00      	cmp	r3, #0
    1a6a:	d10d      	bne.n	1a88 <chEvtSignalI+0x58>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
    1a6c:	9b01      	ldr	r3, [sp, #4]
    1a6e:	f893 3020 	ldrb.w	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    1a72:	2b0b      	cmp	r3, #11
    1a74:	d10e      	bne.n	1a94 <chEvtSignalI+0x64>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    1a76:	9b01      	ldr	r3, [sp, #4]
    1a78:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1a7a:	9b01      	ldr	r3, [sp, #4]
    1a7c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1a7e:	401a      	ands	r2, r3
    1a80:	9b01      	ldr	r3, [sp, #4]
    1a82:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
    1a84:	429a      	cmp	r2, r3
    1a86:	d105      	bne.n	1a94 <chEvtSignalI+0x64>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
    1a88:	9b01      	ldr	r3, [sp, #4]
    1a8a:	2200      	movs	r2, #0
    1a8c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    1a8e:	9801      	ldr	r0, [sp, #4]
    1a90:	f7ff f99e 	bl	dd0 <chSchReadyI>
  }
}
    1a94:	b003      	add	sp, #12
    1a96:	f85d fb04 	ldr.w	pc, [sp], #4
    1a9a:	bf00      	nop
    1a9c:	00003d50 	.word	0x00003d50

00001aa0 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
    1aa0:	b500      	push	{lr}
    1aa2:	b085      	sub	sp, #20
    1aa4:	9003      	str	r0, [sp, #12]
    1aa6:	9102      	str	r1, [sp, #8]
    1aa8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
    1aaa:	9b03      	ldr	r3, [sp, #12]
    1aac:	2b00      	cmp	r3, #0
    1aae:	d005      	beq.n	1abc <chMBObjectInit+0x1c>
    1ab0:	9b02      	ldr	r3, [sp, #8]
    1ab2:	2b00      	cmp	r3, #0
    1ab4:	d002      	beq.n	1abc <chMBObjectInit+0x1c>
    1ab6:	9b01      	ldr	r3, [sp, #4]
    1ab8:	2b00      	cmp	r3, #0
    1aba:	dc02      	bgt.n	1ac2 <chMBObjectInit+0x22>
    1abc:	4810      	ldr	r0, [pc, #64]	; (1b00 <chMBObjectInit+0x60>)
    1abe:	f7fe fdf7 	bl	6b0 <chSysHalt>

  mbp->mb_buffer = buf;
    1ac2:	9b03      	ldr	r3, [sp, #12]
    1ac4:	9a02      	ldr	r2, [sp, #8]
    1ac6:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
    1ac8:	9b03      	ldr	r3, [sp, #12]
    1aca:	9a02      	ldr	r2, [sp, #8]
    1acc:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
    1ace:	9b03      	ldr	r3, [sp, #12]
    1ad0:	9a02      	ldr	r2, [sp, #8]
    1ad2:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
    1ad4:	9b01      	ldr	r3, [sp, #4]
    1ad6:	009b      	lsls	r3, r3, #2
    1ad8:	9a02      	ldr	r2, [sp, #8]
    1ada:	441a      	add	r2, r3
    1adc:	9b03      	ldr	r3, [sp, #12]
    1ade:	605a      	str	r2, [r3, #4]
  chSemObjectInit(&mbp->mb_emptysem, n);
    1ae0:	9b03      	ldr	r3, [sp, #12]
    1ae2:	331c      	adds	r3, #28
    1ae4:	4618      	mov	r0, r3
    1ae6:	9901      	ldr	r1, [sp, #4]
    1ae8:	f7ff ff22 	bl	1930 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
    1aec:	9b03      	ldr	r3, [sp, #12]
    1aee:	3310      	adds	r3, #16
    1af0:	4618      	mov	r0, r3
    1af2:	2100      	movs	r1, #0
    1af4:	f7ff ff1c 	bl	1930 <chSemObjectInit>
}
    1af8:	b005      	add	sp, #20
    1afa:	f85d fb04 	ldr.w	pc, [sp], #4
    1afe:	bf00      	nop
    1b00:	00003d60 	.word	0x00003d60
    1b04:	f3af 8000 	nop.w
    1b08:	f3af 8000 	nop.w
    1b0c:	f3af 8000 	nop.w

00001b10 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1b10:	b082      	sub	sp, #8
    1b12:	2320      	movs	r3, #32
    1b14:	9301      	str	r3, [sp, #4]
    1b16:	9b01      	ldr	r3, [sp, #4]
    1b18:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1b1c:	b002      	add	sp, #8
    1b1e:	4770      	bx	lr

00001b20 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1b20:	b082      	sub	sp, #8
    1b22:	2300      	movs	r3, #0
    1b24:	9301      	str	r3, [sp, #4]
    1b26:	9b01      	ldr	r3, [sp, #4]
    1b28:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1b2c:	b002      	add	sp, #8
    1b2e:	4770      	bx	lr

00001b30 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1b30:	b082      	sub	sp, #8
    1b32:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1b34:	9b01      	ldr	r3, [sp, #4]
    1b36:	9a01      	ldr	r2, [sp, #4]
    1b38:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    1b3a:	9b01      	ldr	r3, [sp, #4]
    1b3c:	9a01      	ldr	r2, [sp, #4]
    1b3e:	605a      	str	r2, [r3, #4]
}
    1b40:	b002      	add	sp, #8
    1b42:	4770      	bx	lr
    1b44:	f3af 8000 	nop.w
    1b48:	f3af 8000 	nop.w
    1b4c:	f3af 8000 	nop.w

00001b50 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1b50:	b508      	push	{r3, lr}

  port_lock();
    1b52:	f7ff ffdd 	bl	1b10 <port_lock>
  _stats_start_measure_crit_thd();
    1b56:	f7ff febb 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1b5a:	f7fe fe11 	bl	780 <_dbg_check_lock>
}
    1b5e:	bd08      	pop	{r3, pc}

00001b60 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1b60:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1b62:	f7fe fe25 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1b66:	f7ff febb 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    1b6a:	4b09      	ldr	r3, [pc, #36]	; (1b90 <chSysUnlock+0x30>)
    1b6c:	681a      	ldr	r2, [r3, #0]
    1b6e:	4b08      	ldr	r3, [pc, #32]	; (1b90 <chSysUnlock+0x30>)
    1b70:	429a      	cmp	r2, r3
    1b72:	d00a      	beq.n	1b8a <chSysUnlock+0x2a>
    1b74:	4b06      	ldr	r3, [pc, #24]	; (1b90 <chSysUnlock+0x30>)
    1b76:	699b      	ldr	r3, [r3, #24]
    1b78:	689a      	ldr	r2, [r3, #8]
    1b7a:	4b05      	ldr	r3, [pc, #20]	; (1b90 <chSysUnlock+0x30>)
    1b7c:	681b      	ldr	r3, [r3, #0]
    1b7e:	689b      	ldr	r3, [r3, #8]
    1b80:	429a      	cmp	r2, r3
    1b82:	d202      	bcs.n	1b8a <chSysUnlock+0x2a>
    1b84:	4803      	ldr	r0, [pc, #12]	; (1b94 <chSysUnlock+0x34>)
    1b86:	f7fe fd93 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    1b8a:	f7ff ffc9 	bl	1b20 <port_unlock>
}
    1b8e:	bd08      	pop	{r3, pc}
    1b90:	20000800 	.word	0x20000800
    1b94:	00003d70 	.word	0x00003d70
    1b98:	f3af 8000 	nop.w
    1b9c:	f3af 8000 	nop.w

00001ba0 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
    1ba0:	b500      	push	{lr}
    1ba2:	b083      	sub	sp, #12
    1ba4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
    1ba6:	9801      	ldr	r0, [sp, #4]
    1ba8:	f7ff ffc2 	bl	1b30 <queue_init>
}
    1bac:	b003      	add	sp, #12
    1bae:	f85d fb04 	ldr.w	pc, [sp], #4
    1bb2:	bf00      	nop
    1bb4:	f3af 8000 	nop.w
    1bb8:	f3af 8000 	nop.w
    1bbc:	f3af 8000 	nop.w

00001bc0 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
    1bc0:	b500      	push	{lr}
    1bc2:	b083      	sub	sp, #12
    1bc4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1bc6:	f7fe fe7b 	bl	8c0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
    1bca:	9b01      	ldr	r3, [sp, #4]
    1bcc:	689b      	ldr	r3, [r3, #8]
    1bce:	2b00      	cmp	r3, #0
    1bd0:	bf14      	ite	ne
    1bd2:	2300      	movne	r3, #0
    1bd4:	2301      	moveq	r3, #1
    1bd6:	b2db      	uxtb	r3, r3
}
    1bd8:	4618      	mov	r0, r3
    1bda:	b003      	add	sp, #12
    1bdc:	f85d fb04 	ldr.w	pc, [sp], #4

00001be0 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
    1be0:	b500      	push	{lr}
    1be2:	b083      	sub	sp, #12
    1be4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1be6:	f7fe fe6b 	bl	8c0 <chDbgCheckClassI>

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
    1bea:	9b01      	ldr	r3, [sp, #4]
    1bec:	695a      	ldr	r2, [r3, #20]
    1bee:	9b01      	ldr	r3, [sp, #4]
    1bf0:	699b      	ldr	r3, [r3, #24]
    1bf2:	429a      	cmp	r2, r3
    1bf4:	d105      	bne.n	1c02 <chIQIsFullI+0x22>
    1bf6:	9b01      	ldr	r3, [sp, #4]
    1bf8:	689b      	ldr	r3, [r3, #8]
    1bfa:	2b00      	cmp	r3, #0
    1bfc:	d001      	beq.n	1c02 <chIQIsFullI+0x22>
    1bfe:	2301      	movs	r3, #1
    1c00:	e000      	b.n	1c04 <chIQIsFullI+0x24>
    1c02:	2300      	movs	r3, #0
    1c04:	f003 0301 	and.w	r3, r3, #1
    1c08:	b2db      	uxtb	r3, r3
}
    1c0a:	4618      	mov	r0, r3
    1c0c:	b003      	add	sp, #12
    1c0e:	f85d fb04 	ldr.w	pc, [sp], #4
    1c12:	bf00      	nop
    1c14:	f3af 8000 	nop.w
    1c18:	f3af 8000 	nop.w
    1c1c:	f3af 8000 	nop.w

00001c20 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
    1c20:	b500      	push	{lr}
    1c22:	b083      	sub	sp, #12
    1c24:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1c26:	f7fe fe4b 	bl	8c0 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    1c2a:	9b01      	ldr	r3, [sp, #4]
    1c2c:	695a      	ldr	r2, [r3, #20]
    1c2e:	9b01      	ldr	r3, [sp, #4]
    1c30:	699b      	ldr	r3, [r3, #24]
    1c32:	429a      	cmp	r2, r3
    1c34:	d105      	bne.n	1c42 <chOQIsEmptyI+0x22>
    1c36:	9b01      	ldr	r3, [sp, #4]
    1c38:	689b      	ldr	r3, [r3, #8]
    1c3a:	2b00      	cmp	r3, #0
    1c3c:	d001      	beq.n	1c42 <chOQIsEmptyI+0x22>
    1c3e:	2301      	movs	r3, #1
    1c40:	e000      	b.n	1c44 <chOQIsEmptyI+0x24>
    1c42:	2300      	movs	r3, #0
    1c44:	f003 0301 	and.w	r3, r3, #1
    1c48:	b2db      	uxtb	r3, r3
}
    1c4a:	4618      	mov	r0, r3
    1c4c:	b003      	add	sp, #12
    1c4e:	f85d fb04 	ldr.w	pc, [sp], #4
    1c52:	bf00      	nop
    1c54:	f3af 8000 	nop.w
    1c58:	f3af 8000 	nop.w
    1c5c:	f3af 8000 	nop.w

00001c60 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
    1c60:	b500      	push	{lr}
    1c62:	b083      	sub	sp, #12
    1c64:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1c66:	f7fe fe2b 	bl	8c0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
    1c6a:	9b01      	ldr	r3, [sp, #4]
    1c6c:	689b      	ldr	r3, [r3, #8]
    1c6e:	2b00      	cmp	r3, #0
    1c70:	bf14      	ite	ne
    1c72:	2300      	movne	r3, #0
    1c74:	2301      	moveq	r3, #1
    1c76:	b2db      	uxtb	r3, r3
}
    1c78:	4618      	mov	r0, r3
    1c7a:	b003      	add	sp, #12
    1c7c:	f85d fb04 	ldr.w	pc, [sp], #4

00001c80 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
    1c80:	b500      	push	{lr}
    1c82:	b085      	sub	sp, #20
    1c84:	9003      	str	r0, [sp, #12]
    1c86:	9102      	str	r1, [sp, #8]
    1c88:	9201      	str	r2, [sp, #4]
    1c8a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
    1c8c:	9b03      	ldr	r3, [sp, #12]
    1c8e:	4618      	mov	r0, r3
    1c90:	f7ff ff86 	bl	1ba0 <chThdQueueObjectInit>
  iqp->q_counter = 0;
    1c94:	9b03      	ldr	r3, [sp, #12]
    1c96:	2200      	movs	r2, #0
    1c98:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
    1c9a:	9b03      	ldr	r3, [sp, #12]
    1c9c:	9a02      	ldr	r2, [sp, #8]
    1c9e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
    1ca0:	9b03      	ldr	r3, [sp, #12]
    1ca2:	9a02      	ldr	r2, [sp, #8]
    1ca4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
    1ca6:	9b03      	ldr	r3, [sp, #12]
    1ca8:	9a02      	ldr	r2, [sp, #8]
    1caa:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
    1cac:	9a02      	ldr	r2, [sp, #8]
    1cae:	9b01      	ldr	r3, [sp, #4]
    1cb0:	441a      	add	r2, r3
    1cb2:	9b03      	ldr	r3, [sp, #12]
    1cb4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
    1cb6:	9b03      	ldr	r3, [sp, #12]
    1cb8:	9a00      	ldr	r2, [sp, #0]
    1cba:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
    1cbc:	9b03      	ldr	r3, [sp, #12]
    1cbe:	9a06      	ldr	r2, [sp, #24]
    1cc0:	621a      	str	r2, [r3, #32]
}
    1cc2:	b005      	add	sp, #20
    1cc4:	f85d fb04 	ldr.w	pc, [sp], #4
    1cc8:	f3af 8000 	nop.w
    1ccc:	f3af 8000 	nop.w

00001cd0 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
    1cd0:	b500      	push	{lr}
    1cd2:	b083      	sub	sp, #12
    1cd4:	9001      	str	r0, [sp, #4]
    1cd6:	460b      	mov	r3, r1
    1cd8:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();
    1cdc:	f7fe fdf0 	bl	8c0 <chDbgCheckClassI>

  if (chIQIsFullI(iqp)) {
    1ce0:	9801      	ldr	r0, [sp, #4]
    1ce2:	f7ff ff7d 	bl	1be0 <chIQIsFullI>
    1ce6:	4603      	mov	r3, r0
    1ce8:	2b00      	cmp	r3, #0
    1cea:	d002      	beq.n	1cf2 <chIQPutI+0x22>
    return Q_FULL;
    1cec:	f06f 0303 	mvn.w	r3, #3
    1cf0:	e01c      	b.n	1d2c <chIQPutI+0x5c>
  }

  iqp->q_counter++;
    1cf2:	9b01      	ldr	r3, [sp, #4]
    1cf4:	689b      	ldr	r3, [r3, #8]
    1cf6:	1c5a      	adds	r2, r3, #1
    1cf8:	9b01      	ldr	r3, [sp, #4]
    1cfa:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
    1cfc:	9b01      	ldr	r3, [sp, #4]
    1cfe:	695b      	ldr	r3, [r3, #20]
    1d00:	1c59      	adds	r1, r3, #1
    1d02:	9a01      	ldr	r2, [sp, #4]
    1d04:	6151      	str	r1, [r2, #20]
    1d06:	f89d 2003 	ldrb.w	r2, [sp, #3]
    1d0a:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
    1d0c:	9b01      	ldr	r3, [sp, #4]
    1d0e:	695a      	ldr	r2, [r3, #20]
    1d10:	9b01      	ldr	r3, [sp, #4]
    1d12:	691b      	ldr	r3, [r3, #16]
    1d14:	429a      	cmp	r2, r3
    1d16:	d303      	bcc.n	1d20 <chIQPutI+0x50>
    iqp->q_wrptr = iqp->q_buffer;
    1d18:	9b01      	ldr	r3, [sp, #4]
    1d1a:	68da      	ldr	r2, [r3, #12]
    1d1c:	9b01      	ldr	r3, [sp, #4]
    1d1e:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
    1d20:	9b01      	ldr	r3, [sp, #4]
    1d22:	4618      	mov	r0, r3
    1d24:	2100      	movs	r1, #0
    1d26:	f7ff fcbb 	bl	16a0 <chThdDequeueNextI>

  return Q_OK;
    1d2a:	2300      	movs	r3, #0
}
    1d2c:	4618      	mov	r0, r3
    1d2e:	b003      	add	sp, #12
    1d30:	f85d fb04 	ldr.w	pc, [sp], #4
    1d34:	f3af 8000 	nop.w
    1d38:	f3af 8000 	nop.w
    1d3c:	f3af 8000 	nop.w

00001d40 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
    1d40:	b500      	push	{lr}
    1d42:	b085      	sub	sp, #20
    1d44:	9001      	str	r0, [sp, #4]
    1d46:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
    1d48:	f7ff ff02 	bl	1b50 <chSysLock>
  if (iqp->q_notify != NULL) {
    1d4c:	9b01      	ldr	r3, [sp, #4]
    1d4e:	69db      	ldr	r3, [r3, #28]
    1d50:	2b00      	cmp	r3, #0
    1d52:	d004      	beq.n	1d5e <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
    1d54:	9b01      	ldr	r3, [sp, #4]
    1d56:	69db      	ldr	r3, [r3, #28]
    1d58:	9801      	ldr	r0, [sp, #4]
    1d5a:	4798      	blx	r3
  }

  while (chIQIsEmptyI(iqp)) {
    1d5c:	e00d      	b.n	1d7a <chIQGetTimeout+0x3a>
    1d5e:	e00c      	b.n	1d7a <chIQGetTimeout+0x3a>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
    1d60:	9b01      	ldr	r3, [sp, #4]
    1d62:	4618      	mov	r0, r3
    1d64:	9900      	ldr	r1, [sp, #0]
    1d66:	f7ff fc7b 	bl	1660 <chThdEnqueueTimeoutS>
    1d6a:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
    1d6c:	9b03      	ldr	r3, [sp, #12]
    1d6e:	2b00      	cmp	r3, #0
    1d70:	da03      	bge.n	1d7a <chIQGetTimeout+0x3a>
      chSysUnlock();
    1d72:	f7ff fef5 	bl	1b60 <chSysUnlock>
      return msg;
    1d76:	9b03      	ldr	r3, [sp, #12]
    1d78:	e020      	b.n	1dbc <chIQGetTimeout+0x7c>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    1d7a:	9801      	ldr	r0, [sp, #4]
    1d7c:	f7ff ff20 	bl	1bc0 <chIQIsEmptyI>
    1d80:	4603      	mov	r3, r0
    1d82:	2b00      	cmp	r3, #0
    1d84:	d1ec      	bne.n	1d60 <chIQGetTimeout+0x20>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
    1d86:	9b01      	ldr	r3, [sp, #4]
    1d88:	689b      	ldr	r3, [r3, #8]
    1d8a:	1e5a      	subs	r2, r3, #1
    1d8c:	9b01      	ldr	r3, [sp, #4]
    1d8e:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
    1d90:	9b01      	ldr	r3, [sp, #4]
    1d92:	699b      	ldr	r3, [r3, #24]
    1d94:	1c59      	adds	r1, r3, #1
    1d96:	9a01      	ldr	r2, [sp, #4]
    1d98:	6191      	str	r1, [r2, #24]
    1d9a:	781b      	ldrb	r3, [r3, #0]
    1d9c:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
    1da0:	9b01      	ldr	r3, [sp, #4]
    1da2:	699a      	ldr	r2, [r3, #24]
    1da4:	9b01      	ldr	r3, [sp, #4]
    1da6:	691b      	ldr	r3, [r3, #16]
    1da8:	429a      	cmp	r2, r3
    1daa:	d303      	bcc.n	1db4 <chIQGetTimeout+0x74>
    iqp->q_rdptr = iqp->q_buffer;
    1dac:	9b01      	ldr	r3, [sp, #4]
    1dae:	68da      	ldr	r2, [r3, #12]
    1db0:	9b01      	ldr	r3, [sp, #4]
    1db2:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
    1db4:	f7ff fed4 	bl	1b60 <chSysUnlock>

  return (msg_t)b;
    1db8:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    1dbc:	4618      	mov	r0, r3
    1dbe:	b005      	add	sp, #20
    1dc0:	f85d fb04 	ldr.w	pc, [sp], #4
    1dc4:	f3af 8000 	nop.w
    1dc8:	f3af 8000 	nop.w
    1dcc:	f3af 8000 	nop.w

00001dd0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
    1dd0:	b500      	push	{lr}
    1dd2:	b087      	sub	sp, #28
    1dd4:	9003      	str	r0, [sp, #12]
    1dd6:	9102      	str	r1, [sp, #8]
    1dd8:	9201      	str	r2, [sp, #4]
    1dda:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
    1ddc:	9b03      	ldr	r3, [sp, #12]
    1dde:	69db      	ldr	r3, [r3, #28]
    1de0:	9304      	str	r3, [sp, #16]
  size_t r = 0;
    1de2:	2300      	movs	r3, #0
    1de4:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
    1de6:	9b01      	ldr	r3, [sp, #4]
    1de8:	2b00      	cmp	r3, #0
    1dea:	d102      	bne.n	1df2 <chIQReadTimeout+0x22>
    1dec:	4825      	ldr	r0, [pc, #148]	; (1e84 <chIQReadTimeout+0xb4>)
    1dee:	f7fe fc5f 	bl	6b0 <chSysHalt>

  chSysLock();
    1df2:	f7ff fead 	bl	1b50 <chSysLock>
  while (true) {
    if (nfy != NULL) {
    1df6:	9b04      	ldr	r3, [sp, #16]
    1df8:	2b00      	cmp	r3, #0
    1dfa:	d003      	beq.n	1e04 <chIQReadTimeout+0x34>
      nfy(iqp);
    1dfc:	9b04      	ldr	r3, [sp, #16]
    1dfe:	9803      	ldr	r0, [sp, #12]
    1e00:	4798      	blx	r3
    }

    while (chIQIsEmptyI(iqp)) {
    1e02:	e00c      	b.n	1e1e <chIQReadTimeout+0x4e>
    1e04:	e00b      	b.n	1e1e <chIQReadTimeout+0x4e>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
    1e06:	9b03      	ldr	r3, [sp, #12]
    1e08:	4618      	mov	r0, r3
    1e0a:	9900      	ldr	r1, [sp, #0]
    1e0c:	f7ff fc28 	bl	1660 <chThdEnqueueTimeoutS>
    1e10:	4603      	mov	r3, r0
    1e12:	2b00      	cmp	r3, #0
    1e14:	d003      	beq.n	1e1e <chIQReadTimeout+0x4e>
        chSysUnlock();
    1e16:	f7ff fea3 	bl	1b60 <chSysUnlock>
        return r;
    1e1a:	9b05      	ldr	r3, [sp, #20]
    1e1c:	e02e      	b.n	1e7c <chIQReadTimeout+0xac>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
    1e1e:	9803      	ldr	r0, [sp, #12]
    1e20:	f7ff fece 	bl	1bc0 <chIQIsEmptyI>
    1e24:	4603      	mov	r3, r0
    1e26:	2b00      	cmp	r3, #0
    1e28:	d1ed      	bne.n	1e06 <chIQReadTimeout+0x36>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
    1e2a:	9b03      	ldr	r3, [sp, #12]
    1e2c:	689b      	ldr	r3, [r3, #8]
    1e2e:	1e5a      	subs	r2, r3, #1
    1e30:	9b03      	ldr	r3, [sp, #12]
    1e32:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
    1e34:	9b02      	ldr	r3, [sp, #8]
    1e36:	1c5a      	adds	r2, r3, #1
    1e38:	9202      	str	r2, [sp, #8]
    1e3a:	9a03      	ldr	r2, [sp, #12]
    1e3c:	6992      	ldr	r2, [r2, #24]
    1e3e:	1c50      	adds	r0, r2, #1
    1e40:	9903      	ldr	r1, [sp, #12]
    1e42:	6188      	str	r0, [r1, #24]
    1e44:	7812      	ldrb	r2, [r2, #0]
    1e46:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
    1e48:	9b03      	ldr	r3, [sp, #12]
    1e4a:	699a      	ldr	r2, [r3, #24]
    1e4c:	9b03      	ldr	r3, [sp, #12]
    1e4e:	691b      	ldr	r3, [r3, #16]
    1e50:	429a      	cmp	r2, r3
    1e52:	d303      	bcc.n	1e5c <chIQReadTimeout+0x8c>
      iqp->q_rdptr = iqp->q_buffer;
    1e54:	9b03      	ldr	r3, [sp, #12]
    1e56:	68da      	ldr	r2, [r3, #12]
    1e58:	9b03      	ldr	r3, [sp, #12]
    1e5a:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    1e5c:	f7ff fe80 	bl	1b60 <chSysUnlock>

    r++;
    1e60:	9b05      	ldr	r3, [sp, #20]
    1e62:	3301      	adds	r3, #1
    1e64:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
    1e66:	9b01      	ldr	r3, [sp, #4]
    1e68:	3b01      	subs	r3, #1
    1e6a:	9301      	str	r3, [sp, #4]
    1e6c:	9b01      	ldr	r3, [sp, #4]
    1e6e:	2b00      	cmp	r3, #0
    1e70:	d101      	bne.n	1e76 <chIQReadTimeout+0xa6>
      return r;
    1e72:	9b05      	ldr	r3, [sp, #20]
    1e74:	e002      	b.n	1e7c <chIQReadTimeout+0xac>
    }

    chSysLock();
    1e76:	f7ff fe6b 	bl	1b50 <chSysLock>
  }
    1e7a:	e7bc      	b.n	1df6 <chIQReadTimeout+0x26>
}
    1e7c:	4618      	mov	r0, r3
    1e7e:	b007      	add	sp, #28
    1e80:	f85d fb04 	ldr.w	pc, [sp], #4
    1e84:	00003d80 	.word	0x00003d80
    1e88:	f3af 8000 	nop.w
    1e8c:	f3af 8000 	nop.w

00001e90 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
    1e90:	b500      	push	{lr}
    1e92:	b085      	sub	sp, #20
    1e94:	9003      	str	r0, [sp, #12]
    1e96:	9102      	str	r1, [sp, #8]
    1e98:	9201      	str	r2, [sp, #4]
    1e9a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
    1e9c:	9b03      	ldr	r3, [sp, #12]
    1e9e:	4618      	mov	r0, r3
    1ea0:	f7ff fe7e 	bl	1ba0 <chThdQueueObjectInit>
  oqp->q_counter = size;
    1ea4:	9b03      	ldr	r3, [sp, #12]
    1ea6:	9a01      	ldr	r2, [sp, #4]
    1ea8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
    1eaa:	9b03      	ldr	r3, [sp, #12]
    1eac:	9a02      	ldr	r2, [sp, #8]
    1eae:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
    1eb0:	9b03      	ldr	r3, [sp, #12]
    1eb2:	9a02      	ldr	r2, [sp, #8]
    1eb4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
    1eb6:	9b03      	ldr	r3, [sp, #12]
    1eb8:	9a02      	ldr	r2, [sp, #8]
    1eba:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
    1ebc:	9a02      	ldr	r2, [sp, #8]
    1ebe:	9b01      	ldr	r3, [sp, #4]
    1ec0:	441a      	add	r2, r3
    1ec2:	9b03      	ldr	r3, [sp, #12]
    1ec4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
    1ec6:	9b03      	ldr	r3, [sp, #12]
    1ec8:	9a00      	ldr	r2, [sp, #0]
    1eca:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
    1ecc:	9b03      	ldr	r3, [sp, #12]
    1ece:	9a06      	ldr	r2, [sp, #24]
    1ed0:	621a      	str	r2, [r3, #32]
}
    1ed2:	b005      	add	sp, #20
    1ed4:	f85d fb04 	ldr.w	pc, [sp], #4
    1ed8:	f3af 8000 	nop.w
    1edc:	f3af 8000 	nop.w

00001ee0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    1ee0:	b500      	push	{lr}
    1ee2:	b087      	sub	sp, #28
    1ee4:	9003      	str	r0, [sp, #12]
    1ee6:	460b      	mov	r3, r1
    1ee8:	9201      	str	r2, [sp, #4]
    1eea:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
    1eee:	f7ff fe2f 	bl	1b50 <chSysLock>
  while (chOQIsFullI(oqp)) {
    1ef2:	e00c      	b.n	1f0e <chOQPutTimeout+0x2e>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    1ef4:	9b03      	ldr	r3, [sp, #12]
    1ef6:	4618      	mov	r0, r3
    1ef8:	9901      	ldr	r1, [sp, #4]
    1efa:	f7ff fbb1 	bl	1660 <chThdEnqueueTimeoutS>
    1efe:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
    1f00:	9b05      	ldr	r3, [sp, #20]
    1f02:	2b00      	cmp	r3, #0
    1f04:	da03      	bge.n	1f0e <chOQPutTimeout+0x2e>
      chSysUnlock();
    1f06:	f7ff fe2b 	bl	1b60 <chSysUnlock>
      return msg;
    1f0a:	9b05      	ldr	r3, [sp, #20]
    1f0c:	e027      	b.n	1f5e <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    1f0e:	9803      	ldr	r0, [sp, #12]
    1f10:	f7ff fea6 	bl	1c60 <chOQIsFullI>
    1f14:	4603      	mov	r3, r0
    1f16:	2b00      	cmp	r3, #0
    1f18:	d1ec      	bne.n	1ef4 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
    1f1a:	9b03      	ldr	r3, [sp, #12]
    1f1c:	689b      	ldr	r3, [r3, #8]
    1f1e:	1e5a      	subs	r2, r3, #1
    1f20:	9b03      	ldr	r3, [sp, #12]
    1f22:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
    1f24:	9b03      	ldr	r3, [sp, #12]
    1f26:	695b      	ldr	r3, [r3, #20]
    1f28:	1c59      	adds	r1, r3, #1
    1f2a:	9a03      	ldr	r2, [sp, #12]
    1f2c:	6151      	str	r1, [r2, #20]
    1f2e:	f89d 200b 	ldrb.w	r2, [sp, #11]
    1f32:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
    1f34:	9b03      	ldr	r3, [sp, #12]
    1f36:	695a      	ldr	r2, [r3, #20]
    1f38:	9b03      	ldr	r3, [sp, #12]
    1f3a:	691b      	ldr	r3, [r3, #16]
    1f3c:	429a      	cmp	r2, r3
    1f3e:	d303      	bcc.n	1f48 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
    1f40:	9b03      	ldr	r3, [sp, #12]
    1f42:	68da      	ldr	r2, [r3, #12]
    1f44:	9b03      	ldr	r3, [sp, #12]
    1f46:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
    1f48:	9b03      	ldr	r3, [sp, #12]
    1f4a:	69db      	ldr	r3, [r3, #28]
    1f4c:	2b00      	cmp	r3, #0
    1f4e:	d003      	beq.n	1f58 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
    1f50:	9b03      	ldr	r3, [sp, #12]
    1f52:	69db      	ldr	r3, [r3, #28]
    1f54:	9803      	ldr	r0, [sp, #12]
    1f56:	4798      	blx	r3
  }
  chSysUnlock();
    1f58:	f7ff fe02 	bl	1b60 <chSysUnlock>

  return Q_OK;
    1f5c:	2300      	movs	r3, #0
}
    1f5e:	4618      	mov	r0, r3
    1f60:	b007      	add	sp, #28
    1f62:	f85d fb04 	ldr.w	pc, [sp], #4
    1f66:	bf00      	nop
    1f68:	f3af 8000 	nop.w
    1f6c:	f3af 8000 	nop.w

00001f70 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
    1f70:	b500      	push	{lr}
    1f72:	b085      	sub	sp, #20
    1f74:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();
    1f76:	f7fe fca3 	bl	8c0 <chDbgCheckClassI>

  if (chOQIsEmptyI(oqp)) {
    1f7a:	9801      	ldr	r0, [sp, #4]
    1f7c:	f7ff fe50 	bl	1c20 <chOQIsEmptyI>
    1f80:	4603      	mov	r3, r0
    1f82:	2b00      	cmp	r3, #0
    1f84:	d002      	beq.n	1f8c <chOQGetI+0x1c>
    return Q_EMPTY;
    1f86:	f06f 0302 	mvn.w	r3, #2
    1f8a:	e01d      	b.n	1fc8 <chOQGetI+0x58>
  }

  oqp->q_counter++;
    1f8c:	9b01      	ldr	r3, [sp, #4]
    1f8e:	689b      	ldr	r3, [r3, #8]
    1f90:	1c5a      	adds	r2, r3, #1
    1f92:	9b01      	ldr	r3, [sp, #4]
    1f94:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
    1f96:	9b01      	ldr	r3, [sp, #4]
    1f98:	699b      	ldr	r3, [r3, #24]
    1f9a:	1c59      	adds	r1, r3, #1
    1f9c:	9a01      	ldr	r2, [sp, #4]
    1f9e:	6191      	str	r1, [r2, #24]
    1fa0:	781b      	ldrb	r3, [r3, #0]
    1fa2:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
    1fa6:	9b01      	ldr	r3, [sp, #4]
    1fa8:	699a      	ldr	r2, [r3, #24]
    1faa:	9b01      	ldr	r3, [sp, #4]
    1fac:	691b      	ldr	r3, [r3, #16]
    1fae:	429a      	cmp	r2, r3
    1fb0:	d303      	bcc.n	1fba <chOQGetI+0x4a>
    oqp->q_rdptr = oqp->q_buffer;
    1fb2:	9b01      	ldr	r3, [sp, #4]
    1fb4:	68da      	ldr	r2, [r3, #12]
    1fb6:	9b01      	ldr	r3, [sp, #4]
    1fb8:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
    1fba:	9b01      	ldr	r3, [sp, #4]
    1fbc:	4618      	mov	r0, r3
    1fbe:	2100      	movs	r1, #0
    1fc0:	f7ff fb6e 	bl	16a0 <chThdDequeueNextI>

  return (msg_t)b;
    1fc4:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    1fc8:	4618      	mov	r0, r3
    1fca:	b005      	add	sp, #20
    1fcc:	f85d fb04 	ldr.w	pc, [sp], #4

00001fd0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
    1fd0:	b500      	push	{lr}
    1fd2:	b087      	sub	sp, #28
    1fd4:	9003      	str	r0, [sp, #12]
    1fd6:	9102      	str	r1, [sp, #8]
    1fd8:	9201      	str	r2, [sp, #4]
    1fda:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
    1fdc:	9b03      	ldr	r3, [sp, #12]
    1fde:	69db      	ldr	r3, [r3, #28]
    1fe0:	9304      	str	r3, [sp, #16]
  size_t w = 0;
    1fe2:	2300      	movs	r3, #0
    1fe4:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
    1fe6:	9b01      	ldr	r3, [sp, #4]
    1fe8:	2b00      	cmp	r3, #0
    1fea:	d102      	bne.n	1ff2 <chOQWriteTimeout+0x22>
    1fec:	4825      	ldr	r0, [pc, #148]	; (2084 <chOQWriteTimeout+0xb4>)
    1fee:	f7fe fb5f 	bl	6b0 <chSysHalt>

  chSysLock();
    1ff2:	f7ff fdad 	bl	1b50 <chSysLock>
  while (true) {
    while (chOQIsFullI(oqp)) {
    1ff6:	e00b      	b.n	2010 <chOQWriteTimeout+0x40>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
    1ff8:	9b03      	ldr	r3, [sp, #12]
    1ffa:	4618      	mov	r0, r3
    1ffc:	9900      	ldr	r1, [sp, #0]
    1ffe:	f7ff fb2f 	bl	1660 <chThdEnqueueTimeoutS>
    2002:	4603      	mov	r3, r0
    2004:	2b00      	cmp	r3, #0
    2006:	d003      	beq.n	2010 <chOQWriteTimeout+0x40>
        chSysUnlock();
    2008:	f7ff fdaa 	bl	1b60 <chSysUnlock>
        return w;
    200c:	9b05      	ldr	r3, [sp, #20]
    200e:	e035      	b.n	207c <chOQWriteTimeout+0xac>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
    2010:	9803      	ldr	r0, [sp, #12]
    2012:	f7ff fe25 	bl	1c60 <chOQIsFullI>
    2016:	4603      	mov	r3, r0
    2018:	2b00      	cmp	r3, #0
    201a:	d1ed      	bne.n	1ff8 <chOQWriteTimeout+0x28>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
    201c:	9b03      	ldr	r3, [sp, #12]
    201e:	689b      	ldr	r3, [r3, #8]
    2020:	1e5a      	subs	r2, r3, #1
    2022:	9b03      	ldr	r3, [sp, #12]
    2024:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
    2026:	9b03      	ldr	r3, [sp, #12]
    2028:	695b      	ldr	r3, [r3, #20]
    202a:	1c59      	adds	r1, r3, #1
    202c:	9a03      	ldr	r2, [sp, #12]
    202e:	6151      	str	r1, [r2, #20]
    2030:	9a02      	ldr	r2, [sp, #8]
    2032:	1c51      	adds	r1, r2, #1
    2034:	9102      	str	r1, [sp, #8]
    2036:	7812      	ldrb	r2, [r2, #0]
    2038:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
    203a:	9b03      	ldr	r3, [sp, #12]
    203c:	695a      	ldr	r2, [r3, #20]
    203e:	9b03      	ldr	r3, [sp, #12]
    2040:	691b      	ldr	r3, [r3, #16]
    2042:	429a      	cmp	r2, r3
    2044:	d303      	bcc.n	204e <chOQWriteTimeout+0x7e>
      oqp->q_wrptr = oqp->q_buffer;
    2046:	9b03      	ldr	r3, [sp, #12]
    2048:	68da      	ldr	r2, [r3, #12]
    204a:	9b03      	ldr	r3, [sp, #12]
    204c:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
    204e:	9b04      	ldr	r3, [sp, #16]
    2050:	2b00      	cmp	r3, #0
    2052:	d002      	beq.n	205a <chOQWriteTimeout+0x8a>
      nfy(oqp);
    2054:	9b04      	ldr	r3, [sp, #16]
    2056:	9803      	ldr	r0, [sp, #12]
    2058:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    205a:	f7ff fd81 	bl	1b60 <chSysUnlock>

    w++;
    205e:	9b05      	ldr	r3, [sp, #20]
    2060:	3301      	adds	r3, #1
    2062:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
    2064:	9b01      	ldr	r3, [sp, #4]
    2066:	3b01      	subs	r3, #1
    2068:	9301      	str	r3, [sp, #4]
    206a:	9b01      	ldr	r3, [sp, #4]
    206c:	2b00      	cmp	r3, #0
    206e:	d101      	bne.n	2074 <chOQWriteTimeout+0xa4>
      return w;
    2070:	9b05      	ldr	r3, [sp, #20]
    2072:	e003      	b.n	207c <chOQWriteTimeout+0xac>
    }
    chSysLock();
    2074:	f7ff fd6c 	bl	1b50 <chSysLock>
  }
    2078:	bf00      	nop

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
    207a:	e7c9      	b.n	2010 <chOQWriteTimeout+0x40>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
    207c:	4618      	mov	r0, r3
    207e:	b007      	add	sp, #28
    2080:	f85d fb04 	ldr.w	pc, [sp], #4
    2084:	00003d90 	.word	0x00003d90
    2088:	f3af 8000 	nop.w
    208c:	f3af 8000 	nop.w

00002090 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2090:	b082      	sub	sp, #8
    2092:	2320      	movs	r3, #32
    2094:	9301      	str	r3, [sp, #4]
    2096:	9b01      	ldr	r3, [sp, #4]
    2098:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    209c:	b002      	add	sp, #8
    209e:	4770      	bx	lr

000020a0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    20a0:	b082      	sub	sp, #8
    20a2:	2300      	movs	r3, #0
    20a4:	9301      	str	r3, [sp, #4]
    20a6:	9b01      	ldr	r3, [sp, #4]
    20a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    20ac:	b002      	add	sp, #8
    20ae:	4770      	bx	lr

000020b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    20b0:	b508      	push	{r3, lr}

  port_lock();
    20b2:	f7ff ffed 	bl	2090 <port_lock>
  _stats_start_measure_crit_thd();
    20b6:	f7ff fc0b 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    20ba:	f7fe fb61 	bl	780 <_dbg_check_lock>
}
    20be:	bd08      	pop	{r3, pc}

000020c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    20c0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    20c2:	f7fe fb75 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    20c6:	f7ff fc0b 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    20ca:	4b09      	ldr	r3, [pc, #36]	; (20f0 <chSysUnlock+0x30>)
    20cc:	681a      	ldr	r2, [r3, #0]
    20ce:	4b08      	ldr	r3, [pc, #32]	; (20f0 <chSysUnlock+0x30>)
    20d0:	429a      	cmp	r2, r3
    20d2:	d00a      	beq.n	20ea <chSysUnlock+0x2a>
    20d4:	4b06      	ldr	r3, [pc, #24]	; (20f0 <chSysUnlock+0x30>)
    20d6:	699b      	ldr	r3, [r3, #24]
    20d8:	689a      	ldr	r2, [r3, #8]
    20da:	4b05      	ldr	r3, [pc, #20]	; (20f0 <chSysUnlock+0x30>)
    20dc:	681b      	ldr	r3, [r3, #0]
    20de:	689b      	ldr	r3, [r3, #8]
    20e0:	429a      	cmp	r2, r3
    20e2:	d202      	bcs.n	20ea <chSysUnlock+0x2a>
    20e4:	4803      	ldr	r0, [pc, #12]	; (20f4 <chSysUnlock+0x34>)
    20e6:	f7fe fae3 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    20ea:	f7ff ffd9 	bl	20a0 <port_unlock>
}
    20ee:	bd08      	pop	{r3, pc}
    20f0:	20000800 	.word	0x20000800
    20f4:	00003db0 	.word	0x00003db0
    20f8:	f3af 8000 	nop.w
    20fc:	f3af 8000 	nop.w

00002100 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
    2100:	4b06      	ldr	r3, [pc, #24]	; (211c <_core_init+0x1c>)
    2102:	3307      	adds	r3, #7
    2104:	f023 0307 	bic.w	r3, r3, #7
    2108:	461a      	mov	r2, r3
    210a:	4b05      	ldr	r3, [pc, #20]	; (2120 <_core_init+0x20>)
    210c:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
    210e:	4b05      	ldr	r3, [pc, #20]	; (2124 <_core_init+0x24>)
    2110:	f023 0307 	bic.w	r3, r3, #7
    2114:	461a      	mov	r2, r3
    2116:	4b04      	ldr	r3, [pc, #16]	; (2128 <_core_init+0x28>)
    2118:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
    211a:	4770      	bx	lr
    211c:	20001150 	.word	0x20001150
    2120:	20000dd8 	.word	0x20000dd8
    2124:	20020000 	.word	0x20020000
    2128:	20000ddc 	.word	0x20000ddc
    212c:	f3af 8000 	nop.w

00002130 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
    2130:	b500      	push	{lr}
    2132:	b085      	sub	sp, #20
    2134:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
    2136:	f7ff ffbb 	bl	20b0 <chSysLock>
  p = chCoreAllocI(size);
    213a:	9801      	ldr	r0, [sp, #4]
    213c:	f000 f808 	bl	2150 <chCoreAllocI>
    2140:	9003      	str	r0, [sp, #12]
  chSysUnlock();
    2142:	f7ff ffbd 	bl	20c0 <chSysUnlock>

  return p;
    2146:	9b03      	ldr	r3, [sp, #12]
}
    2148:	4618      	mov	r0, r3
    214a:	b005      	add	sp, #20
    214c:	f85d fb04 	ldr.w	pc, [sp], #4

00002150 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
    2150:	b500      	push	{lr}
    2152:	b085      	sub	sp, #20
    2154:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();
    2156:	f7fe fbb3 	bl	8c0 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
    215a:	9b01      	ldr	r3, [sp, #4]
    215c:	3307      	adds	r3, #7
    215e:	f023 0307 	bic.w	r3, r3, #7
    2162:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
    2164:	4b0c      	ldr	r3, [pc, #48]	; (2198 <chCoreAllocI+0x48>)
    2166:	681b      	ldr	r3, [r3, #0]
    2168:	461a      	mov	r2, r3
    216a:	4b0c      	ldr	r3, [pc, #48]	; (219c <chCoreAllocI+0x4c>)
    216c:	681b      	ldr	r3, [r3, #0]
    216e:	1ad3      	subs	r3, r2, r3
    2170:	461a      	mov	r2, r3
    2172:	9b01      	ldr	r3, [sp, #4]
    2174:	429a      	cmp	r2, r3
    2176:	d201      	bcs.n	217c <chCoreAllocI+0x2c>
  /*lint -restore*/
    return NULL;
    2178:	2300      	movs	r3, #0
    217a:	e009      	b.n	2190 <chCoreAllocI+0x40>
  }
  p = nextmem;
    217c:	4b07      	ldr	r3, [pc, #28]	; (219c <chCoreAllocI+0x4c>)
    217e:	681b      	ldr	r3, [r3, #0]
    2180:	9303      	str	r3, [sp, #12]
  nextmem += size;
    2182:	4b06      	ldr	r3, [pc, #24]	; (219c <chCoreAllocI+0x4c>)
    2184:	681a      	ldr	r2, [r3, #0]
    2186:	9b01      	ldr	r3, [sp, #4]
    2188:	441a      	add	r2, r3
    218a:	4b04      	ldr	r3, [pc, #16]	; (219c <chCoreAllocI+0x4c>)
    218c:	601a      	str	r2, [r3, #0]

  return p;
    218e:	9b03      	ldr	r3, [sp, #12]
}
    2190:	4618      	mov	r0, r3
    2192:	b005      	add	sp, #20
    2194:	f85d fb04 	ldr.w	pc, [sp], #4
    2198:	20000ddc 	.word	0x20000ddc
    219c:	20000dd8 	.word	0x20000dd8

000021a0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
    21a0:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
    21a2:	4b06      	ldr	r3, [pc, #24]	; (21bc <_heap_init+0x1c>)
    21a4:	4a06      	ldr	r2, [pc, #24]	; (21c0 <_heap_init+0x20>)
    21a6:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
    21a8:	4b04      	ldr	r3, [pc, #16]	; (21bc <_heap_init+0x1c>)
    21aa:	2200      	movs	r2, #0
    21ac:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
    21ae:	4b03      	ldr	r3, [pc, #12]	; (21bc <_heap_init+0x1c>)
    21b0:	2200      	movs	r2, #0
    21b2:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
    21b4:	4803      	ldr	r0, [pc, #12]	; (21c4 <_heap_init+0x24>)
    21b6:	f7ff fbeb 	bl	1990 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
    21ba:	bd08      	pop	{r3, pc}
    21bc:	20000de0 	.word	0x20000de0
    21c0:	00002131 	.word	0x00002131
    21c4:	20000df0 	.word	0x20000df0
    21c8:	f3af 8000 	nop.w
    21cc:	f3af 8000 	nop.w

000021d0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    21d0:	b082      	sub	sp, #8
    21d2:	2320      	movs	r3, #32
    21d4:	9301      	str	r3, [sp, #4]
    21d6:	9b01      	ldr	r3, [sp, #4]
    21d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    21dc:	b002      	add	sp, #8
    21de:	4770      	bx	lr

000021e0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    21e0:	b082      	sub	sp, #8
    21e2:	2300      	movs	r3, #0
    21e4:	9301      	str	r3, [sp, #4]
    21e6:	9b01      	ldr	r3, [sp, #4]
    21e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    21ec:	b002      	add	sp, #8
    21ee:	4770      	bx	lr

000021f0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    21f0:	b508      	push	{r3, lr}

  port_lock();
    21f2:	f7ff ffed 	bl	21d0 <port_lock>
}
    21f6:	bd08      	pop	{r3, pc}
    21f8:	f3af 8000 	nop.w
    21fc:	f3af 8000 	nop.w

00002200 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    2200:	b508      	push	{r3, lr}

  port_unlock();
    2202:	f7ff ffed 	bl	21e0 <port_unlock>
}
    2206:	bd08      	pop	{r3, pc}
    2208:	f3af 8000 	nop.w
    220c:	f3af 8000 	nop.w

00002210 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
    2210:	b510      	push	{r4, lr}
    2212:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    2214:	f3ef 8309 	mrs	r3, PSP
    2218:	461c      	mov	r4, r3
  return(result);
    221a:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
    221c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
    221e:	9b01      	ldr	r3, [sp, #4]
    2220:	3320      	adds	r3, #32
    2222:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
    2224:	9b01      	ldr	r3, [sp, #4]
    2226:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    2228:	9b00      	ldr	r3, [sp, #0]
    222a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
    222e:	f7ff ffe7 	bl	2200 <port_unlock_from_isr>
}
    2232:	b002      	add	sp, #8
    2234:	bd10      	pop	{r4, pc}
    2236:	bf00      	nop
    2238:	f3af 8000 	nop.w
    223c:	f3af 8000 	nop.w

00002240 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
    2240:	b510      	push	{r4, lr}
    2242:	b082      	sub	sp, #8

  port_lock_from_isr();
    2244:	f7ff ffd4 	bl	21f0 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
    2248:	4b13      	ldr	r3, [pc, #76]	; (2298 <_port_irq_epilogue+0x58>)
    224a:	685b      	ldr	r3, [r3, #4]
    224c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    2250:	2b00      	cmp	r3, #0
    2252:	d01d      	beq.n	2290 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    2254:	f3ef 8309 	mrs	r3, PSP
    2258:	461c      	mov	r4, r3
  return(result);
    225a:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
    225c:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
    225e:	9b01      	ldr	r3, [sp, #4]
    2260:	3b20      	subs	r3, #32
    2262:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
    2264:	9b01      	ldr	r3, [sp, #4]
    2266:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    226a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
    226c:	9b01      	ldr	r3, [sp, #4]
    226e:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    2270:	9b00      	ldr	r3, [sp, #0]
    2272:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
    2276:	f7fe fefb 	bl	1070 <chSchIsPreemptionRequired>
    227a:	4603      	mov	r3, r0
    227c:	2b00      	cmp	r3, #0
    227e:	d003      	beq.n	2288 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    2280:	9b01      	ldr	r3, [sp, #4]
    2282:	4a06      	ldr	r2, [pc, #24]	; (229c <_port_irq_epilogue+0x5c>)
    2284:	619a      	str	r2, [r3, #24]
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
    2286:	e005      	b.n	2294 <_port_irq_epilogue+0x54>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    2288:	9b01      	ldr	r3, [sp, #4]
    228a:	4a05      	ldr	r2, [pc, #20]	; (22a0 <_port_irq_epilogue+0x60>)
    228c:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
    228e:	e001      	b.n	2294 <_port_irq_epilogue+0x54>
  }
  port_unlock_from_isr();
    2290:	f7ff ffb6 	bl	2200 <port_unlock_from_isr>
}
    2294:	b002      	add	sp, #8
    2296:	bd10      	pop	{r4, pc}
    2298:	e000ed00 	.word	0xe000ed00
    229c:	000002a9 	.word	0x000002a9
    22a0:	000002bc 	.word	0x000002bc
    22a4:	f3af 8000 	nop.w
    22a8:	f3af 8000 	nop.w
    22ac:	f3af 8000 	nop.w

000022b0 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    22b0:	4770      	bx	lr
    22b2:	bf00      	nop
    22b4:	f3af 8000 	nop.w
    22b8:	f3af 8000 	nop.w
    22bc:	f3af 8000 	nop.w

000022c0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
    22c0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    22c2:	f7ff fff5 	bl	22b0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
    22c6:	f000 facb 	bl	2860 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    22ca:	4806      	ldr	r0, [pc, #24]	; (22e4 <halInit+0x24>)
    22cc:	f001 f8a8 	bl	3420 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
    22d0:	f000 f88e 	bl	23f0 <adcInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    22d4:	f000 f9e4 	bl	26a0 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    22d8:	f001 fba2 	bl	3a20 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    22dc:	f000 f838 	bl	2350 <stInit>
#endif
}
    22e0:	bd08      	pop	{r3, pc}
    22e2:	bf00      	nop
    22e4:	00003f00 	.word	0x00003f00
    22e8:	f3af 8000 	nop.w
    22ec:	f3af 8000 	nop.w

000022f0 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
    22f0:	b082      	sub	sp, #8
    22f2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
    22f4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    22f8:	9a01      	ldr	r2, [sp, #4]
    22fa:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
    22fc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2300:	2200      	movs	r2, #0
    2302:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
    2304:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2308:	2202      	movs	r2, #2
    230a:	60da      	str	r2, [r3, #12]
}
    230c:	b002      	add	sp, #8
    230e:	4770      	bx	lr

00002310 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
    2310:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2314:	2200      	movs	r2, #0
    2316:	60da      	str	r2, [r3, #12]
}
    2318:	4770      	bx	lr
    231a:	bf00      	nop
    231c:	f3af 8000 	nop.w

00002320 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
    2320:	b082      	sub	sp, #8
    2322:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
    2324:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2328:	9a01      	ldr	r2, [sp, #4]
    232a:	635a      	str	r2, [r3, #52]	; 0x34
}
    232c:	b002      	add	sp, #8
    232e:	4770      	bx	lr

00002330 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
    2330:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2334:	68db      	ldr	r3, [r3, #12]
    2336:	f003 0302 	and.w	r3, r3, #2
    233a:	2b00      	cmp	r3, #0
    233c:	bf0c      	ite	eq
    233e:	2300      	moveq	r3, #0
    2340:	2301      	movne	r3, #1
    2342:	b2db      	uxtb	r3, r3
}
    2344:	4618      	mov	r0, r3
    2346:	4770      	bx	lr
    2348:	f3af 8000 	nop.w
    234c:	f3af 8000 	nop.w

00002350 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
    2350:	b508      	push	{r3, lr}

  st_lld_init();
    2352:	f000 fe6d 	bl	3030 <st_lld_init>
}
    2356:	bd08      	pop	{r3, pc}
    2358:	f3af 8000 	nop.w
    235c:	f3af 8000 	nop.w

00002360 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
    2360:	b500      	push	{lr}
    2362:	b083      	sub	sp, #12
    2364:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
    2366:	f7ff ffe3 	bl	2330 <st_lld_is_alarm_active>
    236a:	4603      	mov	r3, r0
    236c:	2b00      	cmp	r3, #0
    236e:	d002      	beq.n	2376 <stStartAlarm+0x16>
    2370:	4804      	ldr	r0, [pc, #16]	; (2384 <stStartAlarm+0x24>)
    2372:	f7fe f99d 	bl	6b0 <chSysHalt>

  st_lld_start_alarm(abstime);
    2376:	9801      	ldr	r0, [sp, #4]
    2378:	f7ff ffba 	bl	22f0 <st_lld_start_alarm>
}
    237c:	b003      	add	sp, #12
    237e:	f85d fb04 	ldr.w	pc, [sp], #4
    2382:	bf00      	nop
    2384:	00003dc0 	.word	0x00003dc0
    2388:	f3af 8000 	nop.w
    238c:	f3af 8000 	nop.w

00002390 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
    2390:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
    2392:	f7ff ffbd 	bl	2310 <st_lld_stop_alarm>
}
    2396:	bd08      	pop	{r3, pc}
    2398:	f3af 8000 	nop.w
    239c:	f3af 8000 	nop.w

000023a0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
    23a0:	b500      	push	{lr}
    23a2:	b083      	sub	sp, #12
    23a4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
    23a6:	f7ff ffc3 	bl	2330 <st_lld_is_alarm_active>
    23aa:	4603      	mov	r3, r0
    23ac:	f083 0301 	eor.w	r3, r3, #1
    23b0:	b2db      	uxtb	r3, r3
    23b2:	2b00      	cmp	r3, #0
    23b4:	d002      	beq.n	23bc <stSetAlarm+0x1c>
    23b6:	4804      	ldr	r0, [pc, #16]	; (23c8 <stSetAlarm+0x28>)
    23b8:	f7fe f97a 	bl	6b0 <chSysHalt>

  st_lld_set_alarm(abstime);
    23bc:	9801      	ldr	r0, [sp, #4]
    23be:	f7ff ffaf 	bl	2320 <st_lld_set_alarm>
}
    23c2:	b003      	add	sp, #12
    23c4:	f85d fb04 	ldr.w	pc, [sp], #4
    23c8:	00003dd0 	.word	0x00003dd0
    23cc:	f3af 8000 	nop.w

000023d0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
    23d0:	b500      	push	{lr}
    23d2:	b083      	sub	sp, #12
    23d4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
    23d6:	9801      	ldr	r0, [sp, #4]
    23d8:	f7ff fada 	bl	1990 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
    23dc:	b003      	add	sp, #12
    23de:	f85d fb04 	ldr.w	pc, [sp], #4
    23e2:	bf00      	nop
    23e4:	f3af 8000 	nop.w
    23e8:	f3af 8000 	nop.w
    23ec:	f3af 8000 	nop.w

000023f0 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
    23f0:	b508      	push	{r3, lr}

  adc_lld_init();
    23f2:	f000 ff75 	bl	32e0 <adc_lld_init>
}
    23f6:	bd08      	pop	{r3, pc}
    23f8:	f3af 8000 	nop.w
    23fc:	f3af 8000 	nop.w

00002400 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
    2400:	b500      	push	{lr}
    2402:	b083      	sub	sp, #12
    2404:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
    2406:	9b01      	ldr	r3, [sp, #4]
    2408:	2201      	movs	r2, #1
    240a:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
    240c:	9b01      	ldr	r3, [sp, #4]
    240e:	2200      	movs	r2, #0
    2410:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
    2412:	9b01      	ldr	r3, [sp, #4]
    2414:	2200      	movs	r2, #0
    2416:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
    2418:	9b01      	ldr	r3, [sp, #4]
    241a:	2200      	movs	r2, #0
    241c:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
    241e:	9b01      	ldr	r3, [sp, #4]
    2420:	2200      	movs	r2, #0
    2422:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
    2424:	9b01      	ldr	r3, [sp, #4]
    2426:	2200      	movs	r2, #0
    2428:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
    242a:	9b01      	ldr	r3, [sp, #4]
    242c:	3318      	adds	r3, #24
    242e:	4618      	mov	r0, r3
    2430:	f7ff ffce 	bl	23d0 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
    2434:	b003      	add	sp, #12
    2436:	f85d fb04 	ldr.w	pc, [sp], #4
    243a:	bf00      	nop
    243c:	f3af 8000 	nop.w

00002440 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2440:	b082      	sub	sp, #8
    2442:	2320      	movs	r3, #32
    2444:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    2446:	9b01      	ldr	r3, [sp, #4]
    2448:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    244c:	b002      	add	sp, #8
    244e:	4770      	bx	lr

00002450 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2450:	b082      	sub	sp, #8
    2452:	2300      	movs	r3, #0
    2454:	9301      	str	r3, [sp, #4]
    2456:	9b01      	ldr	r3, [sp, #4]
    2458:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    245c:	b002      	add	sp, #8
    245e:	4770      	bx	lr

00002460 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    2460:	b508      	push	{r3, lr}

  port_lock();
    2462:	f7ff ffed 	bl	2440 <port_lock>
  _stats_start_measure_crit_thd();
    2466:	f7ff fa33 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    246a:	f7fe f989 	bl	780 <_dbg_check_lock>
}
    246e:	bd08      	pop	{r3, pc}

00002470 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2470:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2472:	f7fe f99d 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2476:	f7ff fa33 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    247a:	4b09      	ldr	r3, [pc, #36]	; (24a0 <chSysUnlock+0x30>)
    247c:	681a      	ldr	r2, [r3, #0]
    247e:	4b08      	ldr	r3, [pc, #32]	; (24a0 <chSysUnlock+0x30>)
    2480:	429a      	cmp	r2, r3
    2482:	d00a      	beq.n	249a <chSysUnlock+0x2a>
    2484:	4b06      	ldr	r3, [pc, #24]	; (24a0 <chSysUnlock+0x30>)
    2486:	699b      	ldr	r3, [r3, #24]
    2488:	689a      	ldr	r2, [r3, #8]
    248a:	4b05      	ldr	r3, [pc, #20]	; (24a0 <chSysUnlock+0x30>)
    248c:	681b      	ldr	r3, [r3, #0]
    248e:	689b      	ldr	r3, [r3, #8]
    2490:	429a      	cmp	r2, r3
    2492:	d202      	bcs.n	249a <chSysUnlock+0x2a>
    2494:	4803      	ldr	r0, [pc, #12]	; (24a4 <chSysUnlock+0x34>)
    2496:	f7fe f90b 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    249a:	f7ff ffd9 	bl	2450 <port_unlock>
}
    249e:	bd08      	pop	{r3, pc}
    24a0:	20000800 	.word	0x20000800
    24a4:	00003e10 	.word	0x00003e10
    24a8:	f3af 8000 	nop.w
    24ac:	f3af 8000 	nop.w

000024b0 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
    24b0:	b082      	sub	sp, #8
    24b2:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
    24b4:	9b01      	ldr	r3, [sp, #4]
    24b6:	9a01      	ldr	r2, [sp, #4]
    24b8:	601a      	str	r2, [r3, #0]
}
    24ba:	b002      	add	sp, #8
    24bc:	4770      	bx	lr
    24be:	bf00      	nop

000024c0 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
    24c0:	b500      	push	{lr}
    24c2:	b083      	sub	sp, #12
    24c4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    24c6:	f7fe f9fb 	bl	8c0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
    24ca:	9b01      	ldr	r3, [sp, #4]
    24cc:	689b      	ldr	r3, [r3, #8]
    24ce:	2b00      	cmp	r3, #0
    24d0:	bf14      	ite	ne
    24d2:	2300      	movne	r3, #0
    24d4:	2301      	moveq	r3, #1
    24d6:	b2db      	uxtb	r3, r3
}
    24d8:	4618      	mov	r0, r3
    24da:	b003      	add	sp, #12
    24dc:	f85d fb04 	ldr.w	pc, [sp], #4

000024e0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
    24e0:	b508      	push	{r3, lr}

  chSysLock();
    24e2:	f7ff ffbd 	bl	2460 <chSysLock>
}
    24e6:	bd08      	pop	{r3, pc}
    24e8:	f3af 8000 	nop.w
    24ec:	f3af 8000 	nop.w

000024f0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
    24f0:	b508      	push	{r3, lr}

  chSysUnlock();
    24f2:	f7ff ffbd 	bl	2470 <chSysUnlock>
}
    24f6:	bd08      	pop	{r3, pc}
    24f8:	f3af 8000 	nop.w
    24fc:	f3af 8000 	nop.w

00002500 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    2500:	b500      	push	{lr}
    2502:	b083      	sub	sp, #12
    2504:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
    2506:	9801      	ldr	r0, [sp, #4]
    2508:	f7ff ffd2 	bl	24b0 <chEvtObjectInit>
}
    250c:	b003      	add	sp, #12
    250e:	f85d fb04 	ldr.w	pc, [sp], #4
    2512:	bf00      	nop
    2514:	f3af 8000 	nop.w
    2518:	f3af 8000 	nop.w
    251c:	f3af 8000 	nop.w

00002520 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    2520:	b500      	push	{lr}
    2522:	b083      	sub	sp, #12
    2524:	9001      	str	r0, [sp, #4]
    2526:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
    2528:	9801      	ldr	r0, [sp, #4]
    252a:	9900      	ldr	r1, [sp, #0]
    252c:	f7ff fa48 	bl	19c0 <chEvtBroadcastFlagsI>
}
    2530:	b003      	add	sp, #12
    2532:	f85d fb04 	ldr.w	pc, [sp], #4
    2536:	bf00      	nop
    2538:	f3af 8000 	nop.w
    253c:	f3af 8000 	nop.w

00002540 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    2540:	b500      	push	{lr}
    2542:	b085      	sub	sp, #20
    2544:	9003      	str	r0, [sp, #12]
    2546:	9102      	str	r1, [sp, #8]
    2548:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    254a:	9b03      	ldr	r3, [sp, #12]
    254c:	3330      	adds	r3, #48	; 0x30
    254e:	4618      	mov	r0, r3
    2550:	9902      	ldr	r1, [sp, #8]
    2552:	9a01      	ldr	r2, [sp, #4]
    2554:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2558:	f7ff fd3a 	bl	1fd0 <chOQWriteTimeout>
    255c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
    255e:	4618      	mov	r0, r3
    2560:	b005      	add	sp, #20
    2562:	f85d fb04 	ldr.w	pc, [sp], #4
    2566:	bf00      	nop
    2568:	f3af 8000 	nop.w
    256c:	f3af 8000 	nop.w

00002570 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    2570:	b500      	push	{lr}
    2572:	b085      	sub	sp, #20
    2574:	9003      	str	r0, [sp, #12]
    2576:	9102      	str	r1, [sp, #8]
    2578:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    257a:	9b03      	ldr	r3, [sp, #12]
    257c:	330c      	adds	r3, #12
    257e:	4618      	mov	r0, r3
    2580:	9902      	ldr	r1, [sp, #8]
    2582:	9a01      	ldr	r2, [sp, #4]
    2584:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2588:	f7ff fc22 	bl	1dd0 <chIQReadTimeout>
    258c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
    258e:	4618      	mov	r0, r3
    2590:	b005      	add	sp, #20
    2592:	f85d fb04 	ldr.w	pc, [sp], #4
    2596:	bf00      	nop
    2598:	f3af 8000 	nop.w
    259c:	f3af 8000 	nop.w

000025a0 <put>:

static msg_t put(void *ip, uint8_t b) {
    25a0:	b500      	push	{lr}
    25a2:	b083      	sub	sp, #12
    25a4:	9001      	str	r0, [sp, #4]
    25a6:	460b      	mov	r3, r1
    25a8:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    25ac:	9b01      	ldr	r3, [sp, #4]
    25ae:	f103 0230 	add.w	r2, r3, #48	; 0x30
    25b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
    25b6:	4610      	mov	r0, r2
    25b8:	4619      	mov	r1, r3
    25ba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    25be:	f7ff fc8f 	bl	1ee0 <chOQPutTimeout>
    25c2:	4603      	mov	r3, r0
}
    25c4:	4618      	mov	r0, r3
    25c6:	b003      	add	sp, #12
    25c8:	f85d fb04 	ldr.w	pc, [sp], #4
    25cc:	f3af 8000 	nop.w

000025d0 <get>:

static msg_t get(void *ip) {
    25d0:	b500      	push	{lr}
    25d2:	b083      	sub	sp, #12
    25d4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    25d6:	9b01      	ldr	r3, [sp, #4]
    25d8:	330c      	adds	r3, #12
    25da:	4618      	mov	r0, r3
    25dc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    25e0:	f7ff fbae 	bl	1d40 <chIQGetTimeout>
    25e4:	4603      	mov	r3, r0
}
    25e6:	4618      	mov	r0, r3
    25e8:	b003      	add	sp, #12
    25ea:	f85d fb04 	ldr.w	pc, [sp], #4
    25ee:	bf00      	nop

000025f0 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    25f0:	b500      	push	{lr}
    25f2:	b085      	sub	sp, #20
    25f4:	9003      	str	r0, [sp, #12]
    25f6:	460b      	mov	r3, r1
    25f8:	9201      	str	r2, [sp, #4]
    25fa:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    25fe:	9b03      	ldr	r3, [sp, #12]
    2600:	f103 0230 	add.w	r2, r3, #48	; 0x30
    2604:	f89d 300b 	ldrb.w	r3, [sp, #11]
    2608:	4610      	mov	r0, r2
    260a:	4619      	mov	r1, r3
    260c:	9a01      	ldr	r2, [sp, #4]
    260e:	f7ff fc67 	bl	1ee0 <chOQPutTimeout>
    2612:	4603      	mov	r3, r0
}
    2614:	4618      	mov	r0, r3
    2616:	b005      	add	sp, #20
    2618:	f85d fb04 	ldr.w	pc, [sp], #4
    261c:	f3af 8000 	nop.w

00002620 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    2620:	b500      	push	{lr}
    2622:	b083      	sub	sp, #12
    2624:	9001      	str	r0, [sp, #4]
    2626:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    2628:	9b01      	ldr	r3, [sp, #4]
    262a:	330c      	adds	r3, #12
    262c:	4618      	mov	r0, r3
    262e:	9900      	ldr	r1, [sp, #0]
    2630:	f7ff fb86 	bl	1d40 <chIQGetTimeout>
    2634:	4603      	mov	r3, r0
}
    2636:	4618      	mov	r0, r3
    2638:	b003      	add	sp, #12
    263a:	f85d fb04 	ldr.w	pc, [sp], #4
    263e:	bf00      	nop

00002640 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    2640:	b500      	push	{lr}
    2642:	b085      	sub	sp, #20
    2644:	9003      	str	r0, [sp, #12]
    2646:	9102      	str	r1, [sp, #8]
    2648:	9201      	str	r2, [sp, #4]
    264a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    264c:	9b03      	ldr	r3, [sp, #12]
    264e:	3330      	adds	r3, #48	; 0x30
    2650:	4618      	mov	r0, r3
    2652:	9902      	ldr	r1, [sp, #8]
    2654:	9a01      	ldr	r2, [sp, #4]
    2656:	9b00      	ldr	r3, [sp, #0]
    2658:	f7ff fcba 	bl	1fd0 <chOQWriteTimeout>
    265c:	4603      	mov	r3, r0
}
    265e:	4618      	mov	r0, r3
    2660:	b005      	add	sp, #20
    2662:	f85d fb04 	ldr.w	pc, [sp], #4
    2666:	bf00      	nop
    2668:	f3af 8000 	nop.w
    266c:	f3af 8000 	nop.w

00002670 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    2670:	b500      	push	{lr}
    2672:	b085      	sub	sp, #20
    2674:	9003      	str	r0, [sp, #12]
    2676:	9102      	str	r1, [sp, #8]
    2678:	9201      	str	r2, [sp, #4]
    267a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    267c:	9b03      	ldr	r3, [sp, #12]
    267e:	330c      	adds	r3, #12
    2680:	4618      	mov	r0, r3
    2682:	9902      	ldr	r1, [sp, #8]
    2684:	9a01      	ldr	r2, [sp, #4]
    2686:	9b00      	ldr	r3, [sp, #0]
    2688:	f7ff fba2 	bl	1dd0 <chIQReadTimeout>
    268c:	4603      	mov	r3, r0
}
    268e:	4618      	mov	r0, r3
    2690:	b005      	add	sp, #20
    2692:	f85d fb04 	ldr.w	pc, [sp], #4
    2696:	bf00      	nop
    2698:	f3af 8000 	nop.w
    269c:	f3af 8000 	nop.w

000026a0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
    26a0:	b508      	push	{r3, lr}

  sd_lld_init();
    26a2:	f001 f975 	bl	3990 <sd_lld_init>
}
    26a6:	bd08      	pop	{r3, pc}
    26a8:	f3af 8000 	nop.w
    26ac:	f3af 8000 	nop.w

000026b0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    26b0:	b500      	push	{lr}
    26b2:	b087      	sub	sp, #28
    26b4:	9005      	str	r0, [sp, #20]
    26b6:	9104      	str	r1, [sp, #16]
    26b8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
    26ba:	9b05      	ldr	r3, [sp, #20]
    26bc:	4a13      	ldr	r2, [pc, #76]	; (270c <sdObjectInit+0x5c>)
    26be:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
    26c0:	9b05      	ldr	r3, [sp, #20]
    26c2:	3304      	adds	r3, #4
    26c4:	4618      	mov	r0, r3
    26c6:	f7ff ff1b 	bl	2500 <osalEventObjectInit>
  sdp->state = SD_STOP;
    26ca:	9b05      	ldr	r3, [sp, #20]
    26cc:	2201      	movs	r2, #1
    26ce:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    26d0:	9b05      	ldr	r3, [sp, #20]
    26d2:	f103 020c 	add.w	r2, r3, #12
    26d6:	9b05      	ldr	r3, [sp, #20]
    26d8:	3354      	adds	r3, #84	; 0x54
    26da:	9905      	ldr	r1, [sp, #20]
    26dc:	9100      	str	r1, [sp, #0]
    26de:	4610      	mov	r0, r2
    26e0:	4619      	mov	r1, r3
    26e2:	2220      	movs	r2, #32
    26e4:	9b04      	ldr	r3, [sp, #16]
    26e6:	f7ff facb 	bl	1c80 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    26ea:	9b05      	ldr	r3, [sp, #20]
    26ec:	f103 0230 	add.w	r2, r3, #48	; 0x30
    26f0:	9b05      	ldr	r3, [sp, #20]
    26f2:	3374      	adds	r3, #116	; 0x74
    26f4:	9905      	ldr	r1, [sp, #20]
    26f6:	9100      	str	r1, [sp, #0]
    26f8:	4610      	mov	r0, r2
    26fa:	4619      	mov	r1, r3
    26fc:	2220      	movs	r2, #32
    26fe:	9b03      	ldr	r3, [sp, #12]
    2700:	f7ff fbc6 	bl	1e90 <chOQObjectInit>
}
    2704:	b007      	add	sp, #28
    2706:	f85d fb04 	ldr.w	pc, [sp], #4
    270a:	bf00      	nop
    270c:	00003de0 	.word	0x00003de0

00002710 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    2710:	b500      	push	{lr}
    2712:	b083      	sub	sp, #12
    2714:	9001      	str	r0, [sp, #4]
    2716:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);
    2718:	9b01      	ldr	r3, [sp, #4]
    271a:	2b00      	cmp	r3, #0
    271c:	d102      	bne.n	2724 <sdStart+0x14>
    271e:	480e      	ldr	r0, [pc, #56]	; (2758 <sdStart+0x48>)
    2720:	f7fd ffc6 	bl	6b0 <chSysHalt>

  osalSysLock();
    2724:	f7ff fedc 	bl	24e0 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
    2728:	9b01      	ldr	r3, [sp, #4]
    272a:	7a1b      	ldrb	r3, [r3, #8]
    272c:	2b01      	cmp	r3, #1
    272e:	d006      	beq.n	273e <sdStart+0x2e>
    2730:	9b01      	ldr	r3, [sp, #4]
    2732:	7a1b      	ldrb	r3, [r3, #8]
    2734:	2b02      	cmp	r3, #2
    2736:	d002      	beq.n	273e <sdStart+0x2e>
    2738:	4807      	ldr	r0, [pc, #28]	; (2758 <sdStart+0x48>)
    273a:	f7fd ffb9 	bl	6b0 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
    273e:	9801      	ldr	r0, [sp, #4]
    2740:	9900      	ldr	r1, [sp, #0]
    2742:	f001 f93d 	bl	39c0 <sd_lld_start>
  sdp->state = SD_READY;
    2746:	9b01      	ldr	r3, [sp, #4]
    2748:	2202      	movs	r2, #2
    274a:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
    274c:	f7ff fed0 	bl	24f0 <osalSysUnlock>
}
    2750:	b003      	add	sp, #12
    2752:	f85d fb04 	ldr.w	pc, [sp], #4
    2756:	bf00      	nop
    2758:	00003e00 	.word	0x00003e00
    275c:	f3af 8000 	nop.w

00002760 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    2760:	b500      	push	{lr}
    2762:	b083      	sub	sp, #12
    2764:	9001      	str	r0, [sp, #4]
    2766:	460b      	mov	r3, r1
    2768:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
    276c:	f7fe f8a8 	bl	8c0 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
    2770:	9b01      	ldr	r3, [sp, #4]
    2772:	2b00      	cmp	r3, #0
    2774:	d102      	bne.n	277c <sdIncomingDataI+0x1c>
    2776:	4813      	ldr	r0, [pc, #76]	; (27c4 <sdIncomingDataI+0x64>)
    2778:	f7fd ff9a 	bl	6b0 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
    277c:	9b01      	ldr	r3, [sp, #4]
    277e:	330c      	adds	r3, #12
    2780:	4618      	mov	r0, r3
    2782:	f7ff fe9d 	bl	24c0 <chIQIsEmptyI>
    2786:	4603      	mov	r3, r0
    2788:	2b00      	cmp	r3, #0
    278a:	d005      	beq.n	2798 <sdIncomingDataI+0x38>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    278c:	9b01      	ldr	r3, [sp, #4]
    278e:	3304      	adds	r3, #4
    2790:	4618      	mov	r0, r3
    2792:	2104      	movs	r1, #4
    2794:	f7ff fec4 	bl	2520 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
    2798:	9b01      	ldr	r3, [sp, #4]
    279a:	f103 020c 	add.w	r2, r3, #12
    279e:	f89d 3003 	ldrb.w	r3, [sp, #3]
    27a2:	4610      	mov	r0, r2
    27a4:	4619      	mov	r1, r3
    27a6:	f7ff fa93 	bl	1cd0 <chIQPutI>
    27aa:	4603      	mov	r3, r0
    27ac:	2b00      	cmp	r3, #0
    27ae:	da05      	bge.n	27bc <sdIncomingDataI+0x5c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    27b0:	9b01      	ldr	r3, [sp, #4]
    27b2:	3304      	adds	r3, #4
    27b4:	4618      	mov	r0, r3
    27b6:	2180      	movs	r1, #128	; 0x80
    27b8:	f7ff feb2 	bl	2520 <osalEventBroadcastFlagsI>
}
    27bc:	b003      	add	sp, #12
    27be:	f85d fb04 	ldr.w	pc, [sp], #4
    27c2:	bf00      	nop
    27c4:	00003e20 	.word	0x00003e20
    27c8:	f3af 8000 	nop.w
    27cc:	f3af 8000 	nop.w

000027d0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
    27d0:	b082      	sub	sp, #8
    27d2:	9001      	str	r0, [sp, #4]
    27d4:	9100      	str	r1, [sp, #0]

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
    27d6:	4911      	ldr	r1, [pc, #68]	; (281c <nvicEnableVector+0x4c>)
    27d8:	9b00      	ldr	r3, [sp, #0]
    27da:	b2db      	uxtb	r3, r3
    27dc:	011b      	lsls	r3, r3, #4
    27de:	b2da      	uxtb	r2, r3
    27e0:	9b01      	ldr	r3, [sp, #4]
    27e2:	440b      	add	r3, r1
    27e4:	f503 7340 	add.w	r3, r3, #768	; 0x300
    27e8:	701a      	strb	r2, [r3, #0]
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
    27ea:	4b0c      	ldr	r3, [pc, #48]	; (281c <nvicEnableVector+0x4c>)
    27ec:	9a01      	ldr	r2, [sp, #4]
    27ee:	0952      	lsrs	r2, r2, #5
    27f0:	9901      	ldr	r1, [sp, #4]
    27f2:	f001 011f 	and.w	r1, r1, #31
    27f6:	2001      	movs	r0, #1
    27f8:	fa00 f101 	lsl.w	r1, r0, r1
    27fc:	3260      	adds	r2, #96	; 0x60
    27fe:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
    2802:	4b06      	ldr	r3, [pc, #24]	; (281c <nvicEnableVector+0x4c>)
    2804:	9a01      	ldr	r2, [sp, #4]
    2806:	0952      	lsrs	r2, r2, #5
    2808:	9901      	ldr	r1, [sp, #4]
    280a:	f001 011f 	and.w	r1, r1, #31
    280e:	2001      	movs	r0, #1
    2810:	fa00 f101 	lsl.w	r1, r0, r1
    2814:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    2818:	b002      	add	sp, #8
    281a:	4770      	bx	lr
    281c:	e000e100 	.word	0xe000e100

00002820 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
    2820:	4b0d      	ldr	r3, [pc, #52]	; (2858 <hal_lld_backup_domain_init+0x38>)
    2822:	4a0d      	ldr	r2, [pc, #52]	; (2858 <hal_lld_backup_domain_init+0x38>)
    2824:	6812      	ldr	r2, [r2, #0]
    2826:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    282a:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
    282c:	4b0b      	ldr	r3, [pc, #44]	; (285c <hal_lld_backup_domain_init+0x3c>)
    282e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    2830:	f403 7340 	and.w	r3, r3, #768	; 0x300
    2834:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    2838:	d006      	beq.n	2848 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
    283a:	4b08      	ldr	r3, [pc, #32]	; (285c <hal_lld_backup_domain_init+0x3c>)
    283c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    2840:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
    2842:	4b06      	ldr	r3, [pc, #24]	; (285c <hal_lld_backup_domain_init+0x3c>)
    2844:	2200      	movs	r2, #0
    2846:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
    2848:	4b03      	ldr	r3, [pc, #12]	; (2858 <hal_lld_backup_domain_init+0x38>)
    284a:	4a03      	ldr	r2, [pc, #12]	; (2858 <hal_lld_backup_domain_init+0x38>)
    284c:	6852      	ldr	r2, [r2, #4]
    284e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    2852:	605a      	str	r2, [r3, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
    2854:	4770      	bx	lr
    2856:	bf00      	nop
    2858:	40007000 	.word	0x40007000
    285c:	40023800 	.word	0x40023800

00002860 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
    2860:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
    2862:	4b17      	ldr	r3, [pc, #92]	; (28c0 <hal_lld_init+0x60>)
    2864:	691b      	ldr	r3, [r3, #16]
    2866:	4b16      	ldr	r3, [pc, #88]	; (28c0 <hal_lld_init+0x60>)
    2868:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    286c:	611a      	str	r2, [r3, #16]
    286e:	4b14      	ldr	r3, [pc, #80]	; (28c0 <hal_lld_init+0x60>)
    2870:	2200      	movs	r2, #0
    2872:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
    2874:	4b12      	ldr	r3, [pc, #72]	; (28c0 <hal_lld_init+0x60>)
    2876:	695b      	ldr	r3, [r3, #20]
    2878:	4b11      	ldr	r3, [pc, #68]	; (28c0 <hal_lld_init+0x60>)
    287a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    287e:	615a      	str	r2, [r3, #20]
    2880:	4b0f      	ldr	r3, [pc, #60]	; (28c0 <hal_lld_init+0x60>)
    2882:	2200      	movs	r2, #0
    2884:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
    2886:	4b0e      	ldr	r3, [pc, #56]	; (28c0 <hal_lld_init+0x60>)
    2888:	4a0d      	ldr	r2, [pc, #52]	; (28c0 <hal_lld_init+0x60>)
    288a:	6a12      	ldr	r2, [r2, #32]
    288c:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
    2890:	621a      	str	r2, [r3, #32]
    2892:	4b0b      	ldr	r3, [pc, #44]	; (28c0 <hal_lld_init+0x60>)
    2894:	2200      	movs	r2, #0
    2896:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
    2898:	4b09      	ldr	r3, [pc, #36]	; (28c0 <hal_lld_init+0x60>)
    289a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    289c:	4b08      	ldr	r3, [pc, #32]	; (28c0 <hal_lld_init+0x60>)
    289e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    28a2:	625a      	str	r2, [r3, #36]	; 0x24
    28a4:	4b06      	ldr	r3, [pc, #24]	; (28c0 <hal_lld_init+0x60>)
    28a6:	2200      	movs	r2, #0
    28a8:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
    28aa:	4b05      	ldr	r3, [pc, #20]	; (28c0 <hal_lld_init+0x60>)
    28ac:	4a04      	ldr	r2, [pc, #16]	; (28c0 <hal_lld_init+0x60>)
    28ae:	6c12      	ldr	r2, [r2, #64]	; 0x40
    28b0:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    28b4:	641a      	str	r2, [r3, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
    28b6:	f7ff ffb3 	bl	2820 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
    28ba:	f000 fb19 	bl	2ef0 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
    28be:	bd08      	pop	{r3, pc}
    28c0:	40023800 	.word	0x40023800
    28c4:	f3af 8000 	nop.w
    28c8:	f3af 8000 	nop.w
    28cc:	f3af 8000 	nop.w

000028d0 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
    28d0:	4b40      	ldr	r3, [pc, #256]	; (29d4 <stm32_clock_init+0x104>)
    28d2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    28d6:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
    28d8:	4b3f      	ldr	r3, [pc, #252]	; (29d8 <stm32_clock_init+0x108>)
    28da:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    28de:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
    28e0:	4b3c      	ldr	r3, [pc, #240]	; (29d4 <stm32_clock_init+0x104>)
    28e2:	4a3c      	ldr	r2, [pc, #240]	; (29d4 <stm32_clock_init+0x104>)
    28e4:	6812      	ldr	r2, [r2, #0]
    28e6:	f042 0201 	orr.w	r2, r2, #1
    28ea:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
    28ec:	bf00      	nop
    28ee:	4b39      	ldr	r3, [pc, #228]	; (29d4 <stm32_clock_init+0x104>)
    28f0:	681b      	ldr	r3, [r3, #0]
    28f2:	f003 0302 	and.w	r3, r3, #2
    28f6:	2b00      	cmp	r3, #0
    28f8:	d0f9      	beq.n	28ee <stm32_clock_init+0x1e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
    28fa:	4b36      	ldr	r3, [pc, #216]	; (29d4 <stm32_clock_init+0x104>)
    28fc:	4a35      	ldr	r2, [pc, #212]	; (29d4 <stm32_clock_init+0x104>)
    28fe:	6892      	ldr	r2, [r2, #8]
    2900:	f022 0203 	bic.w	r2, r2, #3
    2904:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
    2906:	4b33      	ldr	r3, [pc, #204]	; (29d4 <stm32_clock_init+0x104>)
    2908:	4a32      	ldr	r2, [pc, #200]	; (29d4 <stm32_clock_init+0x104>)
    290a:	6892      	ldr	r2, [r2, #8]
    290c:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
    290e:	bf00      	nop
    2910:	4b30      	ldr	r3, [pc, #192]	; (29d4 <stm32_clock_init+0x104>)
    2912:	689b      	ldr	r3, [r3, #8]
    2914:	f003 030c 	and.w	r3, r3, #12
    2918:	2b00      	cmp	r3, #0
    291a:	d1f9      	bne.n	2910 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
    291c:	4b2d      	ldr	r3, [pc, #180]	; (29d4 <stm32_clock_init+0x104>)
    291e:	4a2d      	ldr	r2, [pc, #180]	; (29d4 <stm32_clock_init+0x104>)
    2920:	6812      	ldr	r2, [r2, #0]
    2922:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
    2926:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
    2928:	4b2a      	ldr	r3, [pc, #168]	; (29d4 <stm32_clock_init+0x104>)
    292a:	2200      	movs	r2, #0
    292c:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
    292e:	4b29      	ldr	r3, [pc, #164]	; (29d4 <stm32_clock_init+0x104>)
    2930:	4a28      	ldr	r2, [pc, #160]	; (29d4 <stm32_clock_init+0x104>)
    2932:	6812      	ldr	r2, [r2, #0]
    2934:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    2938:	601a      	str	r2, [r3, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
    293a:	bf00      	nop
    293c:	4b25      	ldr	r3, [pc, #148]	; (29d4 <stm32_clock_init+0x104>)
    293e:	681b      	ldr	r3, [r3, #0]
    2940:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    2944:	2b00      	cmp	r3, #0
    2946:	d0f9      	beq.n	293c <stm32_clock_init+0x6c>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
    2948:	4b22      	ldr	r3, [pc, #136]	; (29d4 <stm32_clock_init+0x104>)
    294a:	4a22      	ldr	r2, [pc, #136]	; (29d4 <stm32_clock_init+0x104>)
    294c:	6f52      	ldr	r2, [r2, #116]	; 0x74
    294e:	f042 0201 	orr.w	r2, r2, #1
    2952:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
    2954:	bf00      	nop
    2956:	4b1f      	ldr	r3, [pc, #124]	; (29d4 <stm32_clock_init+0x104>)
    2958:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    295a:	f003 0302 	and.w	r3, r3, #2
    295e:	2b00      	cmp	r3, #0
    2960:	d0f9      	beq.n	2956 <stm32_clock_init+0x86>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
    2962:	4b1c      	ldr	r3, [pc, #112]	; (29d4 <stm32_clock_init+0x104>)
    2964:	4a1d      	ldr	r2, [pc, #116]	; (29dc <stm32_clock_init+0x10c>)
    2966:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
    2968:	4b1a      	ldr	r3, [pc, #104]	; (29d4 <stm32_clock_init+0x104>)
    296a:	4a1a      	ldr	r2, [pc, #104]	; (29d4 <stm32_clock_init+0x104>)
    296c:	6812      	ldr	r2, [r2, #0]
    296e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    2972:	601a      	str	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
    2974:	bf00      	nop
    2976:	4b18      	ldr	r3, [pc, #96]	; (29d8 <stm32_clock_init+0x108>)
    2978:	685b      	ldr	r3, [r3, #4]
    297a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    297e:	2b00      	cmp	r3, #0
    2980:	d0f9      	beq.n	2976 <stm32_clock_init+0xa6>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
    2982:	bf00      	nop
    2984:	4b13      	ldr	r3, [pc, #76]	; (29d4 <stm32_clock_init+0x104>)
    2986:	681b      	ldr	r3, [r3, #0]
    2988:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    298c:	2b00      	cmp	r3, #0
    298e:	d0f9      	beq.n	2984 <stm32_clock_init+0xb4>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
    2990:	4b10      	ldr	r3, [pc, #64]	; (29d4 <stm32_clock_init+0x104>)
    2992:	4a13      	ldr	r2, [pc, #76]	; (29e0 <stm32_clock_init+0x110>)
    2994:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
    2996:	4b13      	ldr	r3, [pc, #76]	; (29e4 <stm32_clock_init+0x114>)
    2998:	f240 7205 	movw	r2, #1797	; 0x705
    299c:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
    299e:	4b0d      	ldr	r3, [pc, #52]	; (29d4 <stm32_clock_init+0x104>)
    29a0:	4a0c      	ldr	r2, [pc, #48]	; (29d4 <stm32_clock_init+0x104>)
    29a2:	6892      	ldr	r2, [r2, #8]
    29a4:	f042 0202 	orr.w	r2, r2, #2
    29a8:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
    29aa:	bf00      	nop
    29ac:	4b09      	ldr	r3, [pc, #36]	; (29d4 <stm32_clock_init+0x104>)
    29ae:	689b      	ldr	r3, [r3, #8]
    29b0:	f003 030c 	and.w	r3, r3, #12
    29b4:	2b08      	cmp	r3, #8
    29b6:	d1f9      	bne.n	29ac <stm32_clock_init+0xdc>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
    29b8:	4b06      	ldr	r3, [pc, #24]	; (29d4 <stm32_clock_init+0x104>)
    29ba:	4a06      	ldr	r2, [pc, #24]	; (29d4 <stm32_clock_init+0x104>)
    29bc:	6c52      	ldr	r2, [r2, #68]	; 0x44
    29be:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    29c2:	645a      	str	r2, [r3, #68]	; 0x44
    29c4:	4b03      	ldr	r3, [pc, #12]	; (29d4 <stm32_clock_init+0x104>)
    29c6:	4a03      	ldr	r2, [pc, #12]	; (29d4 <stm32_clock_init+0x104>)
    29c8:	6e52      	ldr	r2, [r2, #100]	; 0x64
    29ca:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    29ce:	665a      	str	r2, [r3, #100]	; 0x64
}
    29d0:	4770      	bx	lr
    29d2:	bf00      	nop
    29d4:	40023800 	.word	0x40023800
    29d8:	40007000 	.word	0x40007000
    29dc:	07405408 	.word	0x07405408
    29e0:	38089400 	.word	0x38089400
    29e4:	40023c00 	.word	0x40023c00
    29e8:	f3af 8000 	nop.w
    29ec:	f3af 8000 	nop.w

000029f0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
    29f0:	b500      	push	{lr}
    29f2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    29f4:	f7fe ff3c 	bl	1870 <_stats_increase_irq>
    29f8:	f7fd ff22 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
    29fc:	4b0c      	ldr	r3, [pc, #48]	; (2a30 <Vector6C+0x40>)
    29fe:	681b      	ldr	r3, [r3, #0]
    2a00:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2a04:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
    2a06:	4b0a      	ldr	r3, [pc, #40]	; (2a30 <Vector6C+0x40>)
    2a08:	9a01      	ldr	r2, [sp, #4]
    2a0a:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[0].dma_func)
    2a0c:	4b09      	ldr	r3, [pc, #36]	; (2a34 <Vector6C+0x44>)
    2a0e:	681b      	ldr	r3, [r3, #0]
    2a10:	2b00      	cmp	r3, #0
    2a12:	d006      	beq.n	2a22 <Vector6C+0x32>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
    2a14:	4b07      	ldr	r3, [pc, #28]	; (2a34 <Vector6C+0x44>)
    2a16:	681b      	ldr	r3, [r3, #0]
    2a18:	4a06      	ldr	r2, [pc, #24]	; (2a34 <Vector6C+0x44>)
    2a1a:	6852      	ldr	r2, [r2, #4]
    2a1c:	4610      	mov	r0, r2
    2a1e:	9901      	ldr	r1, [sp, #4]
    2a20:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2a22:	f7fd ff2d 	bl	880 <_dbg_check_leave_isr>
    2a26:	f7ff fc0b 	bl	2240 <_port_irq_epilogue>
}
    2a2a:	b003      	add	sp, #12
    2a2c:	f85d fb04 	ldr.w	pc, [sp], #4
    2a30:	40026000 	.word	0x40026000
    2a34:	20000e04 	.word	0x20000e04
    2a38:	f3af 8000 	nop.w
    2a3c:	f3af 8000 	nop.w

00002a40 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
    2a40:	b500      	push	{lr}
    2a42:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2a44:	f7fe ff14 	bl	1870 <_stats_increase_irq>
    2a48:	f7fd fefa 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
    2a4c:	4b0d      	ldr	r3, [pc, #52]	; (2a84 <Vector70+0x44>)
    2a4e:	681b      	ldr	r3, [r3, #0]
    2a50:	099b      	lsrs	r3, r3, #6
    2a52:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2a56:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
    2a58:	4b0a      	ldr	r3, [pc, #40]	; (2a84 <Vector70+0x44>)
    2a5a:	9a01      	ldr	r2, [sp, #4]
    2a5c:	0192      	lsls	r2, r2, #6
    2a5e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[1].dma_func)
    2a60:	4b09      	ldr	r3, [pc, #36]	; (2a88 <Vector70+0x48>)
    2a62:	689b      	ldr	r3, [r3, #8]
    2a64:	2b00      	cmp	r3, #0
    2a66:	d006      	beq.n	2a76 <Vector70+0x36>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
    2a68:	4b07      	ldr	r3, [pc, #28]	; (2a88 <Vector70+0x48>)
    2a6a:	689b      	ldr	r3, [r3, #8]
    2a6c:	4a06      	ldr	r2, [pc, #24]	; (2a88 <Vector70+0x48>)
    2a6e:	68d2      	ldr	r2, [r2, #12]
    2a70:	4610      	mov	r0, r2
    2a72:	9901      	ldr	r1, [sp, #4]
    2a74:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2a76:	f7fd ff03 	bl	880 <_dbg_check_leave_isr>
    2a7a:	f7ff fbe1 	bl	2240 <_port_irq_epilogue>
}
    2a7e:	b003      	add	sp, #12
    2a80:	f85d fb04 	ldr.w	pc, [sp], #4
    2a84:	40026000 	.word	0x40026000
    2a88:	20000e04 	.word	0x20000e04
    2a8c:	f3af 8000 	nop.w

00002a90 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
    2a90:	b500      	push	{lr}
    2a92:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2a94:	f7fe feec 	bl	1870 <_stats_increase_irq>
    2a98:	f7fd fed2 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
    2a9c:	4b0d      	ldr	r3, [pc, #52]	; (2ad4 <Vector74+0x44>)
    2a9e:	681b      	ldr	r3, [r3, #0]
    2aa0:	0c1b      	lsrs	r3, r3, #16
    2aa2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2aa6:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
    2aa8:	4b0a      	ldr	r3, [pc, #40]	; (2ad4 <Vector74+0x44>)
    2aaa:	9a01      	ldr	r2, [sp, #4]
    2aac:	0412      	lsls	r2, r2, #16
    2aae:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[2].dma_func)
    2ab0:	4b09      	ldr	r3, [pc, #36]	; (2ad8 <Vector74+0x48>)
    2ab2:	691b      	ldr	r3, [r3, #16]
    2ab4:	2b00      	cmp	r3, #0
    2ab6:	d006      	beq.n	2ac6 <Vector74+0x36>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
    2ab8:	4b07      	ldr	r3, [pc, #28]	; (2ad8 <Vector74+0x48>)
    2aba:	691b      	ldr	r3, [r3, #16]
    2abc:	4a06      	ldr	r2, [pc, #24]	; (2ad8 <Vector74+0x48>)
    2abe:	6952      	ldr	r2, [r2, #20]
    2ac0:	4610      	mov	r0, r2
    2ac2:	9901      	ldr	r1, [sp, #4]
    2ac4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2ac6:	f7fd fedb 	bl	880 <_dbg_check_leave_isr>
    2aca:	f7ff fbb9 	bl	2240 <_port_irq_epilogue>
}
    2ace:	b003      	add	sp, #12
    2ad0:	f85d fb04 	ldr.w	pc, [sp], #4
    2ad4:	40026000 	.word	0x40026000
    2ad8:	20000e04 	.word	0x20000e04
    2adc:	f3af 8000 	nop.w

00002ae0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
    2ae0:	b500      	push	{lr}
    2ae2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2ae4:	f7fe fec4 	bl	1870 <_stats_increase_irq>
    2ae8:	f7fd feaa 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
    2aec:	4b0d      	ldr	r3, [pc, #52]	; (2b24 <Vector78+0x44>)
    2aee:	681b      	ldr	r3, [r3, #0]
    2af0:	0d9b      	lsrs	r3, r3, #22
    2af2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2af6:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
    2af8:	4b0a      	ldr	r3, [pc, #40]	; (2b24 <Vector78+0x44>)
    2afa:	9a01      	ldr	r2, [sp, #4]
    2afc:	0592      	lsls	r2, r2, #22
    2afe:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[3].dma_func)
    2b00:	4b09      	ldr	r3, [pc, #36]	; (2b28 <Vector78+0x48>)
    2b02:	699b      	ldr	r3, [r3, #24]
    2b04:	2b00      	cmp	r3, #0
    2b06:	d006      	beq.n	2b16 <Vector78+0x36>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
    2b08:	4b07      	ldr	r3, [pc, #28]	; (2b28 <Vector78+0x48>)
    2b0a:	699b      	ldr	r3, [r3, #24]
    2b0c:	4a06      	ldr	r2, [pc, #24]	; (2b28 <Vector78+0x48>)
    2b0e:	69d2      	ldr	r2, [r2, #28]
    2b10:	4610      	mov	r0, r2
    2b12:	9901      	ldr	r1, [sp, #4]
    2b14:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2b16:	f7fd feb3 	bl	880 <_dbg_check_leave_isr>
    2b1a:	f7ff fb91 	bl	2240 <_port_irq_epilogue>
}
    2b1e:	b003      	add	sp, #12
    2b20:	f85d fb04 	ldr.w	pc, [sp], #4
    2b24:	40026000 	.word	0x40026000
    2b28:	20000e04 	.word	0x20000e04
    2b2c:	f3af 8000 	nop.w

00002b30 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
    2b30:	b500      	push	{lr}
    2b32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2b34:	f7fe fe9c 	bl	1870 <_stats_increase_irq>
    2b38:	f7fd fe82 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
    2b3c:	4b0c      	ldr	r3, [pc, #48]	; (2b70 <Vector7C+0x40>)
    2b3e:	685b      	ldr	r3, [r3, #4]
    2b40:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2b44:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
    2b46:	4b0a      	ldr	r3, [pc, #40]	; (2b70 <Vector7C+0x40>)
    2b48:	9a01      	ldr	r2, [sp, #4]
    2b4a:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[4].dma_func)
    2b4c:	4b09      	ldr	r3, [pc, #36]	; (2b74 <Vector7C+0x44>)
    2b4e:	6a1b      	ldr	r3, [r3, #32]
    2b50:	2b00      	cmp	r3, #0
    2b52:	d006      	beq.n	2b62 <Vector7C+0x32>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
    2b54:	4b07      	ldr	r3, [pc, #28]	; (2b74 <Vector7C+0x44>)
    2b56:	6a1b      	ldr	r3, [r3, #32]
    2b58:	4a06      	ldr	r2, [pc, #24]	; (2b74 <Vector7C+0x44>)
    2b5a:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2b5c:	4610      	mov	r0, r2
    2b5e:	9901      	ldr	r1, [sp, #4]
    2b60:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2b62:	f7fd fe8d 	bl	880 <_dbg_check_leave_isr>
    2b66:	f7ff fb6b 	bl	2240 <_port_irq_epilogue>
}
    2b6a:	b003      	add	sp, #12
    2b6c:	f85d fb04 	ldr.w	pc, [sp], #4
    2b70:	40026000 	.word	0x40026000
    2b74:	20000e04 	.word	0x20000e04
    2b78:	f3af 8000 	nop.w
    2b7c:	f3af 8000 	nop.w

00002b80 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
    2b80:	b500      	push	{lr}
    2b82:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2b84:	f7fe fe74 	bl	1870 <_stats_increase_irq>
    2b88:	f7fd fe5a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
    2b8c:	4b0d      	ldr	r3, [pc, #52]	; (2bc4 <Vector80+0x44>)
    2b8e:	685b      	ldr	r3, [r3, #4]
    2b90:	099b      	lsrs	r3, r3, #6
    2b92:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2b96:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
    2b98:	4b0a      	ldr	r3, [pc, #40]	; (2bc4 <Vector80+0x44>)
    2b9a:	9a01      	ldr	r2, [sp, #4]
    2b9c:	0192      	lsls	r2, r2, #6
    2b9e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[5].dma_func)
    2ba0:	4b09      	ldr	r3, [pc, #36]	; (2bc8 <Vector80+0x48>)
    2ba2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2ba4:	2b00      	cmp	r3, #0
    2ba6:	d006      	beq.n	2bb6 <Vector80+0x36>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
    2ba8:	4b07      	ldr	r3, [pc, #28]	; (2bc8 <Vector80+0x48>)
    2baa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2bac:	4a06      	ldr	r2, [pc, #24]	; (2bc8 <Vector80+0x48>)
    2bae:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    2bb0:	4610      	mov	r0, r2
    2bb2:	9901      	ldr	r1, [sp, #4]
    2bb4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2bb6:	f7fd fe63 	bl	880 <_dbg_check_leave_isr>
    2bba:	f7ff fb41 	bl	2240 <_port_irq_epilogue>
}
    2bbe:	b003      	add	sp, #12
    2bc0:	f85d fb04 	ldr.w	pc, [sp], #4
    2bc4:	40026000 	.word	0x40026000
    2bc8:	20000e04 	.word	0x20000e04
    2bcc:	f3af 8000 	nop.w

00002bd0 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
    2bd0:	b500      	push	{lr}
    2bd2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2bd4:	f7fe fe4c 	bl	1870 <_stats_increase_irq>
    2bd8:	f7fd fe32 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
    2bdc:	4b0d      	ldr	r3, [pc, #52]	; (2c14 <Vector84+0x44>)
    2bde:	685b      	ldr	r3, [r3, #4]
    2be0:	0c1b      	lsrs	r3, r3, #16
    2be2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2be6:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
    2be8:	4b0a      	ldr	r3, [pc, #40]	; (2c14 <Vector84+0x44>)
    2bea:	9a01      	ldr	r2, [sp, #4]
    2bec:	0412      	lsls	r2, r2, #16
    2bee:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[6].dma_func)
    2bf0:	4b09      	ldr	r3, [pc, #36]	; (2c18 <Vector84+0x48>)
    2bf2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2bf4:	2b00      	cmp	r3, #0
    2bf6:	d006      	beq.n	2c06 <Vector84+0x36>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
    2bf8:	4b07      	ldr	r3, [pc, #28]	; (2c18 <Vector84+0x48>)
    2bfa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2bfc:	4a06      	ldr	r2, [pc, #24]	; (2c18 <Vector84+0x48>)
    2bfe:	6b52      	ldr	r2, [r2, #52]	; 0x34
    2c00:	4610      	mov	r0, r2
    2c02:	9901      	ldr	r1, [sp, #4]
    2c04:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2c06:	f7fd fe3b 	bl	880 <_dbg_check_leave_isr>
    2c0a:	f7ff fb19 	bl	2240 <_port_irq_epilogue>
}
    2c0e:	b003      	add	sp, #12
    2c10:	f85d fb04 	ldr.w	pc, [sp], #4
    2c14:	40026000 	.word	0x40026000
    2c18:	20000e04 	.word	0x20000e04
    2c1c:	f3af 8000 	nop.w

00002c20 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
    2c20:	b500      	push	{lr}
    2c22:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2c24:	f7fe fe24 	bl	1870 <_stats_increase_irq>
    2c28:	f7fd fe0a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
    2c2c:	4b0d      	ldr	r3, [pc, #52]	; (2c64 <VectorFC+0x44>)
    2c2e:	685b      	ldr	r3, [r3, #4]
    2c30:	0d9b      	lsrs	r3, r3, #22
    2c32:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2c36:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
    2c38:	4b0a      	ldr	r3, [pc, #40]	; (2c64 <VectorFC+0x44>)
    2c3a:	9a01      	ldr	r2, [sp, #4]
    2c3c:	0592      	lsls	r2, r2, #22
    2c3e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[7].dma_func)
    2c40:	4b09      	ldr	r3, [pc, #36]	; (2c68 <VectorFC+0x48>)
    2c42:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    2c44:	2b00      	cmp	r3, #0
    2c46:	d006      	beq.n	2c56 <VectorFC+0x36>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
    2c48:	4b07      	ldr	r3, [pc, #28]	; (2c68 <VectorFC+0x48>)
    2c4a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    2c4c:	4a06      	ldr	r2, [pc, #24]	; (2c68 <VectorFC+0x48>)
    2c4e:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
    2c50:	4610      	mov	r0, r2
    2c52:	9901      	ldr	r1, [sp, #4]
    2c54:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2c56:	f7fd fe13 	bl	880 <_dbg_check_leave_isr>
    2c5a:	f7ff faf1 	bl	2240 <_port_irq_epilogue>
}
    2c5e:	b003      	add	sp, #12
    2c60:	f85d fb04 	ldr.w	pc, [sp], #4
    2c64:	40026000 	.word	0x40026000
    2c68:	20000e04 	.word	0x20000e04
    2c6c:	f3af 8000 	nop.w

00002c70 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
    2c70:	b500      	push	{lr}
    2c72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2c74:	f7fe fdfc 	bl	1870 <_stats_increase_irq>
    2c78:	f7fd fde2 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
    2c7c:	4b0c      	ldr	r3, [pc, #48]	; (2cb0 <Vector120+0x40>)
    2c7e:	681b      	ldr	r3, [r3, #0]
    2c80:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2c84:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
    2c86:	4b0a      	ldr	r3, [pc, #40]	; (2cb0 <Vector120+0x40>)
    2c88:	9a01      	ldr	r2, [sp, #4]
    2c8a:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[8].dma_func)
    2c8c:	4b09      	ldr	r3, [pc, #36]	; (2cb4 <Vector120+0x44>)
    2c8e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    2c90:	2b00      	cmp	r3, #0
    2c92:	d006      	beq.n	2ca2 <Vector120+0x32>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
    2c94:	4b07      	ldr	r3, [pc, #28]	; (2cb4 <Vector120+0x44>)
    2c96:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    2c98:	4a06      	ldr	r2, [pc, #24]	; (2cb4 <Vector120+0x44>)
    2c9a:	6c52      	ldr	r2, [r2, #68]	; 0x44
    2c9c:	4610      	mov	r0, r2
    2c9e:	9901      	ldr	r1, [sp, #4]
    2ca0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2ca2:	f7fd fded 	bl	880 <_dbg_check_leave_isr>
    2ca6:	f7ff facb 	bl	2240 <_port_irq_epilogue>
}
    2caa:	b003      	add	sp, #12
    2cac:	f85d fb04 	ldr.w	pc, [sp], #4
    2cb0:	40026400 	.word	0x40026400
    2cb4:	20000e04 	.word	0x20000e04
    2cb8:	f3af 8000 	nop.w
    2cbc:	f3af 8000 	nop.w

00002cc0 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
    2cc0:	b500      	push	{lr}
    2cc2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2cc4:	f7fe fdd4 	bl	1870 <_stats_increase_irq>
    2cc8:	f7fd fdba 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
    2ccc:	4b0d      	ldr	r3, [pc, #52]	; (2d04 <Vector124+0x44>)
    2cce:	681b      	ldr	r3, [r3, #0]
    2cd0:	099b      	lsrs	r3, r3, #6
    2cd2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2cd6:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
    2cd8:	4b0a      	ldr	r3, [pc, #40]	; (2d04 <Vector124+0x44>)
    2cda:	9a01      	ldr	r2, [sp, #4]
    2cdc:	0192      	lsls	r2, r2, #6
    2cde:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[9].dma_func)
    2ce0:	4b09      	ldr	r3, [pc, #36]	; (2d08 <Vector124+0x48>)
    2ce2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    2ce4:	2b00      	cmp	r3, #0
    2ce6:	d006      	beq.n	2cf6 <Vector124+0x36>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
    2ce8:	4b07      	ldr	r3, [pc, #28]	; (2d08 <Vector124+0x48>)
    2cea:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    2cec:	4a06      	ldr	r2, [pc, #24]	; (2d08 <Vector124+0x48>)
    2cee:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    2cf0:	4610      	mov	r0, r2
    2cf2:	9901      	ldr	r1, [sp, #4]
    2cf4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2cf6:	f7fd fdc3 	bl	880 <_dbg_check_leave_isr>
    2cfa:	f7ff faa1 	bl	2240 <_port_irq_epilogue>
}
    2cfe:	b003      	add	sp, #12
    2d00:	f85d fb04 	ldr.w	pc, [sp], #4
    2d04:	40026400 	.word	0x40026400
    2d08:	20000e04 	.word	0x20000e04
    2d0c:	f3af 8000 	nop.w

00002d10 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
    2d10:	b500      	push	{lr}
    2d12:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2d14:	f7fe fdac 	bl	1870 <_stats_increase_irq>
    2d18:	f7fd fd92 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
    2d1c:	4b0d      	ldr	r3, [pc, #52]	; (2d54 <Vector128+0x44>)
    2d1e:	681b      	ldr	r3, [r3, #0]
    2d20:	0c1b      	lsrs	r3, r3, #16
    2d22:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2d26:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
    2d28:	4b0a      	ldr	r3, [pc, #40]	; (2d54 <Vector128+0x44>)
    2d2a:	9a01      	ldr	r2, [sp, #4]
    2d2c:	0412      	lsls	r2, r2, #16
    2d2e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[10].dma_func)
    2d30:	4b09      	ldr	r3, [pc, #36]	; (2d58 <Vector128+0x48>)
    2d32:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    2d34:	2b00      	cmp	r3, #0
    2d36:	d006      	beq.n	2d46 <Vector128+0x36>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
    2d38:	4b07      	ldr	r3, [pc, #28]	; (2d58 <Vector128+0x48>)
    2d3a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    2d3c:	4a06      	ldr	r2, [pc, #24]	; (2d58 <Vector128+0x48>)
    2d3e:	6d52      	ldr	r2, [r2, #84]	; 0x54
    2d40:	4610      	mov	r0, r2
    2d42:	9901      	ldr	r1, [sp, #4]
    2d44:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2d46:	f7fd fd9b 	bl	880 <_dbg_check_leave_isr>
    2d4a:	f7ff fa79 	bl	2240 <_port_irq_epilogue>
}
    2d4e:	b003      	add	sp, #12
    2d50:	f85d fb04 	ldr.w	pc, [sp], #4
    2d54:	40026400 	.word	0x40026400
    2d58:	20000e04 	.word	0x20000e04
    2d5c:	f3af 8000 	nop.w

00002d60 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
    2d60:	b500      	push	{lr}
    2d62:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2d64:	f7fe fd84 	bl	1870 <_stats_increase_irq>
    2d68:	f7fd fd6a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
    2d6c:	4b0d      	ldr	r3, [pc, #52]	; (2da4 <Vector12C+0x44>)
    2d6e:	681b      	ldr	r3, [r3, #0]
    2d70:	0d9b      	lsrs	r3, r3, #22
    2d72:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2d76:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
    2d78:	4b0a      	ldr	r3, [pc, #40]	; (2da4 <Vector12C+0x44>)
    2d7a:	9a01      	ldr	r2, [sp, #4]
    2d7c:	0592      	lsls	r2, r2, #22
    2d7e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[11].dma_func)
    2d80:	4b09      	ldr	r3, [pc, #36]	; (2da8 <Vector12C+0x48>)
    2d82:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    2d84:	2b00      	cmp	r3, #0
    2d86:	d006      	beq.n	2d96 <Vector12C+0x36>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
    2d88:	4b07      	ldr	r3, [pc, #28]	; (2da8 <Vector12C+0x48>)
    2d8a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    2d8c:	4a06      	ldr	r2, [pc, #24]	; (2da8 <Vector12C+0x48>)
    2d8e:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
    2d90:	4610      	mov	r0, r2
    2d92:	9901      	ldr	r1, [sp, #4]
    2d94:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2d96:	f7fd fd73 	bl	880 <_dbg_check_leave_isr>
    2d9a:	f7ff fa51 	bl	2240 <_port_irq_epilogue>
}
    2d9e:	b003      	add	sp, #12
    2da0:	f85d fb04 	ldr.w	pc, [sp], #4
    2da4:	40026400 	.word	0x40026400
    2da8:	20000e04 	.word	0x20000e04
    2dac:	f3af 8000 	nop.w

00002db0 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
    2db0:	b500      	push	{lr}
    2db2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2db4:	f7fe fd5c 	bl	1870 <_stats_increase_irq>
    2db8:	f7fd fd42 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
    2dbc:	4b0c      	ldr	r3, [pc, #48]	; (2df0 <Vector130+0x40>)
    2dbe:	685b      	ldr	r3, [r3, #4]
    2dc0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2dc4:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
    2dc6:	4b0a      	ldr	r3, [pc, #40]	; (2df0 <Vector130+0x40>)
    2dc8:	9a01      	ldr	r2, [sp, #4]
    2dca:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[12].dma_func)
    2dcc:	4b09      	ldr	r3, [pc, #36]	; (2df4 <Vector130+0x44>)
    2dce:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    2dd0:	2b00      	cmp	r3, #0
    2dd2:	d006      	beq.n	2de2 <Vector130+0x32>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
    2dd4:	4b07      	ldr	r3, [pc, #28]	; (2df4 <Vector130+0x44>)
    2dd6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    2dd8:	4a06      	ldr	r2, [pc, #24]	; (2df4 <Vector130+0x44>)
    2dda:	6e52      	ldr	r2, [r2, #100]	; 0x64
    2ddc:	4610      	mov	r0, r2
    2dde:	9901      	ldr	r1, [sp, #4]
    2de0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2de2:	f7fd fd4d 	bl	880 <_dbg_check_leave_isr>
    2de6:	f7ff fa2b 	bl	2240 <_port_irq_epilogue>
}
    2dea:	b003      	add	sp, #12
    2dec:	f85d fb04 	ldr.w	pc, [sp], #4
    2df0:	40026400 	.word	0x40026400
    2df4:	20000e04 	.word	0x20000e04
    2df8:	f3af 8000 	nop.w
    2dfc:	f3af 8000 	nop.w

00002e00 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
    2e00:	b500      	push	{lr}
    2e02:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2e04:	f7fe fd34 	bl	1870 <_stats_increase_irq>
    2e08:	f7fd fd1a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
    2e0c:	4b0d      	ldr	r3, [pc, #52]	; (2e44 <Vector150+0x44>)
    2e0e:	685b      	ldr	r3, [r3, #4]
    2e10:	099b      	lsrs	r3, r3, #6
    2e12:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2e16:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
    2e18:	4b0a      	ldr	r3, [pc, #40]	; (2e44 <Vector150+0x44>)
    2e1a:	9a01      	ldr	r2, [sp, #4]
    2e1c:	0192      	lsls	r2, r2, #6
    2e1e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[13].dma_func)
    2e20:	4b09      	ldr	r3, [pc, #36]	; (2e48 <Vector150+0x48>)
    2e22:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    2e24:	2b00      	cmp	r3, #0
    2e26:	d006      	beq.n	2e36 <Vector150+0x36>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
    2e28:	4b07      	ldr	r3, [pc, #28]	; (2e48 <Vector150+0x48>)
    2e2a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    2e2c:	4a06      	ldr	r2, [pc, #24]	; (2e48 <Vector150+0x48>)
    2e2e:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    2e30:	4610      	mov	r0, r2
    2e32:	9901      	ldr	r1, [sp, #4]
    2e34:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2e36:	f7fd fd23 	bl	880 <_dbg_check_leave_isr>
    2e3a:	f7ff fa01 	bl	2240 <_port_irq_epilogue>
}
    2e3e:	b003      	add	sp, #12
    2e40:	f85d fb04 	ldr.w	pc, [sp], #4
    2e44:	40026400 	.word	0x40026400
    2e48:	20000e04 	.word	0x20000e04
    2e4c:	f3af 8000 	nop.w

00002e50 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
    2e50:	b500      	push	{lr}
    2e52:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2e54:	f7fe fd0c 	bl	1870 <_stats_increase_irq>
    2e58:	f7fd fcf2 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
    2e5c:	4b0d      	ldr	r3, [pc, #52]	; (2e94 <Vector154+0x44>)
    2e5e:	685b      	ldr	r3, [r3, #4]
    2e60:	0c1b      	lsrs	r3, r3, #16
    2e62:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2e66:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
    2e68:	4b0a      	ldr	r3, [pc, #40]	; (2e94 <Vector154+0x44>)
    2e6a:	9a01      	ldr	r2, [sp, #4]
    2e6c:	0412      	lsls	r2, r2, #16
    2e6e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[14].dma_func)
    2e70:	4b09      	ldr	r3, [pc, #36]	; (2e98 <Vector154+0x48>)
    2e72:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    2e74:	2b00      	cmp	r3, #0
    2e76:	d006      	beq.n	2e86 <Vector154+0x36>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
    2e78:	4b07      	ldr	r3, [pc, #28]	; (2e98 <Vector154+0x48>)
    2e7a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    2e7c:	4a06      	ldr	r2, [pc, #24]	; (2e98 <Vector154+0x48>)
    2e7e:	6f52      	ldr	r2, [r2, #116]	; 0x74
    2e80:	4610      	mov	r0, r2
    2e82:	9901      	ldr	r1, [sp, #4]
    2e84:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2e86:	f7fd fcfb 	bl	880 <_dbg_check_leave_isr>
    2e8a:	f7ff f9d9 	bl	2240 <_port_irq_epilogue>
}
    2e8e:	b003      	add	sp, #12
    2e90:	f85d fb04 	ldr.w	pc, [sp], #4
    2e94:	40026400 	.word	0x40026400
    2e98:	20000e04 	.word	0x20000e04
    2e9c:	f3af 8000 	nop.w

00002ea0 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
    2ea0:	b500      	push	{lr}
    2ea2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2ea4:	f7fe fce4 	bl	1870 <_stats_increase_irq>
    2ea8:	f7fd fcca 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
    2eac:	4b0d      	ldr	r3, [pc, #52]	; (2ee4 <Vector158+0x44>)
    2eae:	685b      	ldr	r3, [r3, #4]
    2eb0:	0d9b      	lsrs	r3, r3, #22
    2eb2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2eb6:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
    2eb8:	4b0a      	ldr	r3, [pc, #40]	; (2ee4 <Vector158+0x44>)
    2eba:	9a01      	ldr	r2, [sp, #4]
    2ebc:	0592      	lsls	r2, r2, #22
    2ebe:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[15].dma_func)
    2ec0:	4b09      	ldr	r3, [pc, #36]	; (2ee8 <Vector158+0x48>)
    2ec2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    2ec4:	2b00      	cmp	r3, #0
    2ec6:	d006      	beq.n	2ed6 <Vector158+0x36>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
    2ec8:	4b07      	ldr	r3, [pc, #28]	; (2ee8 <Vector158+0x48>)
    2eca:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    2ecc:	4a06      	ldr	r2, [pc, #24]	; (2ee8 <Vector158+0x48>)
    2ece:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
    2ed0:	4610      	mov	r0, r2
    2ed2:	9901      	ldr	r1, [sp, #4]
    2ed4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2ed6:	f7fd fcd3 	bl	880 <_dbg_check_leave_isr>
    2eda:	f7ff f9b1 	bl	2240 <_port_irq_epilogue>
}
    2ede:	b003      	add	sp, #12
    2ee0:	f85d fb04 	ldr.w	pc, [sp], #4
    2ee4:	40026400 	.word	0x40026400
    2ee8:	20000e04 	.word	0x20000e04
    2eec:	f3af 8000 	nop.w

00002ef0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
    2ef0:	b082      	sub	sp, #8
  unsigned i;

  dma_streams_mask = 0U;
    2ef2:	4b16      	ldr	r3, [pc, #88]	; (2f4c <dmaInit+0x5c>)
    2ef4:	2200      	movs	r2, #0
    2ef6:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    2ef8:	2300      	movs	r3, #0
    2efa:	9301      	str	r3, [sp, #4]
    2efc:	e011      	b.n	2f22 <dmaInit+0x32>
    _stm32_dma_streams[i].stream->CR = 0U;
    2efe:	4914      	ldr	r1, [pc, #80]	; (2f50 <dmaInit+0x60>)
    2f00:	9a01      	ldr	r2, [sp, #4]
    2f02:	4613      	mov	r3, r2
    2f04:	005b      	lsls	r3, r3, #1
    2f06:	4413      	add	r3, r2
    2f08:	009b      	lsls	r3, r3, #2
    2f0a:	440b      	add	r3, r1
    2f0c:	681b      	ldr	r3, [r3, #0]
    2f0e:	2200      	movs	r2, #0
    2f10:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
    2f12:	4b10      	ldr	r3, [pc, #64]	; (2f54 <dmaInit+0x64>)
    2f14:	9a01      	ldr	r2, [sp, #4]
    2f16:	2100      	movs	r1, #0
    2f18:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    2f1c:	9b01      	ldr	r3, [sp, #4]
    2f1e:	3301      	adds	r3, #1
    2f20:	9301      	str	r3, [sp, #4]
    2f22:	9b01      	ldr	r3, [sp, #4]
    2f24:	2b0f      	cmp	r3, #15
    2f26:	d9ea      	bls.n	2efe <dmaInit+0xe>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
    2f28:	4b0b      	ldr	r3, [pc, #44]	; (2f58 <dmaInit+0x68>)
    2f2a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2f2e:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
    2f30:	4b09      	ldr	r3, [pc, #36]	; (2f58 <dmaInit+0x68>)
    2f32:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2f36:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
    2f38:	4b08      	ldr	r3, [pc, #32]	; (2f5c <dmaInit+0x6c>)
    2f3a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2f3e:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
    2f40:	4b06      	ldr	r3, [pc, #24]	; (2f5c <dmaInit+0x6c>)
    2f42:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2f46:	60da      	str	r2, [r3, #12]
}
    2f48:	b002      	add	sp, #8
    2f4a:	4770      	bx	lr
    2f4c:	20000e00 	.word	0x20000e00
    2f50:	00003e30 	.word	0x00003e30
    2f54:	20000e04 	.word	0x20000e04
    2f58:	40026000 	.word	0x40026000
    2f5c:	40026400 	.word	0x40026400

00002f60 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2f60:	b082      	sub	sp, #8
    2f62:	2320      	movs	r3, #32
    2f64:	9301      	str	r3, [sp, #4]
    2f66:	9b01      	ldr	r3, [sp, #4]
    2f68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2f6c:	b002      	add	sp, #8
    2f6e:	4770      	bx	lr

00002f70 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2f70:	b082      	sub	sp, #8
    2f72:	2300      	movs	r3, #0
    2f74:	9301      	str	r3, [sp, #4]
    2f76:	9b01      	ldr	r3, [sp, #4]
    2f78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2f7c:	b002      	add	sp, #8
    2f7e:	4770      	bx	lr

00002f80 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    2f80:	b508      	push	{r3, lr}

  port_lock();
    2f82:	f7ff ffed 	bl	2f60 <port_lock>
}
    2f86:	bd08      	pop	{r3, pc}
    2f88:	f3af 8000 	nop.w
    2f8c:	f3af 8000 	nop.w

00002f90 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    2f90:	b508      	push	{r3, lr}

  port_unlock();
    2f92:	f7ff ffed 	bl	2f70 <port_unlock>
}
    2f96:	bd08      	pop	{r3, pc}
    2f98:	f3af 8000 	nop.w
    2f9c:	f3af 8000 	nop.w

00002fa0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    2fa0:	b508      	push	{r3, lr}

  port_lock_from_isr();
    2fa2:	f7ff ffed 	bl	2f80 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    2fa6:	f7fe fca3 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    2faa:	f7fd fc19 	bl	7e0 <_dbg_check_lock_from_isr>
}
    2fae:	bd08      	pop	{r3, pc}

00002fb0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    2fb0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    2fb2:	f7fd fc2d 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    2fb6:	f7fe fca3 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    2fba:	f7ff ffe9 	bl	2f90 <port_unlock_from_isr>
}
    2fbe:	bd08      	pop	{r3, pc}

00002fc0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    2fc0:	b508      	push	{r3, lr}

  chSysLockFromISR();
    2fc2:	f7ff ffed 	bl	2fa0 <chSysLockFromISR>
}
    2fc6:	bd08      	pop	{r3, pc}
    2fc8:	f3af 8000 	nop.w
    2fcc:	f3af 8000 	nop.w

00002fd0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    2fd0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    2fd2:	f7ff ffed 	bl	2fb0 <chSysUnlockFromISR>
}
    2fd6:	bd08      	pop	{r3, pc}
    2fd8:	f3af 8000 	nop.w
    2fdc:	f3af 8000 	nop.w

00002fe0 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
    2fe0:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
    2fe2:	f7fd fb75 	bl	6d0 <chSysTimerHandlerI>
}
    2fe6:	bd08      	pop	{r3, pc}
    2fe8:	f3af 8000 	nop.w
    2fec:	f3af 8000 	nop.w

00002ff0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
    2ff0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    2ff2:	f7fe fc3d 	bl	1870 <_stats_increase_irq>
    2ff6:	f7fd fc23 	bl	840 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    2ffa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2ffe:	691b      	ldr	r3, [r3, #16]
    3000:	f003 0302 	and.w	r3, r3, #2
    3004:	2b00      	cmp	r3, #0
    3006:	d009      	beq.n	301c <VectorB0+0x2c>
    STM32_ST_TIM->SR = 0U;
    3008:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    300c:	2200      	movs	r2, #0
    300e:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
    3010:	f7ff ffd6 	bl	2fc0 <osalSysLockFromISR>
    osalOsTimerHandlerI();
    3014:	f7ff ffe4 	bl	2fe0 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
    3018:	f7ff ffda 	bl	2fd0 <osalSysUnlockFromISR>
  }

  OSAL_IRQ_EPILOGUE();
    301c:	f7fd fc30 	bl	880 <_dbg_check_leave_isr>
    3020:	f7ff f90e 	bl	2240 <_port_irq_epilogue>
}
    3024:	bd08      	pop	{r3, pc}
    3026:	bf00      	nop
    3028:	f3af 8000 	nop.w
    302c:	f3af 8000 	nop.w

00003030 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
    3030:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
    3032:	4b19      	ldr	r3, [pc, #100]	; (3098 <st_lld_init+0x68>)
    3034:	4a18      	ldr	r2, [pc, #96]	; (3098 <st_lld_init+0x68>)
    3036:	6c12      	ldr	r2, [r2, #64]	; 0x40
    3038:	f042 0201 	orr.w	r2, r2, #1
    303c:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
    303e:	4b17      	ldr	r3, [pc, #92]	; (309c <st_lld_init+0x6c>)
    3040:	4a16      	ldr	r2, [pc, #88]	; (309c <st_lld_init+0x6c>)
    3042:	6892      	ldr	r2, [r2, #8]
    3044:	f042 0201 	orr.w	r2, r2, #1
    3048:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
    304a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    304e:	f242 02cf 	movw	r2, #8399	; 0x20cf
    3052:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
    3054:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3058:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    305c:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
    305e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3062:	2200      	movs	r2, #0
    3064:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
    3066:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    306a:	2200      	movs	r2, #0
    306c:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
    306e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3072:	2200      	movs	r2, #0
    3074:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
    3076:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    307a:	2200      	movs	r2, #0
    307c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
    307e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3082:	2201      	movs	r2, #1
    3084:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
    3086:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    308a:	2201      	movs	r2, #1
    308c:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
    308e:	201c      	movs	r0, #28
    3090:	2108      	movs	r1, #8
    3092:	f7ff fb9d 	bl	27d0 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    3096:	bd08      	pop	{r3, pc}
    3098:	40023800 	.word	0x40023800
    309c:	e0042000 	.word	0xe0042000

000030a0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    30a0:	b082      	sub	sp, #8
    30a2:	2320      	movs	r3, #32
    30a4:	9301      	str	r3, [sp, #4]
    30a6:	9b01      	ldr	r3, [sp, #4]
    30a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    30ac:	b002      	add	sp, #8
    30ae:	4770      	bx	lr

000030b0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    30b0:	b082      	sub	sp, #8
    30b2:	2300      	movs	r3, #0
    30b4:	9301      	str	r3, [sp, #4]
    30b6:	9b01      	ldr	r3, [sp, #4]
    30b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    30bc:	b002      	add	sp, #8
    30be:	4770      	bx	lr

000030c0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    30c0:	b508      	push	{r3, lr}

  port_lock();
    30c2:	f7ff ffed 	bl	30a0 <port_lock>
}
    30c6:	bd08      	pop	{r3, pc}
    30c8:	f3af 8000 	nop.w
    30cc:	f3af 8000 	nop.w

000030d0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    30d0:	b508      	push	{r3, lr}

  port_unlock();
    30d2:	f7ff ffed 	bl	30b0 <port_unlock>
}
    30d6:	bd08      	pop	{r3, pc}
    30d8:	f3af 8000 	nop.w
    30dc:	f3af 8000 	nop.w

000030e0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    30e0:	b508      	push	{r3, lr}

  port_lock_from_isr();
    30e2:	f7ff ffed 	bl	30c0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    30e6:	f7fe fc03 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    30ea:	f7fd fb79 	bl	7e0 <_dbg_check_lock_from_isr>
}
    30ee:	bd08      	pop	{r3, pc}

000030f0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    30f0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    30f2:	f7fd fb8d 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    30f6:	f7fe fc03 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    30fa:	f7ff ffe9 	bl	30d0 <port_unlock_from_isr>
}
    30fe:	bd08      	pop	{r3, pc}

00003100 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    3100:	b508      	push	{r3, lr}

  chSysLockFromISR();
    3102:	f7ff ffed 	bl	30e0 <chSysLockFromISR>
}
    3106:	bd08      	pop	{r3, pc}
    3108:	f3af 8000 	nop.w
    310c:	f3af 8000 	nop.w

00003110 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    3110:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    3112:	f7ff ffed 	bl	30f0 <chSysUnlockFromISR>
}
    3116:	bd08      	pop	{r3, pc}
    3118:	f3af 8000 	nop.w
    311c:	f3af 8000 	nop.w

00003120 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    3120:	b500      	push	{lr}
    3122:	b083      	sub	sp, #12
    3124:	9001      	str	r0, [sp, #4]
    3126:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
    3128:	9801      	ldr	r0, [sp, #4]
    312a:	9900      	ldr	r1, [sp, #0]
    312c:	f7fe fa70 	bl	1610 <chThdResumeI>
}
    3130:	b003      	add	sp, #12
    3132:	f85d fb04 	ldr.w	pc, [sp], #4
    3136:	bf00      	nop
    3138:	f3af 8000 	nop.w
    313c:	f3af 8000 	nop.w

00003140 <Vector88>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
    3140:	b500      	push	{lr}
    3142:	b083      	sub	sp, #12
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();
    3144:	f7fe fb94 	bl	1870 <_stats_increase_irq>
    3148:	f7fd fb7a 	bl	840 <_dbg_check_enter_isr>

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
    314c:	4b58      	ldr	r3, [pc, #352]	; (32b0 <Vector88+0x170>)
    314e:	681b      	ldr	r3, [r3, #0]
    3150:	9301      	str	r3, [sp, #4]
  ADC1->SR = 0;
    3152:	4b57      	ldr	r3, [pc, #348]	; (32b0 <Vector88+0x170>)
    3154:	2200      	movs	r2, #0
    3156:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    3158:	9b01      	ldr	r3, [sp, #4]
    315a:	f003 0320 	and.w	r3, r3, #32
    315e:	2b00      	cmp	r3, #0
    3160:	d02d      	beq.n	31be <Vector88+0x7e>
    3162:	4b54      	ldr	r3, [pc, #336]	; (32b4 <Vector88+0x174>)
    3164:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3166:	681b      	ldr	r3, [r3, #0]
    3168:	685b      	ldr	r3, [r3, #4]
    316a:	2b00      	cmp	r3, #0
    316c:	d027      	beq.n	31be <Vector88+0x7e>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
    316e:	4b51      	ldr	r3, [pc, #324]	; (32b4 <Vector88+0x174>)
    3170:	691b      	ldr	r3, [r3, #16]
    3172:	2b00      	cmp	r3, #0
    3174:	d023      	beq.n	31be <Vector88+0x7e>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    3176:	484f      	ldr	r0, [pc, #316]	; (32b4 <Vector88+0x174>)
    3178:	f000 f8fa 	bl	3370 <adc_lld_stop_conversion>
    317c:	4b4d      	ldr	r3, [pc, #308]	; (32b4 <Vector88+0x174>)
    317e:	691b      	ldr	r3, [r3, #16]
    3180:	689b      	ldr	r3, [r3, #8]
    3182:	2b00      	cmp	r3, #0
    3184:	d00f      	beq.n	31a6 <Vector88+0x66>
    3186:	4b4b      	ldr	r3, [pc, #300]	; (32b4 <Vector88+0x174>)
    3188:	2205      	movs	r2, #5
    318a:	701a      	strb	r2, [r3, #0]
    318c:	4b49      	ldr	r3, [pc, #292]	; (32b4 <Vector88+0x174>)
    318e:	691b      	ldr	r3, [r3, #16]
    3190:	689b      	ldr	r3, [r3, #8]
    3192:	4848      	ldr	r0, [pc, #288]	; (32b4 <Vector88+0x174>)
    3194:	2101      	movs	r1, #1
    3196:	4798      	blx	r3
    3198:	4b46      	ldr	r3, [pc, #280]	; (32b4 <Vector88+0x174>)
    319a:	781b      	ldrb	r3, [r3, #0]
    319c:	2b05      	cmp	r3, #5
    319e:	d102      	bne.n	31a6 <Vector88+0x66>
    31a0:	4b44      	ldr	r3, [pc, #272]	; (32b4 <Vector88+0x174>)
    31a2:	2202      	movs	r2, #2
    31a4:	701a      	strb	r2, [r3, #0]
    31a6:	4b43      	ldr	r3, [pc, #268]	; (32b4 <Vector88+0x174>)
    31a8:	2200      	movs	r2, #0
    31aa:	611a      	str	r2, [r3, #16]
    31ac:	f7ff ffa8 	bl	3100 <osalSysLockFromISR>
    31b0:	4841      	ldr	r0, [pc, #260]	; (32b8 <Vector88+0x178>)
    31b2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    31b6:	f7ff ffb3 	bl	3120 <osalThreadResumeI>
    31ba:	f7ff ffa9 	bl	3110 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC1 */

#if STM32_ADC_USE_ADC2
  sr = ADC2->SR;
    31be:	4b3f      	ldr	r3, [pc, #252]	; (32bc <Vector88+0x17c>)
    31c0:	681b      	ldr	r3, [r3, #0]
    31c2:	9301      	str	r3, [sp, #4]
  ADC2->SR = 0;
    31c4:	4b3d      	ldr	r3, [pc, #244]	; (32bc <Vector88+0x17c>)
    31c6:	2200      	movs	r2, #0
    31c8:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD2.dmastp) > 0)) {
    31ca:	9b01      	ldr	r3, [sp, #4]
    31cc:	f003 0320 	and.w	r3, r3, #32
    31d0:	2b00      	cmp	r3, #0
    31d2:	d02d      	beq.n	3230 <Vector88+0xf0>
    31d4:	4b3a      	ldr	r3, [pc, #232]	; (32c0 <Vector88+0x180>)
    31d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    31d8:	681b      	ldr	r3, [r3, #0]
    31da:	685b      	ldr	r3, [r3, #4]
    31dc:	2b00      	cmp	r3, #0
    31de:	d027      	beq.n	3230 <Vector88+0xf0>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD2.grpp != NULL)
    31e0:	4b37      	ldr	r3, [pc, #220]	; (32c0 <Vector88+0x180>)
    31e2:	691b      	ldr	r3, [r3, #16]
    31e4:	2b00      	cmp	r3, #0
    31e6:	d023      	beq.n	3230 <Vector88+0xf0>
      _adc_isr_error_code(&ADCD2, ADC_ERR_OVERFLOW);
    31e8:	4835      	ldr	r0, [pc, #212]	; (32c0 <Vector88+0x180>)
    31ea:	f000 f8c1 	bl	3370 <adc_lld_stop_conversion>
    31ee:	4b34      	ldr	r3, [pc, #208]	; (32c0 <Vector88+0x180>)
    31f0:	691b      	ldr	r3, [r3, #16]
    31f2:	689b      	ldr	r3, [r3, #8]
    31f4:	2b00      	cmp	r3, #0
    31f6:	d00f      	beq.n	3218 <Vector88+0xd8>
    31f8:	4b31      	ldr	r3, [pc, #196]	; (32c0 <Vector88+0x180>)
    31fa:	2205      	movs	r2, #5
    31fc:	701a      	strb	r2, [r3, #0]
    31fe:	4b30      	ldr	r3, [pc, #192]	; (32c0 <Vector88+0x180>)
    3200:	691b      	ldr	r3, [r3, #16]
    3202:	689b      	ldr	r3, [r3, #8]
    3204:	482e      	ldr	r0, [pc, #184]	; (32c0 <Vector88+0x180>)
    3206:	2101      	movs	r1, #1
    3208:	4798      	blx	r3
    320a:	4b2d      	ldr	r3, [pc, #180]	; (32c0 <Vector88+0x180>)
    320c:	781b      	ldrb	r3, [r3, #0]
    320e:	2b05      	cmp	r3, #5
    3210:	d102      	bne.n	3218 <Vector88+0xd8>
    3212:	4b2b      	ldr	r3, [pc, #172]	; (32c0 <Vector88+0x180>)
    3214:	2202      	movs	r2, #2
    3216:	701a      	strb	r2, [r3, #0]
    3218:	4b29      	ldr	r3, [pc, #164]	; (32c0 <Vector88+0x180>)
    321a:	2200      	movs	r2, #0
    321c:	611a      	str	r2, [r3, #16]
    321e:	f7ff ff6f 	bl	3100 <osalSysLockFromISR>
    3222:	4828      	ldr	r0, [pc, #160]	; (32c4 <Vector88+0x184>)
    3224:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3228:	f7ff ff7a 	bl	3120 <osalThreadResumeI>
    322c:	f7ff ff70 	bl	3110 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC2 */

#if STM32_ADC_USE_ADC3
  sr = ADC3->SR;
    3230:	4b25      	ldr	r3, [pc, #148]	; (32c8 <Vector88+0x188>)
    3232:	681b      	ldr	r3, [r3, #0]
    3234:	9301      	str	r3, [sp, #4]
  ADC3->SR = 0;
    3236:	4b24      	ldr	r3, [pc, #144]	; (32c8 <Vector88+0x188>)
    3238:	2200      	movs	r2, #0
    323a:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD3.dmastp) > 0)) {
    323c:	9b01      	ldr	r3, [sp, #4]
    323e:	f003 0320 	and.w	r3, r3, #32
    3242:	2b00      	cmp	r3, #0
    3244:	d02d      	beq.n	32a2 <Vector88+0x162>
    3246:	4b21      	ldr	r3, [pc, #132]	; (32cc <Vector88+0x18c>)
    3248:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    324a:	681b      	ldr	r3, [r3, #0]
    324c:	685b      	ldr	r3, [r3, #4]
    324e:	2b00      	cmp	r3, #0
    3250:	d027      	beq.n	32a2 <Vector88+0x162>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD3.grpp != NULL)
    3252:	4b1e      	ldr	r3, [pc, #120]	; (32cc <Vector88+0x18c>)
    3254:	691b      	ldr	r3, [r3, #16]
    3256:	2b00      	cmp	r3, #0
    3258:	d023      	beq.n	32a2 <Vector88+0x162>
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
    325a:	481c      	ldr	r0, [pc, #112]	; (32cc <Vector88+0x18c>)
    325c:	f000 f888 	bl	3370 <adc_lld_stop_conversion>
    3260:	4b1a      	ldr	r3, [pc, #104]	; (32cc <Vector88+0x18c>)
    3262:	691b      	ldr	r3, [r3, #16]
    3264:	689b      	ldr	r3, [r3, #8]
    3266:	2b00      	cmp	r3, #0
    3268:	d00f      	beq.n	328a <Vector88+0x14a>
    326a:	4b18      	ldr	r3, [pc, #96]	; (32cc <Vector88+0x18c>)
    326c:	2205      	movs	r2, #5
    326e:	701a      	strb	r2, [r3, #0]
    3270:	4b16      	ldr	r3, [pc, #88]	; (32cc <Vector88+0x18c>)
    3272:	691b      	ldr	r3, [r3, #16]
    3274:	689b      	ldr	r3, [r3, #8]
    3276:	4815      	ldr	r0, [pc, #84]	; (32cc <Vector88+0x18c>)
    3278:	2101      	movs	r1, #1
    327a:	4798      	blx	r3
    327c:	4b13      	ldr	r3, [pc, #76]	; (32cc <Vector88+0x18c>)
    327e:	781b      	ldrb	r3, [r3, #0]
    3280:	2b05      	cmp	r3, #5
    3282:	d102      	bne.n	328a <Vector88+0x14a>
    3284:	4b11      	ldr	r3, [pc, #68]	; (32cc <Vector88+0x18c>)
    3286:	2202      	movs	r2, #2
    3288:	701a      	strb	r2, [r3, #0]
    328a:	4b10      	ldr	r3, [pc, #64]	; (32cc <Vector88+0x18c>)
    328c:	2200      	movs	r2, #0
    328e:	611a      	str	r2, [r3, #16]
    3290:	f7ff ff36 	bl	3100 <osalSysLockFromISR>
    3294:	480e      	ldr	r0, [pc, #56]	; (32d0 <Vector88+0x190>)
    3296:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    329a:	f7ff ff41 	bl	3120 <osalThreadResumeI>
    329e:	f7ff ff37 	bl	3110 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
    32a2:	f7fd faed 	bl	880 <_dbg_check_leave_isr>
    32a6:	f7fe ffcb 	bl	2240 <_port_irq_epilogue>
}
    32aa:	b003      	add	sp, #12
    32ac:	f85d fb04 	ldr.w	pc, [sp], #4
    32b0:	40012000 	.word	0x40012000
    32b4:	20000e84 	.word	0x20000e84
    32b8:	20000e98 	.word	0x20000e98
    32bc:	40012100 	.word	0x40012100
    32c0:	20000eb8 	.word	0x20000eb8
    32c4:	20000ecc 	.word	0x20000ecc
    32c8:	40012200 	.word	0x40012200
    32cc:	20000eec 	.word	0x20000eec
    32d0:	20000f00 	.word	0x20000f00
    32d4:	f3af 8000 	nop.w
    32d8:	f3af 8000 	nop.w
    32dc:	f3af 8000 	nop.w

000032e0 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
    32e0:	b508      	push	{r3, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
    32e2:	4814      	ldr	r0, [pc, #80]	; (3334 <adc_lld_init+0x54>)
    32e4:	f7ff f88c 	bl	2400 <adcObjectInit>
  ADCD1.adc = ADC1;
    32e8:	4b12      	ldr	r3, [pc, #72]	; (3334 <adc_lld_init+0x54>)
    32ea:	4a13      	ldr	r2, [pc, #76]	; (3338 <adc_lld_init+0x58>)
    32ec:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
    32ee:	4b11      	ldr	r3, [pc, #68]	; (3334 <adc_lld_init+0x54>)
    32f0:	4a12      	ldr	r2, [pc, #72]	; (333c <adc_lld_init+0x5c>)
    32f2:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
    32f4:	4b0f      	ldr	r3, [pc, #60]	; (3334 <adc_lld_init+0x54>)
    32f6:	4a12      	ldr	r2, [pc, #72]	; (3340 <adc_lld_init+0x60>)
    32f8:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

#if STM32_ADC_USE_ADC2
  /* Driver initialization.*/
  adcObjectInit(&ADCD2);
    32fa:	4812      	ldr	r0, [pc, #72]	; (3344 <adc_lld_init+0x64>)
    32fc:	f7ff f880 	bl	2400 <adcObjectInit>
  ADCD2.adc = ADC2;
    3300:	4b10      	ldr	r3, [pc, #64]	; (3344 <adc_lld_init+0x64>)
    3302:	4a11      	ldr	r2, [pc, #68]	; (3348 <adc_lld_init+0x68>)
    3304:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD2.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC2_DMA_STREAM);
    3306:	4b0f      	ldr	r3, [pc, #60]	; (3344 <adc_lld_init+0x64>)
    3308:	4a10      	ldr	r2, [pc, #64]	; (334c <adc_lld_init+0x6c>)
    330a:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD2.dmamode = STM32_DMA_CR_CHSEL(ADC2_DMA_CHANNEL) |
    330c:	4b0d      	ldr	r3, [pc, #52]	; (3344 <adc_lld_init+0x64>)
    330e:	4a10      	ldr	r2, [pc, #64]	; (3350 <adc_lld_init+0x70>)
    3310:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

#if STM32_ADC_USE_ADC3
  /* Driver initialization.*/
  adcObjectInit(&ADCD3);
    3312:	4810      	ldr	r0, [pc, #64]	; (3354 <adc_lld_init+0x74>)
    3314:	f7ff f874 	bl	2400 <adcObjectInit>
  ADCD3.adc = ADC3;
    3318:	4b0e      	ldr	r3, [pc, #56]	; (3354 <adc_lld_init+0x74>)
    331a:	4a0f      	ldr	r2, [pc, #60]	; (3358 <adc_lld_init+0x78>)
    331c:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD3.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC3_DMA_STREAM);
    331e:	4b0d      	ldr	r3, [pc, #52]	; (3354 <adc_lld_init+0x74>)
    3320:	4a0e      	ldr	r2, [pc, #56]	; (335c <adc_lld_init+0x7c>)
    3322:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD3.dmamode = STM32_DMA_CR_CHSEL(ADC3_DMA_CHANNEL) |
    3324:	4b0b      	ldr	r3, [pc, #44]	; (3354 <adc_lld_init+0x74>)
    3326:	4a0e      	ldr	r2, [pc, #56]	; (3360 <adc_lld_init+0x80>)
    3328:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled because sharing.*/
  nvicEnableVector(STM32_ADC_NUMBER, STM32_ADC_IRQ_PRIORITY);
    332a:	2012      	movs	r0, #18
    332c:	2106      	movs	r1, #6
    332e:	f7ff fa4f 	bl	27d0 <nvicEnableVector>
}
    3332:	bd08      	pop	{r3, pc}
    3334:	20000e84 	.word	0x20000e84
    3338:	40012000 	.word	0x40012000
    333c:	00003ec0 	.word	0x00003ec0
    3340:	00022c16 	.word	0x00022c16
    3344:	20000eb8 	.word	0x20000eb8
    3348:	40012100 	.word	0x40012100
    334c:	00003ea8 	.word	0x00003ea8
    3350:	02022c16 	.word	0x02022c16
    3354:	20000eec 	.word	0x20000eec
    3358:	40012200 	.word	0x40012200
    335c:	00003e9c 	.word	0x00003e9c
    3360:	04022c16 	.word	0x04022c16
    3364:	f3af 8000 	nop.w
    3368:	f3af 8000 	nop.w
    336c:	f3af 8000 	nop.w

00003370 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
    3370:	b082      	sub	sp, #8
    3372:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
    3374:	9b01      	ldr	r3, [sp, #4]
    3376:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3378:	681b      	ldr	r3, [r3, #0]
    337a:	9a01      	ldr	r2, [sp, #4]
    337c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    337e:	6812      	ldr	r2, [r2, #0]
    3380:	6812      	ldr	r2, [r2, #0]
    3382:	f022 021f 	bic.w	r2, r2, #31
    3386:	601a      	str	r2, [r3, #0]
    3388:	bf00      	nop
    338a:	9b01      	ldr	r3, [sp, #4]
    338c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    338e:	681b      	ldr	r3, [r3, #0]
    3390:	681b      	ldr	r3, [r3, #0]
    3392:	f003 0301 	and.w	r3, r3, #1
    3396:	2b00      	cmp	r3, #0
    3398:	d1f7      	bne.n	338a <adc_lld_stop_conversion+0x1a>
    339a:	9b01      	ldr	r3, [sp, #4]
    339c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    339e:	685b      	ldr	r3, [r3, #4]
    33a0:	9a01      	ldr	r2, [sp, #4]
    33a2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    33a4:	7a12      	ldrb	r2, [r2, #8]
    33a6:	213d      	movs	r1, #61	; 0x3d
    33a8:	fa01 f202 	lsl.w	r2, r1, r2
    33ac:	601a      	str	r2, [r3, #0]
  adcp->adc->CR1 = 0;
    33ae:	9b01      	ldr	r3, [sp, #4]
    33b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    33b2:	2200      	movs	r2, #0
    33b4:	605a      	str	r2, [r3, #4]
  adcp->adc->CR2 = 0;
    33b6:	9b01      	ldr	r3, [sp, #4]
    33b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    33ba:	2200      	movs	r2, #0
    33bc:	609a      	str	r2, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
    33be:	9b01      	ldr	r3, [sp, #4]
    33c0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    33c2:	2201      	movs	r2, #1
    33c4:	609a      	str	r2, [r3, #8]
}
    33c6:	b002      	add	sp, #8
    33c8:	4770      	bx	lr
    33ca:	bf00      	nop
    33cc:	f3af 8000 	nop.w

000033d0 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
    33d0:	b082      	sub	sp, #8
    33d2:	9001      	str	r0, [sp, #4]
    33d4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
    33d6:	9b00      	ldr	r3, [sp, #0]
    33d8:	685a      	ldr	r2, [r3, #4]
    33da:	9b01      	ldr	r3, [sp, #4]
    33dc:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
    33de:	9b00      	ldr	r3, [sp, #0]
    33e0:	689a      	ldr	r2, [r3, #8]
    33e2:	9b01      	ldr	r3, [sp, #4]
    33e4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
    33e6:	9b00      	ldr	r3, [sp, #0]
    33e8:	68da      	ldr	r2, [r3, #12]
    33ea:	9b01      	ldr	r3, [sp, #4]
    33ec:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
    33ee:	9b00      	ldr	r3, [sp, #0]
    33f0:	691a      	ldr	r2, [r3, #16]
    33f2:	9b01      	ldr	r3, [sp, #4]
    33f4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
    33f6:	9b00      	ldr	r3, [sp, #0]
    33f8:	695a      	ldr	r2, [r3, #20]
    33fa:	9b01      	ldr	r3, [sp, #4]
    33fc:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
    33fe:	9b00      	ldr	r3, [sp, #0]
    3400:	699a      	ldr	r2, [r3, #24]
    3402:	9b01      	ldr	r3, [sp, #4]
    3404:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
    3406:	9b00      	ldr	r3, [sp, #0]
    3408:	681a      	ldr	r2, [r3, #0]
    340a:	9b01      	ldr	r3, [sp, #4]
    340c:	601a      	str	r2, [r3, #0]
}
    340e:	b002      	add	sp, #8
    3410:	4770      	bx	lr
    3412:	bf00      	nop
    3414:	f3af 8000 	nop.w
    3418:	f3af 8000 	nop.w
    341c:	f3af 8000 	nop.w

00003420 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    3420:	b500      	push	{lr}
    3422:	b083      	sub	sp, #12
    3424:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
    3426:	4a24      	ldr	r2, [pc, #144]	; (34b8 <_pal_lld_init+0x98>)
    3428:	4b23      	ldr	r3, [pc, #140]	; (34b8 <_pal_lld_init+0x98>)
    342a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    342c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    3430:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    3434:	6313      	str	r3, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
    3436:	4a20      	ldr	r2, [pc, #128]	; (34b8 <_pal_lld_init+0x98>)
    3438:	4b1f      	ldr	r3, [pc, #124]	; (34b8 <_pal_lld_init+0x98>)
    343a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    343c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    3440:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    3444:	6513      	str	r3, [r2, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
    3446:	9b01      	ldr	r3, [sp, #4]
    3448:	481c      	ldr	r0, [pc, #112]	; (34bc <_pal_lld_init+0x9c>)
    344a:	4619      	mov	r1, r3
    344c:	f7ff ffc0 	bl	33d0 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
    3450:	9b01      	ldr	r3, [sp, #4]
    3452:	331c      	adds	r3, #28
    3454:	481a      	ldr	r0, [pc, #104]	; (34c0 <_pal_lld_init+0xa0>)
    3456:	4619      	mov	r1, r3
    3458:	f7ff ffba 	bl	33d0 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
    345c:	9b01      	ldr	r3, [sp, #4]
    345e:	3338      	adds	r3, #56	; 0x38
    3460:	4818      	ldr	r0, [pc, #96]	; (34c4 <_pal_lld_init+0xa4>)
    3462:	4619      	mov	r1, r3
    3464:	f7ff ffb4 	bl	33d0 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
    3468:	9b01      	ldr	r3, [sp, #4]
    346a:	3354      	adds	r3, #84	; 0x54
    346c:	4816      	ldr	r0, [pc, #88]	; (34c8 <_pal_lld_init+0xa8>)
    346e:	4619      	mov	r1, r3
    3470:	f7ff ffae 	bl	33d0 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
    3474:	9b01      	ldr	r3, [sp, #4]
    3476:	3370      	adds	r3, #112	; 0x70
    3478:	4814      	ldr	r0, [pc, #80]	; (34cc <_pal_lld_init+0xac>)
    347a:	4619      	mov	r1, r3
    347c:	f7ff ffa8 	bl	33d0 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
    3480:	9b01      	ldr	r3, [sp, #4]
    3482:	338c      	adds	r3, #140	; 0x8c
    3484:	4812      	ldr	r0, [pc, #72]	; (34d0 <_pal_lld_init+0xb0>)
    3486:	4619      	mov	r1, r3
    3488:	f7ff ffa2 	bl	33d0 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
    348c:	9b01      	ldr	r3, [sp, #4]
    348e:	33a8      	adds	r3, #168	; 0xa8
    3490:	4810      	ldr	r0, [pc, #64]	; (34d4 <_pal_lld_init+0xb4>)
    3492:	4619      	mov	r1, r3
    3494:	f7ff ff9c 	bl	33d0 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
    3498:	9b01      	ldr	r3, [sp, #4]
    349a:	33c4      	adds	r3, #196	; 0xc4
    349c:	480e      	ldr	r0, [pc, #56]	; (34d8 <_pal_lld_init+0xb8>)
    349e:	4619      	mov	r1, r3
    34a0:	f7ff ff96 	bl	33d0 <initgpio>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
    34a4:	9b01      	ldr	r3, [sp, #4]
    34a6:	33e0      	adds	r3, #224	; 0xe0
    34a8:	480c      	ldr	r0, [pc, #48]	; (34dc <_pal_lld_init+0xbc>)
    34aa:	4619      	mov	r1, r3
    34ac:	f7ff ff90 	bl	33d0 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
    34b0:	b003      	add	sp, #12
    34b2:	f85d fb04 	ldr.w	pc, [sp], #4
    34b6:	bf00      	nop
    34b8:	40023800 	.word	0x40023800
    34bc:	40020000 	.word	0x40020000
    34c0:	40020400 	.word	0x40020400
    34c4:	40020800 	.word	0x40020800
    34c8:	40020c00 	.word	0x40020c00
    34cc:	40021000 	.word	0x40021000
    34d0:	40021400 	.word	0x40021400
    34d4:	40021800 	.word	0x40021800
    34d8:	40021c00 	.word	0x40021c00
    34dc:	40022000 	.word	0x40022000

000034e0 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    34e0:	b08e      	sub	sp, #56	; 0x38
    34e2:	9003      	str	r0, [sp, #12]
    34e4:	9102      	str	r1, [sp, #8]
    34e6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
    34e8:	9b01      	ldr	r3, [sp, #4]
    34ea:	f003 0303 	and.w	r3, r3, #3
    34ee:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
    34f0:	9b01      	ldr	r3, [sp, #4]
    34f2:	f003 0304 	and.w	r3, r3, #4
    34f6:	089b      	lsrs	r3, r3, #2
    34f8:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
    34fa:	9b01      	ldr	r3, [sp, #4]
    34fc:	f003 0318 	and.w	r3, r3, #24
    3500:	08db      	lsrs	r3, r3, #3
    3502:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
    3504:	9b01      	ldr	r3, [sp, #4]
    3506:	f003 0360 	and.w	r3, r3, #96	; 0x60
    350a:	095b      	lsrs	r3, r3, #5
    350c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
    350e:	9b01      	ldr	r3, [sp, #4]
    3510:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
    3514:	09db      	lsrs	r3, r3, #7
    3516:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
    3518:	2300      	movs	r3, #0
    351a:	9309      	str	r3, [sp, #36]	; 0x24
  while (TRUE) {
    if ((mask & 1) != 0) {
    351c:	9b02      	ldr	r3, [sp, #8]
    351e:	f003 0301 	and.w	r3, r3, #1
    3522:	2b00      	cmp	r3, #0
    3524:	d054      	beq.n	35d0 <_pal_lld_setgroupmode+0xf0>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
    3526:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3528:	f003 0307 	and.w	r3, r3, #7
    352c:	009b      	lsls	r3, r3, #2
    352e:	9a08      	ldr	r2, [sp, #32]
    3530:	fa02 f303 	lsl.w	r3, r2, r3
    3534:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
    3536:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3538:	f003 0307 	and.w	r3, r3, #7
    353c:	009b      	lsls	r3, r3, #2
    353e:	220f      	movs	r2, #15
    3540:	fa02 f303 	lsl.w	r3, r2, r3
    3544:	9306      	str	r3, [sp, #24]
      if (bit < 8)
    3546:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3548:	2b07      	cmp	r3, #7
    354a:	d809      	bhi.n	3560 <_pal_lld_setgroupmode+0x80>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
    354c:	9b03      	ldr	r3, [sp, #12]
    354e:	6a1a      	ldr	r2, [r3, #32]
    3550:	9b06      	ldr	r3, [sp, #24]
    3552:	43db      	mvns	r3, r3
    3554:	401a      	ands	r2, r3
    3556:	9b07      	ldr	r3, [sp, #28]
    3558:	431a      	orrs	r2, r3
    355a:	9b03      	ldr	r3, [sp, #12]
    355c:	621a      	str	r2, [r3, #32]
    355e:	e008      	b.n	3572 <_pal_lld_setgroupmode+0x92>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
    3560:	9b03      	ldr	r3, [sp, #12]
    3562:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    3564:	9b06      	ldr	r3, [sp, #24]
    3566:	43db      	mvns	r3, r3
    3568:	401a      	ands	r2, r3
    356a:	9b07      	ldr	r3, [sp, #28]
    356c:	431a      	orrs	r2, r3
    356e:	9b03      	ldr	r3, [sp, #12]
    3570:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
    3572:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3574:	2201      	movs	r2, #1
    3576:	fa02 f303 	lsl.w	r3, r2, r3
    357a:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
    357c:	9b03      	ldr	r3, [sp, #12]
    357e:	685a      	ldr	r2, [r3, #4]
    3580:	9b05      	ldr	r3, [sp, #20]
    3582:	43db      	mvns	r3, r3
    3584:	401a      	ands	r2, r3
    3586:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    3588:	431a      	orrs	r2, r3
    358a:	9b03      	ldr	r3, [sp, #12]
    358c:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
    358e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3590:	005b      	lsls	r3, r3, #1
    3592:	2203      	movs	r2, #3
    3594:	fa02 f303 	lsl.w	r3, r2, r3
    3598:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
    359a:	9b03      	ldr	r3, [sp, #12]
    359c:	689a      	ldr	r2, [r3, #8]
    359e:	9b04      	ldr	r3, [sp, #16]
    35a0:	43db      	mvns	r3, r3
    35a2:	401a      	ands	r2, r3
    35a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    35a6:	431a      	orrs	r2, r3
    35a8:	9b03      	ldr	r3, [sp, #12]
    35aa:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
    35ac:	9b03      	ldr	r3, [sp, #12]
    35ae:	68da      	ldr	r2, [r3, #12]
    35b0:	9b04      	ldr	r3, [sp, #16]
    35b2:	43db      	mvns	r3, r3
    35b4:	401a      	ands	r2, r3
    35b6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    35b8:	431a      	orrs	r2, r3
    35ba:	9b03      	ldr	r3, [sp, #12]
    35bc:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
    35be:	9b03      	ldr	r3, [sp, #12]
    35c0:	681a      	ldr	r2, [r3, #0]
    35c2:	9b04      	ldr	r3, [sp, #16]
    35c4:	43db      	mvns	r3, r3
    35c6:	401a      	ands	r2, r3
    35c8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    35ca:	431a      	orrs	r2, r3
    35cc:	9b03      	ldr	r3, [sp, #12]
    35ce:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
    35d0:	9b02      	ldr	r3, [sp, #8]
    35d2:	085b      	lsrs	r3, r3, #1
    35d4:	9302      	str	r3, [sp, #8]
    if (!mask)
    35d6:	9b02      	ldr	r3, [sp, #8]
    35d8:	2b00      	cmp	r3, #0
    35da:	d100      	bne.n	35de <_pal_lld_setgroupmode+0xfe>
      return;
    35dc:	e00f      	b.n	35fe <_pal_lld_setgroupmode+0x11e>
    otyper <<= 1;
    35de:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    35e0:	005b      	lsls	r3, r3, #1
    35e2:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
    35e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    35e6:	009b      	lsls	r3, r3, #2
    35e8:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
    35ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    35ec:	009b      	lsls	r3, r3, #2
    35ee:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
    35f0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    35f2:	009b      	lsls	r3, r3, #2
    35f4:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
    35f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    35f8:	3301      	adds	r3, #1
    35fa:	9309      	str	r3, [sp, #36]	; 0x24
  }
    35fc:	e78e      	b.n	351c <_pal_lld_setgroupmode+0x3c>
}
    35fe:	b00e      	add	sp, #56	; 0x38
    3600:	4770      	bx	lr
    3602:	bf00      	nop
    3604:	f3af 8000 	nop.w
    3608:	f3af 8000 	nop.w
    360c:	f3af 8000 	nop.w

00003610 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    3610:	b082      	sub	sp, #8
    3612:	2320      	movs	r3, #32
    3614:	9301      	str	r3, [sp, #4]
    3616:	9b01      	ldr	r3, [sp, #4]
    3618:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    361c:	b002      	add	sp, #8
    361e:	4770      	bx	lr

00003620 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    3620:	b082      	sub	sp, #8
    3622:	2300      	movs	r3, #0
    3624:	9301      	str	r3, [sp, #4]
    3626:	9b01      	ldr	r3, [sp, #4]
    3628:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    362c:	b002      	add	sp, #8
    362e:	4770      	bx	lr

00003630 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    3630:	b508      	push	{r3, lr}

  port_lock();
    3632:	f7ff ffed 	bl	3610 <port_lock>
}
    3636:	bd08      	pop	{r3, pc}
    3638:	f3af 8000 	nop.w
    363c:	f3af 8000 	nop.w

00003640 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    3640:	b508      	push	{r3, lr}

  port_unlock();
    3642:	f7ff ffed 	bl	3620 <port_unlock>
}
    3646:	bd08      	pop	{r3, pc}
    3648:	f3af 8000 	nop.w
    364c:	f3af 8000 	nop.w

00003650 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    3650:	b508      	push	{r3, lr}

  port_lock_from_isr();
    3652:	f7ff ffed 	bl	3630 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    3656:	f7fe f94b 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    365a:	f7fd f8c1 	bl	7e0 <_dbg_check_lock_from_isr>
}
    365e:	bd08      	pop	{r3, pc}

00003660 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    3660:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    3662:	f7fd f8d5 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    3666:	f7fe f94b 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    366a:	f7ff ffe9 	bl	3640 <port_unlock_from_isr>
}
    366e:	bd08      	pop	{r3, pc}

00003670 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
    3670:	b500      	push	{lr}
    3672:	b083      	sub	sp, #12
    3674:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    3676:	f7fd f923 	bl	8c0 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    367a:	9b01      	ldr	r3, [sp, #4]
    367c:	695a      	ldr	r2, [r3, #20]
    367e:	9b01      	ldr	r3, [sp, #4]
    3680:	699b      	ldr	r3, [r3, #24]
    3682:	429a      	cmp	r2, r3
    3684:	d105      	bne.n	3692 <chOQIsEmptyI+0x22>
    3686:	9b01      	ldr	r3, [sp, #4]
    3688:	689b      	ldr	r3, [r3, #8]
    368a:	2b00      	cmp	r3, #0
    368c:	d001      	beq.n	3692 <chOQIsEmptyI+0x22>
    368e:	2301      	movs	r3, #1
    3690:	e000      	b.n	3694 <chOQIsEmptyI+0x24>
    3692:	2300      	movs	r3, #0
    3694:	f003 0301 	and.w	r3, r3, #1
    3698:	b2db      	uxtb	r3, r3
}
    369a:	4618      	mov	r0, r3
    369c:	b003      	add	sp, #12
    369e:	f85d fb04 	ldr.w	pc, [sp], #4
    36a2:	bf00      	nop
    36a4:	f3af 8000 	nop.w
    36a8:	f3af 8000 	nop.w
    36ac:	f3af 8000 	nop.w

000036b0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    36b0:	b508      	push	{r3, lr}

  chSysLockFromISR();
    36b2:	f7ff ffcd 	bl	3650 <chSysLockFromISR>
}
    36b6:	bd08      	pop	{r3, pc}
    36b8:	f3af 8000 	nop.w
    36bc:	f3af 8000 	nop.w

000036c0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    36c0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    36c2:	f7ff ffcd 	bl	3660 <chSysUnlockFromISR>
}
    36c6:	bd08      	pop	{r3, pc}
    36c8:	f3af 8000 	nop.w
    36cc:	f3af 8000 	nop.w

000036d0 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    36d0:	b500      	push	{lr}
    36d2:	b083      	sub	sp, #12
    36d4:	9001      	str	r0, [sp, #4]
    36d6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
    36d8:	9801      	ldr	r0, [sp, #4]
    36da:	9900      	ldr	r1, [sp, #0]
    36dc:	f7fe f970 	bl	19c0 <chEvtBroadcastFlagsI>
}
    36e0:	b003      	add	sp, #12
    36e2:	f85d fb04 	ldr.w	pc, [sp], #4
    36e6:	bf00      	nop
    36e8:	f3af 8000 	nop.w
    36ec:	f3af 8000 	nop.w

000036f0 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
    36f0:	b084      	sub	sp, #16
    36f2:	9001      	str	r0, [sp, #4]
    36f4:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
    36f6:	9b01      	ldr	r3, [sp, #4]
    36f8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    36fc:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
    36fe:	9b01      	ldr	r3, [sp, #4]
    3700:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    3704:	4b1d      	ldr	r3, [pc, #116]	; (377c <usart_init+0x8c>)
    3706:	429a      	cmp	r2, r3
    3708:	d005      	beq.n	3716 <usart_init+0x26>
    370a:	9b01      	ldr	r3, [sp, #4]
    370c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    3710:	4b1b      	ldr	r3, [pc, #108]	; (3780 <usart_init+0x90>)
    3712:	429a      	cmp	r2, r3
    3714:	d107      	bne.n	3726 <usart_init+0x36>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
    3716:	9b00      	ldr	r3, [sp, #0]
    3718:	681b      	ldr	r3, [r3, #0]
    371a:	4a1a      	ldr	r2, [pc, #104]	; (3784 <usart_init+0x94>)
    371c:	fbb2 f2f3 	udiv	r2, r2, r3
    3720:	9b03      	ldr	r3, [sp, #12]
    3722:	609a      	str	r2, [r3, #8]
    3724:	e006      	b.n	3734 <usart_init+0x44>
  else
    u->BRR = STM32_PCLK1 / config->speed;
    3726:	9b00      	ldr	r3, [sp, #0]
    3728:	681b      	ldr	r3, [r3, #0]
    372a:	4a17      	ldr	r2, [pc, #92]	; (3788 <usart_init+0x98>)
    372c:	fbb2 f2f3 	udiv	r2, r2, r3
    3730:	9b03      	ldr	r3, [sp, #12]
    3732:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
    3734:	9b00      	ldr	r3, [sp, #0]
    3736:	88db      	ldrh	r3, [r3, #6]
    3738:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    373c:	b29b      	uxth	r3, r3
    373e:	461a      	mov	r2, r3
    3740:	9b03      	ldr	r3, [sp, #12]
    3742:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
    3744:	9b00      	ldr	r3, [sp, #0]
    3746:	891b      	ldrh	r3, [r3, #8]
    3748:	f043 0301 	orr.w	r3, r3, #1
    374c:	b29b      	uxth	r3, r3
    374e:	461a      	mov	r2, r3
    3750:	9b03      	ldr	r3, [sp, #12]
    3752:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
    3754:	9b00      	ldr	r3, [sp, #0]
    3756:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
    3758:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
    375c:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
    3760:	b29b      	uxth	r3, r3
    3762:	461a      	mov	r2, r3
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
    3764:	9b03      	ldr	r3, [sp, #12]
    3766:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
    3768:	9b03      	ldr	r3, [sp, #12]
    376a:	2200      	movs	r2, #0
    376c:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
    376e:	9b03      	ldr	r3, [sp, #12]
    3770:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
    3772:	9b03      	ldr	r3, [sp, #12]
    3774:	685b      	ldr	r3, [r3, #4]
}
    3776:	b004      	add	sp, #16
    3778:	4770      	bx	lr
    377a:	bf00      	nop
    377c:	40011000 	.word	0x40011000
    3780:	40011400 	.word	0x40011400
    3784:	0501bd00 	.word	0x0501bd00
    3788:	0280de80 	.word	0x0280de80
    378c:	f3af 8000 	nop.w

00003790 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
    3790:	b500      	push	{lr}
    3792:	b085      	sub	sp, #20
    3794:	9001      	str	r0, [sp, #4]
    3796:	460b      	mov	r3, r1
    3798:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
    379c:	2300      	movs	r3, #0
    379e:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
    37a0:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    37a4:	f003 0308 	and.w	r3, r3, #8
    37a8:	2b00      	cmp	r3, #0
    37aa:	d003      	beq.n	37b4 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
    37ac:	9b03      	ldr	r3, [sp, #12]
    37ae:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    37b2:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
    37b4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    37b8:	f003 0301 	and.w	r3, r3, #1
    37bc:	2b00      	cmp	r3, #0
    37be:	d003      	beq.n	37c8 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
    37c0:	9b03      	ldr	r3, [sp, #12]
    37c2:	f043 0320 	orr.w	r3, r3, #32
    37c6:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
    37c8:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    37cc:	f003 0302 	and.w	r3, r3, #2
    37d0:	2b00      	cmp	r3, #0
    37d2:	d003      	beq.n	37dc <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
    37d4:	9b03      	ldr	r3, [sp, #12]
    37d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    37da:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
    37dc:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    37e0:	f003 0304 	and.w	r3, r3, #4
    37e4:	2b00      	cmp	r3, #0
    37e6:	d003      	beq.n	37f0 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
    37e8:	9b03      	ldr	r3, [sp, #12]
    37ea:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    37ee:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
    37f0:	9b01      	ldr	r3, [sp, #4]
    37f2:	3304      	adds	r3, #4
    37f4:	4618      	mov	r0, r3
    37f6:	9903      	ldr	r1, [sp, #12]
    37f8:	f7ff ff6a 	bl	36d0 <osalEventBroadcastFlagsI>
}
    37fc:	b005      	add	sp, #20
    37fe:	f85d fb04 	ldr.w	pc, [sp], #4
    3802:	bf00      	nop
    3804:	f3af 8000 	nop.w
    3808:	f3af 8000 	nop.w
    380c:	f3af 8000 	nop.w

00003810 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
    3810:	b500      	push	{lr}
    3812:	b087      	sub	sp, #28
    3814:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
    3816:	9b01      	ldr	r3, [sp, #4]
    3818:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    381c:	9304      	str	r3, [sp, #16]
  uint16_t cr1 = u->CR1;
    381e:	9b04      	ldr	r3, [sp, #16]
    3820:	68db      	ldr	r3, [r3, #12]
    3822:	f8ad 300e 	strh.w	r3, [sp, #14]
  uint16_t sr = u->SR;
    3826:	9b04      	ldr	r3, [sp, #16]
    3828:	681b      	ldr	r3, [r3, #0]
    382a:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    382e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3832:	f403 7380 	and.w	r3, r3, #256	; 0x100
    3836:	2b00      	cmp	r3, #0
    3838:	d00e      	beq.n	3858 <serve_interrupt+0x48>
    osalSysLockFromISR();
    383a:	f7ff ff39 	bl	36b0 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    383e:	9b01      	ldr	r3, [sp, #4]
    3840:	3304      	adds	r3, #4
    3842:	4618      	mov	r0, r3
    3844:	f44f 7100 	mov.w	r1, #512	; 0x200
    3848:	f7ff ff42 	bl	36d0 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
    384c:	9b04      	ldr	r3, [sp, #16]
    384e:	f46f 7280 	mvn.w	r2, #256	; 0x100
    3852:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
    3854:	f7ff ff34 	bl	36c0 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  osalSysLockFromISR();
    3858:	f7ff ff2a 	bl	36b0 <osalSysLockFromISR>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
    385c:	e01f      	b.n	389e <serve_interrupt+0x8e>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
    385e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3862:	f003 030f 	and.w	r3, r3, #15
    3866:	2b00      	cmp	r3, #0
    3868:	d005      	beq.n	3876 <serve_interrupt+0x66>
      set_error(sdp, sr);
    386a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    386e:	9801      	ldr	r0, [sp, #4]
    3870:	4619      	mov	r1, r3
    3872:	f7ff ff8d 	bl	3790 <set_error>
    b = u->DR;
    3876:	9b04      	ldr	r3, [sp, #16]
    3878:	685b      	ldr	r3, [r3, #4]
    387a:	f88d 300d 	strb.w	r3, [sp, #13]
    if (sr & USART_SR_RXNE)
    387e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3882:	f003 0320 	and.w	r3, r3, #32
    3886:	2b00      	cmp	r3, #0
    3888:	d005      	beq.n	3896 <serve_interrupt+0x86>
      sdIncomingDataI(sdp, b);
    388a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    388e:	9801      	ldr	r0, [sp, #4]
    3890:	4619      	mov	r1, r3
    3892:	f7fe ff65 	bl	2760 <sdIncomingDataI>
    sr = u->SR;
    3896:	9b04      	ldr	r3, [sp, #16]
    3898:	681b      	ldr	r3, [r3, #0]
    389a:	f8ad 3016 	strh.w	r3, [sp, #22]
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
    389e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    38a2:	f003 032f 	and.w	r3, r3, #47	; 0x2f
    38a6:	2b00      	cmp	r3, #0
    38a8:	d1d9      	bne.n	385e <serve_interrupt+0x4e>
    b = u->DR;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
  }
  osalSysUnlockFromISR();
    38aa:	f7ff ff09 	bl	36c0 <osalSysUnlockFromISR>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    38ae:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    38b2:	f003 0380 	and.w	r3, r3, #128	; 0x80
    38b6:	2b00      	cmp	r3, #0
    38b8:	d024      	beq.n	3904 <serve_interrupt+0xf4>
    38ba:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    38be:	f003 0380 	and.w	r3, r3, #128	; 0x80
    38c2:	2b00      	cmp	r3, #0
    38c4:	d01e      	beq.n	3904 <serve_interrupt+0xf4>
    msg_t b;
    osalSysLockFromISR();
    38c6:	f7ff fef3 	bl	36b0 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
    38ca:	9b01      	ldr	r3, [sp, #4]
    38cc:	3330      	adds	r3, #48	; 0x30
    38ce:	4618      	mov	r0, r3
    38d0:	f7fe fb4e 	bl	1f70 <chOQGetI>
    38d4:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
    38d6:	9b02      	ldr	r3, [sp, #8]
    38d8:	2b00      	cmp	r3, #0
    38da:	da0e      	bge.n	38fa <serve_interrupt+0xea>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    38dc:	9b01      	ldr	r3, [sp, #4]
    38de:	3304      	adds	r3, #4
    38e0:	4618      	mov	r0, r3
    38e2:	2108      	movs	r1, #8
    38e4:	f7ff fef4 	bl	36d0 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    38e8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    38ec:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    38f0:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    38f4:	9b04      	ldr	r3, [sp, #16]
    38f6:	60da      	str	r2, [r3, #12]
    38f8:	e002      	b.n	3900 <serve_interrupt+0xf0>
    }
    else
      u->DR = b;
    38fa:	9a02      	ldr	r2, [sp, #8]
    38fc:	9b04      	ldr	r3, [sp, #16]
    38fe:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
    3900:	f7ff fede 	bl	36c0 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    3904:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3908:	f003 0340 	and.w	r3, r3, #64	; 0x40
    390c:	2b00      	cmp	r3, #0
    390e:	d01b      	beq.n	3948 <serve_interrupt+0x138>
    osalSysLockFromISR();
    3910:	f7ff fece 	bl	36b0 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
    3914:	9b01      	ldr	r3, [sp, #4]
    3916:	3330      	adds	r3, #48	; 0x30
    3918:	4618      	mov	r0, r3
    391a:	f7ff fea9 	bl	3670 <chOQIsEmptyI>
    391e:	4603      	mov	r3, r0
    3920:	2b00      	cmp	r3, #0
    3922:	d005      	beq.n	3930 <serve_interrupt+0x120>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    3924:	9b01      	ldr	r3, [sp, #4]
    3926:	3304      	adds	r3, #4
    3928:	4618      	mov	r0, r3
    392a:	2110      	movs	r1, #16
    392c:	f7ff fed0 	bl	36d0 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
    3930:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    3934:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    3938:	9b04      	ldr	r3, [sp, #16]
    393a:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
    393c:	9b04      	ldr	r3, [sp, #16]
    393e:	f06f 0240 	mvn.w	r2, #64	; 0x40
    3942:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
    3944:	f7ff febc 	bl	36c0 <osalSysUnlockFromISR>
  }
}
    3948:	b007      	add	sp, #28
    394a:	f85d fb04 	ldr.w	pc, [sp], #4
    394e:	bf00      	nop

00003950 <notify3>:
  USART2->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {
    3950:	b082      	sub	sp, #8
    3952:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE;
    3954:	4b03      	ldr	r3, [pc, #12]	; (3964 <notify3+0x14>)
    3956:	4a03      	ldr	r2, [pc, #12]	; (3964 <notify3+0x14>)
    3958:	68d2      	ldr	r2, [r2, #12]
    395a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    395e:	60da      	str	r2, [r3, #12]
}
    3960:	b002      	add	sp, #8
    3962:	4770      	bx	lr
    3964:	40004800 	.word	0x40004800
    3968:	f3af 8000 	nop.w
    396c:	f3af 8000 	nop.w

00003970 <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
    3970:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    3972:	f7fd ff7d 	bl	1870 <_stats_increase_irq>
    3976:	f7fc ff63 	bl	840 <_dbg_check_enter_isr>

  serve_interrupt(&SD3);
    397a:	4804      	ldr	r0, [pc, #16]	; (398c <VectorDC+0x1c>)
    397c:	f7ff ff48 	bl	3810 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
    3980:	f7fc ff7e 	bl	880 <_dbg_check_leave_isr>
    3984:	f7fe fc5c 	bl	2240 <_port_irq_epilogue>
}
    3988:	bd08      	pop	{r3, pc}
    398a:	bf00      	nop
    398c:	20000f20 	.word	0x20000f20

00003990 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
    3990:	b508      	push	{r3, lr}
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
    3992:	4805      	ldr	r0, [pc, #20]	; (39a8 <sd_lld_init+0x18>)
    3994:	2100      	movs	r1, #0
    3996:	4a05      	ldr	r2, [pc, #20]	; (39ac <sd_lld_init+0x1c>)
    3998:	f7fe fe8a 	bl	26b0 <sdObjectInit>
  SD3.usart = USART3;
    399c:	4b02      	ldr	r3, [pc, #8]	; (39a8 <sd_lld_init+0x18>)
    399e:	4a04      	ldr	r2, [pc, #16]	; (39b0 <sd_lld_init+0x20>)
    39a0:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
    39a4:	bd08      	pop	{r3, pc}
    39a6:	bf00      	nop
    39a8:	20000f20 	.word	0x20000f20
    39ac:	00003951 	.word	0x00003951
    39b0:	40004800 	.word	0x40004800
    39b4:	f3af 8000 	nop.w
    39b8:	f3af 8000 	nop.w
    39bc:	f3af 8000 	nop.w

000039c0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
    39c0:	b500      	push	{lr}
    39c2:	b083      	sub	sp, #12
    39c4:	9001      	str	r0, [sp, #4]
    39c6:	9100      	str	r1, [sp, #0]

  if (config == NULL)
    39c8:	9b00      	ldr	r3, [sp, #0]
    39ca:	2b00      	cmp	r3, #0
    39cc:	d101      	bne.n	39d2 <sd_lld_start+0x12>
    config = &default_config;
    39ce:	4b0d      	ldr	r3, [pc, #52]	; (3a04 <sd_lld_start+0x44>)
    39d0:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
    39d2:	9b01      	ldr	r3, [sp, #4]
    39d4:	7a1b      	ldrb	r3, [r3, #8]
    39d6:	2b01      	cmp	r3, #1
    39d8:	d10d      	bne.n	39f6 <sd_lld_start+0x36>
      rccEnableUSART2(FALSE);
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
    39da:	9a01      	ldr	r2, [sp, #4]
    39dc:	4b0a      	ldr	r3, [pc, #40]	; (3a08 <sd_lld_start+0x48>)
    39de:	429a      	cmp	r2, r3
    39e0:	d109      	bne.n	39f6 <sd_lld_start+0x36>
      rccEnableUSART3(FALSE);
    39e2:	4b0a      	ldr	r3, [pc, #40]	; (3a0c <sd_lld_start+0x4c>)
    39e4:	4a09      	ldr	r2, [pc, #36]	; (3a0c <sd_lld_start+0x4c>)
    39e6:	6c12      	ldr	r2, [r2, #64]	; 0x40
    39e8:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
    39ec:	641a      	str	r2, [r3, #64]	; 0x40
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
    39ee:	2027      	movs	r0, #39	; 0x27
    39f0:	210c      	movs	r1, #12
    39f2:	f7fe feed 	bl	27d0 <nvicEnableVector>
      rccEnableUART8(FALSE);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
    39f6:	9801      	ldr	r0, [sp, #4]
    39f8:	9900      	ldr	r1, [sp, #0]
    39fa:	f7ff fe79 	bl	36f0 <usart_init>
}
    39fe:	b003      	add	sp, #12
    3a00:	f85d fb04 	ldr.w	pc, [sp], #4
    3a04:	00003ef0 	.word	0x00003ef0
    3a08:	20000f20 	.word	0x20000f20
    3a0c:	40023800 	.word	0x40023800

00003a10 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
    3a10:	b508      	push	{r3, lr}

  stm32_clock_init();
    3a12:	f7fe ff5d 	bl	28d0 <stm32_clock_init>
}
    3a16:	bd08      	pop	{r3, pc}
    3a18:	f3af 8000 	nop.w
    3a1c:	f3af 8000 	nop.w

00003a20 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
    3a20:	4770      	bx	lr
    3a22:	bf00      	nop
    3a24:	f3af 8000 	nop.w
    3a28:	f3af 8000 	nop.w
    3a2c:	f3af 8000 	nop.w

00003a30 <main>:
#include "main.h"

uint8_t cca_exp_io_mode;


int main(void) {
    3a30:	b500      	push	{lr}
    3a32:	b085      	sub	sp, #20
	halInit();
    3a34:	f7fe fc44 	bl	22c0 <halInit>
	chSysInit();
    3a38:	f7fc fdf2 	bl	620 <chSysInit>
	thread_t *listener,*writer;
	
	
	palWriteGroup(GPIOD,0xFFFFU,0,0x0000U);//all ports low
    3a3c:	4b11      	ldr	r3, [pc, #68]	; (3a84 <main+0x54>)
    3a3e:	4a12      	ldr	r2, [pc, #72]	; (3a88 <main+0x58>)
    3a40:	619a      	str	r2, [r3, #24]
	chThdSetPriority(NORMALPRIO);
    3a42:	2040      	movs	r0, #64	; 0x40
    3a44:	f7fd fd4c 	bl	14e0 <chThdSetPriority>
	init_IO();
    3a48:	f000 f82a 	bl	3aa0 <init_IO>
	init_protocol();
    3a4c:	f000 f860 	bl	3b10 <init_protocol>
    listener = chThdCreateStatic(serialListen, sizeof(serialListen), LOWPRIO, rxListen, NULL);
    3a50:	2300      	movs	r3, #0
    3a52:	9300      	str	r3, [sp, #0]
    3a54:	480d      	ldr	r0, [pc, #52]	; (3a8c <main+0x5c>)
    3a56:	f44f 7194 	mov.w	r1, #296	; 0x128
    3a5a:	2202      	movs	r2, #2
    3a5c:	4b0c      	ldr	r3, [pc, #48]	; (3a90 <main+0x60>)
    3a5e:	f7fd fd0f 	bl	1480 <chThdCreateStatic>
    3a62:	9003      	str	r0, [sp, #12]
    //writer = chThdCreateStatic(serialTalk, sizeof(serialTalk), LOWPRIO, txWrite, NULL);
    
	while(!0)
	{
		palWriteGroup(GPIOD,0xFFFFU,0,0xFFFFU);//all ports high
    3a64:	4b07      	ldr	r3, [pc, #28]	; (3a84 <main+0x54>)
    3a66:	f64f 72ff 	movw	r2, #65535	; 0xffff
    3a6a:	619a      	str	r2, [r3, #24]
		chThdSleepMilliseconds(1000);
    3a6c:	f242 7010 	movw	r0, #10000	; 0x2710
    3a70:	f7fd fd6e 	bl	1550 <chThdSleep>
		palWriteGroup(GPIOD,0xFFFFU,0,0x0000U);
    3a74:	4b03      	ldr	r3, [pc, #12]	; (3a84 <main+0x54>)
    3a76:	4a04      	ldr	r2, [pc, #16]	; (3a88 <main+0x58>)
    3a78:	619a      	str	r2, [r3, #24]
		chThdSleepMilliseconds(1000);
    3a7a:	f242 7010 	movw	r0, #10000	; 0x2710
    3a7e:	f7fd fd67 	bl	1550 <chThdSleep>
	}
    3a82:	e7ef      	b.n	3a64 <main+0x34>
    3a84:	40020c00 	.word	0x40020c00
    3a88:	ffff0000 	.word	0xffff0000
    3a8c:	20000fb8 	.word	0x20000fb8
    3a90:	00003b61 	.word	0x00003b61
    3a94:	f3af 8000 	nop.w
    3a98:	f3af 8000 	nop.w
    3a9c:	f3af 8000 	nop.w

00003aa0 <init_IO>:
	return 0;/*never reach here*/
}


void init_IO(void)
{
    3aa0:	b508      	push	{r3, lr}
	//adc_configure();
	//btn b portlarn (16 tane) pull up input olarak a
	palSetGroupMode(GPIOB, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
    3aa2:	4814      	ldr	r0, [pc, #80]	; (3af4 <init_IO+0x54>)
    3aa4:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3aa8:	2220      	movs	r2, #32
    3aaa:	f7ff fd19 	bl	34e0 <_pal_lld_setgroupmode>
	
	//set_cca_exp_io_mode();
	
	if( cca_exp_io_mode == CCA_EXP_IO_MODE_OUTPUT)
    3aae:	4b12      	ldr	r3, [pc, #72]	; (3af8 <init_IO+0x58>)
    3ab0:	781b      	ldrb	r3, [r3, #0]
    3ab2:	2b00      	cmp	r3, #0
    3ab4:	d10c      	bne.n	3ad0 <init_IO+0x30>
	{
		palSetGroupMode(GPIOD, PAL_GROUP_MASK(16), 0, PAL_MODE_OUTPUT_PUSHPULL);
    3ab6:	4811      	ldr	r0, [pc, #68]	; (3afc <init_IO+0x5c>)
    3ab8:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3abc:	2201      	movs	r2, #1
    3abe:	f7ff fd0f 	bl	34e0 <_pal_lld_setgroupmode>
		palSetGroupMode(GPIOE, PAL_GROUP_MASK(16), 0, PAL_MODE_OUTPUT_PUSHPULL);
    3ac2:	480f      	ldr	r0, [pc, #60]	; (3b00 <init_IO+0x60>)
    3ac4:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3ac8:	2201      	movs	r2, #1
    3aca:	f7ff fd09 	bl	34e0 <_pal_lld_setgroupmode>
    3ace:	e00f      	b.n	3af0 <init_IO+0x50>
	}
	else if( cca_exp_io_mode == CCA_EXP_IO_MODE_INPUT)
    3ad0:	4b09      	ldr	r3, [pc, #36]	; (3af8 <init_IO+0x58>)
    3ad2:	781b      	ldrb	r3, [r3, #0]
    3ad4:	2b01      	cmp	r3, #1
    3ad6:	d10b      	bne.n	3af0 <init_IO+0x50>
	{
		palSetGroupMode(GPIOD, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
    3ad8:	4808      	ldr	r0, [pc, #32]	; (3afc <init_IO+0x5c>)
    3ada:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3ade:	2220      	movs	r2, #32
    3ae0:	f7ff fcfe 	bl	34e0 <_pal_lld_setgroupmode>
		palSetGroupMode(GPIOE, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
    3ae4:	4806      	ldr	r0, [pc, #24]	; (3b00 <init_IO+0x60>)
    3ae6:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3aea:	2220      	movs	r2, #32
    3aec:	f7ff fcf8 	bl	34e0 <_pal_lld_setgroupmode>
	}
	else
	{
		;// Never reach here
	}
	return;
    3af0:	bf00      	nop
}
    3af2:	bd08      	pop	{r3, pc}
    3af4:	40020400 	.word	0x40020400
    3af8:	200010e0 	.word	0x200010e0
    3afc:	40020c00 	.word	0x40020c00
    3b00:	40021000 	.word	0x40021000
    3b04:	f3af 8000 	nop.w
    3b08:	f3af 8000 	nop.w
    3b0c:	f3af 8000 	nop.w

00003b10 <init_protocol>:
/*MEMORYPOOL_DECL(mpool, 64, NULL);//say ka olmal belli deil
msg_t protocol_01_buffer[64];*/
uint8_t buffer[2];

void init_protocol(void)
{
    3b10:	b508      	push	{r3, lr}
	chMBObjectInit(&serialMbox, txMailboxArea, 16);
    3b12:	480c      	ldr	r0, [pc, #48]	; (3b44 <init_protocol+0x34>)
    3b14:	490c      	ldr	r1, [pc, #48]	; (3b48 <init_protocol+0x38>)
    3b16:	2210      	movs	r2, #16
    3b18:	f7fd ffc2 	bl	1aa0 <chMBObjectInit>
	//chPoolLoadArray(&mpool,protocol_01_buffer,64);
	/*palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(7));
	palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(7));
	sdStart(&SD1, NULL);*///sd1 onun bunun ocuu mu neden almyo insan delirtiyo ?
	palSetPadMode(GPIOB, 10, PAL_MODE_ALTERNATE(7)); // used function : USART3_TX
    3b1c:	480b      	ldr	r0, [pc, #44]	; (3b4c <init_protocol+0x3c>)
    3b1e:	f44f 6180 	mov.w	r1, #1024	; 0x400
    3b22:	f240 3282 	movw	r2, #898	; 0x382
    3b26:	f7ff fcdb 	bl	34e0 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOB, 11, PAL_MODE_ALTERNATE(7)); // used function : USART3_RX
    3b2a:	4808      	ldr	r0, [pc, #32]	; (3b4c <init_protocol+0x3c>)
    3b2c:	f44f 6100 	mov.w	r1, #2048	; 0x800
    3b30:	f240 3282 	movw	r2, #898	; 0x382
    3b34:	f7ff fcd4 	bl	34e0 <_pal_lld_setgroupmode>

	sdStart(&SD3, NULL);
    3b38:	4805      	ldr	r0, [pc, #20]	; (3b50 <init_protocol+0x40>)
    3b3a:	2100      	movs	r1, #0
    3b3c:	f7fe fde8 	bl	2710 <sdStart>
	return;
    3b40:	bf00      	nop
}
    3b42:	bd08      	pop	{r3, pc}
    3b44:	20001124 	.word	0x20001124
    3b48:	200010e4 	.word	0x200010e4
    3b4c:	40020400 	.word	0x40020400
    3b50:	20000f20 	.word	0x20000f20
    3b54:	f3af 8000 	nop.w
    3b58:	f3af 8000 	nop.w
    3b5c:	f3af 8000 	nop.w

00003b60 <rxListen>:

void *rxListen(void *arg)
{
    3b60:	b500      	push	{lr}
    3b62:	b083      	sub	sp, #12
    3b64:	9001      	str	r0, [sp, #4]
	//msg_t *buffer;
	while(!0)
	{
		//buffer = (msg_t *)chPoolAlloc(&mpool);
		sdRead(&SD3, buffer, 2);
    3b66:	480b      	ldr	r0, [pc, #44]	; (3b94 <rxListen+0x34>)
    3b68:	490b      	ldr	r1, [pc, #44]	; (3b98 <rxListen+0x38>)
    3b6a:	2202      	movs	r2, #2
    3b6c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3b70:	f7fe f92e 	bl	1dd0 <chIQReadTimeout>
		chThdSleepMilliseconds(100);
    3b74:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    3b78:	f7fd fcea 	bl	1550 <chThdSleep>
		sdWrite(&SD3, buffer,2);
    3b7c:	4807      	ldr	r0, [pc, #28]	; (3b9c <rxListen+0x3c>)
    3b7e:	4906      	ldr	r1, [pc, #24]	; (3b98 <rxListen+0x38>)
    3b80:	2202      	movs	r2, #2
    3b82:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3b86:	f7fe fa23 	bl	1fd0 <chOQWriteTimeout>
		chThdSleepMilliseconds(100);
    3b8a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    3b8e:	f7fd fcdf 	bl	1550 <chThdSleep>
		//chMBPost(&serialMbox, buffer, TIME_IMMEDIATE);
	}
    3b92:	e7e8      	b.n	3b66 <rxListen+0x6>
    3b94:	20000f2c 	.word	0x20000f2c
    3b98:	2000114c 	.word	0x2000114c
    3b9c:	20000f50 	.word	0x20000f50
    3ba0:	656c6469 	.word	0x656c6469
	...
    3bb0:	31235653 	.word	0x31235653
    3bb4:	00000000 	.word	0x00000000
    3bb8:	32235653 	.word	0x32235653
    3bbc:	00000000 	.word	0x00000000
    3bc0:	33235653 	.word	0x33235653
    3bc4:	00000000 	.word	0x00000000
    3bc8:	34235653 	.word	0x34235653
    3bcc:	00000000 	.word	0x00000000
    3bd0:	35235653 	.word	0x35235653
    3bd4:	00000000 	.word	0x00000000
    3bd8:	36235653 	.word	0x36235653
    3bdc:	00000000 	.word	0x00000000
    3be0:	37235653 	.word	0x37235653
    3be4:	00000000 	.word	0x00000000
    3be8:	38235653 	.word	0x38235653
    3bec:	00000000 	.word	0x00000000
    3bf0:	39235653 	.word	0x39235653
    3bf4:	00000000 	.word	0x00000000
    3bf8:	31235653 	.word	0x31235653
    3bfc:	00000030 	.word	0x00000030
    3c00:	31235653 	.word	0x31235653
    3c04:	00000031 	.word	0x00000031
	...
    3c10:	63617473 	.word	0x63617473
    3c14:	766f206b 	.word	0x766f206b
    3c18:	6c667265 	.word	0x6c667265
    3c1c:	0000776f 	.word	0x0000776f

00003c20 <__func__.6011>:
    3c20:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

00003c30 <__func__.6628>:
    3c30:	54566863 65536f44 00004974 00000000     chVTDoSetI......

00003c40 <__func__.6636>:
    3c40:	54566863 65526f44 49746573 00000000     chVTDoResetI....

00003c50 <__func__.6625>:
    3c50:	63536863 61655268 00497964 00000000     chSchReadyI.....

00003c60 <__func__.6637>:
    3c60:	68546863 65724364 49657461 00000000     chThdCreateI....

00003c70 <__func__.5925>:
    3c70:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00003c80 <__func__.6653>:
    3c80:	68546863 74655364 6f697250 79746972     chThdSetPriority
	...

00003ca0 <__func__.6096>:
    3ca0:	68546863 656c5364 00537065 00000000     chThdSleepS.....

00003cb0 <__func__.6681>:
    3cb0:	68546863 69784564 00005374 00000000     chThdExitS......

00003cc0 <__func__.6703>:
    3cc0:	68546863 73655264 49656d75 00000000     chThdResumeI....

00003cd0 <__func__.6108>:
    3cd0:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
    3ce0:	00497478 00000000 00000000 00000000     xtI.............

00003cf0 <ch_debug>:
    3cf0:	6e69616d 18021600 08600404 1814100c     main......`.....
    3d00:	2221201c 00000000 00000000 00000000     . !"............

00003d10 <__func__.6621>:
    3d10:	65536863 6a624f6d 49746365 0074696e     chSemObjectInit.

00003d20 <__func__.6620>:
    3d20:	744d6863 6a624f78 49746365 0074696e     chMtxObjectInit.

00003d30 <__func__.6645>:
    3d30:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
    3d40:	49736761 00000000 00000000 00000000     agsI............

00003d50 <__func__.6662>:
    3d50:	76456863 67695374 496c616e 00000000     chEvtSignalI....

00003d60 <__func__.6622>:
    3d60:	424d6863 656a624f 6e497463 00007469     chMBObjectInit..

00003d70 <__func__.5925>:
    3d70:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00003d80 <__func__.6648>:
    3d80:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.

00003d90 <__func__.6684>:
    3d90:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

00003db0 <__func__.5925>:
    3db0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00003dc0 <__func__.7143>:
    3dc0:	74537473 41747261 6d72616c 00000000     stStartAlarm....

00003dd0 <__func__.7150>:
    3dd0:	65537473 616c4174 00006d72 00000000     stSetAlarm......

00003de0 <vmt>:
    3de0:	00002541 00002571 000025a1 000025d1     A%..q%...%...%..
    3df0:	000025f1 00002621 00002641 00002671     .%..!&..A&..q&..

00003e00 <__func__.7188>:
    3e00:	74536473 00747261 00000000 00000000     sdStart.........

00003e10 <__func__.5925>:
    3e10:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00003e20 <__func__.7197>:
    3e20:	6e496473 696d6f63 6144676e 00496174     sdIncomingDataI.

00003e30 <_stm32_dma_streams>:
    3e30:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
    3e40:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
    3e50:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
    3e60:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
    3e70:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
    3e80:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
    3e90:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
    3ea0:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
    3eb0:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
    3ec0:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
    3ed0:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
    3ee0:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

00003ef0 <default_config>:
    3ef0:	00002580 40000000 00000000 00000000     .%.....@........

00003f00 <pal_default_config>:
    3f00:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
    3f10:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
    3f20:	00000240 ffffffff 55514515 0000ffff     @........EQU....
    3f30:	04000000 00000040 02208001 00000000     ....@..... .....
    3f40:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
    3f50:	00060600 55000100 00000000 ffffffff     .......U........
    3f60:	00555055 00000fff 00000000 00000000     UPU.............
    3f70:	00000040 00000000 ffffffff 00000000     @...............
    3f80:	0000ffff 00000000 00000000 00000000     ................
    3f90:	00000000 ffffffff 00000000 0000ffff     ................
	...
    3fb0:	ffffffff 00000000 0000ffff 00000000     ................
	...
    3fcc:	ffffffff 00000000 0000ffff 00000000     ................
	...
    3fe8:	ffffffff 00000000 0000ffff 00000000     ................
    3ff8:	00000000                                ....
