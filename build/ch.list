
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

000001c0 <Reset_Handler>:
     1c0:	b672      	cpsid	i
     1c2:	4821      	ldr	r0, [pc, #132]	; (248 <endfiniloop+0x4>)
     1c4:	f380 8809 	msr	PSP, r0
     1c8:	2002      	movs	r0, #2
     1ca:	f380 8814 	msr	CONTROL, r0
     1ce:	f3bf 8f6f 	isb	sy
     1d2:	f000 f875 	bl	2c0 <__core_init>
     1d6:	f003 fdf3 	bl	3dc0 <__early_init>
     1da:	481c      	ldr	r0, [pc, #112]	; (24c <endfiniloop+0x8>)
     1dc:	491c      	ldr	r1, [pc, #112]	; (250 <endfiniloop+0xc>)
     1de:	4a1d      	ldr	r2, [pc, #116]	; (254 <endfiniloop+0x10>)

000001e0 <msloop>:
     1e0:	4291      	cmp	r1, r2
     1e2:	bf3c      	itt	cc
     1e4:	f841 0b04 	strcc.w	r0, [r1], #4
     1e8:	e7fa      	bcc.n	1e0 <msloop>
     1ea:	491b      	ldr	r1, [pc, #108]	; (258 <endfiniloop+0x14>)
     1ec:	4a16      	ldr	r2, [pc, #88]	; (248 <endfiniloop+0x4>)

000001ee <psloop>:
     1ee:	4291      	cmp	r1, r2
     1f0:	bf3c      	itt	cc
     1f2:	f841 0b04 	strcc.w	r0, [r1], #4
     1f6:	e7fa      	bcc.n	1ee <psloop>
     1f8:	4918      	ldr	r1, [pc, #96]	; (25c <endfiniloop+0x18>)
     1fa:	4a19      	ldr	r2, [pc, #100]	; (260 <endfiniloop+0x1c>)
     1fc:	4b19      	ldr	r3, [pc, #100]	; (264 <endfiniloop+0x20>)

000001fe <dloop>:
     1fe:	429a      	cmp	r2, r3
     200:	bf3e      	ittt	cc
     202:	f851 0b04 	ldrcc.w	r0, [r1], #4
     206:	f842 0b04 	strcc.w	r0, [r2], #4
     20a:	e7f8      	bcc.n	1fe <dloop>
     20c:	2000      	movs	r0, #0
     20e:	4916      	ldr	r1, [pc, #88]	; (268 <endfiniloop+0x24>)
     210:	4a16      	ldr	r2, [pc, #88]	; (26c <endfiniloop+0x28>)

00000212 <bloop>:
     212:	4291      	cmp	r1, r2
     214:	bf3c      	itt	cc
     216:	f841 0b04 	strcc.w	r0, [r1], #4
     21a:	e7fa      	bcc.n	212 <bloop>
     21c:	f000 f858 	bl	2d0 <__late_init>
     220:	4c13      	ldr	r4, [pc, #76]	; (270 <endfiniloop+0x2c>)
     222:	4d14      	ldr	r5, [pc, #80]	; (274 <endfiniloop+0x30>)

00000224 <initloop>:
     224:	42ac      	cmp	r4, r5
     226:	da03      	bge.n	230 <endinitloop>
     228:	f854 1b04 	ldr.w	r1, [r4], #4
     22c:	4788      	blx	r1
     22e:	e7f9      	b.n	224 <initloop>

00000230 <endinitloop>:
     230:	f003 fdd6 	bl	3de0 <main>
     234:	4c10      	ldr	r4, [pc, #64]	; (278 <endfiniloop+0x34>)
     236:	4d11      	ldr	r5, [pc, #68]	; (27c <endfiniloop+0x38>)

00000238 <finiloop>:
     238:	42ac      	cmp	r4, r5
     23a:	da03      	bge.n	244 <endfiniloop>
     23c:	f854 1b04 	ldr.w	r1, [r4], #4
     240:	4788      	blx	r1
     242:	e7f9      	b.n	238 <finiloop>

00000244 <endfiniloop>:
     244:	f000 b84c 	b.w	2e0 <__default_exit>
     248:	20000800 	.word	0x20000800
     24c:	55555555 	.word	0x55555555
     250:	20000000 	.word	0x20000000
     254:	20000400 	.word	0x20000400
     258:	20000400 	.word	0x20000400
     25c:	00004460 	.word	0x00004460
     260:	20000800 	.word	0x20000800
     264:	20000800 	.word	0x20000800
     268:	20000800 	.word	0x20000800
     26c:	200012f4 	.word	0x200012f4
     270:	000001c0 	.word	0x000001c0
     274:	000001c0 	.word	0x000001c0
     278:	000001c0 	.word	0x000001c0
     27c:	000001c0 	.word	0x000001c0

00000280 <_port_switch>:
     280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     284:	f8c1 d00c 	str.w	sp, [r1, #12]
     288:	f8d0 d00c 	ldr.w	sp, [r0, #12]
     28c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00000290 <_port_thread_start>:
     290:	f000 fa8e 	bl	7b0 <_dbg_check_unlock>
     294:	f001 fb24 	bl	18e0 <_stats_stop_measure_crit_thd>
     298:	2300      	movs	r3, #0
     29a:	f383 8811 	msr	BASEPRI, r3
     29e:	4628      	mov	r0, r5
     2a0:	47a0      	blx	r4
     2a2:	2000      	movs	r0, #0
     2a4:	f001 f964 	bl	1570 <chThdExit>

000002a8 <_port_switch_from_isr>:
     2a8:	f001 fb12 	bl	18d0 <_stats_start_measure_crit_thd>
     2ac:	f000 fa68 	bl	780 <_dbg_check_lock>
     2b0:	f000 ff4e 	bl	1150 <chSchDoReschedule>
     2b4:	f000 fa7c 	bl	7b0 <_dbg_check_unlock>
     2b8:	f001 fb12 	bl	18e0 <_stats_stop_measure_crit_thd>

000002bc <_port_exit_from_isr>:
     2bc:	df00      	svc	0
     2be:	e7fe      	b.n	2be <_port_exit_from_isr+0x2>

000002c0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
     2c0:	4770      	bx	lr
     2c2:	bf00      	nop
     2c4:	f3af 8000 	nop.w
     2c8:	f3af 8000 	nop.w
     2cc:	f3af 8000 	nop.w

000002d0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
     2d0:	4770      	bx	lr
     2d2:	bf00      	nop
     2d4:	f3af 8000 	nop.w
     2d8:	f3af 8000 	nop.w
     2dc:	f3af 8000 	nop.w

000002e0 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
     2e0:	e7fe      	b.n	2e0 <__default_exit>
     2e2:	bf00      	nop
     2e4:	f3af 8000 	nop.w
     2e8:	f3af 8000 	nop.w
     2ec:	f3af 8000 	nop.w

000002f0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
     2f0:	e7fe      	b.n	2f0 <_unhandled_exception>
     2f2:	bf00      	nop
     2f4:	f3af 8000 	nop.w
     2f8:	f3af 8000 	nop.w
     2fc:	f3af 8000 	nop.w

00000300 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
     300:	b084      	sub	sp, #16
     302:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
     304:	9b01      	ldr	r3, [sp, #4]
     306:	f003 0307 	and.w	r3, r3, #7
     30a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
     30c:	4b0a      	ldr	r3, [pc, #40]	; (338 <NVIC_SetPriorityGrouping+0x38>)
     30e:	68db      	ldr	r3, [r3, #12]
     310:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
     312:	9a02      	ldr	r2, [sp, #8]
     314:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
     318:	4013      	ands	r3, r2
     31a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
     31c:	9b03      	ldr	r3, [sp, #12]
     31e:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
     320:	9b02      	ldr	r3, [sp, #8]
     322:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
     324:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
     328:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     32c:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
     32e:	4b02      	ldr	r3, [pc, #8]	; (338 <NVIC_SetPriorityGrouping+0x38>)
     330:	9a02      	ldr	r2, [sp, #8]
     332:	60da      	str	r2, [r3, #12]
}
     334:	b004      	add	sp, #16
     336:	4770      	bx	lr
     338:	e000ed00 	.word	0xe000ed00
     33c:	f3af 8000 	nop.w

00000340 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
     340:	b082      	sub	sp, #8
     342:	4603      	mov	r3, r0
     344:	9100      	str	r1, [sp, #0]
     346:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
     34a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
     34e:	2b00      	cmp	r3, #0
     350:	da0c      	bge.n	36c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     352:	490c      	ldr	r1, [pc, #48]	; (384 <NVIC_SetPriority+0x44>)
     354:	f89d 3007 	ldrb.w	r3, [sp, #7]
     358:	f003 030f 	and.w	r3, r3, #15
     35c:	3b04      	subs	r3, #4
     35e:	9a00      	ldr	r2, [sp, #0]
     360:	b2d2      	uxtb	r2, r2
     362:	0112      	lsls	r2, r2, #4
     364:	b2d2      	uxtb	r2, r2
     366:	440b      	add	r3, r1
     368:	761a      	strb	r2, [r3, #24]
     36a:	e009      	b.n	380 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     36c:	4906      	ldr	r1, [pc, #24]	; (388 <NVIC_SetPriority+0x48>)
     36e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
     372:	9a00      	ldr	r2, [sp, #0]
     374:	b2d2      	uxtb	r2, r2
     376:	0112      	lsls	r2, r2, #4
     378:	b2d2      	uxtb	r2, r2
     37a:	440b      	add	r3, r1
     37c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
     380:	b002      	add	sp, #8
     382:	4770      	bx	lr
     384:	e000ed00 	.word	0xe000ed00
     388:	e000e100 	.word	0xe000e100
     38c:	f3af 8000 	nop.w

00000390 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
     390:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
     392:	4b0e      	ldr	r3, [pc, #56]	; (3cc <port_init+0x3c>)
     394:	2200      	movs	r2, #0
     396:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
     398:	2003      	movs	r0, #3
     39a:	f7ff ffb1 	bl	300 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
     39e:	4b0c      	ldr	r3, [pc, #48]	; (3d0 <port_init+0x40>)
     3a0:	4a0b      	ldr	r2, [pc, #44]	; (3d0 <port_init+0x40>)
     3a2:	68d2      	ldr	r2, [r2, #12]
     3a4:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
     3a8:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
     3aa:	4b0a      	ldr	r3, [pc, #40]	; (3d4 <port_init+0x44>)
     3ac:	4a09      	ldr	r2, [pc, #36]	; (3d4 <port_init+0x44>)
     3ae:	6812      	ldr	r2, [r2, #0]
     3b0:	f042 0201 	orr.w	r2, r2, #1
     3b4:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
     3b6:	f06f 0004 	mvn.w	r0, #4
     3ba:	2101      	movs	r1, #1
     3bc:	f7ff ffc0 	bl	340 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
     3c0:	f06f 0001 	mvn.w	r0, #1
     3c4:	2102      	movs	r1, #2
     3c6:	f7ff ffbb 	bl	340 <NVIC_SetPriority>
}
     3ca:	bd08      	pop	{r3, pc}
     3cc:	e000ed00 	.word	0xe000ed00
     3d0:	e000edf0 	.word	0xe000edf0
     3d4:	e0001000 	.word	0xe0001000
     3d8:	f3af 8000 	nop.w
     3dc:	f3af 8000 	nop.w

000003e0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     3e0:	b082      	sub	sp, #8
     3e2:	2320      	movs	r3, #32
     3e4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     3e6:	9b01      	ldr	r3, [sp, #4]
     3e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     3ec:	b002      	add	sp, #8
     3ee:	4770      	bx	lr

000003f0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     3f0:	b082      	sub	sp, #8
     3f2:	2300      	movs	r3, #0
     3f4:	9301      	str	r3, [sp, #4]
     3f6:	9b01      	ldr	r3, [sp, #4]
     3f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     3fc:	b002      	add	sp, #8
     3fe:	4770      	bx	lr

00000400 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     400:	b508      	push	{r3, lr}

  port_lock();
     402:	f7ff ffed 	bl	3e0 <port_lock>
}
     406:	bd08      	pop	{r3, pc}
     408:	f3af 8000 	nop.w
     40c:	f3af 8000 	nop.w

00000410 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     410:	b508      	push	{r3, lr}

  port_unlock();
     412:	f7ff ffed 	bl	3f0 <port_unlock>
}
     416:	bd08      	pop	{r3, pc}
     418:	f3af 8000 	nop.w
     41c:	f3af 8000 	nop.w

00000420 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
     420:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
     422:	4770      	bx	lr
     424:	f3af 8000 	nop.w
     428:	f3af 8000 	nop.w
     42c:	f3af 8000 	nop.w

00000430 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
     430:	b082      	sub	sp, #8
     432:	2300      	movs	r3, #0
     434:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     436:	9b01      	ldr	r3, [sp, #4]
     438:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
     43c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
     43e:	b002      	add	sp, #8
     440:	4770      	bx	lr
     442:	bf00      	nop
     444:	f3af 8000 	nop.w
     448:	f3af 8000 	nop.w
     44c:	f3af 8000 	nop.w

00000450 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
     450:	4770      	bx	lr
     452:	bf00      	nop
     454:	f3af 8000 	nop.w
     458:	f3af 8000 	nop.w
     45c:	f3af 8000 	nop.w

00000460 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     460:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     464:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     466:	4618      	mov	r0, r3
     468:	4770      	bx	lr
     46a:	bf00      	nop
     46c:	f3af 8000 	nop.w

00000470 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
     470:	b508      	push	{r3, lr}

  stStopAlarm();
     472:	f002 f965 	bl	2740 <stStopAlarm>
}
     476:	bd08      	pop	{r3, pc}
     478:	f3af 8000 	nop.w
     47c:	f3af 8000 	nop.w

00000480 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
     480:	b500      	push	{lr}
     482:	b083      	sub	sp, #12
     484:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
     486:	9801      	ldr	r0, [sp, #4]
     488:	f002 f962 	bl	2750 <stSetAlarm>
}
     48c:	b003      	add	sp, #12
     48e:	f85d fb04 	ldr.w	pc, [sp], #4
     492:	bf00      	nop
     494:	f3af 8000 	nop.w
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w

000004a0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     4a0:	b508      	push	{r3, lr}

  return stGetCounter();
     4a2:	f7ff ffdd 	bl	460 <st_lld_get_counter>
     4a6:	4603      	mov	r3, r0
}
     4a8:	4618      	mov	r0, r3
     4aa:	bd08      	pop	{r3, pc}
     4ac:	f3af 8000 	nop.w

000004b0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
     4b0:	b508      	push	{r3, lr}

  _dbg_check_enable();
     4b2:	f000 f94d 	bl	750 <_dbg_check_enable>
  port_enable();
     4b6:	f7ff ffbb 	bl	430 <port_enable>
}
     4ba:	bd08      	pop	{r3, pc}
     4bc:	f3af 8000 	nop.w

000004c0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
     4c0:	b508      	push	{r3, lr}

  port_lock_from_isr();
     4c2:	f7ff ff9d 	bl	400 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
     4c6:	f001 fa13 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
     4ca:	f000 f989 	bl	7e0 <_dbg_check_lock_from_isr>
}
     4ce:	bd08      	pop	{r3, pc}

000004d0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
     4d0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
     4d2:	f000 f99d 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
     4d6:	f001 fa13 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
     4da:	f7ff ff99 	bl	410 <port_unlock_from_isr>
}
     4de:	bd08      	pop	{r3, pc}

000004e0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     4e0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     4e2:	f7ff ffdd 	bl	4a0 <port_timer_get_time>
     4e6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     4e8:	4618      	mov	r0, r3
     4ea:	bd08      	pop	{r3, pc}
     4ec:	f3af 8000 	nop.w

000004f0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
     4f0:	b500      	push	{lr}
     4f2:	b085      	sub	sp, #20

  chDbgCheckClassI();
     4f4:	f000 f9e4 	bl	8c0 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
     4f8:	4b33      	ldr	r3, [pc, #204]	; (5c8 <chVTDoTickI+0xd8>)
     4fa:	69db      	ldr	r3, [r3, #28]
     4fc:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
     4fe:	f7ff ffef 	bl	4e0 <chVTGetSystemTimeX>
     502:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
     504:	e02a      	b.n	55c <chVTDoTickI+0x6c>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
     506:	4b30      	ldr	r3, [pc, #192]	; (5c8 <chVTDoTickI+0xd8>)
     508:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     50a:	9b03      	ldr	r3, [sp, #12]
     50c:	689b      	ldr	r3, [r3, #8]
     50e:	441a      	add	r2, r3
     510:	4b2d      	ldr	r3, [pc, #180]	; (5c8 <chVTDoTickI+0xd8>)
     512:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     514:	9b03      	ldr	r3, [sp, #12]
     516:	681b      	ldr	r3, [r3, #0]
     518:	4a2c      	ldr	r2, [pc, #176]	; (5cc <chVTDoTickI+0xdc>)
     51a:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
     51c:	9b03      	ldr	r3, [sp, #12]
     51e:	681a      	ldr	r2, [r3, #0]
     520:	4b29      	ldr	r3, [pc, #164]	; (5c8 <chVTDoTickI+0xd8>)
     522:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
     524:	9b03      	ldr	r3, [sp, #12]
     526:	68db      	ldr	r3, [r3, #12]
     528:	9300      	str	r3, [sp, #0]
    vtp->vt_func = NULL;
     52a:	9b03      	ldr	r3, [sp, #12]
     52c:	2200      	movs	r2, #0
     52e:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
     530:	4b25      	ldr	r3, [pc, #148]	; (5c8 <chVTDoTickI+0xd8>)
     532:	69da      	ldr	r2, [r3, #28]
     534:	4b25      	ldr	r3, [pc, #148]	; (5cc <chVTDoTickI+0xdc>)
     536:	429a      	cmp	r2, r3
     538:	d101      	bne.n	53e <chVTDoTickI+0x4e>
      port_timer_stop_alarm();
     53a:	f7ff ff99 	bl	470 <port_timer_stop_alarm>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
     53e:	f7ff ffc7 	bl	4d0 <chSysUnlockFromISR>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
     542:	9b03      	ldr	r3, [sp, #12]
     544:	691a      	ldr	r2, [r3, #16]
     546:	9b00      	ldr	r3, [sp, #0]
     548:	4610      	mov	r0, r2
     54a:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
     54c:	f7ff ffb8 	bl	4c0 <chSysLockFromISR>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
     550:	4b1d      	ldr	r3, [pc, #116]	; (5c8 <chVTDoTickI+0xd8>)
     552:	69db      	ldr	r3, [r3, #28]
     554:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
     556:	f7ff ffc3 	bl	4e0 <chVTGetSystemTimeX>
     55a:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
     55c:	9b03      	ldr	r3, [sp, #12]
     55e:	689a      	ldr	r2, [r3, #8]
     560:	4b19      	ldr	r3, [pc, #100]	; (5c8 <chVTDoTickI+0xd8>)
     562:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     564:	9902      	ldr	r1, [sp, #8]
     566:	1acb      	subs	r3, r1, r3
     568:	429a      	cmp	r2, r3
     56a:	d9cc      	bls.n	506 <chVTDoTickI+0x16>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
     56c:	4b16      	ldr	r3, [pc, #88]	; (5c8 <chVTDoTickI+0xd8>)
     56e:	69da      	ldr	r2, [r3, #28]
     570:	4b16      	ldr	r3, [pc, #88]	; (5cc <chVTDoTickI+0xdc>)
     572:	429a      	cmp	r2, r3
     574:	d100      	bne.n	578 <chVTDoTickI+0x88>
    return;
     576:	e023      	b.n	5c0 <chVTDoTickI+0xd0>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
     578:	4b13      	ldr	r3, [pc, #76]	; (5c8 <chVTDoTickI+0xd8>)
     57a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     57c:	9b03      	ldr	r3, [sp, #12]
     57e:	689b      	ldr	r3, [r3, #8]
     580:	441a      	add	r2, r3
     582:	9b02      	ldr	r3, [sp, #8]
     584:	1ad3      	subs	r3, r2, r3
     586:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
     588:	9b01      	ldr	r3, [sp, #4]
     58a:	2b01      	cmp	r3, #1
     58c:	d801      	bhi.n	592 <chVTDoTickI+0xa2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
     58e:	2302      	movs	r3, #2
     590:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
     592:	9a02      	ldr	r2, [sp, #8]
     594:	9b01      	ldr	r3, [sp, #4]
     596:	4413      	add	r3, r2
     598:	4618      	mov	r0, r3
     59a:	f7ff ff71 	bl	480 <port_timer_set_alarm>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
     59e:	f7ff ff9f 	bl	4e0 <chVTGetSystemTimeX>
     5a2:	4602      	mov	r2, r0
     5a4:	4b08      	ldr	r3, [pc, #32]	; (5c8 <chVTDoTickI+0xd8>)
     5a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     5a8:	1ad2      	subs	r2, r2, r3
     5aa:	9902      	ldr	r1, [sp, #8]
     5ac:	9b01      	ldr	r3, [sp, #4]
     5ae:	4419      	add	r1, r3
     5b0:	4b05      	ldr	r3, [pc, #20]	; (5c8 <chVTDoTickI+0xd8>)
     5b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     5b4:	1acb      	subs	r3, r1, r3
     5b6:	429a      	cmp	r2, r3
     5b8:	d902      	bls.n	5c0 <chVTDoTickI+0xd0>
     5ba:	4805      	ldr	r0, [pc, #20]	; (5d0 <chVTDoTickI+0xe0>)
     5bc:	f000 f878 	bl	6b0 <chSysHalt>
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     5c0:	b005      	add	sp, #20
     5c2:	f85d fb04 	ldr.w	pc, [sp], #4
     5c6:	bf00      	nop
     5c8:	20000800 	.word	0x20000800
     5cc:	2000081c 	.word	0x2000081c
     5d0:	00004020 	.word	0x00004020
     5d4:	f3af 8000 	nop.w
     5d8:	f3af 8000 	nop.w
     5dc:	f3af 8000 	nop.w

000005e0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
     5e0:	b082      	sub	sp, #8
     5e2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
     5e4:	4b02      	ldr	r3, [pc, #8]	; (5f0 <chRegSetThreadName+0x10>)
     5e6:	699b      	ldr	r3, [r3, #24]
     5e8:	9a01      	ldr	r2, [sp, #4]
     5ea:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
     5ec:	b002      	add	sp, #8
     5ee:	4770      	bx	lr
     5f0:	20000800 	.word	0x20000800
     5f4:	f3af 8000 	nop.w
     5f8:	f3af 8000 	nop.w
     5fc:	f3af 8000 	nop.w

00000600 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
     600:	b082      	sub	sp, #8
     602:	9001      	str	r0, [sp, #4]
     604:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
     606:	9b01      	ldr	r3, [sp, #4]
     608:	9a00      	ldr	r2, [sp, #0]
     60a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
     60c:	b002      	add	sp, #8
     60e:	4770      	bx	lr

00000610 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
     610:	b500      	push	{lr}
     612:	b083      	sub	sp, #12
     614:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
     616:	f7ff ff1b 	bl	450 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
  }
     61a:	e7fc      	b.n	616 <_idle_thread+0x6>
     61c:	f3af 8000 	nop.w

00000620 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
     620:	b500      	push	{lr}
     622:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
     624:	f7ff feb4 	bl	390 <port_init>
  _scheduler_init();
     628:	f000 fbc2 	bl	db0 <_scheduler_init>
  _vt_init();
     62c:	f000 f9f8 	bl	a20 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
     630:	f001 f88e 	bl	1750 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
     634:	f001 ff3c 	bl	24b0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
     638:	f001 ff8a 	bl	2550 <_heap_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  _stats_init();
     63c:	f001 f900 	bl	1840 <_stats_init>
#endif
#if CH_DBG_ENABLE_TRACE == TRUE
  _dbg_trace_init();
     640:	f000 f96e 	bl	920 <_dbg_trace_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
     644:	4812      	ldr	r0, [pc, #72]	; (690 <chSysInit+0x70>)
     646:	2140      	movs	r1, #64	; 0x40
     648:	f000 fe7a 	bl	1340 <_thread_init>
     64c:	4602      	mov	r2, r0
     64e:	4b11      	ldr	r3, [pc, #68]	; (694 <chSysInit+0x74>)
     650:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
     652:	4b10      	ldr	r3, [pc, #64]	; (694 <chSysInit+0x74>)
     654:	699b      	ldr	r3, [r3, #24]
     656:	2201      	movs	r2, #1
     658:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
     65c:	4b0d      	ldr	r3, [pc, #52]	; (694 <chSysInit+0x74>)
     65e:	699b      	ldr	r3, [r3, #24]
     660:	4a0d      	ldr	r2, [pc, #52]	; (698 <chSysInit+0x78>)
     662:	61da      	str	r2, [r3, #28]
#endif
  chSysEnable();
     664:	f7ff ff24 	bl	4b0 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
     668:	480c      	ldr	r0, [pc, #48]	; (69c <chSysInit+0x7c>)
     66a:	f7ff ffb9 	bl	5e0 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
     66e:	2300      	movs	r3, #0
     670:	9300      	str	r3, [sp, #0]
     672:	480b      	ldr	r0, [pc, #44]	; (6a0 <chSysInit+0x80>)
     674:	21f8      	movs	r1, #248	; 0xf8
     676:	2201      	movs	r2, #1
     678:	4b0a      	ldr	r3, [pc, #40]	; (6a4 <chSysInit+0x84>)
     67a:	f000 ff01 	bl	1480 <chThdCreateStatic>
     67e:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
     680:	9803      	ldr	r0, [sp, #12]
     682:	4909      	ldr	r1, [pc, #36]	; (6a8 <chSysInit+0x88>)
     684:	f7ff ffbc 	bl	600 <chRegSetThreadNameX>
  }
#endif
}
     688:	b005      	add	sp, #20
     68a:	f85d fb04 	ldr.w	pc, [sp], #4
     68e:	bf00      	nop
     690:	20000c40 	.word	0x20000c40
     694:	20000800 	.word	0x20000800
     698:	20000400 	.word	0x20000400
     69c:	000040f0 	.word	0x000040f0
     6a0:	20000ce0 	.word	0x20000ce0
     6a4:	00000611 	.word	0x00000611
     6a8:	00003fa0 	.word	0x00003fa0
     6ac:	f3af 8000 	nop.w

000006b0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
     6b0:	b500      	push	{lr}
     6b2:	b083      	sub	sp, #12
     6b4:	9001      	str	r0, [sp, #4]

  port_disable();
     6b6:	f7ff feb3 	bl	420 <port_disable>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
     6ba:	4b02      	ldr	r3, [pc, #8]	; (6c4 <chSysHalt+0x14>)
     6bc:	9a01      	ldr	r2, [sp, #4]
     6be:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
     6c0:	e7fe      	b.n	6c0 <chSysHalt+0x10>
     6c2:	bf00      	nop
     6c4:	20000800 	.word	0x20000800
     6c8:	f3af 8000 	nop.w
     6cc:	f3af 8000 	nop.w

000006d0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     6d0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
     6d2:	f000 f8f5 	bl	8c0 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
     6d6:	f7ff ff0b 	bl	4f0 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
     6da:	bd08      	pop	{r3, pc}
     6dc:	f3af 8000 	nop.w

000006e0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     6e0:	b082      	sub	sp, #8
     6e2:	2320      	movs	r3, #32
     6e4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     6e6:	9b01      	ldr	r3, [sp, #4]
     6e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     6ec:	b002      	add	sp, #8
     6ee:	4770      	bx	lr

000006f0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     6f0:	b082      	sub	sp, #8
     6f2:	2300      	movs	r3, #0
     6f4:	9301      	str	r3, [sp, #4]
     6f6:	9b01      	ldr	r3, [sp, #4]
     6f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     6fc:	b002      	add	sp, #8
     6fe:	4770      	bx	lr

00000700 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     700:	b508      	push	{r3, lr}

  port_lock();
     702:	f7ff ffed 	bl	6e0 <port_lock>
}
     706:	bd08      	pop	{r3, pc}
     708:	f3af 8000 	nop.w
     70c:	f3af 8000 	nop.w

00000710 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     710:	b508      	push	{r3, lr}

  port_unlock();
     712:	f7ff ffed 	bl	6f0 <port_unlock>
}
     716:	bd08      	pop	{r3, pc}
     718:	f3af 8000 	nop.w
     71c:	f3af 8000 	nop.w

00000720 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     720:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     724:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     726:	4618      	mov	r0, r3
     728:	4770      	bx	lr
     72a:	bf00      	nop
     72c:	f3af 8000 	nop.w

00000730 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     730:	b508      	push	{r3, lr}

  return stGetCounter();
     732:	f7ff fff5 	bl	720 <st_lld_get_counter>
     736:	4603      	mov	r3, r0
}
     738:	4618      	mov	r0, r3
     73a:	bd08      	pop	{r3, pc}
     73c:	f3af 8000 	nop.w

00000740 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     740:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     742:	f7ff fff5 	bl	730 <port_timer_get_time>
     746:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     748:	4618      	mov	r0, r3
     74a:	bd08      	pop	{r3, pc}
     74c:	f3af 8000 	nop.w

00000750 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
     750:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     752:	4b06      	ldr	r3, [pc, #24]	; (76c <_dbg_check_enable+0x1c>)
     754:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     756:	2b00      	cmp	r3, #0
     758:	d103      	bne.n	762 <_dbg_check_enable+0x12>
     75a:	4b04      	ldr	r3, [pc, #16]	; (76c <_dbg_check_enable+0x1c>)
     75c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     75e:	2b00      	cmp	r3, #0
     760:	d002      	beq.n	768 <_dbg_check_enable+0x18>
    chSysHalt("SV#3");
     762:	4803      	ldr	r0, [pc, #12]	; (770 <_dbg_check_enable+0x20>)
     764:	f7ff ffa4 	bl	6b0 <chSysHalt>
  }
}
     768:	bd08      	pop	{r3, pc}
     76a:	bf00      	nop
     76c:	20000800 	.word	0x20000800
     770:	00003fc0 	.word	0x00003fc0
     774:	f3af 8000 	nop.w
     778:	f3af 8000 	nop.w
     77c:	f3af 8000 	nop.w

00000780 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
     780:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     782:	4b07      	ldr	r3, [pc, #28]	; (7a0 <_dbg_check_lock+0x20>)
     784:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     786:	2b00      	cmp	r3, #0
     788:	d103      	bne.n	792 <_dbg_check_lock+0x12>
     78a:	4b05      	ldr	r3, [pc, #20]	; (7a0 <_dbg_check_lock+0x20>)
     78c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     78e:	2b00      	cmp	r3, #0
     790:	d002      	beq.n	798 <_dbg_check_lock+0x18>
    chSysHalt("SV#4");
     792:	4804      	ldr	r0, [pc, #16]	; (7a4 <_dbg_check_lock+0x24>)
     794:	f7ff ff8c 	bl	6b0 <chSysHalt>
  }
  _dbg_enter_lock();
     798:	4b01      	ldr	r3, [pc, #4]	; (7a0 <_dbg_check_lock+0x20>)
     79a:	2201      	movs	r2, #1
     79c:	635a      	str	r2, [r3, #52]	; 0x34
}
     79e:	bd08      	pop	{r3, pc}
     7a0:	20000800 	.word	0x20000800
     7a4:	00003fc8 	.word	0x00003fc8
     7a8:	f3af 8000 	nop.w
     7ac:	f3af 8000 	nop.w

000007b0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
     7b0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     7b2:	4b07      	ldr	r3, [pc, #28]	; (7d0 <_dbg_check_unlock+0x20>)
     7b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     7b6:	2b00      	cmp	r3, #0
     7b8:	d103      	bne.n	7c2 <_dbg_check_unlock+0x12>
     7ba:	4b05      	ldr	r3, [pc, #20]	; (7d0 <_dbg_check_unlock+0x20>)
     7bc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     7be:	2b00      	cmp	r3, #0
     7c0:	dc02      	bgt.n	7c8 <_dbg_check_unlock+0x18>
    chSysHalt("SV#5");
     7c2:	4804      	ldr	r0, [pc, #16]	; (7d4 <_dbg_check_unlock+0x24>)
     7c4:	f7ff ff74 	bl	6b0 <chSysHalt>
  }
  _dbg_leave_lock();
     7c8:	4b01      	ldr	r3, [pc, #4]	; (7d0 <_dbg_check_unlock+0x20>)
     7ca:	2200      	movs	r2, #0
     7cc:	635a      	str	r2, [r3, #52]	; 0x34
}
     7ce:	bd08      	pop	{r3, pc}
     7d0:	20000800 	.word	0x20000800
     7d4:	00003fd0 	.word	0x00003fd0
     7d8:	f3af 8000 	nop.w
     7dc:	f3af 8000 	nop.w

000007e0 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
     7e0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     7e2:	4b07      	ldr	r3, [pc, #28]	; (800 <_dbg_check_lock_from_isr+0x20>)
     7e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     7e6:	2b00      	cmp	r3, #0
     7e8:	dd03      	ble.n	7f2 <_dbg_check_lock_from_isr+0x12>
     7ea:	4b05      	ldr	r3, [pc, #20]	; (800 <_dbg_check_lock_from_isr+0x20>)
     7ec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     7ee:	2b00      	cmp	r3, #0
     7f0:	d002      	beq.n	7f8 <_dbg_check_lock_from_isr+0x18>
    chSysHalt("SV#6");
     7f2:	4804      	ldr	r0, [pc, #16]	; (804 <_dbg_check_lock_from_isr+0x24>)
     7f4:	f7ff ff5c 	bl	6b0 <chSysHalt>
  }
  _dbg_enter_lock();
     7f8:	4b01      	ldr	r3, [pc, #4]	; (800 <_dbg_check_lock_from_isr+0x20>)
     7fa:	2201      	movs	r2, #1
     7fc:	635a      	str	r2, [r3, #52]	; 0x34
}
     7fe:	bd08      	pop	{r3, pc}
     800:	20000800 	.word	0x20000800
     804:	00003fd8 	.word	0x00003fd8
     808:	f3af 8000 	nop.w
     80c:	f3af 8000 	nop.w

00000810 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
     810:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     812:	4b07      	ldr	r3, [pc, #28]	; (830 <_dbg_check_unlock_from_isr+0x20>)
     814:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     816:	2b00      	cmp	r3, #0
     818:	dd03      	ble.n	822 <_dbg_check_unlock_from_isr+0x12>
     81a:	4b05      	ldr	r3, [pc, #20]	; (830 <_dbg_check_unlock_from_isr+0x20>)
     81c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     81e:	2b00      	cmp	r3, #0
     820:	dc02      	bgt.n	828 <_dbg_check_unlock_from_isr+0x18>
    chSysHalt("SV#7");
     822:	4804      	ldr	r0, [pc, #16]	; (834 <_dbg_check_unlock_from_isr+0x24>)
     824:	f7ff ff44 	bl	6b0 <chSysHalt>
  }
  _dbg_leave_lock();
     828:	4b01      	ldr	r3, [pc, #4]	; (830 <_dbg_check_unlock_from_isr+0x20>)
     82a:	2200      	movs	r2, #0
     82c:	635a      	str	r2, [r3, #52]	; 0x34
}
     82e:	bd08      	pop	{r3, pc}
     830:	20000800 	.word	0x20000800
     834:	00003fe0 	.word	0x00003fe0
     838:	f3af 8000 	nop.w
     83c:	f3af 8000 	nop.w

00000840 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
     840:	b508      	push	{r3, lr}

  port_lock_from_isr();
     842:	f7ff ff5d 	bl	700 <port_lock_from_isr>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     846:	4b09      	ldr	r3, [pc, #36]	; (86c <_dbg_check_enter_isr+0x2c>)
     848:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     84a:	2b00      	cmp	r3, #0
     84c:	db03      	blt.n	856 <_dbg_check_enter_isr+0x16>
     84e:	4b07      	ldr	r3, [pc, #28]	; (86c <_dbg_check_enter_isr+0x2c>)
     850:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     852:	2b00      	cmp	r3, #0
     854:	d002      	beq.n	85c <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
     856:	4806      	ldr	r0, [pc, #24]	; (870 <_dbg_check_enter_isr+0x30>)
     858:	f7ff ff2a 	bl	6b0 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
     85c:	4b03      	ldr	r3, [pc, #12]	; (86c <_dbg_check_enter_isr+0x2c>)
     85e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     860:	1c5a      	adds	r2, r3, #1
     862:	4b02      	ldr	r3, [pc, #8]	; (86c <_dbg_check_enter_isr+0x2c>)
     864:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
     866:	f7ff ff53 	bl	710 <port_unlock_from_isr>
}
     86a:	bd08      	pop	{r3, pc}
     86c:	20000800 	.word	0x20000800
     870:	00003fe8 	.word	0x00003fe8
     874:	f3af 8000 	nop.w
     878:	f3af 8000 	nop.w
     87c:	f3af 8000 	nop.w

00000880 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
     880:	b508      	push	{r3, lr}

  port_lock_from_isr();
     882:	f7ff ff3d 	bl	700 <port_lock_from_isr>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     886:	4b09      	ldr	r3, [pc, #36]	; (8ac <_dbg_check_leave_isr+0x2c>)
     888:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     88a:	2b00      	cmp	r3, #0
     88c:	dd03      	ble.n	896 <_dbg_check_leave_isr+0x16>
     88e:	4b07      	ldr	r3, [pc, #28]	; (8ac <_dbg_check_leave_isr+0x2c>)
     890:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     892:	2b00      	cmp	r3, #0
     894:	d002      	beq.n	89c <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
     896:	4806      	ldr	r0, [pc, #24]	; (8b0 <_dbg_check_leave_isr+0x30>)
     898:	f7ff ff0a 	bl	6b0 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
     89c:	4b03      	ldr	r3, [pc, #12]	; (8ac <_dbg_check_leave_isr+0x2c>)
     89e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     8a0:	1e5a      	subs	r2, r3, #1
     8a2:	4b02      	ldr	r3, [pc, #8]	; (8ac <_dbg_check_leave_isr+0x2c>)
     8a4:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
     8a6:	f7ff ff33 	bl	710 <port_unlock_from_isr>
}
     8aa:	bd08      	pop	{r3, pc}
     8ac:	20000800 	.word	0x20000800
     8b0:	00003ff0 	.word	0x00003ff0
     8b4:	f3af 8000 	nop.w
     8b8:	f3af 8000 	nop.w
     8bc:	f3af 8000 	nop.w

000008c0 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
     8c0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     8c2:	4b06      	ldr	r3, [pc, #24]	; (8dc <chDbgCheckClassI+0x1c>)
     8c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     8c6:	2b00      	cmp	r3, #0
     8c8:	db03      	blt.n	8d2 <chDbgCheckClassI+0x12>
     8ca:	4b04      	ldr	r3, [pc, #16]	; (8dc <chDbgCheckClassI+0x1c>)
     8cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     8ce:	2b00      	cmp	r3, #0
     8d0:	dc02      	bgt.n	8d8 <chDbgCheckClassI+0x18>
    chSysHalt("SV#10");
     8d2:	4803      	ldr	r0, [pc, #12]	; (8e0 <chDbgCheckClassI+0x20>)
     8d4:	f7ff feec 	bl	6b0 <chSysHalt>
  }
}
     8d8:	bd08      	pop	{r3, pc}
     8da:	bf00      	nop
     8dc:	20000800 	.word	0x20000800
     8e0:	00003ff8 	.word	0x00003ff8
     8e4:	f3af 8000 	nop.w
     8e8:	f3af 8000 	nop.w
     8ec:	f3af 8000 	nop.w

000008f0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
     8f0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     8f2:	4b06      	ldr	r3, [pc, #24]	; (90c <chDbgCheckClassS+0x1c>)
     8f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     8f6:	2b00      	cmp	r3, #0
     8f8:	d103      	bne.n	902 <chDbgCheckClassS+0x12>
     8fa:	4b04      	ldr	r3, [pc, #16]	; (90c <chDbgCheckClassS+0x1c>)
     8fc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     8fe:	2b00      	cmp	r3, #0
     900:	dc02      	bgt.n	908 <chDbgCheckClassS+0x18>
    chSysHalt("SV#11");
     902:	4803      	ldr	r0, [pc, #12]	; (910 <chDbgCheckClassS+0x20>)
     904:	f7ff fed4 	bl	6b0 <chSysHalt>
  }
}
     908:	bd08      	pop	{r3, pc}
     90a:	bf00      	nop
     90c:	20000800 	.word	0x20000800
     910:	00004000 	.word	0x00004000
     914:	f3af 8000 	nop.w
     918:	f3af 8000 	nop.w
     91c:	f3af 8000 	nop.w

00000920 <_dbg_trace_init>:
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
     920:	4b03      	ldr	r3, [pc, #12]	; (930 <_dbg_trace_init+0x10>)
     922:	2240      	movs	r2, #64	; 0x40
     924:	639a      	str	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
     926:	4b02      	ldr	r3, [pc, #8]	; (930 <_dbg_trace_init+0x10>)
     928:	4a02      	ldr	r2, [pc, #8]	; (934 <_dbg_trace_init+0x14>)
     92a:	63da      	str	r2, [r3, #60]	; 0x3c
}
     92c:	4770      	bx	lr
     92e:	bf00      	nop
     930:	20000800 	.word	0x20000800
     934:	20000840 	.word	0x20000840
     938:	f3af 8000 	nop.w
     93c:	f3af 8000 	nop.w

00000940 <_dbg_trace>:
 *
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {
     940:	b510      	push	{r4, lr}
     942:	b082      	sub	sp, #8
     944:	9001      	str	r0, [sp, #4]

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
     946:	4b13      	ldr	r3, [pc, #76]	; (994 <_dbg_trace+0x54>)
     948:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
     94a:	f7ff fef9 	bl	740 <chVTGetSystemTimeX>
     94e:	4603      	mov	r3, r0
     950:	6023      	str	r3, [r4, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
     952:	4b10      	ldr	r3, [pc, #64]	; (994 <_dbg_trace+0x54>)
     954:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     956:	4a0f      	ldr	r2, [pc, #60]	; (994 <_dbg_trace+0x54>)
     958:	6992      	ldr	r2, [r2, #24]
     95a:	605a      	str	r2, [r3, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
     95c:	4b0d      	ldr	r3, [pc, #52]	; (994 <_dbg_trace+0x54>)
     95e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     960:	9a01      	ldr	r2, [sp, #4]
     962:	6a52      	ldr	r2, [r2, #36]	; 0x24
     964:	609a      	str	r2, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
     966:	4b0b      	ldr	r3, [pc, #44]	; (994 <_dbg_trace+0x54>)
     968:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     96a:	9a01      	ldr	r2, [sp, #4]
     96c:	f892 2020 	ldrb.w	r2, [r2, #32]
     970:	731a      	strb	r2, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
     972:	4b08      	ldr	r3, [pc, #32]	; (994 <_dbg_trace+0x54>)
     974:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     976:	f103 0210 	add.w	r2, r3, #16
     97a:	4b06      	ldr	r3, [pc, #24]	; (994 <_dbg_trace+0x54>)
     97c:	63da      	str	r2, [r3, #60]	; 0x3c
     97e:	4b05      	ldr	r3, [pc, #20]	; (994 <_dbg_trace+0x54>)
     980:	6bda      	ldr	r2, [r3, #60]	; 0x3c
     982:	4b05      	ldr	r3, [pc, #20]	; (998 <_dbg_trace+0x58>)
     984:	429a      	cmp	r2, r3
     986:	d302      	bcc.n	98e <_dbg_trace+0x4e>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
     988:	4b02      	ldr	r3, [pc, #8]	; (994 <_dbg_trace+0x54>)
     98a:	4a04      	ldr	r2, [pc, #16]	; (99c <_dbg_trace+0x5c>)
     98c:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
     98e:	b002      	add	sp, #8
     990:	bd10      	pop	{r4, pc}
     992:	bf00      	nop
     994:	20000800 	.word	0x20000800
     998:	20000c40 	.word	0x20000c40
     99c:	20000840 	.word	0x20000840

000009a0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     9a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     9a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     9a6:	4618      	mov	r0, r3
     9a8:	4770      	bx	lr
     9aa:	bf00      	nop
     9ac:	f3af 8000 	nop.w

000009b0 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
     9b0:	b500      	push	{lr}
     9b2:	b083      	sub	sp, #12
     9b4:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
     9b6:	9801      	ldr	r0, [sp, #4]
     9b8:	f001 feaa 	bl	2710 <stStartAlarm>
}
     9bc:	b003      	add	sp, #12
     9be:	f85d fb04 	ldr.w	pc, [sp], #4
     9c2:	bf00      	nop
     9c4:	f3af 8000 	nop.w
     9c8:	f3af 8000 	nop.w
     9cc:	f3af 8000 	nop.w

000009d0 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
     9d0:	b508      	push	{r3, lr}

  stStopAlarm();
     9d2:	f001 feb5 	bl	2740 <stStopAlarm>
}
     9d6:	bd08      	pop	{r3, pc}
     9d8:	f3af 8000 	nop.w
     9dc:	f3af 8000 	nop.w

000009e0 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
     9e0:	b500      	push	{lr}
     9e2:	b083      	sub	sp, #12
     9e4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
     9e6:	9801      	ldr	r0, [sp, #4]
     9e8:	f001 feb2 	bl	2750 <stSetAlarm>
}
     9ec:	b003      	add	sp, #12
     9ee:	f85d fb04 	ldr.w	pc, [sp], #4
     9f2:	bf00      	nop
     9f4:	f3af 8000 	nop.w
     9f8:	f3af 8000 	nop.w
     9fc:	f3af 8000 	nop.w

00000a00 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     a00:	b508      	push	{r3, lr}

  return stGetCounter();
     a02:	f7ff ffcd 	bl	9a0 <st_lld_get_counter>
     a06:	4603      	mov	r3, r0
}
     a08:	4618      	mov	r0, r3
     a0a:	bd08      	pop	{r3, pc}
     a0c:	f3af 8000 	nop.w

00000a10 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     a10:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     a12:	f7ff fff5 	bl	a00 <port_timer_get_time>
     a16:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     a18:	4618      	mov	r0, r3
     a1a:	bd08      	pop	{r3, pc}
     a1c:	f3af 8000 	nop.w

00000a20 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
     a20:	4b06      	ldr	r3, [pc, #24]	; (a3c <_vt_init+0x1c>)
     a22:	4a07      	ldr	r2, [pc, #28]	; (a40 <_vt_init+0x20>)
     a24:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
     a26:	4b05      	ldr	r3, [pc, #20]	; (a3c <_vt_init+0x1c>)
     a28:	4a05      	ldr	r2, [pc, #20]	; (a40 <_vt_init+0x20>)
     a2a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
     a2c:	4b03      	ldr	r3, [pc, #12]	; (a3c <_vt_init+0x1c>)
     a2e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     a32:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
     a34:	4b01      	ldr	r3, [pc, #4]	; (a3c <_vt_init+0x1c>)
     a36:	2200      	movs	r2, #0
     a38:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     a3a:	4770      	bx	lr
     a3c:	20000800 	.word	0x20000800
     a40:	2000081c 	.word	0x2000081c
     a44:	f3af 8000 	nop.w
     a48:	f3af 8000 	nop.w
     a4c:	f3af 8000 	nop.w

00000a50 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
     a50:	b500      	push	{lr}
     a52:	b089      	sub	sp, #36	; 0x24
     a54:	9003      	str	r0, [sp, #12]
     a56:	9102      	str	r1, [sp, #8]
     a58:	9201      	str	r2, [sp, #4]
     a5a:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
     a5c:	f7ff ff30 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
     a60:	9b03      	ldr	r3, [sp, #12]
     a62:	2b00      	cmp	r3, #0
     a64:	d005      	beq.n	a72 <chVTDoSetI+0x22>
     a66:	9b01      	ldr	r3, [sp, #4]
     a68:	2b00      	cmp	r3, #0
     a6a:	d002      	beq.n	a72 <chVTDoSetI+0x22>
     a6c:	9b02      	ldr	r3, [sp, #8]
     a6e:	2b00      	cmp	r3, #0
     a70:	d102      	bne.n	a78 <chVTDoSetI+0x28>
     a72:	483a      	ldr	r0, [pc, #232]	; (b5c <chVTDoSetI+0x10c>)
     a74:	f7ff fe1c 	bl	6b0 <chSysHalt>

  vtp->vt_par = par;
     a78:	9b03      	ldr	r3, [sp, #12]
     a7a:	9a00      	ldr	r2, [sp, #0]
     a7c:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
     a7e:	9b03      	ldr	r3, [sp, #12]
     a80:	9a01      	ldr	r2, [sp, #4]
     a82:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
     a84:	f7ff ffc4 	bl	a10 <chVTGetSystemTimeX>
     a88:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
     a8a:	9b02      	ldr	r3, [sp, #8]
     a8c:	2b01      	cmp	r3, #1
     a8e:	d801      	bhi.n	a94 <chVTDoSetI+0x44>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
     a90:	2302      	movs	r3, #2
     a92:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
     a94:	4b32      	ldr	r3, [pc, #200]	; (b60 <chVTDoSetI+0x110>)
     a96:	69da      	ldr	r2, [r3, #28]
     a98:	4b32      	ldr	r3, [pc, #200]	; (b64 <chVTDoSetI+0x114>)
     a9a:	429a      	cmp	r2, r3
     a9c:	d119      	bne.n	ad2 <chVTDoSetI+0x82>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
     a9e:	4b30      	ldr	r3, [pc, #192]	; (b60 <chVTDoSetI+0x110>)
     aa0:	9a05      	ldr	r2, [sp, #20]
     aa2:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
     aa4:	4b2e      	ldr	r3, [pc, #184]	; (b60 <chVTDoSetI+0x110>)
     aa6:	9a03      	ldr	r2, [sp, #12]
     aa8:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
     aaa:	4b2d      	ldr	r3, [pc, #180]	; (b60 <chVTDoSetI+0x110>)
     aac:	9a03      	ldr	r2, [sp, #12]
     aae:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
     ab0:	9b03      	ldr	r3, [sp, #12]
     ab2:	4a2c      	ldr	r2, [pc, #176]	; (b64 <chVTDoSetI+0x114>)
     ab4:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
     ab6:	9b03      	ldr	r3, [sp, #12]
     ab8:	4a2a      	ldr	r2, [pc, #168]	; (b64 <chVTDoSetI+0x114>)
     aba:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
     abc:	9b03      	ldr	r3, [sp, #12]
     abe:	9a02      	ldr	r2, [sp, #8]
     ac0:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
     ac2:	4b27      	ldr	r3, [pc, #156]	; (b60 <chVTDoSetI+0x110>)
     ac4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     ac6:	9b02      	ldr	r3, [sp, #8]
     ac8:	4413      	add	r3, r2
     aca:	4618      	mov	r0, r3
     acc:	f7ff ff70 	bl	9b0 <port_timer_start_alarm>

      return;
     ad0:	e040      	b.n	b54 <chVTDoSetI+0x104>
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
     ad2:	9a05      	ldr	r2, [sp, #20]
     ad4:	9b02      	ldr	r3, [sp, #8]
     ad6:	441a      	add	r2, r3
     ad8:	4b21      	ldr	r3, [pc, #132]	; (b60 <chVTDoSetI+0x110>)
     ada:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     adc:	1ad3      	subs	r3, r2, r3
     ade:	9306      	str	r3, [sp, #24]
    if (delta < ch.vtlist.vt_next->vt_delta) {
     ae0:	4b1f      	ldr	r3, [pc, #124]	; (b60 <chVTDoSetI+0x110>)
     ae2:	69db      	ldr	r3, [r3, #28]
     ae4:	689a      	ldr	r2, [r3, #8]
     ae6:	9b06      	ldr	r3, [sp, #24]
     ae8:	429a      	cmp	r2, r3
     aea:	d906      	bls.n	afa <chVTDoSetI+0xaa>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
     aec:	4b1c      	ldr	r3, [pc, #112]	; (b60 <chVTDoSetI+0x110>)
     aee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     af0:	9b06      	ldr	r3, [sp, #24]
     af2:	4413      	add	r3, r2
     af4:	4618      	mov	r0, r3
     af6:	f7ff ff73 	bl	9e0 <port_timer_set_alarm>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
     afa:	4b19      	ldr	r3, [pc, #100]	; (b60 <chVTDoSetI+0x110>)
     afc:	69db      	ldr	r3, [r3, #28]
     afe:	9307      	str	r3, [sp, #28]
  while (p->vt_delta < delta) {
     b00:	e007      	b.n	b12 <chVTDoSetI+0xc2>
    delta -= p->vt_delta;
     b02:	9b07      	ldr	r3, [sp, #28]
     b04:	689b      	ldr	r3, [r3, #8]
     b06:	9a06      	ldr	r2, [sp, #24]
     b08:	1ad3      	subs	r3, r2, r3
     b0a:	9306      	str	r3, [sp, #24]
    p = p->vt_next;
     b0c:	9b07      	ldr	r3, [sp, #28]
     b0e:	681b      	ldr	r3, [r3, #0]
     b10:	9307      	str	r3, [sp, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
     b12:	9b07      	ldr	r3, [sp, #28]
     b14:	689a      	ldr	r2, [r3, #8]
     b16:	9b06      	ldr	r3, [sp, #24]
     b18:	429a      	cmp	r2, r3
     b1a:	d3f2      	bcc.n	b02 <chVTDoSetI+0xb2>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
     b1c:	9b03      	ldr	r3, [sp, #12]
     b1e:	9a07      	ldr	r2, [sp, #28]
     b20:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
     b22:	9b03      	ldr	r3, [sp, #12]
     b24:	681b      	ldr	r3, [r3, #0]
     b26:	685a      	ldr	r2, [r3, #4]
     b28:	9b03      	ldr	r3, [sp, #12]
     b2a:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
     b2c:	9b03      	ldr	r3, [sp, #12]
     b2e:	685b      	ldr	r3, [r3, #4]
     b30:	9a03      	ldr	r2, [sp, #12]
     b32:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
     b34:	9b07      	ldr	r3, [sp, #28]
     b36:	9a03      	ldr	r2, [sp, #12]
     b38:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
     b3a:	9b03      	ldr	r3, [sp, #12]
     b3c:	9a06      	ldr	r2, [sp, #24]
     b3e:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
     b40:	9b07      	ldr	r3, [sp, #28]
     b42:	689a      	ldr	r2, [r3, #8]
     b44:	9b06      	ldr	r3, [sp, #24]
     b46:	1ad2      	subs	r2, r2, r3
     b48:	9b07      	ldr	r3, [sp, #28]
     b4a:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
     b4c:	4b04      	ldr	r3, [pc, #16]	; (b60 <chVTDoSetI+0x110>)
     b4e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     b52:	625a      	str	r2, [r3, #36]	; 0x24
}
     b54:	b009      	add	sp, #36	; 0x24
     b56:	f85d fb04 	ldr.w	pc, [sp], #4
     b5a:	bf00      	nop
     b5c:	00004030 	.word	0x00004030
     b60:	20000800 	.word	0x20000800
     b64:	2000081c 	.word	0x2000081c
     b68:	f3af 8000 	nop.w
     b6c:	f3af 8000 	nop.w

00000b70 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
     b70:	b500      	push	{lr}
     b72:	b085      	sub	sp, #20
     b74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     b76:	f7ff fea3 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
     b7a:	9b01      	ldr	r3, [sp, #4]
     b7c:	2b00      	cmp	r3, #0
     b7e:	d102      	bne.n	b86 <chVTDoResetI+0x16>
     b80:	4836      	ldr	r0, [pc, #216]	; (c5c <chVTDoResetI+0xec>)
     b82:	f7ff fd95 	bl	6b0 <chSysHalt>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
     b86:	9b01      	ldr	r3, [sp, #4]
     b88:	68db      	ldr	r3, [r3, #12]
     b8a:	2b00      	cmp	r3, #0
     b8c:	d102      	bne.n	b94 <chVTDoResetI+0x24>
     b8e:	4833      	ldr	r0, [pc, #204]	; (c5c <chVTDoResetI+0xec>)
     b90:	f7ff fd8e 	bl	6b0 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
     b94:	4b32      	ldr	r3, [pc, #200]	; (c60 <chVTDoResetI+0xf0>)
     b96:	69da      	ldr	r2, [r3, #28]
     b98:	9b01      	ldr	r3, [sp, #4]
     b9a:	429a      	cmp	r2, r3
     b9c:	d01c      	beq.n	bd8 <chVTDoResetI+0x68>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
     b9e:	9b01      	ldr	r3, [sp, #4]
     ba0:	685b      	ldr	r3, [r3, #4]
     ba2:	9a01      	ldr	r2, [sp, #4]
     ba4:	6812      	ldr	r2, [r2, #0]
     ba6:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
     ba8:	9b01      	ldr	r3, [sp, #4]
     baa:	681b      	ldr	r3, [r3, #0]
     bac:	9a01      	ldr	r2, [sp, #4]
     bae:	6852      	ldr	r2, [r2, #4]
     bb0:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
     bb2:	9b01      	ldr	r3, [sp, #4]
     bb4:	2200      	movs	r2, #0
     bb6:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
     bb8:	9b01      	ldr	r3, [sp, #4]
     bba:	681a      	ldr	r2, [r3, #0]
     bbc:	4b29      	ldr	r3, [pc, #164]	; (c64 <chVTDoResetI+0xf4>)
     bbe:	429a      	cmp	r2, r3
     bc0:	d009      	beq.n	bd6 <chVTDoResetI+0x66>
      vtp->vt_next->vt_delta += vtp->vt_delta;
     bc2:	9b01      	ldr	r3, [sp, #4]
     bc4:	681b      	ldr	r3, [r3, #0]
     bc6:	9a01      	ldr	r2, [sp, #4]
     bc8:	6812      	ldr	r2, [r2, #0]
     bca:	6891      	ldr	r1, [r2, #8]
     bcc:	9a01      	ldr	r2, [sp, #4]
     bce:	6892      	ldr	r2, [r2, #8]
     bd0:	440a      	add	r2, r1
     bd2:	609a      	str	r2, [r3, #8]

    return;
     bd4:	e03e      	b.n	c54 <chVTDoResetI+0xe4>
     bd6:	e03d      	b.n	c54 <chVTDoResetI+0xe4>
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
     bd8:	9b01      	ldr	r3, [sp, #4]
     bda:	681a      	ldr	r2, [r3, #0]
     bdc:	4b20      	ldr	r3, [pc, #128]	; (c60 <chVTDoResetI+0xf0>)
     bde:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     be0:	4b1f      	ldr	r3, [pc, #124]	; (c60 <chVTDoResetI+0xf0>)
     be2:	69db      	ldr	r3, [r3, #28]
     be4:	4a1f      	ldr	r2, [pc, #124]	; (c64 <chVTDoResetI+0xf4>)
     be6:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
     be8:	9b01      	ldr	r3, [sp, #4]
     bea:	2200      	movs	r2, #0
     bec:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
     bee:	4b1c      	ldr	r3, [pc, #112]	; (c60 <chVTDoResetI+0xf0>)
     bf0:	69da      	ldr	r2, [r3, #28]
     bf2:	4b1c      	ldr	r3, [pc, #112]	; (c64 <chVTDoResetI+0xf4>)
     bf4:	429a      	cmp	r2, r3
     bf6:	d102      	bne.n	bfe <chVTDoResetI+0x8e>
    port_timer_stop_alarm();
     bf8:	f7ff feea 	bl	9d0 <port_timer_stop_alarm>

    return;
     bfc:	e02a      	b.n	c54 <chVTDoResetI+0xe4>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
     bfe:	4b18      	ldr	r3, [pc, #96]	; (c60 <chVTDoResetI+0xf0>)
     c00:	69db      	ldr	r3, [r3, #28]
     c02:	4a17      	ldr	r2, [pc, #92]	; (c60 <chVTDoResetI+0xf0>)
     c04:	69d2      	ldr	r2, [r2, #28]
     c06:	6891      	ldr	r1, [r2, #8]
     c08:	9a01      	ldr	r2, [sp, #4]
     c0a:	6892      	ldr	r2, [r2, #8]
     c0c:	440a      	add	r2, r1
     c0e:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
     c10:	f7ff fefe 	bl	a10 <chVTGetSystemTimeX>
     c14:	4602      	mov	r2, r0
     c16:	4b12      	ldr	r3, [pc, #72]	; (c60 <chVTDoResetI+0xf0>)
     c18:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     c1a:	1ad3      	subs	r3, r2, r3
     c1c:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
     c1e:	4b10      	ldr	r3, [pc, #64]	; (c60 <chVTDoResetI+0xf0>)
     c20:	69db      	ldr	r3, [r3, #28]
     c22:	689a      	ldr	r2, [r3, #8]
     c24:	9b02      	ldr	r3, [sp, #8]
     c26:	429a      	cmp	r2, r3
     c28:	d800      	bhi.n	c2c <chVTDoResetI+0xbc>
    return;
     c2a:	e013      	b.n	c54 <chVTDoResetI+0xe4>
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
     c2c:	4b0c      	ldr	r3, [pc, #48]	; (c60 <chVTDoResetI+0xf0>)
     c2e:	69db      	ldr	r3, [r3, #28]
     c30:	689a      	ldr	r2, [r3, #8]
     c32:	9b02      	ldr	r3, [sp, #8]
     c34:	1ad3      	subs	r3, r2, r3
     c36:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
     c38:	9b03      	ldr	r3, [sp, #12]
     c3a:	2b01      	cmp	r3, #1
     c3c:	d801      	bhi.n	c42 <chVTDoResetI+0xd2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
     c3e:	2302      	movs	r3, #2
     c40:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
     c42:	4b07      	ldr	r3, [pc, #28]	; (c60 <chVTDoResetI+0xf0>)
     c44:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     c46:	9b02      	ldr	r3, [sp, #8]
     c48:	441a      	add	r2, r3
     c4a:	9b03      	ldr	r3, [sp, #12]
     c4c:	4413      	add	r3, r2
     c4e:	4618      	mov	r0, r3
     c50:	f7ff fec6 	bl	9e0 <port_timer_set_alarm>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     c54:	b005      	add	sp, #20
     c56:	f85d fb04 	ldr.w	pc, [sp], #4
     c5a:	bf00      	nop
     c5c:	00004040 	.word	0x00004040
     c60:	20000800 	.word	0x20000800
     c64:	2000081c 	.word	0x2000081c
     c68:	f3af 8000 	nop.w
     c6c:	f3af 8000 	nop.w

00000c70 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     c70:	b082      	sub	sp, #8
     c72:	2320      	movs	r3, #32
     c74:	9301      	str	r3, [sp, #4]
     c76:	9b01      	ldr	r3, [sp, #4]
     c78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     c7c:	b002      	add	sp, #8
     c7e:	4770      	bx	lr

00000c80 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     c80:	b082      	sub	sp, #8
     c82:	2300      	movs	r3, #0
     c84:	9301      	str	r3, [sp, #4]
     c86:	9b01      	ldr	r3, [sp, #4]
     c88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     c8c:	b002      	add	sp, #8
     c8e:	4770      	bx	lr

00000c90 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     c90:	b508      	push	{r3, lr}

  port_lock();
     c92:	f7ff ffed 	bl	c70 <port_lock>
}
     c96:	bd08      	pop	{r3, pc}
     c98:	f3af 8000 	nop.w
     c9c:	f3af 8000 	nop.w

00000ca0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     ca0:	b508      	push	{r3, lr}

  port_unlock();
     ca2:	f7ff ffed 	bl	c80 <port_unlock>
}
     ca6:	bd08      	pop	{r3, pc}
     ca8:	f3af 8000 	nop.w
     cac:	f3af 8000 	nop.w

00000cb0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
     cb0:	b082      	sub	sp, #8
     cb2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
     cb4:	9b01      	ldr	r3, [sp, #4]
     cb6:	9a01      	ldr	r2, [sp, #4]
     cb8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
     cba:	9b01      	ldr	r3, [sp, #4]
     cbc:	9a01      	ldr	r2, [sp, #4]
     cbe:	605a      	str	r2, [r3, #4]
}
     cc0:	b002      	add	sp, #8
     cc2:	4770      	bx	lr
     cc4:	f3af 8000 	nop.w
     cc8:	f3af 8000 	nop.w
     ccc:	f3af 8000 	nop.w

00000cd0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
     cd0:	b084      	sub	sp, #16
     cd2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
     cd4:	9b01      	ldr	r3, [sp, #4]
     cd6:	681b      	ldr	r3, [r3, #0]
     cd8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
     cda:	9b03      	ldr	r3, [sp, #12]
     cdc:	681a      	ldr	r2, [r3, #0]
     cde:	9b01      	ldr	r3, [sp, #4]
     ce0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
     ce2:	9b01      	ldr	r3, [sp, #4]
     ce4:	681b      	ldr	r3, [r3, #0]
     ce6:	9a01      	ldr	r2, [sp, #4]
     ce8:	605a      	str	r2, [r3, #4]

  return tp;
     cea:	9b03      	ldr	r3, [sp, #12]
}
     cec:	4618      	mov	r0, r3
     cee:	b004      	add	sp, #16
     cf0:	4770      	bx	lr
     cf2:	bf00      	nop
     cf4:	f3af 8000 	nop.w
     cf8:	f3af 8000 	nop.w
     cfc:	f3af 8000 	nop.w

00000d00 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
     d00:	b082      	sub	sp, #8
     d02:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
     d04:	9b01      	ldr	r3, [sp, #4]
     d06:	685b      	ldr	r3, [r3, #4]
     d08:	9a01      	ldr	r2, [sp, #4]
     d0a:	6812      	ldr	r2, [r2, #0]
     d0c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
     d0e:	9b01      	ldr	r3, [sp, #4]
     d10:	681b      	ldr	r3, [r3, #0]
     d12:	9a01      	ldr	r2, [sp, #4]
     d14:	6852      	ldr	r2, [r2, #4]
     d16:	605a      	str	r2, [r3, #4]

  return tp;
     d18:	9b01      	ldr	r3, [sp, #4]
}
     d1a:	4618      	mov	r0, r3
     d1c:	b002      	add	sp, #8
     d1e:	4770      	bx	lr

00000d20 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
     d20:	b508      	push	{r3, lr}

  chDbgCheckClassI();
     d22:	f7ff fdcd 	bl	8c0 <chDbgCheckClassI>

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
     d26:	4b06      	ldr	r3, [pc, #24]	; (d40 <chSchIsRescRequiredI+0x20>)
     d28:	681b      	ldr	r3, [r3, #0]
     d2a:	689a      	ldr	r2, [r3, #8]
     d2c:	4b04      	ldr	r3, [pc, #16]	; (d40 <chSchIsRescRequiredI+0x20>)
     d2e:	699b      	ldr	r3, [r3, #24]
     d30:	689b      	ldr	r3, [r3, #8]
     d32:	429a      	cmp	r2, r3
     d34:	bf94      	ite	ls
     d36:	2300      	movls	r3, #0
     d38:	2301      	movhi	r3, #1
     d3a:	b2db      	uxtb	r3, r3
}
     d3c:	4618      	mov	r0, r3
     d3e:	bd08      	pop	{r3, pc}
     d40:	20000800 	.word	0x20000800
     d44:	f3af 8000 	nop.w
     d48:	f3af 8000 	nop.w
     d4c:	f3af 8000 	nop.w

00000d50 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
     d50:	b508      	push	{r3, lr}

  port_lock_from_isr();
     d52:	f7ff ff9d 	bl	c90 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
     d56:	f000 fdcb 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
     d5a:	f7ff fd41 	bl	7e0 <_dbg_check_lock_from_isr>
}
     d5e:	bd08      	pop	{r3, pc}

00000d60 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
     d60:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
     d62:	f7ff fd55 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
     d66:	f000 fdcb 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
     d6a:	f7ff ff99 	bl	ca0 <port_unlock_from_isr>
}
     d6e:	bd08      	pop	{r3, pc}

00000d70 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
     d70:	b500      	push	{lr}
     d72:	b083      	sub	sp, #12
     d74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     d76:	f7ff fda3 	bl	8c0 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
     d7a:	9b01      	ldr	r3, [sp, #4]
     d7c:	68db      	ldr	r3, [r3, #12]
     d7e:	2b00      	cmp	r3, #0
     d80:	bf0c      	ite	eq
     d82:	2300      	moveq	r3, #0
     d84:	2301      	movne	r3, #1
     d86:	b2db      	uxtb	r3, r3
}
     d88:	4618      	mov	r0, r3
     d8a:	b003      	add	sp, #12
     d8c:	f85d fb04 	ldr.w	pc, [sp], #4

00000d90 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
     d90:	b500      	push	{lr}
     d92:	b083      	sub	sp, #12
     d94:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     d96:	f7ff fd93 	bl	8c0 <chDbgCheckClassI>

  sp->s_cnt++;
     d9a:	9b01      	ldr	r3, [sp, #4]
     d9c:	689b      	ldr	r3, [r3, #8]
     d9e:	1c5a      	adds	r2, r3, #1
     da0:	9b01      	ldr	r3, [sp, #4]
     da2:	609a      	str	r2, [r3, #8]
}
     da4:	b003      	add	sp, #12
     da6:	f85d fb04 	ldr.w	pc, [sp], #4
     daa:	bf00      	nop
     dac:	f3af 8000 	nop.w

00000db0 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
     db0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
     db2:	4806      	ldr	r0, [pc, #24]	; (dcc <_scheduler_init+0x1c>)
     db4:	f7ff ff7c 	bl	cb0 <queue_init>
  ch.rlist.r_prio = NOPRIO;
     db8:	4b04      	ldr	r3, [pc, #16]	; (dcc <_scheduler_init+0x1c>)
     dba:	2200      	movs	r2, #0
     dbc:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
     dbe:	4b03      	ldr	r3, [pc, #12]	; (dcc <_scheduler_init+0x1c>)
     dc0:	4a02      	ldr	r2, [pc, #8]	; (dcc <_scheduler_init+0x1c>)
     dc2:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
     dc4:	4b01      	ldr	r3, [pc, #4]	; (dcc <_scheduler_init+0x1c>)
     dc6:	4a01      	ldr	r2, [pc, #4]	; (dcc <_scheduler_init+0x1c>)
     dc8:	615a      	str	r2, [r3, #20]
#endif
}
     dca:	bd08      	pop	{r3, pc}
     dcc:	20000800 	.word	0x20000800

00000dd0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     dd0:	b500      	push	{lr}
     dd2:	b085      	sub	sp, #20
     dd4:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
     dd6:	f7ff fd73 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
     dda:	9b01      	ldr	r3, [sp, #4]
     ddc:	2b00      	cmp	r3, #0
     dde:	d102      	bne.n	de6 <chSchReadyI+0x16>
     de0:	4818      	ldr	r0, [pc, #96]	; (e44 <chSchReadyI+0x74>)
     de2:	f7ff fc65 	bl	6b0 <chSysHalt>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
     de6:	9b01      	ldr	r3, [sp, #4]
     de8:	f893 3020 	ldrb.w	r3, [r3, #32]
     dec:	2b00      	cmp	r3, #0
     dee:	d004      	beq.n	dfa <chSchReadyI+0x2a>
     df0:	9b01      	ldr	r3, [sp, #4]
     df2:	f893 3020 	ldrb.w	r3, [r3, #32]
     df6:	2b0f      	cmp	r3, #15
     df8:	d102      	bne.n	e00 <chSchReadyI+0x30>
     dfa:	4812      	ldr	r0, [pc, #72]	; (e44 <chSchReadyI+0x74>)
     dfc:	f7ff fc58 	bl	6b0 <chSysHalt>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     e00:	9b01      	ldr	r3, [sp, #4]
     e02:	2200      	movs	r2, #0
     e04:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
     e08:	4b0f      	ldr	r3, [pc, #60]	; (e48 <chSchReadyI+0x78>)
     e0a:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
     e0c:	9b03      	ldr	r3, [sp, #12]
     e0e:	681b      	ldr	r3, [r3, #0]
     e10:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
     e12:	9b03      	ldr	r3, [sp, #12]
     e14:	689a      	ldr	r2, [r3, #8]
     e16:	9b01      	ldr	r3, [sp, #4]
     e18:	689b      	ldr	r3, [r3, #8]
     e1a:	429a      	cmp	r2, r3
     e1c:	d2f6      	bcs.n	e0c <chSchReadyI+0x3c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     e1e:	9b01      	ldr	r3, [sp, #4]
     e20:	9a03      	ldr	r2, [sp, #12]
     e22:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
     e24:	9b03      	ldr	r3, [sp, #12]
     e26:	685a      	ldr	r2, [r3, #4]
     e28:	9b01      	ldr	r3, [sp, #4]
     e2a:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
     e2c:	9b01      	ldr	r3, [sp, #4]
     e2e:	685b      	ldr	r3, [r3, #4]
     e30:	9a01      	ldr	r2, [sp, #4]
     e32:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
     e34:	9b03      	ldr	r3, [sp, #12]
     e36:	9a01      	ldr	r2, [sp, #4]
     e38:	605a      	str	r2, [r3, #4]

  return tp;
     e3a:	9b01      	ldr	r3, [sp, #4]
}
     e3c:	4618      	mov	r0, r3
     e3e:	b005      	add	sp, #20
     e40:	f85d fb04 	ldr.w	pc, [sp], #4
     e44:	00004050 	.word	0x00004050
     e48:	20000800 	.word	0x20000800
     e4c:	f3af 8000 	nop.w

00000e50 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
     e50:	b510      	push	{r4, lr}
     e52:	b084      	sub	sp, #16
     e54:	4603      	mov	r3, r0
     e56:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();
     e5a:	f7ff fd49 	bl	8f0 <chDbgCheckClassS>

  otp = currp;
     e5e:	4b19      	ldr	r3, [pc, #100]	; (ec4 <chSchGoSleepS+0x74>)
     e60:	699b      	ldr	r3, [r3, #24]
     e62:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
     e64:	9b03      	ldr	r3, [sp, #12]
     e66:	f89d 2007 	ldrb.w	r2, [sp, #7]
     e6a:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
     e6e:	4815      	ldr	r0, [pc, #84]	; (ec4 <chSchGoSleepS+0x74>)
     e70:	f7ff ff2e 	bl	cd0 <queue_fifo_remove>
     e74:	4602      	mov	r2, r0
     e76:	4b13      	ldr	r3, [pc, #76]	; (ec4 <chSchGoSleepS+0x74>)
     e78:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
     e7a:	4b12      	ldr	r3, [pc, #72]	; (ec4 <chSchGoSleepS+0x74>)
     e7c:	699b      	ldr	r3, [r3, #24]
     e7e:	2201      	movs	r2, #1
     e80:	f883 2020 	strb.w	r2, [r3, #32]
  chSysSwitch(currp, otp);
     e84:	9803      	ldr	r0, [sp, #12]
     e86:	f7ff fd5b 	bl	940 <_dbg_trace>
     e8a:	4b0e      	ldr	r3, [pc, #56]	; (ec4 <chSchGoSleepS+0x74>)
     e8c:	699b      	ldr	r3, [r3, #24]
     e8e:	4618      	mov	r0, r3
     e90:	9903      	ldr	r1, [sp, #12]
     e92:	f000 fcfd 	bl	1890 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
     e96:	f3ef 8309 	mrs	r3, PSP
     e9a:	461c      	mov	r4, r3
  return(result);
     e9c:	4623      	mov	r3, r4
     e9e:	9302      	str	r3, [sp, #8]
     ea0:	9b02      	ldr	r3, [sp, #8]
     ea2:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
     ea6:	9b03      	ldr	r3, [sp, #12]
     ea8:	69db      	ldr	r3, [r3, #28]
     eaa:	429a      	cmp	r2, r3
     eac:	d202      	bcs.n	eb4 <chSchGoSleepS+0x64>
     eae:	4806      	ldr	r0, [pc, #24]	; (ec8 <chSchGoSleepS+0x78>)
     eb0:	f7ff fbfe 	bl	6b0 <chSysHalt>
     eb4:	4b03      	ldr	r3, [pc, #12]	; (ec4 <chSchGoSleepS+0x74>)
     eb6:	699b      	ldr	r3, [r3, #24]
     eb8:	4618      	mov	r0, r3
     eba:	9903      	ldr	r1, [sp, #12]
     ebc:	f7ff f9e0 	bl	280 <_port_switch>
}
     ec0:	b004      	add	sp, #16
     ec2:	bd10      	pop	{r4, pc}
     ec4:	20000800 	.word	0x20000800
     ec8:	00004010 	.word	0x00004010
     ecc:	f3af 8000 	nop.w

00000ed0 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
     ed0:	b500      	push	{lr}
     ed2:	b085      	sub	sp, #20
     ed4:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
     ed6:	9b01      	ldr	r3, [sp, #4]
     ed8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
     eda:	f7ff ff39 	bl	d50 <chSysLockFromISR>
  switch (tp->p_state) {
     ede:	9b03      	ldr	r3, [sp, #12]
     ee0:	f893 3020 	ldrb.w	r3, [r3, #32]
     ee4:	2b07      	cmp	r3, #7
     ee6:	d824      	bhi.n	f32 <wakeup+0x62>
     ee8:	a201      	add	r2, pc, #4	; (adr r2, ef0 <wakeup+0x20>)
     eea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     eee:	bf00      	nop
     ef0:	00000f11 	.word	0x00000f11
     ef4:	00000f33 	.word	0x00000f33
     ef8:	00000f33 	.word	0x00000f33
     efc:	00000f17 	.word	0x00000f17
     f00:	00000f2b 	.word	0x00000f2b
     f04:	00000f21 	.word	0x00000f21
     f08:	00000f33 	.word	0x00000f33
     f0c:	00000f2b 	.word	0x00000f2b
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
     f10:	f7ff ff26 	bl	d60 <chSysUnlockFromISR>
    return;
     f14:	e017      	b.n	f46 <wakeup+0x76>
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
     f16:	9b03      	ldr	r3, [sp, #12]
     f18:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     f1a:	2200      	movs	r2, #0
     f1c:	601a      	str	r2, [r3, #0]
    break;
     f1e:	e009      	b.n	f34 <wakeup+0x64>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
     f20:	9b03      	ldr	r3, [sp, #12]
     f22:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     f24:	4618      	mov	r0, r3
     f26:	f7ff ff33 	bl	d90 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
     f2a:	9803      	ldr	r0, [sp, #12]
     f2c:	f7ff fee8 	bl	d00 <queue_dequeue>
    break;
     f30:	e000      	b.n	f34 <wakeup+0x64>
  default:
    /* Any other state, nothing to do.*/
    break;
     f32:	bf00      	nop
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
     f34:	9b03      	ldr	r3, [sp, #12]
     f36:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     f3a:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
     f3c:	9803      	ldr	r0, [sp, #12]
     f3e:	f7ff ff47 	bl	dd0 <chSchReadyI>
  chSysUnlockFromISR();
     f42:	f7ff ff0d 	bl	d60 <chSysUnlockFromISR>
}
     f46:	b005      	add	sp, #20
     f48:	f85d fb04 	ldr.w	pc, [sp], #4
     f4c:	f3af 8000 	nop.w

00000f50 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
     f50:	b500      	push	{lr}
     f52:	b089      	sub	sp, #36	; 0x24
     f54:	4603      	mov	r3, r0
     f56:	9100      	str	r1, [sp, #0]
     f58:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
     f5c:	f7ff fcc8 	bl	8f0 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
     f60:	9b00      	ldr	r3, [sp, #0]
     f62:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
     f66:	d019      	beq.n	f9c <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
     f68:	4b12      	ldr	r3, [pc, #72]	; (fb4 <chSchGoSleepTimeoutS+0x64>)
     f6a:	699b      	ldr	r3, [r3, #24]
     f6c:	aa03      	add	r2, sp, #12
     f6e:	4610      	mov	r0, r2
     f70:	9900      	ldr	r1, [sp, #0]
     f72:	4a11      	ldr	r2, [pc, #68]	; (fb8 <chSchGoSleepTimeoutS+0x68>)
     f74:	f7ff fd6c 	bl	a50 <chVTDoSetI>
    chSchGoSleepS(newstate);
     f78:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f7c:	4618      	mov	r0, r3
     f7e:	f7ff ff67 	bl	e50 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     f82:	ab03      	add	r3, sp, #12
     f84:	4618      	mov	r0, r3
     f86:	f7ff fef3 	bl	d70 <chVTIsArmedI>
     f8a:	4603      	mov	r3, r0
     f8c:	2b00      	cmp	r3, #0
     f8e:	d004      	beq.n	f9a <chSchGoSleepTimeoutS+0x4a>
      chVTDoResetI(&vt);
     f90:	ab03      	add	r3, sp, #12
     f92:	4618      	mov	r0, r3
     f94:	f7ff fdec 	bl	b70 <chVTDoResetI>
     f98:	e005      	b.n	fa6 <chSchGoSleepTimeoutS+0x56>
     f9a:	e004      	b.n	fa6 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
     f9c:	f89d 3007 	ldrb.w	r3, [sp, #7]
     fa0:	4618      	mov	r0, r3
     fa2:	f7ff ff55 	bl	e50 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
     fa6:	4b03      	ldr	r3, [pc, #12]	; (fb4 <chSchGoSleepTimeoutS+0x64>)
     fa8:	699b      	ldr	r3, [r3, #24]
     faa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     fac:	4618      	mov	r0, r3
     fae:	b009      	add	sp, #36	; 0x24
     fb0:	f85d fb04 	ldr.w	pc, [sp], #4
     fb4:	20000800 	.word	0x20000800
     fb8:	00000ed1 	.word	0x00000ed1
     fbc:	f3af 8000 	nop.w

00000fc0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     fc0:	b510      	push	{r4, lr}
     fc2:	b084      	sub	sp, #16
     fc4:	9001      	str	r0, [sp, #4]
     fc6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
     fc8:	f7ff fc92 	bl	8f0 <chDbgCheckClassS>

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
     fcc:	9b01      	ldr	r3, [sp, #4]
     fce:	9a00      	ldr	r2, [sp, #0]
     fd0:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
     fd2:	9b01      	ldr	r3, [sp, #4]
     fd4:	689a      	ldr	r2, [r3, #8]
     fd6:	4b19      	ldr	r3, [pc, #100]	; (103c <__ram5_size__+0x3c>)
     fd8:	699b      	ldr	r3, [r3, #24]
     fda:	689b      	ldr	r3, [r3, #8]
     fdc:	429a      	cmp	r2, r3
     fde:	d803      	bhi.n	fe8 <chSchWakeupS+0x28>
    (void) chSchReadyI(ntp);
     fe0:	9801      	ldr	r0, [sp, #4]
     fe2:	f7ff fef5 	bl	dd0 <chSchReadyI>
     fe6:	e026      	b.n	1036 <__ram5_size__+0x36>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
     fe8:	4b14      	ldr	r3, [pc, #80]	; (103c <__ram5_size__+0x3c>)
     fea:	699b      	ldr	r3, [r3, #24]
     fec:	4618      	mov	r0, r3
     fee:	f7ff feef 	bl	dd0 <chSchReadyI>
     ff2:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
     ff4:	4b11      	ldr	r3, [pc, #68]	; (103c <__ram5_size__+0x3c>)
     ff6:	9a01      	ldr	r2, [sp, #4]
     ff8:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
     ffa:	9b01      	ldr	r3, [sp, #4]
     ffc:	2201      	movs	r2, #1
     ffe:	f883 2020 	strb.w	r2, [r3, #32]
    chSysSwitch(ntp, otp);
    1002:	9803      	ldr	r0, [sp, #12]
    1004:	f7ff fc9c 	bl	940 <_dbg_trace>
    1008:	9801      	ldr	r0, [sp, #4]
    100a:	9903      	ldr	r1, [sp, #12]
    100c:	f000 fc40 	bl	1890 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    1010:	f3ef 8309 	mrs	r3, PSP
    1014:	461c      	mov	r4, r3
  return(result);
    1016:	4623      	mov	r3, r4
    1018:	9302      	str	r3, [sp, #8]
    101a:	9b02      	ldr	r3, [sp, #8]
    101c:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    1020:	9b03      	ldr	r3, [sp, #12]
    1022:	69db      	ldr	r3, [r3, #28]
    1024:	429a      	cmp	r2, r3
    1026:	d202      	bcs.n	102e <__ram5_size__+0x2e>
    1028:	4805      	ldr	r0, [pc, #20]	; (1040 <__ram5_size__+0x40>)
    102a:	f7ff fb41 	bl	6b0 <chSysHalt>
    102e:	9801      	ldr	r0, [sp, #4]
    1030:	9903      	ldr	r1, [sp, #12]
    1032:	f7ff f925 	bl	280 <_port_switch>
  }
}
    1036:	b004      	add	sp, #16
    1038:	bd10      	pop	{r4, pc}
    103a:	bf00      	nop
    103c:	20000800 	.word	0x20000800
    1040:	00004010 	.word	0x00004010
    1044:	f3af 8000 	nop.w
    1048:	f3af 8000 	nop.w
    104c:	f3af 8000 	nop.w

00001050 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
    1050:	b508      	push	{r3, lr}

  chDbgCheckClassS();
    1052:	f7ff fc4d 	bl	8f0 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
    1056:	f7ff fe63 	bl	d20 <chSchIsRescRequiredI>
    105a:	4603      	mov	r3, r0
    105c:	2b00      	cmp	r3, #0
    105e:	d001      	beq.n	1064 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
    1060:	f000 f81e 	bl	10a0 <chSchDoRescheduleAhead>
  }
}
    1064:	bd08      	pop	{r3, pc}
    1066:	bf00      	nop
    1068:	f3af 8000 	nop.w
    106c:	f3af 8000 	nop.w

00001070 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
    1070:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
    1072:	4b09      	ldr	r3, [pc, #36]	; (1098 <chSchIsPreemptionRequired+0x28>)
    1074:	681b      	ldr	r3, [r3, #0]
    1076:	689b      	ldr	r3, [r3, #8]
    1078:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
    107a:	4b07      	ldr	r3, [pc, #28]	; (1098 <chSchIsPreemptionRequired+0x28>)
    107c:	699b      	ldr	r3, [r3, #24]
    107e:	689b      	ldr	r3, [r3, #8]
    1080:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
    1082:	9a01      	ldr	r2, [sp, #4]
    1084:	9b00      	ldr	r3, [sp, #0]
    1086:	429a      	cmp	r2, r3
    1088:	bf94      	ite	ls
    108a:	2300      	movls	r3, #0
    108c:	2301      	movhi	r3, #1
    108e:	b2db      	uxtb	r3, r3
#endif
}
    1090:	4618      	mov	r0, r3
    1092:	b002      	add	sp, #8
    1094:	4770      	bx	lr
    1096:	bf00      	nop
    1098:	20000800 	.word	0x20000800
    109c:	f3af 8000 	nop.w

000010a0 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
    10a0:	b510      	push	{r4, lr}
    10a2:	b084      	sub	sp, #16
  thread_t *otp, *cp;

  otp = currp;
    10a4:	4b25      	ldr	r3, [pc, #148]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10a6:	699b      	ldr	r3, [r3, #24]
    10a8:	9302      	str	r3, [sp, #8]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
    10aa:	4824      	ldr	r0, [pc, #144]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10ac:	f7ff fe10 	bl	cd0 <queue_fifo_remove>
    10b0:	4602      	mov	r2, r0
    10b2:	4b22      	ldr	r3, [pc, #136]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10b4:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
    10b6:	4b21      	ldr	r3, [pc, #132]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10b8:	699b      	ldr	r3, [r3, #24]
    10ba:	2201      	movs	r2, #1
    10bc:	f883 2020 	strb.w	r2, [r3, #32]

  otp->p_state = CH_STATE_READY;
    10c0:	9b02      	ldr	r3, [sp, #8]
    10c2:	2200      	movs	r2, #0
    10c4:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
    10c8:	4b1c      	ldr	r3, [pc, #112]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10ca:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
    10cc:	9b03      	ldr	r3, [sp, #12]
    10ce:	681b      	ldr	r3, [r3, #0]
    10d0:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio > otp->p_prio);
    10d2:	9b03      	ldr	r3, [sp, #12]
    10d4:	689a      	ldr	r2, [r3, #8]
    10d6:	9b02      	ldr	r3, [sp, #8]
    10d8:	689b      	ldr	r3, [r3, #8]
    10da:	429a      	cmp	r2, r3
    10dc:	d8f6      	bhi.n	10cc <chSchDoRescheduleAhead+0x2c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
    10de:	9b02      	ldr	r3, [sp, #8]
    10e0:	9a03      	ldr	r2, [sp, #12]
    10e2:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
    10e4:	9b03      	ldr	r3, [sp, #12]
    10e6:	685a      	ldr	r2, [r3, #4]
    10e8:	9b02      	ldr	r3, [sp, #8]
    10ea:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
    10ec:	9b02      	ldr	r3, [sp, #8]
    10ee:	685b      	ldr	r3, [r3, #4]
    10f0:	9a02      	ldr	r2, [sp, #8]
    10f2:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
    10f4:	9b03      	ldr	r3, [sp, #12]
    10f6:	9a02      	ldr	r2, [sp, #8]
    10f8:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
    10fa:	9802      	ldr	r0, [sp, #8]
    10fc:	f7ff fc20 	bl	940 <_dbg_trace>
    1100:	4b0e      	ldr	r3, [pc, #56]	; (113c <chSchDoRescheduleAhead+0x9c>)
    1102:	699b      	ldr	r3, [r3, #24]
    1104:	4618      	mov	r0, r3
    1106:	9902      	ldr	r1, [sp, #8]
    1108:	f000 fbc2 	bl	1890 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    110c:	f3ef 8309 	mrs	r3, PSP
    1110:	461c      	mov	r4, r3
  return(result);
    1112:	4623      	mov	r3, r4
    1114:	9301      	str	r3, [sp, #4]
    1116:	9b01      	ldr	r3, [sp, #4]
    1118:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    111c:	9b02      	ldr	r3, [sp, #8]
    111e:	69db      	ldr	r3, [r3, #28]
    1120:	429a      	cmp	r2, r3
    1122:	d202      	bcs.n	112a <chSchDoRescheduleAhead+0x8a>
    1124:	4806      	ldr	r0, [pc, #24]	; (1140 <chSchDoRescheduleAhead+0xa0>)
    1126:	f7ff fac3 	bl	6b0 <chSysHalt>
    112a:	4b04      	ldr	r3, [pc, #16]	; (113c <chSchDoRescheduleAhead+0x9c>)
    112c:	699b      	ldr	r3, [r3, #24]
    112e:	4618      	mov	r0, r3
    1130:	9902      	ldr	r1, [sp, #8]
    1132:	f7ff f8a5 	bl	280 <_port_switch>
}
    1136:	b004      	add	sp, #16
    1138:	bd10      	pop	{r4, pc}
    113a:	bf00      	nop
    113c:	20000800 	.word	0x20000800
    1140:	00004010 	.word	0x00004010
    1144:	f3af 8000 	nop.w
    1148:	f3af 8000 	nop.w
    114c:	f3af 8000 	nop.w

00001150 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    1150:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
    1152:	f7ff ffa5 	bl	10a0 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
    1156:	bd08      	pop	{r3, pc}
    1158:	f3af 8000 	nop.w
    115c:	f3af 8000 	nop.w

00001160 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1160:	b082      	sub	sp, #8
    1162:	2320      	movs	r3, #32
    1164:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    1166:	9b01      	ldr	r3, [sp, #4]
    1168:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    116c:	b002      	add	sp, #8
    116e:	4770      	bx	lr

00001170 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1170:	b082      	sub	sp, #8
    1172:	2300      	movs	r3, #0
    1174:	9301      	str	r3, [sp, #4]
    1176:	9b01      	ldr	r3, [sp, #4]
    1178:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    117c:	b002      	add	sp, #8
    117e:	4770      	bx	lr

00001180 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
    1180:	b082      	sub	sp, #8
    1182:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
    1184:	9b01      	ldr	r3, [sp, #4]
    1186:	9a01      	ldr	r2, [sp, #4]
    1188:	601a      	str	r2, [r3, #0]
}
    118a:	b002      	add	sp, #8
    118c:	4770      	bx	lr
    118e:	bf00      	nop

00001190 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
    1190:	b082      	sub	sp, #8
    1192:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
    1194:	9b01      	ldr	r3, [sp, #4]
    1196:	681a      	ldr	r2, [r3, #0]
    1198:	9b01      	ldr	r3, [sp, #4]
    119a:	429a      	cmp	r2, r3
    119c:	bf0c      	ite	eq
    119e:	2300      	moveq	r3, #0
    11a0:	2301      	movne	r3, #1
    11a2:	b2db      	uxtb	r3, r3
}
    11a4:	4618      	mov	r0, r3
    11a6:	b002      	add	sp, #8
    11a8:	4770      	bx	lr
    11aa:	bf00      	nop
    11ac:	f3af 8000 	nop.w

000011b0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    11b0:	b082      	sub	sp, #8
    11b2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    11b4:	9b01      	ldr	r3, [sp, #4]
    11b6:	9a01      	ldr	r2, [sp, #4]
    11b8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    11ba:	9b01      	ldr	r3, [sp, #4]
    11bc:	9a01      	ldr	r2, [sp, #4]
    11be:	605a      	str	r2, [r3, #4]
}
    11c0:	b002      	add	sp, #8
    11c2:	4770      	bx	lr
    11c4:	f3af 8000 	nop.w
    11c8:	f3af 8000 	nop.w
    11cc:	f3af 8000 	nop.w

000011d0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
    11d0:	b082      	sub	sp, #8
    11d2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
    11d4:	9b01      	ldr	r3, [sp, #4]
    11d6:	681a      	ldr	r2, [r3, #0]
    11d8:	9b01      	ldr	r3, [sp, #4]
    11da:	429a      	cmp	r2, r3
    11dc:	bf0c      	ite	eq
    11de:	2300      	moveq	r3, #0
    11e0:	2301      	movne	r3, #1
    11e2:	b2db      	uxtb	r3, r3
}
    11e4:	4618      	mov	r0, r3
    11e6:	b002      	add	sp, #8
    11e8:	4770      	bx	lr
    11ea:	bf00      	nop
    11ec:	f3af 8000 	nop.w

000011f0 <list_remove>:

  tp->p_next = tlp->p_next;
  tlp->p_next = tp;
}

static inline thread_t *list_remove(threads_list_t *tlp) {
    11f0:	b084      	sub	sp, #16
    11f2:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
    11f4:	9b01      	ldr	r3, [sp, #4]
    11f6:	681b      	ldr	r3, [r3, #0]
    11f8:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
    11fa:	9b03      	ldr	r3, [sp, #12]
    11fc:	681a      	ldr	r2, [r3, #0]
    11fe:	9b01      	ldr	r3, [sp, #4]
    1200:	601a      	str	r2, [r3, #0]

  return tp;
    1202:	9b03      	ldr	r3, [sp, #12]
}
    1204:	4618      	mov	r0, r3
    1206:	b004      	add	sp, #16
    1208:	4770      	bx	lr
    120a:	bf00      	nop
    120c:	f3af 8000 	nop.w

00001210 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
    1210:	b082      	sub	sp, #8
    1212:	9001      	str	r0, [sp, #4]
    1214:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
    1216:	9b01      	ldr	r3, [sp, #4]
    1218:	9a00      	ldr	r2, [sp, #0]
    121a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
    121c:	9b00      	ldr	r3, [sp, #0]
    121e:	685a      	ldr	r2, [r3, #4]
    1220:	9b01      	ldr	r3, [sp, #4]
    1222:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    1224:	9b01      	ldr	r3, [sp, #4]
    1226:	685b      	ldr	r3, [r3, #4]
    1228:	9a01      	ldr	r2, [sp, #4]
    122a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
    122c:	9b00      	ldr	r3, [sp, #0]
    122e:	9a01      	ldr	r2, [sp, #4]
    1230:	605a      	str	r2, [r3, #4]
}
    1232:	b002      	add	sp, #8
    1234:	4770      	bx	lr
    1236:	bf00      	nop
    1238:	f3af 8000 	nop.w
    123c:	f3af 8000 	nop.w

00001240 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
    1240:	b084      	sub	sp, #16
    1242:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
    1244:	9b01      	ldr	r3, [sp, #4]
    1246:	681b      	ldr	r3, [r3, #0]
    1248:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
    124a:	9b03      	ldr	r3, [sp, #12]
    124c:	681a      	ldr	r2, [r3, #0]
    124e:	9b01      	ldr	r3, [sp, #4]
    1250:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1252:	9b01      	ldr	r3, [sp, #4]
    1254:	681b      	ldr	r3, [r3, #0]
    1256:	9a01      	ldr	r2, [sp, #4]
    1258:	605a      	str	r2, [r3, #4]

  return tp;
    125a:	9b03      	ldr	r3, [sp, #12]
}
    125c:	4618      	mov	r0, r3
    125e:	b004      	add	sp, #16
    1260:	4770      	bx	lr
    1262:	bf00      	nop
    1264:	f3af 8000 	nop.w
    1268:	f3af 8000 	nop.w
    126c:	f3af 8000 	nop.w

00001270 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1270:	b508      	push	{r3, lr}

  port_lock();
    1272:	f7ff ff75 	bl	1160 <port_lock>
  _stats_start_measure_crit_thd();
    1276:	f000 fb2b 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    127a:	f7ff fa81 	bl	780 <_dbg_check_lock>
}
    127e:	bd08      	pop	{r3, pc}

00001280 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1280:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1282:	f7ff fa95 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1286:	f000 fb2b 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    128a:	4b09      	ldr	r3, [pc, #36]	; (12b0 <chSysUnlock+0x30>)
    128c:	681a      	ldr	r2, [r3, #0]
    128e:	4b08      	ldr	r3, [pc, #32]	; (12b0 <chSysUnlock+0x30>)
    1290:	429a      	cmp	r2, r3
    1292:	d00a      	beq.n	12aa <chSysUnlock+0x2a>
    1294:	4b06      	ldr	r3, [pc, #24]	; (12b0 <chSysUnlock+0x30>)
    1296:	699b      	ldr	r3, [r3, #24]
    1298:	689a      	ldr	r2, [r3, #8]
    129a:	4b05      	ldr	r3, [pc, #20]	; (12b0 <chSysUnlock+0x30>)
    129c:	681b      	ldr	r3, [r3, #0]
    129e:	689b      	ldr	r3, [r3, #8]
    12a0:	429a      	cmp	r2, r3
    12a2:	d202      	bcs.n	12aa <chSysUnlock+0x2a>
    12a4:	4803      	ldr	r0, [pc, #12]	; (12b4 <chSysUnlock+0x34>)
    12a6:	f7ff fa03 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    12aa:	f7ff ff61 	bl	1170 <port_unlock>
}
    12ae:	bd08      	pop	{r3, pc}
    12b0:	20000800 	.word	0x20000800
    12b4:	00004070 	.word	0x00004070
    12b8:	f3af 8000 	nop.w
    12bc:	f3af 8000 	nop.w

000012c0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
    12c0:	b500      	push	{lr}
    12c2:	b083      	sub	sp, #12
    12c4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
    12c6:	9b01      	ldr	r3, [sp, #4]
    12c8:	2b00      	cmp	r3, #0
    12ca:	d102      	bne.n	12d2 <chThdSleepS+0x12>
    12cc:	4804      	ldr	r0, [pc, #16]	; (12e0 <chThdSleepS+0x20>)
    12ce:	f7ff f9ef 	bl	6b0 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
    12d2:	2008      	movs	r0, #8
    12d4:	9901      	ldr	r1, [sp, #4]
    12d6:	f7ff fe3b 	bl	f50 <chSchGoSleepTimeoutS>
}
    12da:	b003      	add	sp, #12
    12dc:	f85d fb04 	ldr.w	pc, [sp], #4
    12e0:	000040a0 	.word	0x000040a0
    12e4:	f3af 8000 	nop.w
    12e8:	f3af 8000 	nop.w
    12ec:	f3af 8000 	nop.w

000012f0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    12f0:	b500      	push	{lr}
    12f2:	b085      	sub	sp, #20
    12f4:	9001      	str	r0, [sp, #4]
    12f6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
    12f8:	9801      	ldr	r0, [sp, #4]
    12fa:	f7ff ff69 	bl	11d0 <queue_notempty>
    12fe:	4603      	mov	r3, r0
    1300:	f083 0301 	eor.w	r3, r3, #1
    1304:	b2db      	uxtb	r3, r3
    1306:	2b00      	cmp	r3, #0
    1308:	d002      	beq.n	1310 <chThdDoDequeueNextI+0x20>
    130a:	480c      	ldr	r0, [pc, #48]	; (133c <chThdDoDequeueNextI+0x4c>)
    130c:	f7ff f9d0 	bl	6b0 <chSysHalt>

  tp = queue_fifo_remove(tqp);
    1310:	9801      	ldr	r0, [sp, #4]
    1312:	f7ff ff95 	bl	1240 <queue_fifo_remove>
    1316:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
    1318:	9b03      	ldr	r3, [sp, #12]
    131a:	f893 3020 	ldrb.w	r3, [r3, #32]
    131e:	2b04      	cmp	r3, #4
    1320:	d002      	beq.n	1328 <chThdDoDequeueNextI+0x38>
    1322:	4806      	ldr	r0, [pc, #24]	; (133c <chThdDoDequeueNextI+0x4c>)
    1324:	f7ff f9c4 	bl	6b0 <chSysHalt>

  tp->p_u.rdymsg = msg;
    1328:	9b03      	ldr	r3, [sp, #12]
    132a:	9a00      	ldr	r2, [sp, #0]
    132c:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
    132e:	9803      	ldr	r0, [sp, #12]
    1330:	f7ff fd4e 	bl	dd0 <chSchReadyI>
}
    1334:	b005      	add	sp, #20
    1336:	f85d fb04 	ldr.w	pc, [sp], #4
    133a:	bf00      	nop
    133c:	000040d0 	.word	0x000040d0

00001340 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
    1340:	b500      	push	{lr}
    1342:	b083      	sub	sp, #12
    1344:	9001      	str	r0, [sp, #4]
    1346:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
    1348:	9b01      	ldr	r3, [sp, #4]
    134a:	9a00      	ldr	r2, [sp, #0]
    134c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
    134e:	9b01      	ldr	r3, [sp, #4]
    1350:	2202      	movs	r2, #2
    1352:	f883 2020 	strb.w	r2, [r3, #32]
  tp->p_flags = CH_FLAG_MODE_STATIC;
    1356:	9b01      	ldr	r3, [sp, #4]
    1358:	2200      	movs	r2, #0
    135a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
    135e:	9b01      	ldr	r3, [sp, #4]
    1360:	9a00      	ldr	r2, [sp, #0]
    1362:	641a      	str	r2, [r3, #64]	; 0x40
  tp->p_mtxlist = NULL;
    1364:	9b01      	ldr	r3, [sp, #4]
    1366:	2200      	movs	r2, #0
    1368:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
    136a:	9b01      	ldr	r3, [sp, #4]
    136c:	2200      	movs	r2, #0
    136e:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
    1370:	9b01      	ldr	r3, [sp, #4]
    1372:	2201      	movs	r2, #1
    1374:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
    1378:	9b01      	ldr	r3, [sp, #4]
    137a:	2200      	movs	r2, #0
    137c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
    137e:	9b01      	ldr	r3, [sp, #4]
    1380:	4a15      	ldr	r2, [pc, #84]	; (13d8 <_thread_init+0x98>)
    1382:	611a      	str	r2, [r3, #16]
    1384:	4b14      	ldr	r3, [pc, #80]	; (13d8 <_thread_init+0x98>)
    1386:	695a      	ldr	r2, [r3, #20]
    1388:	9b01      	ldr	r3, [sp, #4]
    138a:	615a      	str	r2, [r3, #20]
    138c:	9b01      	ldr	r3, [sp, #4]
    138e:	695b      	ldr	r3, [r3, #20]
    1390:	9a01      	ldr	r2, [sp, #4]
    1392:	611a      	str	r2, [r3, #16]
    1394:	4b10      	ldr	r3, [pc, #64]	; (13d8 <_thread_init+0x98>)
    1396:	9a01      	ldr	r2, [sp, #4]
    1398:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
    139a:	9b01      	ldr	r3, [sp, #4]
    139c:	3328      	adds	r3, #40	; 0x28
    139e:	4618      	mov	r0, r3
    13a0:	f7ff feee 	bl	1180 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
    13a4:	9b01      	ldr	r3, [sp, #4]
    13a6:	332c      	adds	r3, #44	; 0x2c
    13a8:	4618      	mov	r0, r3
    13aa:	f7ff ff01 	bl	11b0 <queue_init>
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
    13ae:	9b01      	ldr	r3, [sp, #4]
    13b0:	f103 0260 	add.w	r2, r3, #96	; 0x60
    13b4:	9b01      	ldr	r3, [sp, #4]
    13b6:	61da      	str	r2, [r3, #28]
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->p_stats);
    13b8:	9b01      	ldr	r3, [sp, #4]
    13ba:	3348      	adds	r3, #72	; 0x48
    13bc:	4618      	mov	r0, r3
    13be:	f000 f9e7 	bl	1790 <chTMObjectInit>
  chTMStartMeasurementX(&tp->p_stats);
    13c2:	9b01      	ldr	r3, [sp, #4]
    13c4:	3348      	adds	r3, #72	; 0x48
    13c6:	4618      	mov	r0, r3
    13c8:	f000 f9fa 	bl	17c0 <chTMStartMeasurementX>
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
    13cc:	9b01      	ldr	r3, [sp, #4]
}
    13ce:	4618      	mov	r0, r3
    13d0:	b003      	add	sp, #12
    13d2:	f85d fb04 	ldr.w	pc, [sp], #4
    13d6:	bf00      	nop
    13d8:	20000800 	.word	0x20000800
    13dc:	f3af 8000 	nop.w

000013e0 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
    13e0:	b084      	sub	sp, #16
    13e2:	9003      	str	r0, [sp, #12]
    13e4:	9102      	str	r1, [sp, #8]
    13e6:	4613      	mov	r3, r2
    13e8:	f88d 3007 	strb.w	r3, [sp, #7]

  while (startp < endp) {
    13ec:	e005      	b.n	13fa <_thread_memfill+0x1a>
    *startp++ = v;
    13ee:	9b03      	ldr	r3, [sp, #12]
    13f0:	1c5a      	adds	r2, r3, #1
    13f2:	9203      	str	r2, [sp, #12]
    13f4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    13f8:	701a      	strb	r2, [r3, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    13fa:	9a03      	ldr	r2, [sp, #12]
    13fc:	9b02      	ldr	r3, [sp, #8]
    13fe:	429a      	cmp	r2, r3
    1400:	d3f5      	bcc.n	13ee <_thread_memfill+0xe>
    *startp++ = v;
  }
}
    1402:	b004      	add	sp, #16
    1404:	4770      	bx	lr
    1406:	bf00      	nop
    1408:	f3af 8000 	nop.w
    140c:	f3af 8000 	nop.w

00001410 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
    1410:	b500      	push	{lr}
    1412:	b087      	sub	sp, #28
    1414:	9003      	str	r0, [sp, #12]
    1416:	9102      	str	r1, [sp, #8]
    1418:	9201      	str	r2, [sp, #4]
    141a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
    141c:	9b03      	ldr	r3, [sp, #12]
    141e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
    1420:	f7ff fa4e 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
    1424:	9b03      	ldr	r3, [sp, #12]
    1426:	2b00      	cmp	r3, #0
    1428:	d008      	beq.n	143c <chThdCreateI+0x2c>
    142a:	9b02      	ldr	r3, [sp, #8]
    142c:	2be7      	cmp	r3, #231	; 0xe7
    142e:	d905      	bls.n	143c <chThdCreateI+0x2c>
    1430:	9b01      	ldr	r3, [sp, #4]
    1432:	2b7f      	cmp	r3, #127	; 0x7f
    1434:	d802      	bhi.n	143c <chThdCreateI+0x2c>
    1436:	9b00      	ldr	r3, [sp, #0]
    1438:	2b00      	cmp	r3, #0
    143a:	d102      	bne.n	1442 <chThdCreateI+0x32>
    143c:	480e      	ldr	r0, [pc, #56]	; (1478 <chThdCreateI+0x68>)
    143e:	f7ff f937 	bl	6b0 <chSysHalt>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    1442:	9b02      	ldr	r3, [sp, #8]
    1444:	3b24      	subs	r3, #36	; 0x24
    1446:	9a03      	ldr	r2, [sp, #12]
    1448:	441a      	add	r2, r3
    144a:	9b05      	ldr	r3, [sp, #20]
    144c:	60da      	str	r2, [r3, #12]
    144e:	9b05      	ldr	r3, [sp, #20]
    1450:	68db      	ldr	r3, [r3, #12]
    1452:	9a00      	ldr	r2, [sp, #0]
    1454:	601a      	str	r2, [r3, #0]
    1456:	9b05      	ldr	r3, [sp, #20]
    1458:	68db      	ldr	r3, [r3, #12]
    145a:	9a08      	ldr	r2, [sp, #32]
    145c:	605a      	str	r2, [r3, #4]
    145e:	9b05      	ldr	r3, [sp, #20]
    1460:	68db      	ldr	r3, [r3, #12]
    1462:	4a06      	ldr	r2, [pc, #24]	; (147c <chThdCreateI+0x6c>)
    1464:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
    1466:	9805      	ldr	r0, [sp, #20]
    1468:	9901      	ldr	r1, [sp, #4]
    146a:	f7ff ff69 	bl	1340 <_thread_init>
    146e:	4603      	mov	r3, r0
}
    1470:	4618      	mov	r0, r3
    1472:	b007      	add	sp, #28
    1474:	f85d fb04 	ldr.w	pc, [sp], #4
    1478:	00004060 	.word	0x00004060
    147c:	00000291 	.word	0x00000291

00001480 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
    1480:	b500      	push	{lr}
    1482:	b089      	sub	sp, #36	; 0x24
    1484:	9005      	str	r0, [sp, #20]
    1486:	9104      	str	r1, [sp, #16]
    1488:	9203      	str	r2, [sp, #12]
    148a:	9302      	str	r3, [sp, #8]
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
    148c:	9b05      	ldr	r3, [sp, #20]
    148e:	3360      	adds	r3, #96	; 0x60
    1490:	9805      	ldr	r0, [sp, #20]
    1492:	4619      	mov	r1, r3
    1494:	22ff      	movs	r2, #255	; 0xff
    1496:	f7ff ffa3 	bl	13e0 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
    149a:	9b05      	ldr	r3, [sp, #20]
    149c:	f103 0260 	add.w	r2, r3, #96	; 0x60
    14a0:	9905      	ldr	r1, [sp, #20]
    14a2:	9b04      	ldr	r3, [sp, #16]
    14a4:	440b      	add	r3, r1
    14a6:	4610      	mov	r0, r2
    14a8:	4619      	mov	r1, r3
    14aa:	2255      	movs	r2, #85	; 0x55
    14ac:	f7ff ff98 	bl	13e0 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
    14b0:	f7ff fede 	bl	1270 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
    14b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    14b6:	9300      	str	r3, [sp, #0]
    14b8:	9805      	ldr	r0, [sp, #20]
    14ba:	9904      	ldr	r1, [sp, #16]
    14bc:	9a03      	ldr	r2, [sp, #12]
    14be:	9b02      	ldr	r3, [sp, #8]
    14c0:	f7ff ffa6 	bl	1410 <chThdCreateI>
    14c4:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
    14c6:	9807      	ldr	r0, [sp, #28]
    14c8:	2100      	movs	r1, #0
    14ca:	f7ff fd79 	bl	fc0 <chSchWakeupS>
  chSysUnlock();
    14ce:	f7ff fed7 	bl	1280 <chSysUnlock>

  return tp;
    14d2:	9b07      	ldr	r3, [sp, #28]
}
    14d4:	4618      	mov	r0, r3
    14d6:	b009      	add	sp, #36	; 0x24
    14d8:	f85d fb04 	ldr.w	pc, [sp], #4
    14dc:	f3af 8000 	nop.w

000014e0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
    14e0:	b500      	push	{lr}
    14e2:	b085      	sub	sp, #20
    14e4:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
    14e6:	9b01      	ldr	r3, [sp, #4]
    14e8:	2b7f      	cmp	r3, #127	; 0x7f
    14ea:	d902      	bls.n	14f2 <chThdSetPriority+0x12>
    14ec:	4813      	ldr	r0, [pc, #76]	; (153c <chThdSetPriority+0x5c>)
    14ee:	f7ff f8df 	bl	6b0 <chSysHalt>

  chSysLock();
    14f2:	f7ff febd 	bl	1270 <chSysLock>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
    14f6:	4b12      	ldr	r3, [pc, #72]	; (1540 <chThdSetPriority+0x60>)
    14f8:	699b      	ldr	r3, [r3, #24]
    14fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    14fc:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
    14fe:	4b10      	ldr	r3, [pc, #64]	; (1540 <chThdSetPriority+0x60>)
    1500:	699b      	ldr	r3, [r3, #24]
    1502:	689a      	ldr	r2, [r3, #8]
    1504:	4b0e      	ldr	r3, [pc, #56]	; (1540 <chThdSetPriority+0x60>)
    1506:	699b      	ldr	r3, [r3, #24]
    1508:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    150a:	429a      	cmp	r2, r3
    150c:	d005      	beq.n	151a <chThdSetPriority+0x3a>
    150e:	4b0c      	ldr	r3, [pc, #48]	; (1540 <chThdSetPriority+0x60>)
    1510:	699b      	ldr	r3, [r3, #24]
    1512:	689a      	ldr	r2, [r3, #8]
    1514:	9b01      	ldr	r3, [sp, #4]
    1516:	429a      	cmp	r2, r3
    1518:	d203      	bcs.n	1522 <chThdSetPriority+0x42>
    currp->p_prio = newprio;
    151a:	4b09      	ldr	r3, [pc, #36]	; (1540 <chThdSetPriority+0x60>)
    151c:	699b      	ldr	r3, [r3, #24]
    151e:	9a01      	ldr	r2, [sp, #4]
    1520:	609a      	str	r2, [r3, #8]
  }
  currp->p_realprio = newprio;
    1522:	4b07      	ldr	r3, [pc, #28]	; (1540 <chThdSetPriority+0x60>)
    1524:	699b      	ldr	r3, [r3, #24]
    1526:	9a01      	ldr	r2, [sp, #4]
    1528:	641a      	str	r2, [r3, #64]	; 0x40
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
    152a:	f7ff fd91 	bl	1050 <chSchRescheduleS>
  chSysUnlock();
    152e:	f7ff fea7 	bl	1280 <chSysUnlock>

  return oldprio;
    1532:	9b03      	ldr	r3, [sp, #12]
}
    1534:	4618      	mov	r0, r3
    1536:	b005      	add	sp, #20
    1538:	f85d fb04 	ldr.w	pc, [sp], #4
    153c:	00004080 	.word	0x00004080
    1540:	20000800 	.word	0x20000800
    1544:	f3af 8000 	nop.w
    1548:	f3af 8000 	nop.w
    154c:	f3af 8000 	nop.w

00001550 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
    1550:	b500      	push	{lr}
    1552:	b083      	sub	sp, #12
    1554:	9001      	str	r0, [sp, #4]

  chSysLock();
    1556:	f7ff fe8b 	bl	1270 <chSysLock>
  chThdSleepS(time);
    155a:	9801      	ldr	r0, [sp, #4]
    155c:	f7ff feb0 	bl	12c0 <chThdSleepS>
  chSysUnlock();
    1560:	f7ff fe8e 	bl	1280 <chSysUnlock>
}
    1564:	b003      	add	sp, #12
    1566:	f85d fb04 	ldr.w	pc, [sp], #4
    156a:	bf00      	nop
    156c:	f3af 8000 	nop.w

00001570 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
    1570:	b500      	push	{lr}
    1572:	b083      	sub	sp, #12
    1574:	9001      	str	r0, [sp, #4]

  chSysLock();
    1576:	f7ff fe7b 	bl	1270 <chSysLock>
  chThdExitS(msg);
    157a:	9801      	ldr	r0, [sp, #4]
    157c:	f000 f808 	bl	1590 <chThdExitS>
  /* The thread never returns here.*/
}
    1580:	b003      	add	sp, #12
    1582:	f85d fb04 	ldr.w	pc, [sp], #4
    1586:	bf00      	nop
    1588:	f3af 8000 	nop.w
    158c:	f3af 8000 	nop.w

00001590 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
    1590:	b500      	push	{lr}
    1592:	b085      	sub	sp, #20
    1594:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
    1596:	4b19      	ldr	r3, [pc, #100]	; (15fc <chThdExitS+0x6c>)
    1598:	699b      	ldr	r3, [r3, #24]
    159a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
    159c:	9b03      	ldr	r3, [sp, #12]
    159e:	9a01      	ldr	r2, [sp, #4]
    15a0:	625a      	str	r2, [r3, #36]	; 0x24
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    15a2:	e008      	b.n	15b6 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->p_waiting));
    15a4:	9b03      	ldr	r3, [sp, #12]
    15a6:	3328      	adds	r3, #40	; 0x28
    15a8:	4618      	mov	r0, r3
    15aa:	f7ff fe21 	bl	11f0 <list_remove>
    15ae:	4603      	mov	r3, r0
    15b0:	4618      	mov	r0, r3
    15b2:	f7ff fc0d 	bl	dd0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    15b6:	9b03      	ldr	r3, [sp, #12]
    15b8:	3328      	adds	r3, #40	; 0x28
    15ba:	4618      	mov	r0, r3
    15bc:	f7ff fde8 	bl	1190 <list_notempty>
    15c0:	4603      	mov	r3, r0
    15c2:	2b00      	cmp	r3, #0
    15c4:	d1ee      	bne.n	15a4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    15c6:	9b03      	ldr	r3, [sp, #12]
    15c8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    15cc:	f003 0303 	and.w	r3, r3, #3
    15d0:	2b00      	cmp	r3, #0
    15d2:	d109      	bne.n	15e8 <chThdExitS+0x58>
    REG_REMOVE(tp);
    15d4:	9b03      	ldr	r3, [sp, #12]
    15d6:	695b      	ldr	r3, [r3, #20]
    15d8:	9a03      	ldr	r2, [sp, #12]
    15da:	6912      	ldr	r2, [r2, #16]
    15dc:	611a      	str	r2, [r3, #16]
    15de:	9b03      	ldr	r3, [sp, #12]
    15e0:	691b      	ldr	r3, [r3, #16]
    15e2:	9a03      	ldr	r2, [sp, #12]
    15e4:	6952      	ldr	r2, [r2, #20]
    15e6:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
    15e8:	200f      	movs	r0, #15
    15ea:	f7ff fc31 	bl	e50 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
    15ee:	4804      	ldr	r0, [pc, #16]	; (1600 <chThdExitS+0x70>)
    15f0:	f7ff f85e 	bl	6b0 <chSysHalt>
}
    15f4:	b005      	add	sp, #20
    15f6:	f85d fb04 	ldr.w	pc, [sp], #4
    15fa:	bf00      	nop
    15fc:	20000800 	.word	0x20000800
    1600:	000040b0 	.word	0x000040b0
    1604:	f3af 8000 	nop.w
    1608:	f3af 8000 	nop.w
    160c:	f3af 8000 	nop.w

00001610 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    1610:	b500      	push	{lr}
    1612:	b085      	sub	sp, #20
    1614:	9001      	str	r0, [sp, #4]
    1616:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
    1618:	9b01      	ldr	r3, [sp, #4]
    161a:	681b      	ldr	r3, [r3, #0]
    161c:	2b00      	cmp	r3, #0
    161e:	d013      	beq.n	1648 <chThdResumeI+0x38>
    thread_t *tp = *trp;
    1620:	9b01      	ldr	r3, [sp, #4]
    1622:	681b      	ldr	r3, [r3, #0]
    1624:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
    1626:	9b03      	ldr	r3, [sp, #12]
    1628:	f893 3020 	ldrb.w	r3, [r3, #32]
    162c:	2b03      	cmp	r3, #3
    162e:	d002      	beq.n	1636 <chThdResumeI+0x26>
    1630:	4807      	ldr	r0, [pc, #28]	; (1650 <chThdResumeI+0x40>)
    1632:	f7ff f83d 	bl	6b0 <chSysHalt>
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    1636:	9b01      	ldr	r3, [sp, #4]
    1638:	2200      	movs	r2, #0
    163a:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
    163c:	9b03      	ldr	r3, [sp, #12]
    163e:	9a00      	ldr	r2, [sp, #0]
    1640:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    1642:	9803      	ldr	r0, [sp, #12]
    1644:	f7ff fbc4 	bl	dd0 <chSchReadyI>
  }
}
    1648:	b005      	add	sp, #20
    164a:	f85d fb04 	ldr.w	pc, [sp], #4
    164e:	bf00      	nop
    1650:	000040c0 	.word	0x000040c0
    1654:	f3af 8000 	nop.w
    1658:	f3af 8000 	nop.w
    165c:	f3af 8000 	nop.w

00001660 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
    1660:	b500      	push	{lr}
    1662:	b083      	sub	sp, #12
    1664:	9001      	str	r0, [sp, #4]
    1666:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
    1668:	9b00      	ldr	r3, [sp, #0]
    166a:	2b00      	cmp	r3, #0
    166c:	d102      	bne.n	1674 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
    166e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1672:	e00a      	b.n	168a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
    1674:	4b07      	ldr	r3, [pc, #28]	; (1694 <chThdEnqueueTimeoutS+0x34>)
    1676:	699b      	ldr	r3, [r3, #24]
    1678:	4618      	mov	r0, r3
    167a:	9901      	ldr	r1, [sp, #4]
    167c:	f7ff fdc8 	bl	1210 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1680:	2004      	movs	r0, #4
    1682:	9900      	ldr	r1, [sp, #0]
    1684:	f7ff fc64 	bl	f50 <chSchGoSleepTimeoutS>
    1688:	4603      	mov	r3, r0
}
    168a:	4618      	mov	r0, r3
    168c:	b003      	add	sp, #12
    168e:	f85d fb04 	ldr.w	pc, [sp], #4
    1692:	bf00      	nop
    1694:	20000800 	.word	0x20000800
    1698:	f3af 8000 	nop.w
    169c:	f3af 8000 	nop.w

000016a0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    16a0:	b500      	push	{lr}
    16a2:	b083      	sub	sp, #12
    16a4:	9001      	str	r0, [sp, #4]
    16a6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
    16a8:	9801      	ldr	r0, [sp, #4]
    16aa:	f7ff fd91 	bl	11d0 <queue_notempty>
    16ae:	4603      	mov	r3, r0
    16b0:	2b00      	cmp	r3, #0
    16b2:	d003      	beq.n	16bc <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
    16b4:	9801      	ldr	r0, [sp, #4]
    16b6:	9900      	ldr	r1, [sp, #0]
    16b8:	f7ff fe1a 	bl	12f0 <chThdDoDequeueNextI>
  }
}
    16bc:	b003      	add	sp, #12
    16be:	f85d fb04 	ldr.w	pc, [sp], #4
    16c2:	bf00      	nop
    16c4:	f3af 8000 	nop.w
    16c8:	f3af 8000 	nop.w
    16cc:	f3af 8000 	nop.w

000016d0 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
    16d0:	4b01      	ldr	r3, [pc, #4]	; (16d8 <port_rt_get_counter_value+0x8>)
    16d2:	685b      	ldr	r3, [r3, #4]
}
    16d4:	4618      	mov	r0, r3
    16d6:	4770      	bx	lr
    16d8:	e0001000 	.word	0xe0001000
    16dc:	f3af 8000 	nop.w

000016e0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
    16e0:	b084      	sub	sp, #16
    16e2:	9003      	str	r0, [sp, #12]
    16e4:	9102      	str	r1, [sp, #8]
    16e6:	9201      	str	r2, [sp, #4]

  tmp->n++;
    16e8:	9b03      	ldr	r3, [sp, #12]
    16ea:	68db      	ldr	r3, [r3, #12]
    16ec:	1c5a      	adds	r2, r3, #1
    16ee:	9b03      	ldr	r3, [sp, #12]
    16f0:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
    16f2:	9b03      	ldr	r3, [sp, #12]
    16f4:	689b      	ldr	r3, [r3, #8]
    16f6:	9a02      	ldr	r2, [sp, #8]
    16f8:	1ad2      	subs	r2, r2, r3
    16fa:	9b01      	ldr	r3, [sp, #4]
    16fc:	1ad2      	subs	r2, r2, r3
    16fe:	9b03      	ldr	r3, [sp, #12]
    1700:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
    1702:	9b03      	ldr	r3, [sp, #12]
    1704:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
    1708:	9b03      	ldr	r3, [sp, #12]
    170a:	689b      	ldr	r3, [r3, #8]
    170c:	461a      	mov	r2, r3
    170e:	f04f 0300 	mov.w	r3, #0
    1712:	1812      	adds	r2, r2, r0
    1714:	eb43 0301 	adc.w	r3, r3, r1
    1718:	9903      	ldr	r1, [sp, #12]
    171a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
    171e:	9b03      	ldr	r3, [sp, #12]
    1720:	689a      	ldr	r2, [r3, #8]
    1722:	9b03      	ldr	r3, [sp, #12]
    1724:	685b      	ldr	r3, [r3, #4]
    1726:	429a      	cmp	r2, r3
    1728:	d904      	bls.n	1734 <tm_stop+0x54>
    tmp->worst = tmp->last;
    172a:	9b03      	ldr	r3, [sp, #12]
    172c:	689a      	ldr	r2, [r3, #8]
    172e:	9b03      	ldr	r3, [sp, #12]
    1730:	605a      	str	r2, [r3, #4]
    1732:	e009      	b.n	1748 <tm_stop+0x68>
  }
  else if (tmp->last < tmp->best) {
    1734:	9b03      	ldr	r3, [sp, #12]
    1736:	689a      	ldr	r2, [r3, #8]
    1738:	9b03      	ldr	r3, [sp, #12]
    173a:	681b      	ldr	r3, [r3, #0]
    173c:	429a      	cmp	r2, r3
    173e:	d203      	bcs.n	1748 <tm_stop+0x68>
    tmp->best = tmp->last;
    1740:	9b03      	ldr	r3, [sp, #12]
    1742:	689a      	ldr	r2, [r3, #8]
    1744:	9b03      	ldr	r3, [sp, #12]
    1746:	601a      	str	r2, [r3, #0]
  }
  /*lint -restore*/
}
    1748:	b004      	add	sp, #16
    174a:	4770      	bx	lr
    174c:	f3af 8000 	nop.w

00001750 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
    1750:	b500      	push	{lr}
    1752:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
    1754:	4b0b      	ldr	r3, [pc, #44]	; (1784 <_tm_init+0x34>)
    1756:	2200      	movs	r2, #0
    1758:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
  chTMObjectInit(&tm);
    175c:	466b      	mov	r3, sp
    175e:	4618      	mov	r0, r3
    1760:	f000 f816 	bl	1790 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
    1764:	466b      	mov	r3, sp
    1766:	4618      	mov	r0, r3
    1768:	f000 f82a 	bl	17c0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
    176c:	466b      	mov	r3, sp
    176e:	4618      	mov	r0, r3
    1770:	f000 f836 	bl	17e0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
    1774:	9a02      	ldr	r2, [sp, #8]
    1776:	4b03      	ldr	r3, [pc, #12]	; (1784 <_tm_init+0x34>)
    1778:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
}
    177c:	b007      	add	sp, #28
    177e:	f85d fb04 	ldr.w	pc, [sp], #4
    1782:	bf00      	nop
    1784:	20000800 	.word	0x20000800
    1788:	f3af 8000 	nop.w
    178c:	f3af 8000 	nop.w

00001790 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
    1790:	b082      	sub	sp, #8
    1792:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
    1794:	9b01      	ldr	r3, [sp, #4]
    1796:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    179a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
    179c:	9b01      	ldr	r3, [sp, #4]
    179e:	2200      	movs	r2, #0
    17a0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
    17a2:	9b01      	ldr	r3, [sp, #4]
    17a4:	2200      	movs	r2, #0
    17a6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
    17a8:	9b01      	ldr	r3, [sp, #4]
    17aa:	2200      	movs	r2, #0
    17ac:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
    17ae:	9901      	ldr	r1, [sp, #4]
    17b0:	f04f 0200 	mov.w	r2, #0
    17b4:	f04f 0300 	mov.w	r3, #0
    17b8:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
    17bc:	b002      	add	sp, #8
    17be:	4770      	bx	lr

000017c0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
    17c0:	b500      	push	{lr}
    17c2:	b083      	sub	sp, #12
    17c4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
    17c6:	f7ff ff83 	bl	16d0 <port_rt_get_counter_value>
    17ca:	4602      	mov	r2, r0
    17cc:	9b01      	ldr	r3, [sp, #4]
    17ce:	609a      	str	r2, [r3, #8]
}
    17d0:	b003      	add	sp, #12
    17d2:	f85d fb04 	ldr.w	pc, [sp], #4
    17d6:	bf00      	nop
    17d8:	f3af 8000 	nop.w
    17dc:	f3af 8000 	nop.w

000017e0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
    17e0:	b500      	push	{lr}
    17e2:	b083      	sub	sp, #12
    17e4:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
    17e6:	f7ff ff73 	bl	16d0 <port_rt_get_counter_value>
    17ea:	4602      	mov	r2, r0
    17ec:	4b05      	ldr	r3, [pc, #20]	; (1804 <chTMStopMeasurementX+0x24>)
    17ee:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
    17f2:	9801      	ldr	r0, [sp, #4]
    17f4:	4611      	mov	r1, r2
    17f6:	461a      	mov	r2, r3
    17f8:	f7ff ff72 	bl	16e0 <tm_stop>
}
    17fc:	b003      	add	sp, #12
    17fe:	f85d fb04 	ldr.w	pc, [sp], #4
    1802:	bf00      	nop
    1804:	20000800 	.word	0x20000800
    1808:	f3af 8000 	nop.w
    180c:	f3af 8000 	nop.w

00001810 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
    1810:	b500      	push	{lr}
    1812:	b083      	sub	sp, #12
    1814:	9001      	str	r0, [sp, #4]
    1816:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
    1818:	f7ff ff5a 	bl	16d0 <port_rt_get_counter_value>
    181c:	4602      	mov	r2, r0
    181e:	9b00      	ldr	r3, [sp, #0]
    1820:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
    1822:	9b00      	ldr	r3, [sp, #0]
    1824:	689b      	ldr	r3, [r3, #8]
    1826:	9801      	ldr	r0, [sp, #4]
    1828:	4619      	mov	r1, r3
    182a:	2200      	movs	r2, #0
    182c:	f7ff ff58 	bl	16e0 <tm_stop>
}
    1830:	b003      	add	sp, #12
    1832:	f85d fb04 	ldr.w	pc, [sp], #4
    1836:	bf00      	nop
    1838:	f3af 8000 	nop.w
    183c:	f3af 8000 	nop.w

00001840 <_stats_init>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
    1840:	b508      	push	{r3, lr}

  ch.kernel_stats.n_irq = (ucnt_t)0;
    1842:	4b07      	ldr	r3, [pc, #28]	; (1860 <_stats_init+0x20>)
    1844:	2200      	movs	r2, #0
    1846:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
    184a:	4b05      	ldr	r3, [pc, #20]	; (1860 <_stats_init+0x20>)
    184c:	2200      	movs	r2, #0
    184e:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
    1852:	4804      	ldr	r0, [pc, #16]	; (1864 <_stats_init+0x24>)
    1854:	f7ff ff9c 	bl	1790 <chTMObjectInit>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
    1858:	4803      	ldr	r0, [pc, #12]	; (1868 <_stats_init+0x28>)
    185a:	f7ff ff99 	bl	1790 <chTMObjectInit>
}
    185e:	bd08      	pop	{r3, pc}
    1860:	20000800 	.word	0x20000800
    1864:	20000cb0 	.word	0x20000cb0
    1868:	20000cc8 	.word	0x20000cc8
    186c:	f3af 8000 	nop.w

00001870 <_stats_increase_irq>:
/**
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {

  ch.kernel_stats.n_irq++;
    1870:	4b03      	ldr	r3, [pc, #12]	; (1880 <_stats_increase_irq+0x10>)
    1872:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
    1876:	1c5a      	adds	r2, r3, #1
    1878:	4b01      	ldr	r3, [pc, #4]	; (1880 <_stats_increase_irq+0x10>)
    187a:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
}
    187e:	4770      	bx	lr
    1880:	20000800 	.word	0x20000800
    1884:	f3af 8000 	nop.w
    1888:	f3af 8000 	nop.w
    188c:	f3af 8000 	nop.w

00001890 <_stats_ctxswc>:
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
    1890:	b500      	push	{lr}
    1892:	b083      	sub	sp, #12
    1894:	9001      	str	r0, [sp, #4]
    1896:	9100      	str	r1, [sp, #0]

  ch.kernel_stats.n_ctxswc++;
    1898:	4b09      	ldr	r3, [pc, #36]	; (18c0 <_stats_ctxswc+0x30>)
    189a:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
    189e:	1c5a      	adds	r2, r3, #1
    18a0:	4b07      	ldr	r3, [pc, #28]	; (18c0 <_stats_ctxswc+0x30>)
    18a2:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
    18a6:	9b00      	ldr	r3, [sp, #0]
    18a8:	f103 0248 	add.w	r2, r3, #72	; 0x48
    18ac:	9b01      	ldr	r3, [sp, #4]
    18ae:	3348      	adds	r3, #72	; 0x48
    18b0:	4610      	mov	r0, r2
    18b2:	4619      	mov	r1, r3
    18b4:	f7ff ffac 	bl	1810 <chTMChainMeasurementToX>
}
    18b8:	b003      	add	sp, #12
    18ba:	f85d fb04 	ldr.w	pc, [sp], #4
    18be:	bf00      	nop
    18c0:	20000800 	.word	0x20000800
    18c4:	f3af 8000 	nop.w
    18c8:	f3af 8000 	nop.w
    18cc:	f3af 8000 	nop.w

000018d0 <_stats_start_measure_crit_thd>:

/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {
    18d0:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
    18d2:	4802      	ldr	r0, [pc, #8]	; (18dc <_stats_start_measure_crit_thd+0xc>)
    18d4:	f7ff ff74 	bl	17c0 <chTMStartMeasurementX>
}
    18d8:	bd08      	pop	{r3, pc}
    18da:	bf00      	nop
    18dc:	20000cb0 	.word	0x20000cb0

000018e0 <_stats_stop_measure_crit_thd>:

/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {
    18e0:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
    18e2:	4802      	ldr	r0, [pc, #8]	; (18ec <_stats_stop_measure_crit_thd+0xc>)
    18e4:	f7ff ff7c 	bl	17e0 <chTMStopMeasurementX>
}
    18e8:	bd08      	pop	{r3, pc}
    18ea:	bf00      	nop
    18ec:	20000cb0 	.word	0x20000cb0

000018f0 <_stats_start_measure_crit_isr>:

/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {
    18f0:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
    18f2:	4802      	ldr	r0, [pc, #8]	; (18fc <_stats_start_measure_crit_isr+0xc>)
    18f4:	f7ff ff64 	bl	17c0 <chTMStartMeasurementX>
}
    18f8:	bd08      	pop	{r3, pc}
    18fa:	bf00      	nop
    18fc:	20000cc8 	.word	0x20000cc8

00001900 <_stats_stop_measure_crit_isr>:

/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {
    1900:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
    1902:	4802      	ldr	r0, [pc, #8]	; (190c <_stats_stop_measure_crit_isr+0xc>)
    1904:	f7ff ff6c 	bl	17e0 <chTMStopMeasurementX>
}
    1908:	bd08      	pop	{r3, pc}
    190a:	bf00      	nop
    190c:	20000cc8 	.word	0x20000cc8

00001910 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1910:	b082      	sub	sp, #8
    1912:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1914:	9b01      	ldr	r3, [sp, #4]
    1916:	9a01      	ldr	r2, [sp, #4]
    1918:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    191a:	9b01      	ldr	r3, [sp, #4]
    191c:	9a01      	ldr	r2, [sp, #4]
    191e:	605a      	str	r2, [r3, #4]
}
    1920:	b002      	add	sp, #8
    1922:	4770      	bx	lr
    1924:	f3af 8000 	nop.w
    1928:	f3af 8000 	nop.w
    192c:	f3af 8000 	nop.w

00001930 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
    1930:	b082      	sub	sp, #8
    1932:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
    1934:	9b01      	ldr	r3, [sp, #4]
    1936:	681a      	ldr	r2, [r3, #0]
    1938:	9b01      	ldr	r3, [sp, #4]
    193a:	429a      	cmp	r2, r3
    193c:	bf14      	ite	ne
    193e:	2300      	movne	r3, #0
    1940:	2301      	moveq	r3, #1
    1942:	b2db      	uxtb	r3, r3
}
    1944:	4618      	mov	r0, r3
    1946:	b002      	add	sp, #8
    1948:	4770      	bx	lr
    194a:	bf00      	nop
    194c:	f3af 8000 	nop.w

00001950 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
    1950:	b082      	sub	sp, #8
    1952:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
    1954:	9b01      	ldr	r3, [sp, #4]
    1956:	681a      	ldr	r2, [r3, #0]
    1958:	9b01      	ldr	r3, [sp, #4]
    195a:	429a      	cmp	r2, r3
    195c:	bf0c      	ite	eq
    195e:	2300      	moveq	r3, #0
    1960:	2301      	movne	r3, #1
    1962:	b2db      	uxtb	r3, r3
}
    1964:	4618      	mov	r0, r3
    1966:	b002      	add	sp, #8
    1968:	4770      	bx	lr
    196a:	bf00      	nop
    196c:	f3af 8000 	nop.w

00001970 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
    1970:	b082      	sub	sp, #8
    1972:	9001      	str	r0, [sp, #4]
    1974:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
    1976:	9b01      	ldr	r3, [sp, #4]
    1978:	9a00      	ldr	r2, [sp, #0]
    197a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
    197c:	9b00      	ldr	r3, [sp, #0]
    197e:	685a      	ldr	r2, [r3, #4]
    1980:	9b01      	ldr	r3, [sp, #4]
    1982:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    1984:	9b01      	ldr	r3, [sp, #4]
    1986:	685b      	ldr	r3, [r3, #4]
    1988:	9a01      	ldr	r2, [sp, #4]
    198a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
    198c:	9b00      	ldr	r3, [sp, #0]
    198e:	9a01      	ldr	r2, [sp, #4]
    1990:	605a      	str	r2, [r3, #4]
}
    1992:	b002      	add	sp, #8
    1994:	4770      	bx	lr
    1996:	bf00      	nop
    1998:	f3af 8000 	nop.w
    199c:	f3af 8000 	nop.w

000019a0 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
    19a0:	b084      	sub	sp, #16
    19a2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
    19a4:	9b01      	ldr	r3, [sp, #4]
    19a6:	681b      	ldr	r3, [r3, #0]
    19a8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
    19aa:	9b03      	ldr	r3, [sp, #12]
    19ac:	681a      	ldr	r2, [r3, #0]
    19ae:	9b01      	ldr	r3, [sp, #4]
    19b0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    19b2:	9b01      	ldr	r3, [sp, #4]
    19b4:	681b      	ldr	r3, [r3, #0]
    19b6:	9a01      	ldr	r2, [sp, #4]
    19b8:	605a      	str	r2, [r3, #4]

  return tp;
    19ba:	9b03      	ldr	r3, [sp, #12]
}
    19bc:	4618      	mov	r0, r3
    19be:	b004      	add	sp, #16
    19c0:	4770      	bx	lr
    19c2:	bf00      	nop
    19c4:	f3af 8000 	nop.w
    19c8:	f3af 8000 	nop.w
    19cc:	f3af 8000 	nop.w

000019d0 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
    19d0:	b500      	push	{lr}
    19d2:	b083      	sub	sp, #12
    19d4:	9001      	str	r0, [sp, #4]
    19d6:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
    19d8:	9b01      	ldr	r3, [sp, #4]
    19da:	2b00      	cmp	r3, #0
    19dc:	d002      	beq.n	19e4 <chSemObjectInit+0x14>
    19de:	9b00      	ldr	r3, [sp, #0]
    19e0:	2b00      	cmp	r3, #0
    19e2:	da02      	bge.n	19ea <chSemObjectInit+0x1a>
    19e4:	4806      	ldr	r0, [pc, #24]	; (1a00 <chSemObjectInit+0x30>)
    19e6:	f7fe fe63 	bl	6b0 <chSysHalt>

  queue_init(&sp->s_queue);
    19ea:	9b01      	ldr	r3, [sp, #4]
    19ec:	4618      	mov	r0, r3
    19ee:	f7ff ff8f 	bl	1910 <queue_init>
  sp->s_cnt = n;
    19f2:	9b01      	ldr	r3, [sp, #4]
    19f4:	9a00      	ldr	r2, [sp, #0]
    19f6:	609a      	str	r2, [r3, #8]
}
    19f8:	b003      	add	sp, #12
    19fa:	f85d fb04 	ldr.w	pc, [sp], #4
    19fe:	bf00      	nop
    1a00:	00004110 	.word	0x00004110
    1a04:	f3af 8000 	nop.w
    1a08:	f3af 8000 	nop.w
    1a0c:	f3af 8000 	nop.w

00001a10 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
    1a10:	b500      	push	{lr}
    1a12:	b083      	sub	sp, #12
    1a14:	9001      	str	r0, [sp, #4]
    1a16:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
    1a18:	f7fe ff6a 	bl	8f0 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
    1a1c:	9b01      	ldr	r3, [sp, #4]
    1a1e:	2b00      	cmp	r3, #0
    1a20:	d102      	bne.n	1a28 <chSemWaitTimeoutS+0x18>
    1a22:	4826      	ldr	r0, [pc, #152]	; (1abc <chSemWaitTimeoutS+0xac>)
    1a24:	f7fe fe44 	bl	6b0 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
    1a28:	9b01      	ldr	r3, [sp, #4]
    1a2a:	689b      	ldr	r3, [r3, #8]
    1a2c:	2b00      	cmp	r3, #0
    1a2e:	db09      	blt.n	1a44 <chSemWaitTimeoutS+0x34>
    1a30:	9b01      	ldr	r3, [sp, #4]
    1a32:	4618      	mov	r0, r3
    1a34:	f7ff ff7c 	bl	1930 <queue_isempty>
    1a38:	4603      	mov	r3, r0
    1a3a:	f083 0301 	eor.w	r3, r3, #1
    1a3e:	b2db      	uxtb	r3, r3
    1a40:	2b00      	cmp	r3, #0
    1a42:	d010      	beq.n	1a66 <chSemWaitTimeoutS+0x56>
    1a44:	9b01      	ldr	r3, [sp, #4]
    1a46:	689b      	ldr	r3, [r3, #8]
    1a48:	2b00      	cmp	r3, #0
    1a4a:	da09      	bge.n	1a60 <chSemWaitTimeoutS+0x50>
    1a4c:	9b01      	ldr	r3, [sp, #4]
    1a4e:	4618      	mov	r0, r3
    1a50:	f7ff ff7e 	bl	1950 <queue_notempty>
    1a54:	4603      	mov	r3, r0
    1a56:	f083 0301 	eor.w	r3, r3, #1
    1a5a:	b2db      	uxtb	r3, r3
    1a5c:	2b00      	cmp	r3, #0
    1a5e:	d002      	beq.n	1a66 <chSemWaitTimeoutS+0x56>
    1a60:	4816      	ldr	r0, [pc, #88]	; (1abc <chSemWaitTimeoutS+0xac>)
    1a62:	f7fe fe25 	bl	6b0 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    1a66:	9b01      	ldr	r3, [sp, #4]
    1a68:	689b      	ldr	r3, [r3, #8]
    1a6a:	1e5a      	subs	r2, r3, #1
    1a6c:	9b01      	ldr	r3, [sp, #4]
    1a6e:	609a      	str	r2, [r3, #8]
    1a70:	9b01      	ldr	r3, [sp, #4]
    1a72:	689b      	ldr	r3, [r3, #8]
    1a74:	2b00      	cmp	r3, #0
    1a76:	da1b      	bge.n	1ab0 <chSemWaitTimeoutS+0xa0>
    if (TIME_IMMEDIATE == time) {
    1a78:	9b00      	ldr	r3, [sp, #0]
    1a7a:	2b00      	cmp	r3, #0
    1a7c:	d107      	bne.n	1a8e <chSemWaitTimeoutS+0x7e>
      sp->s_cnt++;
    1a7e:	9b01      	ldr	r3, [sp, #4]
    1a80:	689b      	ldr	r3, [r3, #8]
    1a82:	1c5a      	adds	r2, r3, #1
    1a84:	9b01      	ldr	r3, [sp, #4]
    1a86:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
    1a88:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1a8c:	e011      	b.n	1ab2 <chSemWaitTimeoutS+0xa2>
    }
    currp->p_u.wtsemp = sp;
    1a8e:	4b0c      	ldr	r3, [pc, #48]	; (1ac0 <chSemWaitTimeoutS+0xb0>)
    1a90:	699b      	ldr	r3, [r3, #24]
    1a92:	9a01      	ldr	r2, [sp, #4]
    1a94:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->s_queue);
    1a96:	4b0a      	ldr	r3, [pc, #40]	; (1ac0 <chSemWaitTimeoutS+0xb0>)
    1a98:	699a      	ldr	r2, [r3, #24]
    1a9a:	9b01      	ldr	r3, [sp, #4]
    1a9c:	4610      	mov	r0, r2
    1a9e:	4619      	mov	r1, r3
    1aa0:	f7ff ff66 	bl	1970 <queue_insert>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
    1aa4:	2005      	movs	r0, #5
    1aa6:	9900      	ldr	r1, [sp, #0]
    1aa8:	f7ff fa52 	bl	f50 <chSchGoSleepTimeoutS>
    1aac:	4603      	mov	r3, r0
    1aae:	e000      	b.n	1ab2 <chSemWaitTimeoutS+0xa2>
  }

  return MSG_OK;
    1ab0:	2300      	movs	r3, #0
}
    1ab2:	4618      	mov	r0, r3
    1ab4:	b003      	add	sp, #12
    1ab6:	f85d fb04 	ldr.w	pc, [sp], #4
    1aba:	bf00      	nop
    1abc:	00004120 	.word	0x00004120
    1ac0:	20000800 	.word	0x20000800
    1ac4:	f3af 8000 	nop.w
    1ac8:	f3af 8000 	nop.w
    1acc:	f3af 8000 	nop.w

00001ad0 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    1ad0:	b500      	push	{lr}
    1ad2:	b085      	sub	sp, #20
    1ad4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1ad6:	f7fe fef3 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(sp != NULL);
    1ada:	9b01      	ldr	r3, [sp, #4]
    1adc:	2b00      	cmp	r3, #0
    1ade:	d102      	bne.n	1ae6 <chSemSignalI+0x16>
    1ae0:	481c      	ldr	r0, [pc, #112]	; (1b54 <chSemSignalI+0x84>)
    1ae2:	f7fe fde5 	bl	6b0 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
    1ae6:	9b01      	ldr	r3, [sp, #4]
    1ae8:	689b      	ldr	r3, [r3, #8]
    1aea:	2b00      	cmp	r3, #0
    1aec:	db09      	blt.n	1b02 <chSemSignalI+0x32>
    1aee:	9b01      	ldr	r3, [sp, #4]
    1af0:	4618      	mov	r0, r3
    1af2:	f7ff ff1d 	bl	1930 <queue_isempty>
    1af6:	4603      	mov	r3, r0
    1af8:	f083 0301 	eor.w	r3, r3, #1
    1afc:	b2db      	uxtb	r3, r3
    1afe:	2b00      	cmp	r3, #0
    1b00:	d010      	beq.n	1b24 <chSemSignalI+0x54>
    1b02:	9b01      	ldr	r3, [sp, #4]
    1b04:	689b      	ldr	r3, [r3, #8]
    1b06:	2b00      	cmp	r3, #0
    1b08:	da09      	bge.n	1b1e <chSemSignalI+0x4e>
    1b0a:	9b01      	ldr	r3, [sp, #4]
    1b0c:	4618      	mov	r0, r3
    1b0e:	f7ff ff1f 	bl	1950 <queue_notempty>
    1b12:	4603      	mov	r3, r0
    1b14:	f083 0301 	eor.w	r3, r3, #1
    1b18:	b2db      	uxtb	r3, r3
    1b1a:	2b00      	cmp	r3, #0
    1b1c:	d002      	beq.n	1b24 <chSemSignalI+0x54>
    1b1e:	480d      	ldr	r0, [pc, #52]	; (1b54 <chSemSignalI+0x84>)
    1b20:	f7fe fdc6 	bl	6b0 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
    1b24:	9b01      	ldr	r3, [sp, #4]
    1b26:	689b      	ldr	r3, [r3, #8]
    1b28:	1c5a      	adds	r2, r3, #1
    1b2a:	9b01      	ldr	r3, [sp, #4]
    1b2c:	609a      	str	r2, [r3, #8]
    1b2e:	9b01      	ldr	r3, [sp, #4]
    1b30:	689b      	ldr	r3, [r3, #8]
    1b32:	2b00      	cmp	r3, #0
    1b34:	dc0a      	bgt.n	1b4c <chSemSignalI+0x7c>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    1b36:	9b01      	ldr	r3, [sp, #4]
    1b38:	4618      	mov	r0, r3
    1b3a:	f7ff ff31 	bl	19a0 <queue_fifo_remove>
    1b3e:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
    1b40:	9b03      	ldr	r3, [sp, #12]
    1b42:	2200      	movs	r2, #0
    1b44:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    1b46:	9803      	ldr	r0, [sp, #12]
    1b48:	f7ff f942 	bl	dd0 <chSchReadyI>
  }
}
    1b4c:	b005      	add	sp, #20
    1b4e:	f85d fb04 	ldr.w	pc, [sp], #4
    1b52:	bf00      	nop
    1b54:	00004140 	.word	0x00004140
    1b58:	f3af 8000 	nop.w
    1b5c:	f3af 8000 	nop.w

00001b60 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1b60:	b082      	sub	sp, #8
    1b62:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1b64:	9b01      	ldr	r3, [sp, #4]
    1b66:	9a01      	ldr	r2, [sp, #4]
    1b68:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    1b6a:	9b01      	ldr	r3, [sp, #4]
    1b6c:	9a01      	ldr	r2, [sp, #4]
    1b6e:	605a      	str	r2, [r3, #4]
}
    1b70:	b002      	add	sp, #8
    1b72:	4770      	bx	lr
    1b74:	f3af 8000 	nop.w
    1b78:	f3af 8000 	nop.w
    1b7c:	f3af 8000 	nop.w

00001b80 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
    1b80:	b500      	push	{lr}
    1b82:	b083      	sub	sp, #12
    1b84:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
    1b86:	9b01      	ldr	r3, [sp, #4]
    1b88:	2b00      	cmp	r3, #0
    1b8a:	d102      	bne.n	1b92 <chMtxObjectInit+0x12>
    1b8c:	4806      	ldr	r0, [pc, #24]	; (1ba8 <chMtxObjectInit+0x28>)
    1b8e:	f7fe fd8f 	bl	6b0 <chSysHalt>

  queue_init(&mp->m_queue);
    1b92:	9b01      	ldr	r3, [sp, #4]
    1b94:	4618      	mov	r0, r3
    1b96:	f7ff ffe3 	bl	1b60 <queue_init>
  mp->m_owner = NULL;
    1b9a:	9b01      	ldr	r3, [sp, #4]
    1b9c:	2200      	movs	r2, #0
    1b9e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
    1ba0:	b003      	add	sp, #12
    1ba2:	f85d fb04 	ldr.w	pc, [sp], #4
    1ba6:	bf00      	nop
    1ba8:	00004150 	.word	0x00004150
    1bac:	f3af 8000 	nop.w

00001bb0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    1bb0:	b500      	push	{lr}
    1bb2:	b085      	sub	sp, #20
    1bb4:	9001      	str	r0, [sp, #4]
    1bb6:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
    1bb8:	f7fe fe82 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
    1bbc:	9b01      	ldr	r3, [sp, #4]
    1bbe:	2b00      	cmp	r3, #0
    1bc0:	d102      	bne.n	1bc8 <chEvtBroadcastFlagsI+0x18>
    1bc2:	4814      	ldr	r0, [pc, #80]	; (1c14 <chEvtBroadcastFlagsI+0x64>)
    1bc4:	f7fe fd74 	bl	6b0 <chSysHalt>

  elp = esp->es_next;
    1bc8:	9b01      	ldr	r3, [sp, #4]
    1bca:	681b      	ldr	r3, [r3, #0]
    1bcc:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    1bce:	e01a      	b.n	1c06 <chEvtBroadcastFlagsI+0x56>
  /*lint -restore*/
    elp->el_flags |= flags;
    1bd0:	9b03      	ldr	r3, [sp, #12]
    1bd2:	68da      	ldr	r2, [r3, #12]
    1bd4:	9b00      	ldr	r3, [sp, #0]
    1bd6:	431a      	orrs	r2, r3
    1bd8:	9b03      	ldr	r3, [sp, #12]
    1bda:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    1bdc:	9b00      	ldr	r3, [sp, #0]
    1bde:	2b00      	cmp	r3, #0
    1be0:	d006      	beq.n	1bf0 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
    1be2:	9b03      	ldr	r3, [sp, #12]
    1be4:	68da      	ldr	r2, [r3, #12]
    1be6:	9b03      	ldr	r3, [sp, #12]
    1be8:	691b      	ldr	r3, [r3, #16]
    1bea:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    1bec:	2b00      	cmp	r3, #0
    1bee:	d007      	beq.n	1c00 <chEvtBroadcastFlagsI+0x50>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    1bf0:	9b03      	ldr	r3, [sp, #12]
    1bf2:	685a      	ldr	r2, [r3, #4]
    1bf4:	9b03      	ldr	r3, [sp, #12]
    1bf6:	689b      	ldr	r3, [r3, #8]
    1bf8:	4610      	mov	r0, r2
    1bfa:	4619      	mov	r1, r3
    1bfc:	f000 f810 	bl	1c20 <chEvtSignalI>
    }
    elp = elp->el_next;
    1c00:	9b03      	ldr	r3, [sp, #12]
    1c02:	681b      	ldr	r3, [r3, #0]
    1c04:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    1c06:	9a03      	ldr	r2, [sp, #12]
    1c08:	9b01      	ldr	r3, [sp, #4]
    1c0a:	429a      	cmp	r2, r3
    1c0c:	d1e0      	bne.n	1bd0 <chEvtBroadcastFlagsI+0x20>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
    1c0e:	b005      	add	sp, #20
    1c10:	f85d fb04 	ldr.w	pc, [sp], #4
    1c14:	00004160 	.word	0x00004160
    1c18:	f3af 8000 	nop.w
    1c1c:	f3af 8000 	nop.w

00001c20 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
    1c20:	b500      	push	{lr}
    1c22:	b083      	sub	sp, #12
    1c24:	9001      	str	r0, [sp, #4]
    1c26:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
    1c28:	f7fe fe4a 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
    1c2c:	9b01      	ldr	r3, [sp, #4]
    1c2e:	2b00      	cmp	r3, #0
    1c30:	d102      	bne.n	1c38 <chEvtSignalI+0x18>
    1c32:	4816      	ldr	r0, [pc, #88]	; (1c8c <chEvtSignalI+0x6c>)
    1c34:	f7fe fd3c 	bl	6b0 <chSysHalt>

  tp->p_epending |= events;
    1c38:	9b01      	ldr	r3, [sp, #4]
    1c3a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1c3c:	9b00      	ldr	r3, [sp, #0]
    1c3e:	431a      	orrs	r2, r3
    1c40:	9b01      	ldr	r3, [sp, #4]
    1c42:	639a      	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    1c44:	9b01      	ldr	r3, [sp, #4]
    1c46:	f893 3020 	ldrb.w	r3, [r3, #32]
    1c4a:	2b0a      	cmp	r3, #10
    1c4c:	d106      	bne.n	1c5c <chEvtSignalI+0x3c>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    1c4e:	9b01      	ldr	r3, [sp, #4]
    1c50:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1c52:	9b01      	ldr	r3, [sp, #4]
    1c54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1c56:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    1c58:	2b00      	cmp	r3, #0
    1c5a:	d10d      	bne.n	1c78 <chEvtSignalI+0x58>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
    1c5c:	9b01      	ldr	r3, [sp, #4]
    1c5e:	f893 3020 	ldrb.w	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    1c62:	2b0b      	cmp	r3, #11
    1c64:	d10e      	bne.n	1c84 <chEvtSignalI+0x64>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    1c66:	9b01      	ldr	r3, [sp, #4]
    1c68:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1c6a:	9b01      	ldr	r3, [sp, #4]
    1c6c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1c6e:	401a      	ands	r2, r3
    1c70:	9b01      	ldr	r3, [sp, #4]
    1c72:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
    1c74:	429a      	cmp	r2, r3
    1c76:	d105      	bne.n	1c84 <chEvtSignalI+0x64>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
    1c78:	9b01      	ldr	r3, [sp, #4]
    1c7a:	2200      	movs	r2, #0
    1c7c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    1c7e:	9801      	ldr	r0, [sp, #4]
    1c80:	f7ff f8a6 	bl	dd0 <chSchReadyI>
  }
}
    1c84:	b003      	add	sp, #12
    1c86:	f85d fb04 	ldr.w	pc, [sp], #4
    1c8a:	bf00      	nop
    1c8c:	00004180 	.word	0x00004180

00001c90 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1c90:	b082      	sub	sp, #8
    1c92:	2320      	movs	r3, #32
    1c94:	9301      	str	r3, [sp, #4]
    1c96:	9b01      	ldr	r3, [sp, #4]
    1c98:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1c9c:	b002      	add	sp, #8
    1c9e:	4770      	bx	lr

00001ca0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1ca0:	b082      	sub	sp, #8
    1ca2:	2300      	movs	r3, #0
    1ca4:	9301      	str	r3, [sp, #4]
    1ca6:	9b01      	ldr	r3, [sp, #4]
    1ca8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1cac:	b002      	add	sp, #8
    1cae:	4770      	bx	lr

00001cb0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1cb0:	b508      	push	{r3, lr}

  port_lock();
    1cb2:	f7ff ffed 	bl	1c90 <port_lock>
  _stats_start_measure_crit_thd();
    1cb6:	f7ff fe0b 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1cba:	f7fe fd61 	bl	780 <_dbg_check_lock>
}
    1cbe:	bd08      	pop	{r3, pc}

00001cc0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1cc0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1cc2:	f7fe fd75 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1cc6:	f7ff fe0b 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    1cca:	4b09      	ldr	r3, [pc, #36]	; (1cf0 <chSysUnlock+0x30>)
    1ccc:	681a      	ldr	r2, [r3, #0]
    1cce:	4b08      	ldr	r3, [pc, #32]	; (1cf0 <chSysUnlock+0x30>)
    1cd0:	429a      	cmp	r2, r3
    1cd2:	d00a      	beq.n	1cea <chSysUnlock+0x2a>
    1cd4:	4b06      	ldr	r3, [pc, #24]	; (1cf0 <chSysUnlock+0x30>)
    1cd6:	699b      	ldr	r3, [r3, #24]
    1cd8:	689a      	ldr	r2, [r3, #8]
    1cda:	4b05      	ldr	r3, [pc, #20]	; (1cf0 <chSysUnlock+0x30>)
    1cdc:	681b      	ldr	r3, [r3, #0]
    1cde:	689b      	ldr	r3, [r3, #8]
    1ce0:	429a      	cmp	r2, r3
    1ce2:	d202      	bcs.n	1cea <chSysUnlock+0x2a>
    1ce4:	4803      	ldr	r0, [pc, #12]	; (1cf4 <chSysUnlock+0x34>)
    1ce6:	f7fe fce3 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    1cea:	f7ff ffd9 	bl	1ca0 <port_unlock>
}
    1cee:	bd08      	pop	{r3, pc}
    1cf0:	20000800 	.word	0x20000800
    1cf4:	000041a0 	.word	0x000041a0
    1cf8:	f3af 8000 	nop.w
    1cfc:	f3af 8000 	nop.w

00001d00 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
    1d00:	b500      	push	{lr}
    1d02:	b085      	sub	sp, #20
    1d04:	9003      	str	r0, [sp, #12]
    1d06:	9102      	str	r1, [sp, #8]
    1d08:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
    1d0a:	9b03      	ldr	r3, [sp, #12]
    1d0c:	2b00      	cmp	r3, #0
    1d0e:	d005      	beq.n	1d1c <chMBObjectInit+0x1c>
    1d10:	9b02      	ldr	r3, [sp, #8]
    1d12:	2b00      	cmp	r3, #0
    1d14:	d002      	beq.n	1d1c <chMBObjectInit+0x1c>
    1d16:	9b01      	ldr	r3, [sp, #4]
    1d18:	2b00      	cmp	r3, #0
    1d1a:	dc02      	bgt.n	1d22 <chMBObjectInit+0x22>
    1d1c:	4810      	ldr	r0, [pc, #64]	; (1d60 <chMBObjectInit+0x60>)
    1d1e:	f7fe fcc7 	bl	6b0 <chSysHalt>

  mbp->mb_buffer = buf;
    1d22:	9b03      	ldr	r3, [sp, #12]
    1d24:	9a02      	ldr	r2, [sp, #8]
    1d26:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
    1d28:	9b03      	ldr	r3, [sp, #12]
    1d2a:	9a02      	ldr	r2, [sp, #8]
    1d2c:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
    1d2e:	9b03      	ldr	r3, [sp, #12]
    1d30:	9a02      	ldr	r2, [sp, #8]
    1d32:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
    1d34:	9b01      	ldr	r3, [sp, #4]
    1d36:	009b      	lsls	r3, r3, #2
    1d38:	9a02      	ldr	r2, [sp, #8]
    1d3a:	441a      	add	r2, r3
    1d3c:	9b03      	ldr	r3, [sp, #12]
    1d3e:	605a      	str	r2, [r3, #4]
  chSemObjectInit(&mbp->mb_emptysem, n);
    1d40:	9b03      	ldr	r3, [sp, #12]
    1d42:	331c      	adds	r3, #28
    1d44:	4618      	mov	r0, r3
    1d46:	9901      	ldr	r1, [sp, #4]
    1d48:	f7ff fe42 	bl	19d0 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
    1d4c:	9b03      	ldr	r3, [sp, #12]
    1d4e:	3310      	adds	r3, #16
    1d50:	4618      	mov	r0, r3
    1d52:	2100      	movs	r1, #0
    1d54:	f7ff fe3c 	bl	19d0 <chSemObjectInit>
}
    1d58:	b005      	add	sp, #20
    1d5a:	f85d fb04 	ldr.w	pc, [sp], #4
    1d5e:	bf00      	nop
    1d60:	00004190 	.word	0x00004190
    1d64:	f3af 8000 	nop.w
    1d68:	f3af 8000 	nop.w
    1d6c:	f3af 8000 	nop.w

00001d70 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    1d70:	b500      	push	{lr}
    1d72:	b087      	sub	sp, #28
    1d74:	9003      	str	r0, [sp, #12]
    1d76:	9102      	str	r1, [sp, #8]
    1d78:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
    1d7a:	f7ff ff99 	bl	1cb0 <chSysLock>
  rdymsg = chMBPostS(mbp, msg, timeout);
    1d7e:	9803      	ldr	r0, [sp, #12]
    1d80:	9902      	ldr	r1, [sp, #8]
    1d82:	9a01      	ldr	r2, [sp, #4]
    1d84:	f000 f80c 	bl	1da0 <chMBPostS>
    1d88:	9005      	str	r0, [sp, #20]
  chSysUnlock();
    1d8a:	f7ff ff99 	bl	1cc0 <chSysUnlock>

  return rdymsg;
    1d8e:	9b05      	ldr	r3, [sp, #20]
}
    1d90:	4618      	mov	r0, r3
    1d92:	b007      	add	sp, #28
    1d94:	f85d fb04 	ldr.w	pc, [sp], #4
    1d98:	f3af 8000 	nop.w
    1d9c:	f3af 8000 	nop.w

00001da0 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    1da0:	b500      	push	{lr}
    1da2:	b087      	sub	sp, #28
    1da4:	9003      	str	r0, [sp, #12]
    1da6:	9102      	str	r1, [sp, #8]
    1da8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
    1daa:	f7fe fda1 	bl	8f0 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);
    1dae:	9b03      	ldr	r3, [sp, #12]
    1db0:	2b00      	cmp	r3, #0
    1db2:	d102      	bne.n	1dba <chMBPostS+0x1a>
    1db4:	4814      	ldr	r0, [pc, #80]	; (1e08 <chMBPostS+0x68>)
    1db6:	f7fe fc7b 	bl	6b0 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
    1dba:	9b03      	ldr	r3, [sp, #12]
    1dbc:	331c      	adds	r3, #28
    1dbe:	4618      	mov	r0, r3
    1dc0:	9901      	ldr	r1, [sp, #4]
    1dc2:	f7ff fe25 	bl	1a10 <chSemWaitTimeoutS>
    1dc6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
    1dc8:	9b05      	ldr	r3, [sp, #20]
    1dca:	2b00      	cmp	r3, #0
    1dcc:	d117      	bne.n	1dfe <chMBPostS+0x5e>
    *mbp->mb_wrptr++ = msg;
    1dce:	9b03      	ldr	r3, [sp, #12]
    1dd0:	689b      	ldr	r3, [r3, #8]
    1dd2:	1d19      	adds	r1, r3, #4
    1dd4:	9a03      	ldr	r2, [sp, #12]
    1dd6:	6091      	str	r1, [r2, #8]
    1dd8:	9a02      	ldr	r2, [sp, #8]
    1dda:	601a      	str	r2, [r3, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
    1ddc:	9b03      	ldr	r3, [sp, #12]
    1dde:	689a      	ldr	r2, [r3, #8]
    1de0:	9b03      	ldr	r3, [sp, #12]
    1de2:	685b      	ldr	r3, [r3, #4]
    1de4:	429a      	cmp	r2, r3
    1de6:	d303      	bcc.n	1df0 <chMBPostS+0x50>
      mbp->mb_wrptr = mbp->mb_buffer;
    1de8:	9b03      	ldr	r3, [sp, #12]
    1dea:	681a      	ldr	r2, [r3, #0]
    1dec:	9b03      	ldr	r3, [sp, #12]
    1dee:	609a      	str	r2, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
    1df0:	9b03      	ldr	r3, [sp, #12]
    1df2:	3310      	adds	r3, #16
    1df4:	4618      	mov	r0, r3
    1df6:	f7ff fe6b 	bl	1ad0 <chSemSignalI>
    chSchRescheduleS();
    1dfa:	f7ff f929 	bl	1050 <chSchRescheduleS>
  }

  return rdymsg;
    1dfe:	9b05      	ldr	r3, [sp, #20]
}
    1e00:	4618      	mov	r0, r3
    1e02:	b007      	add	sp, #28
    1e04:	f85d fb04 	ldr.w	pc, [sp], #4
    1e08:	000041b0 	.word	0x000041b0
    1e0c:	f3af 8000 	nop.w

00001e10 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    1e10:	b500      	push	{lr}
    1e12:	b087      	sub	sp, #28
    1e14:	9003      	str	r0, [sp, #12]
    1e16:	9102      	str	r1, [sp, #8]
    1e18:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
    1e1a:	f7ff ff49 	bl	1cb0 <chSysLock>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    1e1e:	9803      	ldr	r0, [sp, #12]
    1e20:	9902      	ldr	r1, [sp, #8]
    1e22:	9a01      	ldr	r2, [sp, #4]
    1e24:	f000 f80c 	bl	1e40 <chMBFetchS>
    1e28:	9005      	str	r0, [sp, #20]
  chSysUnlock();
    1e2a:	f7ff ff49 	bl	1cc0 <chSysUnlock>

  return rdymsg;
    1e2e:	9b05      	ldr	r3, [sp, #20]
}
    1e30:	4618      	mov	r0, r3
    1e32:	b007      	add	sp, #28
    1e34:	f85d fb04 	ldr.w	pc, [sp], #4
    1e38:	f3af 8000 	nop.w
    1e3c:	f3af 8000 	nop.w

00001e40 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    1e40:	b500      	push	{lr}
    1e42:	b087      	sub	sp, #28
    1e44:	9003      	str	r0, [sp, #12]
    1e46:	9102      	str	r1, [sp, #8]
    1e48:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
    1e4a:	f7fe fd51 	bl	8f0 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
    1e4e:	9b03      	ldr	r3, [sp, #12]
    1e50:	2b00      	cmp	r3, #0
    1e52:	d002      	beq.n	1e5a <chMBFetchS+0x1a>
    1e54:	9b02      	ldr	r3, [sp, #8]
    1e56:	2b00      	cmp	r3, #0
    1e58:	d102      	bne.n	1e60 <chMBFetchS+0x20>
    1e5a:	4815      	ldr	r0, [pc, #84]	; (1eb0 <chMBFetchS+0x70>)
    1e5c:	f7fe fc28 	bl	6b0 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
    1e60:	9b03      	ldr	r3, [sp, #12]
    1e62:	3310      	adds	r3, #16
    1e64:	4618      	mov	r0, r3
    1e66:	9901      	ldr	r1, [sp, #4]
    1e68:	f7ff fdd2 	bl	1a10 <chSemWaitTimeoutS>
    1e6c:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
    1e6e:	9b05      	ldr	r3, [sp, #20]
    1e70:	2b00      	cmp	r3, #0
    1e72:	d118      	bne.n	1ea6 <chMBFetchS+0x66>
    *msgp = *mbp->mb_rdptr++;
    1e74:	9b03      	ldr	r3, [sp, #12]
    1e76:	68db      	ldr	r3, [r3, #12]
    1e78:	1d19      	adds	r1, r3, #4
    1e7a:	9a03      	ldr	r2, [sp, #12]
    1e7c:	60d1      	str	r1, [r2, #12]
    1e7e:	681a      	ldr	r2, [r3, #0]
    1e80:	9b02      	ldr	r3, [sp, #8]
    1e82:	601a      	str	r2, [r3, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
    1e84:	9b03      	ldr	r3, [sp, #12]
    1e86:	68da      	ldr	r2, [r3, #12]
    1e88:	9b03      	ldr	r3, [sp, #12]
    1e8a:	685b      	ldr	r3, [r3, #4]
    1e8c:	429a      	cmp	r2, r3
    1e8e:	d303      	bcc.n	1e98 <chMBFetchS+0x58>
      mbp->mb_rdptr = mbp->mb_buffer;
    1e90:	9b03      	ldr	r3, [sp, #12]
    1e92:	681a      	ldr	r2, [r3, #0]
    1e94:	9b03      	ldr	r3, [sp, #12]
    1e96:	60da      	str	r2, [r3, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
    1e98:	9b03      	ldr	r3, [sp, #12]
    1e9a:	331c      	adds	r3, #28
    1e9c:	4618      	mov	r0, r3
    1e9e:	f7ff fe17 	bl	1ad0 <chSemSignalI>
    chSchRescheduleS();
    1ea2:	f7ff f8d5 	bl	1050 <chSchRescheduleS>
  }

  return rdymsg;
    1ea6:	9b05      	ldr	r3, [sp, #20]
}
    1ea8:	4618      	mov	r0, r3
    1eaa:	b007      	add	sp, #28
    1eac:	f85d fb04 	ldr.w	pc, [sp], #4
    1eb0:	000041c0 	.word	0x000041c0
    1eb4:	f3af 8000 	nop.w
    1eb8:	f3af 8000 	nop.w
    1ebc:	f3af 8000 	nop.w

00001ec0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1ec0:	b082      	sub	sp, #8
    1ec2:	2320      	movs	r3, #32
    1ec4:	9301      	str	r3, [sp, #4]
    1ec6:	9b01      	ldr	r3, [sp, #4]
    1ec8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1ecc:	b002      	add	sp, #8
    1ece:	4770      	bx	lr

00001ed0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1ed0:	b082      	sub	sp, #8
    1ed2:	2300      	movs	r3, #0
    1ed4:	9301      	str	r3, [sp, #4]
    1ed6:	9b01      	ldr	r3, [sp, #4]
    1ed8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1edc:	b002      	add	sp, #8
    1ede:	4770      	bx	lr

00001ee0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1ee0:	b082      	sub	sp, #8
    1ee2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1ee4:	9b01      	ldr	r3, [sp, #4]
    1ee6:	9a01      	ldr	r2, [sp, #4]
    1ee8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    1eea:	9b01      	ldr	r3, [sp, #4]
    1eec:	9a01      	ldr	r2, [sp, #4]
    1eee:	605a      	str	r2, [r3, #4]
}
    1ef0:	b002      	add	sp, #8
    1ef2:	4770      	bx	lr
    1ef4:	f3af 8000 	nop.w
    1ef8:	f3af 8000 	nop.w
    1efc:	f3af 8000 	nop.w

00001f00 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1f00:	b508      	push	{r3, lr}

  port_lock();
    1f02:	f7ff ffdd 	bl	1ec0 <port_lock>
  _stats_start_measure_crit_thd();
    1f06:	f7ff fce3 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1f0a:	f7fe fc39 	bl	780 <_dbg_check_lock>
}
    1f0e:	bd08      	pop	{r3, pc}

00001f10 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1f10:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1f12:	f7fe fc4d 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1f16:	f7ff fce3 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    1f1a:	4b09      	ldr	r3, [pc, #36]	; (1f40 <chSysUnlock+0x30>)
    1f1c:	681a      	ldr	r2, [r3, #0]
    1f1e:	4b08      	ldr	r3, [pc, #32]	; (1f40 <chSysUnlock+0x30>)
    1f20:	429a      	cmp	r2, r3
    1f22:	d00a      	beq.n	1f3a <chSysUnlock+0x2a>
    1f24:	4b06      	ldr	r3, [pc, #24]	; (1f40 <chSysUnlock+0x30>)
    1f26:	699b      	ldr	r3, [r3, #24]
    1f28:	689a      	ldr	r2, [r3, #8]
    1f2a:	4b05      	ldr	r3, [pc, #20]	; (1f40 <chSysUnlock+0x30>)
    1f2c:	681b      	ldr	r3, [r3, #0]
    1f2e:	689b      	ldr	r3, [r3, #8]
    1f30:	429a      	cmp	r2, r3
    1f32:	d202      	bcs.n	1f3a <chSysUnlock+0x2a>
    1f34:	4803      	ldr	r0, [pc, #12]	; (1f44 <chSysUnlock+0x34>)
    1f36:	f7fe fbbb 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    1f3a:	f7ff ffc9 	bl	1ed0 <port_unlock>
}
    1f3e:	bd08      	pop	{r3, pc}
    1f40:	20000800 	.word	0x20000800
    1f44:	000041d0 	.word	0x000041d0
    1f48:	f3af 8000 	nop.w
    1f4c:	f3af 8000 	nop.w

00001f50 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
    1f50:	b500      	push	{lr}
    1f52:	b083      	sub	sp, #12
    1f54:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
    1f56:	9801      	ldr	r0, [sp, #4]
    1f58:	f7ff ffc2 	bl	1ee0 <queue_init>
}
    1f5c:	b003      	add	sp, #12
    1f5e:	f85d fb04 	ldr.w	pc, [sp], #4
    1f62:	bf00      	nop
    1f64:	f3af 8000 	nop.w
    1f68:	f3af 8000 	nop.w
    1f6c:	f3af 8000 	nop.w

00001f70 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
    1f70:	b500      	push	{lr}
    1f72:	b083      	sub	sp, #12
    1f74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1f76:	f7fe fca3 	bl	8c0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
    1f7a:	9b01      	ldr	r3, [sp, #4]
    1f7c:	689b      	ldr	r3, [r3, #8]
    1f7e:	2b00      	cmp	r3, #0
    1f80:	bf14      	ite	ne
    1f82:	2300      	movne	r3, #0
    1f84:	2301      	moveq	r3, #1
    1f86:	b2db      	uxtb	r3, r3
}
    1f88:	4618      	mov	r0, r3
    1f8a:	b003      	add	sp, #12
    1f8c:	f85d fb04 	ldr.w	pc, [sp], #4

00001f90 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
    1f90:	b500      	push	{lr}
    1f92:	b083      	sub	sp, #12
    1f94:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1f96:	f7fe fc93 	bl	8c0 <chDbgCheckClassI>

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
    1f9a:	9b01      	ldr	r3, [sp, #4]
    1f9c:	695a      	ldr	r2, [r3, #20]
    1f9e:	9b01      	ldr	r3, [sp, #4]
    1fa0:	699b      	ldr	r3, [r3, #24]
    1fa2:	429a      	cmp	r2, r3
    1fa4:	d105      	bne.n	1fb2 <chIQIsFullI+0x22>
    1fa6:	9b01      	ldr	r3, [sp, #4]
    1fa8:	689b      	ldr	r3, [r3, #8]
    1faa:	2b00      	cmp	r3, #0
    1fac:	d001      	beq.n	1fb2 <chIQIsFullI+0x22>
    1fae:	2301      	movs	r3, #1
    1fb0:	e000      	b.n	1fb4 <chIQIsFullI+0x24>
    1fb2:	2300      	movs	r3, #0
    1fb4:	f003 0301 	and.w	r3, r3, #1
    1fb8:	b2db      	uxtb	r3, r3
}
    1fba:	4618      	mov	r0, r3
    1fbc:	b003      	add	sp, #12
    1fbe:	f85d fb04 	ldr.w	pc, [sp], #4
    1fc2:	bf00      	nop
    1fc4:	f3af 8000 	nop.w
    1fc8:	f3af 8000 	nop.w
    1fcc:	f3af 8000 	nop.w

00001fd0 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
    1fd0:	b500      	push	{lr}
    1fd2:	b083      	sub	sp, #12
    1fd4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1fd6:	f7fe fc73 	bl	8c0 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    1fda:	9b01      	ldr	r3, [sp, #4]
    1fdc:	695a      	ldr	r2, [r3, #20]
    1fde:	9b01      	ldr	r3, [sp, #4]
    1fe0:	699b      	ldr	r3, [r3, #24]
    1fe2:	429a      	cmp	r2, r3
    1fe4:	d105      	bne.n	1ff2 <chOQIsEmptyI+0x22>
    1fe6:	9b01      	ldr	r3, [sp, #4]
    1fe8:	689b      	ldr	r3, [r3, #8]
    1fea:	2b00      	cmp	r3, #0
    1fec:	d001      	beq.n	1ff2 <chOQIsEmptyI+0x22>
    1fee:	2301      	movs	r3, #1
    1ff0:	e000      	b.n	1ff4 <chOQIsEmptyI+0x24>
    1ff2:	2300      	movs	r3, #0
    1ff4:	f003 0301 	and.w	r3, r3, #1
    1ff8:	b2db      	uxtb	r3, r3
}
    1ffa:	4618      	mov	r0, r3
    1ffc:	b003      	add	sp, #12
    1ffe:	f85d fb04 	ldr.w	pc, [sp], #4
    2002:	bf00      	nop
    2004:	f3af 8000 	nop.w
    2008:	f3af 8000 	nop.w
    200c:	f3af 8000 	nop.w

00002010 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
    2010:	b500      	push	{lr}
    2012:	b083      	sub	sp, #12
    2014:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    2016:	f7fe fc53 	bl	8c0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
    201a:	9b01      	ldr	r3, [sp, #4]
    201c:	689b      	ldr	r3, [r3, #8]
    201e:	2b00      	cmp	r3, #0
    2020:	bf14      	ite	ne
    2022:	2300      	movne	r3, #0
    2024:	2301      	moveq	r3, #1
    2026:	b2db      	uxtb	r3, r3
}
    2028:	4618      	mov	r0, r3
    202a:	b003      	add	sp, #12
    202c:	f85d fb04 	ldr.w	pc, [sp], #4

00002030 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
    2030:	b500      	push	{lr}
    2032:	b085      	sub	sp, #20
    2034:	9003      	str	r0, [sp, #12]
    2036:	9102      	str	r1, [sp, #8]
    2038:	9201      	str	r2, [sp, #4]
    203a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
    203c:	9b03      	ldr	r3, [sp, #12]
    203e:	4618      	mov	r0, r3
    2040:	f7ff ff86 	bl	1f50 <chThdQueueObjectInit>
  iqp->q_counter = 0;
    2044:	9b03      	ldr	r3, [sp, #12]
    2046:	2200      	movs	r2, #0
    2048:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
    204a:	9b03      	ldr	r3, [sp, #12]
    204c:	9a02      	ldr	r2, [sp, #8]
    204e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
    2050:	9b03      	ldr	r3, [sp, #12]
    2052:	9a02      	ldr	r2, [sp, #8]
    2054:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
    2056:	9b03      	ldr	r3, [sp, #12]
    2058:	9a02      	ldr	r2, [sp, #8]
    205a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
    205c:	9a02      	ldr	r2, [sp, #8]
    205e:	9b01      	ldr	r3, [sp, #4]
    2060:	441a      	add	r2, r3
    2062:	9b03      	ldr	r3, [sp, #12]
    2064:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
    2066:	9b03      	ldr	r3, [sp, #12]
    2068:	9a00      	ldr	r2, [sp, #0]
    206a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
    206c:	9b03      	ldr	r3, [sp, #12]
    206e:	9a06      	ldr	r2, [sp, #24]
    2070:	621a      	str	r2, [r3, #32]
}
    2072:	b005      	add	sp, #20
    2074:	f85d fb04 	ldr.w	pc, [sp], #4
    2078:	f3af 8000 	nop.w
    207c:	f3af 8000 	nop.w

00002080 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
    2080:	b500      	push	{lr}
    2082:	b083      	sub	sp, #12
    2084:	9001      	str	r0, [sp, #4]
    2086:	460b      	mov	r3, r1
    2088:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();
    208c:	f7fe fc18 	bl	8c0 <chDbgCheckClassI>

  if (chIQIsFullI(iqp)) {
    2090:	9801      	ldr	r0, [sp, #4]
    2092:	f7ff ff7d 	bl	1f90 <chIQIsFullI>
    2096:	4603      	mov	r3, r0
    2098:	2b00      	cmp	r3, #0
    209a:	d002      	beq.n	20a2 <chIQPutI+0x22>
    return Q_FULL;
    209c:	f06f 0303 	mvn.w	r3, #3
    20a0:	e01c      	b.n	20dc <chIQPutI+0x5c>
  }

  iqp->q_counter++;
    20a2:	9b01      	ldr	r3, [sp, #4]
    20a4:	689b      	ldr	r3, [r3, #8]
    20a6:	1c5a      	adds	r2, r3, #1
    20a8:	9b01      	ldr	r3, [sp, #4]
    20aa:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
    20ac:	9b01      	ldr	r3, [sp, #4]
    20ae:	695b      	ldr	r3, [r3, #20]
    20b0:	1c59      	adds	r1, r3, #1
    20b2:	9a01      	ldr	r2, [sp, #4]
    20b4:	6151      	str	r1, [r2, #20]
    20b6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    20ba:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
    20bc:	9b01      	ldr	r3, [sp, #4]
    20be:	695a      	ldr	r2, [r3, #20]
    20c0:	9b01      	ldr	r3, [sp, #4]
    20c2:	691b      	ldr	r3, [r3, #16]
    20c4:	429a      	cmp	r2, r3
    20c6:	d303      	bcc.n	20d0 <chIQPutI+0x50>
    iqp->q_wrptr = iqp->q_buffer;
    20c8:	9b01      	ldr	r3, [sp, #4]
    20ca:	68da      	ldr	r2, [r3, #12]
    20cc:	9b01      	ldr	r3, [sp, #4]
    20ce:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
    20d0:	9b01      	ldr	r3, [sp, #4]
    20d2:	4618      	mov	r0, r3
    20d4:	2100      	movs	r1, #0
    20d6:	f7ff fae3 	bl	16a0 <chThdDequeueNextI>

  return Q_OK;
    20da:	2300      	movs	r3, #0
}
    20dc:	4618      	mov	r0, r3
    20de:	b003      	add	sp, #12
    20e0:	f85d fb04 	ldr.w	pc, [sp], #4
    20e4:	f3af 8000 	nop.w
    20e8:	f3af 8000 	nop.w
    20ec:	f3af 8000 	nop.w

000020f0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
    20f0:	b500      	push	{lr}
    20f2:	b085      	sub	sp, #20
    20f4:	9001      	str	r0, [sp, #4]
    20f6:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
    20f8:	f7ff ff02 	bl	1f00 <chSysLock>
  if (iqp->q_notify != NULL) {
    20fc:	9b01      	ldr	r3, [sp, #4]
    20fe:	69db      	ldr	r3, [r3, #28]
    2100:	2b00      	cmp	r3, #0
    2102:	d004      	beq.n	210e <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
    2104:	9b01      	ldr	r3, [sp, #4]
    2106:	69db      	ldr	r3, [r3, #28]
    2108:	9801      	ldr	r0, [sp, #4]
    210a:	4798      	blx	r3
  }

  while (chIQIsEmptyI(iqp)) {
    210c:	e00d      	b.n	212a <chIQGetTimeout+0x3a>
    210e:	e00c      	b.n	212a <chIQGetTimeout+0x3a>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
    2110:	9b01      	ldr	r3, [sp, #4]
    2112:	4618      	mov	r0, r3
    2114:	9900      	ldr	r1, [sp, #0]
    2116:	f7ff faa3 	bl	1660 <chThdEnqueueTimeoutS>
    211a:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
    211c:	9b03      	ldr	r3, [sp, #12]
    211e:	2b00      	cmp	r3, #0
    2120:	da03      	bge.n	212a <chIQGetTimeout+0x3a>
      chSysUnlock();
    2122:	f7ff fef5 	bl	1f10 <chSysUnlock>
      return msg;
    2126:	9b03      	ldr	r3, [sp, #12]
    2128:	e020      	b.n	216c <chIQGetTimeout+0x7c>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    212a:	9801      	ldr	r0, [sp, #4]
    212c:	f7ff ff20 	bl	1f70 <chIQIsEmptyI>
    2130:	4603      	mov	r3, r0
    2132:	2b00      	cmp	r3, #0
    2134:	d1ec      	bne.n	2110 <chIQGetTimeout+0x20>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
    2136:	9b01      	ldr	r3, [sp, #4]
    2138:	689b      	ldr	r3, [r3, #8]
    213a:	1e5a      	subs	r2, r3, #1
    213c:	9b01      	ldr	r3, [sp, #4]
    213e:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
    2140:	9b01      	ldr	r3, [sp, #4]
    2142:	699b      	ldr	r3, [r3, #24]
    2144:	1c59      	adds	r1, r3, #1
    2146:	9a01      	ldr	r2, [sp, #4]
    2148:	6191      	str	r1, [r2, #24]
    214a:	781b      	ldrb	r3, [r3, #0]
    214c:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
    2150:	9b01      	ldr	r3, [sp, #4]
    2152:	699a      	ldr	r2, [r3, #24]
    2154:	9b01      	ldr	r3, [sp, #4]
    2156:	691b      	ldr	r3, [r3, #16]
    2158:	429a      	cmp	r2, r3
    215a:	d303      	bcc.n	2164 <chIQGetTimeout+0x74>
    iqp->q_rdptr = iqp->q_buffer;
    215c:	9b01      	ldr	r3, [sp, #4]
    215e:	68da      	ldr	r2, [r3, #12]
    2160:	9b01      	ldr	r3, [sp, #4]
    2162:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
    2164:	f7ff fed4 	bl	1f10 <chSysUnlock>

  return (msg_t)b;
    2168:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    216c:	4618      	mov	r0, r3
    216e:	b005      	add	sp, #20
    2170:	f85d fb04 	ldr.w	pc, [sp], #4
    2174:	f3af 8000 	nop.w
    2178:	f3af 8000 	nop.w
    217c:	f3af 8000 	nop.w

00002180 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
    2180:	b500      	push	{lr}
    2182:	b087      	sub	sp, #28
    2184:	9003      	str	r0, [sp, #12]
    2186:	9102      	str	r1, [sp, #8]
    2188:	9201      	str	r2, [sp, #4]
    218a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
    218c:	9b03      	ldr	r3, [sp, #12]
    218e:	69db      	ldr	r3, [r3, #28]
    2190:	9304      	str	r3, [sp, #16]
  size_t r = 0;
    2192:	2300      	movs	r3, #0
    2194:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
    2196:	9b01      	ldr	r3, [sp, #4]
    2198:	2b00      	cmp	r3, #0
    219a:	d102      	bne.n	21a2 <chIQReadTimeout+0x22>
    219c:	4825      	ldr	r0, [pc, #148]	; (2234 <chIQReadTimeout+0xb4>)
    219e:	f7fe fa87 	bl	6b0 <chSysHalt>

  chSysLock();
    21a2:	f7ff fead 	bl	1f00 <chSysLock>
  while (true) {
    if (nfy != NULL) {
    21a6:	9b04      	ldr	r3, [sp, #16]
    21a8:	2b00      	cmp	r3, #0
    21aa:	d003      	beq.n	21b4 <chIQReadTimeout+0x34>
      nfy(iqp);
    21ac:	9b04      	ldr	r3, [sp, #16]
    21ae:	9803      	ldr	r0, [sp, #12]
    21b0:	4798      	blx	r3
    }

    while (chIQIsEmptyI(iqp)) {
    21b2:	e00c      	b.n	21ce <chIQReadTimeout+0x4e>
    21b4:	e00b      	b.n	21ce <chIQReadTimeout+0x4e>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
    21b6:	9b03      	ldr	r3, [sp, #12]
    21b8:	4618      	mov	r0, r3
    21ba:	9900      	ldr	r1, [sp, #0]
    21bc:	f7ff fa50 	bl	1660 <chThdEnqueueTimeoutS>
    21c0:	4603      	mov	r3, r0
    21c2:	2b00      	cmp	r3, #0
    21c4:	d003      	beq.n	21ce <chIQReadTimeout+0x4e>
        chSysUnlock();
    21c6:	f7ff fea3 	bl	1f10 <chSysUnlock>
        return r;
    21ca:	9b05      	ldr	r3, [sp, #20]
    21cc:	e02e      	b.n	222c <chIQReadTimeout+0xac>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
    21ce:	9803      	ldr	r0, [sp, #12]
    21d0:	f7ff fece 	bl	1f70 <chIQIsEmptyI>
    21d4:	4603      	mov	r3, r0
    21d6:	2b00      	cmp	r3, #0
    21d8:	d1ed      	bne.n	21b6 <chIQReadTimeout+0x36>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
    21da:	9b03      	ldr	r3, [sp, #12]
    21dc:	689b      	ldr	r3, [r3, #8]
    21de:	1e5a      	subs	r2, r3, #1
    21e0:	9b03      	ldr	r3, [sp, #12]
    21e2:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
    21e4:	9b02      	ldr	r3, [sp, #8]
    21e6:	1c5a      	adds	r2, r3, #1
    21e8:	9202      	str	r2, [sp, #8]
    21ea:	9a03      	ldr	r2, [sp, #12]
    21ec:	6992      	ldr	r2, [r2, #24]
    21ee:	1c50      	adds	r0, r2, #1
    21f0:	9903      	ldr	r1, [sp, #12]
    21f2:	6188      	str	r0, [r1, #24]
    21f4:	7812      	ldrb	r2, [r2, #0]
    21f6:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
    21f8:	9b03      	ldr	r3, [sp, #12]
    21fa:	699a      	ldr	r2, [r3, #24]
    21fc:	9b03      	ldr	r3, [sp, #12]
    21fe:	691b      	ldr	r3, [r3, #16]
    2200:	429a      	cmp	r2, r3
    2202:	d303      	bcc.n	220c <chIQReadTimeout+0x8c>
      iqp->q_rdptr = iqp->q_buffer;
    2204:	9b03      	ldr	r3, [sp, #12]
    2206:	68da      	ldr	r2, [r3, #12]
    2208:	9b03      	ldr	r3, [sp, #12]
    220a:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    220c:	f7ff fe80 	bl	1f10 <chSysUnlock>

    r++;
    2210:	9b05      	ldr	r3, [sp, #20]
    2212:	3301      	adds	r3, #1
    2214:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
    2216:	9b01      	ldr	r3, [sp, #4]
    2218:	3b01      	subs	r3, #1
    221a:	9301      	str	r3, [sp, #4]
    221c:	9b01      	ldr	r3, [sp, #4]
    221e:	2b00      	cmp	r3, #0
    2220:	d101      	bne.n	2226 <chIQReadTimeout+0xa6>
      return r;
    2222:	9b05      	ldr	r3, [sp, #20]
    2224:	e002      	b.n	222c <chIQReadTimeout+0xac>
    }

    chSysLock();
    2226:	f7ff fe6b 	bl	1f00 <chSysLock>
  }
    222a:	e7bc      	b.n	21a6 <chIQReadTimeout+0x26>
}
    222c:	4618      	mov	r0, r3
    222e:	b007      	add	sp, #28
    2230:	f85d fb04 	ldr.w	pc, [sp], #4
    2234:	000041e0 	.word	0x000041e0
    2238:	f3af 8000 	nop.w
    223c:	f3af 8000 	nop.w

00002240 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
    2240:	b500      	push	{lr}
    2242:	b085      	sub	sp, #20
    2244:	9003      	str	r0, [sp, #12]
    2246:	9102      	str	r1, [sp, #8]
    2248:	9201      	str	r2, [sp, #4]
    224a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
    224c:	9b03      	ldr	r3, [sp, #12]
    224e:	4618      	mov	r0, r3
    2250:	f7ff fe7e 	bl	1f50 <chThdQueueObjectInit>
  oqp->q_counter = size;
    2254:	9b03      	ldr	r3, [sp, #12]
    2256:	9a01      	ldr	r2, [sp, #4]
    2258:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
    225a:	9b03      	ldr	r3, [sp, #12]
    225c:	9a02      	ldr	r2, [sp, #8]
    225e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
    2260:	9b03      	ldr	r3, [sp, #12]
    2262:	9a02      	ldr	r2, [sp, #8]
    2264:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
    2266:	9b03      	ldr	r3, [sp, #12]
    2268:	9a02      	ldr	r2, [sp, #8]
    226a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
    226c:	9a02      	ldr	r2, [sp, #8]
    226e:	9b01      	ldr	r3, [sp, #4]
    2270:	441a      	add	r2, r3
    2272:	9b03      	ldr	r3, [sp, #12]
    2274:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
    2276:	9b03      	ldr	r3, [sp, #12]
    2278:	9a00      	ldr	r2, [sp, #0]
    227a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
    227c:	9b03      	ldr	r3, [sp, #12]
    227e:	9a06      	ldr	r2, [sp, #24]
    2280:	621a      	str	r2, [r3, #32]
}
    2282:	b005      	add	sp, #20
    2284:	f85d fb04 	ldr.w	pc, [sp], #4
    2288:	f3af 8000 	nop.w
    228c:	f3af 8000 	nop.w

00002290 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    2290:	b500      	push	{lr}
    2292:	b087      	sub	sp, #28
    2294:	9003      	str	r0, [sp, #12]
    2296:	460b      	mov	r3, r1
    2298:	9201      	str	r2, [sp, #4]
    229a:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
    229e:	f7ff fe2f 	bl	1f00 <chSysLock>
  while (chOQIsFullI(oqp)) {
    22a2:	e00c      	b.n	22be <chOQPutTimeout+0x2e>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    22a4:	9b03      	ldr	r3, [sp, #12]
    22a6:	4618      	mov	r0, r3
    22a8:	9901      	ldr	r1, [sp, #4]
    22aa:	f7ff f9d9 	bl	1660 <chThdEnqueueTimeoutS>
    22ae:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
    22b0:	9b05      	ldr	r3, [sp, #20]
    22b2:	2b00      	cmp	r3, #0
    22b4:	da03      	bge.n	22be <chOQPutTimeout+0x2e>
      chSysUnlock();
    22b6:	f7ff fe2b 	bl	1f10 <chSysUnlock>
      return msg;
    22ba:	9b05      	ldr	r3, [sp, #20]
    22bc:	e027      	b.n	230e <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    22be:	9803      	ldr	r0, [sp, #12]
    22c0:	f7ff fea6 	bl	2010 <chOQIsFullI>
    22c4:	4603      	mov	r3, r0
    22c6:	2b00      	cmp	r3, #0
    22c8:	d1ec      	bne.n	22a4 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
    22ca:	9b03      	ldr	r3, [sp, #12]
    22cc:	689b      	ldr	r3, [r3, #8]
    22ce:	1e5a      	subs	r2, r3, #1
    22d0:	9b03      	ldr	r3, [sp, #12]
    22d2:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
    22d4:	9b03      	ldr	r3, [sp, #12]
    22d6:	695b      	ldr	r3, [r3, #20]
    22d8:	1c59      	adds	r1, r3, #1
    22da:	9a03      	ldr	r2, [sp, #12]
    22dc:	6151      	str	r1, [r2, #20]
    22de:	f89d 200b 	ldrb.w	r2, [sp, #11]
    22e2:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
    22e4:	9b03      	ldr	r3, [sp, #12]
    22e6:	695a      	ldr	r2, [r3, #20]
    22e8:	9b03      	ldr	r3, [sp, #12]
    22ea:	691b      	ldr	r3, [r3, #16]
    22ec:	429a      	cmp	r2, r3
    22ee:	d303      	bcc.n	22f8 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
    22f0:	9b03      	ldr	r3, [sp, #12]
    22f2:	68da      	ldr	r2, [r3, #12]
    22f4:	9b03      	ldr	r3, [sp, #12]
    22f6:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
    22f8:	9b03      	ldr	r3, [sp, #12]
    22fa:	69db      	ldr	r3, [r3, #28]
    22fc:	2b00      	cmp	r3, #0
    22fe:	d003      	beq.n	2308 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
    2300:	9b03      	ldr	r3, [sp, #12]
    2302:	69db      	ldr	r3, [r3, #28]
    2304:	9803      	ldr	r0, [sp, #12]
    2306:	4798      	blx	r3
  }
  chSysUnlock();
    2308:	f7ff fe02 	bl	1f10 <chSysUnlock>

  return Q_OK;
    230c:	2300      	movs	r3, #0
}
    230e:	4618      	mov	r0, r3
    2310:	b007      	add	sp, #28
    2312:	f85d fb04 	ldr.w	pc, [sp], #4
    2316:	bf00      	nop
    2318:	f3af 8000 	nop.w
    231c:	f3af 8000 	nop.w

00002320 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
    2320:	b500      	push	{lr}
    2322:	b085      	sub	sp, #20
    2324:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();
    2326:	f7fe facb 	bl	8c0 <chDbgCheckClassI>

  if (chOQIsEmptyI(oqp)) {
    232a:	9801      	ldr	r0, [sp, #4]
    232c:	f7ff fe50 	bl	1fd0 <chOQIsEmptyI>
    2330:	4603      	mov	r3, r0
    2332:	2b00      	cmp	r3, #0
    2334:	d002      	beq.n	233c <chOQGetI+0x1c>
    return Q_EMPTY;
    2336:	f06f 0302 	mvn.w	r3, #2
    233a:	e01d      	b.n	2378 <chOQGetI+0x58>
  }

  oqp->q_counter++;
    233c:	9b01      	ldr	r3, [sp, #4]
    233e:	689b      	ldr	r3, [r3, #8]
    2340:	1c5a      	adds	r2, r3, #1
    2342:	9b01      	ldr	r3, [sp, #4]
    2344:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
    2346:	9b01      	ldr	r3, [sp, #4]
    2348:	699b      	ldr	r3, [r3, #24]
    234a:	1c59      	adds	r1, r3, #1
    234c:	9a01      	ldr	r2, [sp, #4]
    234e:	6191      	str	r1, [r2, #24]
    2350:	781b      	ldrb	r3, [r3, #0]
    2352:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
    2356:	9b01      	ldr	r3, [sp, #4]
    2358:	699a      	ldr	r2, [r3, #24]
    235a:	9b01      	ldr	r3, [sp, #4]
    235c:	691b      	ldr	r3, [r3, #16]
    235e:	429a      	cmp	r2, r3
    2360:	d303      	bcc.n	236a <chOQGetI+0x4a>
    oqp->q_rdptr = oqp->q_buffer;
    2362:	9b01      	ldr	r3, [sp, #4]
    2364:	68da      	ldr	r2, [r3, #12]
    2366:	9b01      	ldr	r3, [sp, #4]
    2368:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
    236a:	9b01      	ldr	r3, [sp, #4]
    236c:	4618      	mov	r0, r3
    236e:	2100      	movs	r1, #0
    2370:	f7ff f996 	bl	16a0 <chThdDequeueNextI>

  return (msg_t)b;
    2374:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    2378:	4618      	mov	r0, r3
    237a:	b005      	add	sp, #20
    237c:	f85d fb04 	ldr.w	pc, [sp], #4

00002380 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
    2380:	b500      	push	{lr}
    2382:	b087      	sub	sp, #28
    2384:	9003      	str	r0, [sp, #12]
    2386:	9102      	str	r1, [sp, #8]
    2388:	9201      	str	r2, [sp, #4]
    238a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
    238c:	9b03      	ldr	r3, [sp, #12]
    238e:	69db      	ldr	r3, [r3, #28]
    2390:	9304      	str	r3, [sp, #16]
  size_t w = 0;
    2392:	2300      	movs	r3, #0
    2394:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
    2396:	9b01      	ldr	r3, [sp, #4]
    2398:	2b00      	cmp	r3, #0
    239a:	d102      	bne.n	23a2 <chOQWriteTimeout+0x22>
    239c:	4825      	ldr	r0, [pc, #148]	; (2434 <chOQWriteTimeout+0xb4>)
    239e:	f7fe f987 	bl	6b0 <chSysHalt>

  chSysLock();
    23a2:	f7ff fdad 	bl	1f00 <chSysLock>
  while (true) {
    while (chOQIsFullI(oqp)) {
    23a6:	e00b      	b.n	23c0 <chOQWriteTimeout+0x40>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
    23a8:	9b03      	ldr	r3, [sp, #12]
    23aa:	4618      	mov	r0, r3
    23ac:	9900      	ldr	r1, [sp, #0]
    23ae:	f7ff f957 	bl	1660 <chThdEnqueueTimeoutS>
    23b2:	4603      	mov	r3, r0
    23b4:	2b00      	cmp	r3, #0
    23b6:	d003      	beq.n	23c0 <chOQWriteTimeout+0x40>
        chSysUnlock();
    23b8:	f7ff fdaa 	bl	1f10 <chSysUnlock>
        return w;
    23bc:	9b05      	ldr	r3, [sp, #20]
    23be:	e035      	b.n	242c <chOQWriteTimeout+0xac>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
    23c0:	9803      	ldr	r0, [sp, #12]
    23c2:	f7ff fe25 	bl	2010 <chOQIsFullI>
    23c6:	4603      	mov	r3, r0
    23c8:	2b00      	cmp	r3, #0
    23ca:	d1ed      	bne.n	23a8 <chOQWriteTimeout+0x28>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
    23cc:	9b03      	ldr	r3, [sp, #12]
    23ce:	689b      	ldr	r3, [r3, #8]
    23d0:	1e5a      	subs	r2, r3, #1
    23d2:	9b03      	ldr	r3, [sp, #12]
    23d4:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
    23d6:	9b03      	ldr	r3, [sp, #12]
    23d8:	695b      	ldr	r3, [r3, #20]
    23da:	1c59      	adds	r1, r3, #1
    23dc:	9a03      	ldr	r2, [sp, #12]
    23de:	6151      	str	r1, [r2, #20]
    23e0:	9a02      	ldr	r2, [sp, #8]
    23e2:	1c51      	adds	r1, r2, #1
    23e4:	9102      	str	r1, [sp, #8]
    23e6:	7812      	ldrb	r2, [r2, #0]
    23e8:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
    23ea:	9b03      	ldr	r3, [sp, #12]
    23ec:	695a      	ldr	r2, [r3, #20]
    23ee:	9b03      	ldr	r3, [sp, #12]
    23f0:	691b      	ldr	r3, [r3, #16]
    23f2:	429a      	cmp	r2, r3
    23f4:	d303      	bcc.n	23fe <chOQWriteTimeout+0x7e>
      oqp->q_wrptr = oqp->q_buffer;
    23f6:	9b03      	ldr	r3, [sp, #12]
    23f8:	68da      	ldr	r2, [r3, #12]
    23fa:	9b03      	ldr	r3, [sp, #12]
    23fc:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
    23fe:	9b04      	ldr	r3, [sp, #16]
    2400:	2b00      	cmp	r3, #0
    2402:	d002      	beq.n	240a <chOQWriteTimeout+0x8a>
      nfy(oqp);
    2404:	9b04      	ldr	r3, [sp, #16]
    2406:	9803      	ldr	r0, [sp, #12]
    2408:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    240a:	f7ff fd81 	bl	1f10 <chSysUnlock>

    w++;
    240e:	9b05      	ldr	r3, [sp, #20]
    2410:	3301      	adds	r3, #1
    2412:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
    2414:	9b01      	ldr	r3, [sp, #4]
    2416:	3b01      	subs	r3, #1
    2418:	9301      	str	r3, [sp, #4]
    241a:	9b01      	ldr	r3, [sp, #4]
    241c:	2b00      	cmp	r3, #0
    241e:	d101      	bne.n	2424 <chOQWriteTimeout+0xa4>
      return w;
    2420:	9b05      	ldr	r3, [sp, #20]
    2422:	e003      	b.n	242c <chOQWriteTimeout+0xac>
    }
    chSysLock();
    2424:	f7ff fd6c 	bl	1f00 <chSysLock>
  }
    2428:	bf00      	nop

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
    242a:	e7c9      	b.n	23c0 <chOQWriteTimeout+0x40>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
    242c:	4618      	mov	r0, r3
    242e:	b007      	add	sp, #28
    2430:	f85d fb04 	ldr.w	pc, [sp], #4
    2434:	000041f0 	.word	0x000041f0
    2438:	f3af 8000 	nop.w
    243c:	f3af 8000 	nop.w

00002440 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2440:	b082      	sub	sp, #8
    2442:	2320      	movs	r3, #32
    2444:	9301      	str	r3, [sp, #4]
    2446:	9b01      	ldr	r3, [sp, #4]
    2448:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    244c:	b002      	add	sp, #8
    244e:	4770      	bx	lr

00002450 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2450:	b082      	sub	sp, #8
    2452:	2300      	movs	r3, #0
    2454:	9301      	str	r3, [sp, #4]
    2456:	9b01      	ldr	r3, [sp, #4]
    2458:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    245c:	b002      	add	sp, #8
    245e:	4770      	bx	lr

00002460 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    2460:	b508      	push	{r3, lr}

  port_lock();
    2462:	f7ff ffed 	bl	2440 <port_lock>
  _stats_start_measure_crit_thd();
    2466:	f7ff fa33 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    246a:	f7fe f989 	bl	780 <_dbg_check_lock>
}
    246e:	bd08      	pop	{r3, pc}

00002470 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2470:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2472:	f7fe f99d 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2476:	f7ff fa33 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    247a:	4b09      	ldr	r3, [pc, #36]	; (24a0 <chSysUnlock+0x30>)
    247c:	681a      	ldr	r2, [r3, #0]
    247e:	4b08      	ldr	r3, [pc, #32]	; (24a0 <chSysUnlock+0x30>)
    2480:	429a      	cmp	r2, r3
    2482:	d00a      	beq.n	249a <chSysUnlock+0x2a>
    2484:	4b06      	ldr	r3, [pc, #24]	; (24a0 <chSysUnlock+0x30>)
    2486:	699b      	ldr	r3, [r3, #24]
    2488:	689a      	ldr	r2, [r3, #8]
    248a:	4b05      	ldr	r3, [pc, #20]	; (24a0 <chSysUnlock+0x30>)
    248c:	681b      	ldr	r3, [r3, #0]
    248e:	689b      	ldr	r3, [r3, #8]
    2490:	429a      	cmp	r2, r3
    2492:	d202      	bcs.n	249a <chSysUnlock+0x2a>
    2494:	4803      	ldr	r0, [pc, #12]	; (24a4 <chSysUnlock+0x34>)
    2496:	f7fe f90b 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    249a:	f7ff ffd9 	bl	2450 <port_unlock>
}
    249e:	bd08      	pop	{r3, pc}
    24a0:	20000800 	.word	0x20000800
    24a4:	00004210 	.word	0x00004210
    24a8:	f3af 8000 	nop.w
    24ac:	f3af 8000 	nop.w

000024b0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
    24b0:	4b06      	ldr	r3, [pc, #24]	; (24cc <_core_init+0x1c>)
    24b2:	3307      	adds	r3, #7
    24b4:	f023 0307 	bic.w	r3, r3, #7
    24b8:	461a      	mov	r2, r3
    24ba:	4b05      	ldr	r3, [pc, #20]	; (24d0 <_core_init+0x20>)
    24bc:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
    24be:	4b05      	ldr	r3, [pc, #20]	; (24d4 <_core_init+0x24>)
    24c0:	f023 0307 	bic.w	r3, r3, #7
    24c4:	461a      	mov	r2, r3
    24c6:	4b04      	ldr	r3, [pc, #16]	; (24d8 <_core_init+0x28>)
    24c8:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
    24ca:	4770      	bx	lr
    24cc:	200012f8 	.word	0x200012f8
    24d0:	20000dd8 	.word	0x20000dd8
    24d4:	20020000 	.word	0x20020000
    24d8:	20000ddc 	.word	0x20000ddc
    24dc:	f3af 8000 	nop.w

000024e0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
    24e0:	b500      	push	{lr}
    24e2:	b085      	sub	sp, #20
    24e4:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
    24e6:	f7ff ffbb 	bl	2460 <chSysLock>
  p = chCoreAllocI(size);
    24ea:	9801      	ldr	r0, [sp, #4]
    24ec:	f000 f808 	bl	2500 <chCoreAllocI>
    24f0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
    24f2:	f7ff ffbd 	bl	2470 <chSysUnlock>

  return p;
    24f6:	9b03      	ldr	r3, [sp, #12]
}
    24f8:	4618      	mov	r0, r3
    24fa:	b005      	add	sp, #20
    24fc:	f85d fb04 	ldr.w	pc, [sp], #4

00002500 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
    2500:	b500      	push	{lr}
    2502:	b085      	sub	sp, #20
    2504:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();
    2506:	f7fe f9db 	bl	8c0 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
    250a:	9b01      	ldr	r3, [sp, #4]
    250c:	3307      	adds	r3, #7
    250e:	f023 0307 	bic.w	r3, r3, #7
    2512:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
    2514:	4b0c      	ldr	r3, [pc, #48]	; (2548 <chCoreAllocI+0x48>)
    2516:	681b      	ldr	r3, [r3, #0]
    2518:	461a      	mov	r2, r3
    251a:	4b0c      	ldr	r3, [pc, #48]	; (254c <chCoreAllocI+0x4c>)
    251c:	681b      	ldr	r3, [r3, #0]
    251e:	1ad3      	subs	r3, r2, r3
    2520:	461a      	mov	r2, r3
    2522:	9b01      	ldr	r3, [sp, #4]
    2524:	429a      	cmp	r2, r3
    2526:	d201      	bcs.n	252c <chCoreAllocI+0x2c>
  /*lint -restore*/
    return NULL;
    2528:	2300      	movs	r3, #0
    252a:	e009      	b.n	2540 <chCoreAllocI+0x40>
  }
  p = nextmem;
    252c:	4b07      	ldr	r3, [pc, #28]	; (254c <chCoreAllocI+0x4c>)
    252e:	681b      	ldr	r3, [r3, #0]
    2530:	9303      	str	r3, [sp, #12]
  nextmem += size;
    2532:	4b06      	ldr	r3, [pc, #24]	; (254c <chCoreAllocI+0x4c>)
    2534:	681a      	ldr	r2, [r3, #0]
    2536:	9b01      	ldr	r3, [sp, #4]
    2538:	441a      	add	r2, r3
    253a:	4b04      	ldr	r3, [pc, #16]	; (254c <chCoreAllocI+0x4c>)
    253c:	601a      	str	r2, [r3, #0]

  return p;
    253e:	9b03      	ldr	r3, [sp, #12]
}
    2540:	4618      	mov	r0, r3
    2542:	b005      	add	sp, #20
    2544:	f85d fb04 	ldr.w	pc, [sp], #4
    2548:	20000ddc 	.word	0x20000ddc
    254c:	20000dd8 	.word	0x20000dd8

00002550 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
    2550:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
    2552:	4b06      	ldr	r3, [pc, #24]	; (256c <_heap_init+0x1c>)
    2554:	4a06      	ldr	r2, [pc, #24]	; (2570 <_heap_init+0x20>)
    2556:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
    2558:	4b04      	ldr	r3, [pc, #16]	; (256c <_heap_init+0x1c>)
    255a:	2200      	movs	r2, #0
    255c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
    255e:	4b03      	ldr	r3, [pc, #12]	; (256c <_heap_init+0x1c>)
    2560:	2200      	movs	r2, #0
    2562:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
    2564:	4803      	ldr	r0, [pc, #12]	; (2574 <_heap_init+0x24>)
    2566:	f7ff fb0b 	bl	1b80 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
    256a:	bd08      	pop	{r3, pc}
    256c:	20000de0 	.word	0x20000de0
    2570:	000024e1 	.word	0x000024e1
    2574:	20000df0 	.word	0x20000df0
    2578:	f3af 8000 	nop.w
    257c:	f3af 8000 	nop.w

00002580 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2580:	b082      	sub	sp, #8
    2582:	2320      	movs	r3, #32
    2584:	9301      	str	r3, [sp, #4]
    2586:	9b01      	ldr	r3, [sp, #4]
    2588:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    258c:	b002      	add	sp, #8
    258e:	4770      	bx	lr

00002590 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2590:	b082      	sub	sp, #8
    2592:	2300      	movs	r3, #0
    2594:	9301      	str	r3, [sp, #4]
    2596:	9b01      	ldr	r3, [sp, #4]
    2598:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    259c:	b002      	add	sp, #8
    259e:	4770      	bx	lr

000025a0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    25a0:	b508      	push	{r3, lr}

  port_lock();
    25a2:	f7ff ffed 	bl	2580 <port_lock>
}
    25a6:	bd08      	pop	{r3, pc}
    25a8:	f3af 8000 	nop.w
    25ac:	f3af 8000 	nop.w

000025b0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    25b0:	b508      	push	{r3, lr}

  port_unlock();
    25b2:	f7ff ffed 	bl	2590 <port_unlock>
}
    25b6:	bd08      	pop	{r3, pc}
    25b8:	f3af 8000 	nop.w
    25bc:	f3af 8000 	nop.w

000025c0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
    25c0:	b510      	push	{r4, lr}
    25c2:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    25c4:	f3ef 8309 	mrs	r3, PSP
    25c8:	461c      	mov	r4, r3
  return(result);
    25ca:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
    25cc:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
    25ce:	9b01      	ldr	r3, [sp, #4]
    25d0:	3320      	adds	r3, #32
    25d2:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
    25d4:	9b01      	ldr	r3, [sp, #4]
    25d6:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    25d8:	9b00      	ldr	r3, [sp, #0]
    25da:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
    25de:	f7ff ffe7 	bl	25b0 <port_unlock_from_isr>
}
    25e2:	b002      	add	sp, #8
    25e4:	bd10      	pop	{r4, pc}
    25e6:	bf00      	nop
    25e8:	f3af 8000 	nop.w
    25ec:	f3af 8000 	nop.w

000025f0 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
    25f0:	b510      	push	{r4, lr}
    25f2:	b082      	sub	sp, #8

  port_lock_from_isr();
    25f4:	f7ff ffd4 	bl	25a0 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
    25f8:	4b13      	ldr	r3, [pc, #76]	; (2648 <_port_irq_epilogue+0x58>)
    25fa:	685b      	ldr	r3, [r3, #4]
    25fc:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    2600:	2b00      	cmp	r3, #0
    2602:	d01d      	beq.n	2640 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    2604:	f3ef 8309 	mrs	r3, PSP
    2608:	461c      	mov	r4, r3
  return(result);
    260a:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
    260c:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
    260e:	9b01      	ldr	r3, [sp, #4]
    2610:	3b20      	subs	r3, #32
    2612:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
    2614:	9b01      	ldr	r3, [sp, #4]
    2616:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    261a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
    261c:	9b01      	ldr	r3, [sp, #4]
    261e:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    2620:	9b00      	ldr	r3, [sp, #0]
    2622:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
    2626:	f7fe fd23 	bl	1070 <chSchIsPreemptionRequired>
    262a:	4603      	mov	r3, r0
    262c:	2b00      	cmp	r3, #0
    262e:	d003      	beq.n	2638 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    2630:	9b01      	ldr	r3, [sp, #4]
    2632:	4a06      	ldr	r2, [pc, #24]	; (264c <_port_irq_epilogue+0x5c>)
    2634:	619a      	str	r2, [r3, #24]
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
    2636:	e005      	b.n	2644 <_port_irq_epilogue+0x54>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    2638:	9b01      	ldr	r3, [sp, #4]
    263a:	4a05      	ldr	r2, [pc, #20]	; (2650 <_port_irq_epilogue+0x60>)
    263c:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
    263e:	e001      	b.n	2644 <_port_irq_epilogue+0x54>
  }
  port_unlock_from_isr();
    2640:	f7ff ffb6 	bl	25b0 <port_unlock_from_isr>
}
    2644:	b002      	add	sp, #8
    2646:	bd10      	pop	{r4, pc}
    2648:	e000ed00 	.word	0xe000ed00
    264c:	000002a9 	.word	0x000002a9
    2650:	000002bc 	.word	0x000002bc
    2654:	f3af 8000 	nop.w
    2658:	f3af 8000 	nop.w
    265c:	f3af 8000 	nop.w

00002660 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    2660:	4770      	bx	lr
    2662:	bf00      	nop
    2664:	f3af 8000 	nop.w
    2668:	f3af 8000 	nop.w
    266c:	f3af 8000 	nop.w

00002670 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
    2670:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    2672:	f7ff fff5 	bl	2660 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
    2676:	f000 facb 	bl	2c10 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    267a:	4806      	ldr	r0, [pc, #24]	; (2694 <halInit+0x24>)
    267c:	f001 f8a8 	bl	37d0 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
    2680:	f000 f88e 	bl	27a0 <adcInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    2684:	f000 f9e4 	bl	2a50 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    2688:	f001 fba2 	bl	3dd0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    268c:	f000 f838 	bl	2700 <stInit>
#endif
}
    2690:	bd08      	pop	{r3, pc}
    2692:	bf00      	nop
    2694:	00004360 	.word	0x00004360
    2698:	f3af 8000 	nop.w
    269c:	f3af 8000 	nop.w

000026a0 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
    26a0:	b082      	sub	sp, #8
    26a2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
    26a4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    26a8:	9a01      	ldr	r2, [sp, #4]
    26aa:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
    26ac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    26b0:	2200      	movs	r2, #0
    26b2:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
    26b4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    26b8:	2202      	movs	r2, #2
    26ba:	60da      	str	r2, [r3, #12]
}
    26bc:	b002      	add	sp, #8
    26be:	4770      	bx	lr

000026c0 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
    26c0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    26c4:	2200      	movs	r2, #0
    26c6:	60da      	str	r2, [r3, #12]
}
    26c8:	4770      	bx	lr
    26ca:	bf00      	nop
    26cc:	f3af 8000 	nop.w

000026d0 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
    26d0:	b082      	sub	sp, #8
    26d2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
    26d4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    26d8:	9a01      	ldr	r2, [sp, #4]
    26da:	635a      	str	r2, [r3, #52]	; 0x34
}
    26dc:	b002      	add	sp, #8
    26de:	4770      	bx	lr

000026e0 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
    26e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    26e4:	68db      	ldr	r3, [r3, #12]
    26e6:	f003 0302 	and.w	r3, r3, #2
    26ea:	2b00      	cmp	r3, #0
    26ec:	bf0c      	ite	eq
    26ee:	2300      	moveq	r3, #0
    26f0:	2301      	movne	r3, #1
    26f2:	b2db      	uxtb	r3, r3
}
    26f4:	4618      	mov	r0, r3
    26f6:	4770      	bx	lr
    26f8:	f3af 8000 	nop.w
    26fc:	f3af 8000 	nop.w

00002700 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
    2700:	b508      	push	{r3, lr}

  st_lld_init();
    2702:	f000 fe6d 	bl	33e0 <st_lld_init>
}
    2706:	bd08      	pop	{r3, pc}
    2708:	f3af 8000 	nop.w
    270c:	f3af 8000 	nop.w

00002710 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
    2710:	b500      	push	{lr}
    2712:	b083      	sub	sp, #12
    2714:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
    2716:	f7ff ffe3 	bl	26e0 <st_lld_is_alarm_active>
    271a:	4603      	mov	r3, r0
    271c:	2b00      	cmp	r3, #0
    271e:	d002      	beq.n	2726 <stStartAlarm+0x16>
    2720:	4804      	ldr	r0, [pc, #16]	; (2734 <stStartAlarm+0x24>)
    2722:	f7fd ffc5 	bl	6b0 <chSysHalt>

  st_lld_start_alarm(abstime);
    2726:	9801      	ldr	r0, [sp, #4]
    2728:	f7ff ffba 	bl	26a0 <st_lld_start_alarm>
}
    272c:	b003      	add	sp, #12
    272e:	f85d fb04 	ldr.w	pc, [sp], #4
    2732:	bf00      	nop
    2734:	00004220 	.word	0x00004220
    2738:	f3af 8000 	nop.w
    273c:	f3af 8000 	nop.w

00002740 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
    2740:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
    2742:	f7ff ffbd 	bl	26c0 <st_lld_stop_alarm>
}
    2746:	bd08      	pop	{r3, pc}
    2748:	f3af 8000 	nop.w
    274c:	f3af 8000 	nop.w

00002750 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
    2750:	b500      	push	{lr}
    2752:	b083      	sub	sp, #12
    2754:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
    2756:	f7ff ffc3 	bl	26e0 <st_lld_is_alarm_active>
    275a:	4603      	mov	r3, r0
    275c:	f083 0301 	eor.w	r3, r3, #1
    2760:	b2db      	uxtb	r3, r3
    2762:	2b00      	cmp	r3, #0
    2764:	d002      	beq.n	276c <stSetAlarm+0x1c>
    2766:	4804      	ldr	r0, [pc, #16]	; (2778 <stSetAlarm+0x28>)
    2768:	f7fd ffa2 	bl	6b0 <chSysHalt>

  st_lld_set_alarm(abstime);
    276c:	9801      	ldr	r0, [sp, #4]
    276e:	f7ff ffaf 	bl	26d0 <st_lld_set_alarm>
}
    2772:	b003      	add	sp, #12
    2774:	f85d fb04 	ldr.w	pc, [sp], #4
    2778:	00004230 	.word	0x00004230
    277c:	f3af 8000 	nop.w

00002780 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
    2780:	b500      	push	{lr}
    2782:	b083      	sub	sp, #12
    2784:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
    2786:	9801      	ldr	r0, [sp, #4]
    2788:	f7ff f9fa 	bl	1b80 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
    278c:	b003      	add	sp, #12
    278e:	f85d fb04 	ldr.w	pc, [sp], #4
    2792:	bf00      	nop
    2794:	f3af 8000 	nop.w
    2798:	f3af 8000 	nop.w
    279c:	f3af 8000 	nop.w

000027a0 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
    27a0:	b508      	push	{r3, lr}

  adc_lld_init();
    27a2:	f000 ff75 	bl	3690 <adc_lld_init>
}
    27a6:	bd08      	pop	{r3, pc}
    27a8:	f3af 8000 	nop.w
    27ac:	f3af 8000 	nop.w

000027b0 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
    27b0:	b500      	push	{lr}
    27b2:	b083      	sub	sp, #12
    27b4:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
    27b6:	9b01      	ldr	r3, [sp, #4]
    27b8:	2201      	movs	r2, #1
    27ba:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
    27bc:	9b01      	ldr	r3, [sp, #4]
    27be:	2200      	movs	r2, #0
    27c0:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
    27c2:	9b01      	ldr	r3, [sp, #4]
    27c4:	2200      	movs	r2, #0
    27c6:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
    27c8:	9b01      	ldr	r3, [sp, #4]
    27ca:	2200      	movs	r2, #0
    27cc:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
    27ce:	9b01      	ldr	r3, [sp, #4]
    27d0:	2200      	movs	r2, #0
    27d2:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
    27d4:	9b01      	ldr	r3, [sp, #4]
    27d6:	2200      	movs	r2, #0
    27d8:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
    27da:	9b01      	ldr	r3, [sp, #4]
    27dc:	3318      	adds	r3, #24
    27de:	4618      	mov	r0, r3
    27e0:	f7ff ffce 	bl	2780 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
    27e4:	b003      	add	sp, #12
    27e6:	f85d fb04 	ldr.w	pc, [sp], #4
    27ea:	bf00      	nop
    27ec:	f3af 8000 	nop.w

000027f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    27f0:	b082      	sub	sp, #8
    27f2:	2320      	movs	r3, #32
    27f4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    27f6:	9b01      	ldr	r3, [sp, #4]
    27f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    27fc:	b002      	add	sp, #8
    27fe:	4770      	bx	lr

00002800 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2800:	b082      	sub	sp, #8
    2802:	2300      	movs	r3, #0
    2804:	9301      	str	r3, [sp, #4]
    2806:	9b01      	ldr	r3, [sp, #4]
    2808:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    280c:	b002      	add	sp, #8
    280e:	4770      	bx	lr

00002810 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    2810:	b508      	push	{r3, lr}

  port_lock();
    2812:	f7ff ffed 	bl	27f0 <port_lock>
  _stats_start_measure_crit_thd();
    2816:	f7ff f85b 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    281a:	f7fd ffb1 	bl	780 <_dbg_check_lock>
}
    281e:	bd08      	pop	{r3, pc}

00002820 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2820:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2822:	f7fd ffc5 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2826:	f7ff f85b 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    282a:	4b09      	ldr	r3, [pc, #36]	; (2850 <chSysUnlock+0x30>)
    282c:	681a      	ldr	r2, [r3, #0]
    282e:	4b08      	ldr	r3, [pc, #32]	; (2850 <chSysUnlock+0x30>)
    2830:	429a      	cmp	r2, r3
    2832:	d00a      	beq.n	284a <chSysUnlock+0x2a>
    2834:	4b06      	ldr	r3, [pc, #24]	; (2850 <chSysUnlock+0x30>)
    2836:	699b      	ldr	r3, [r3, #24]
    2838:	689a      	ldr	r2, [r3, #8]
    283a:	4b05      	ldr	r3, [pc, #20]	; (2850 <chSysUnlock+0x30>)
    283c:	681b      	ldr	r3, [r3, #0]
    283e:	689b      	ldr	r3, [r3, #8]
    2840:	429a      	cmp	r2, r3
    2842:	d202      	bcs.n	284a <chSysUnlock+0x2a>
    2844:	4803      	ldr	r0, [pc, #12]	; (2854 <chSysUnlock+0x34>)
    2846:	f7fd ff33 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    284a:	f7ff ffd9 	bl	2800 <port_unlock>
}
    284e:	bd08      	pop	{r3, pc}
    2850:	20000800 	.word	0x20000800
    2854:	00004270 	.word	0x00004270
    2858:	f3af 8000 	nop.w
    285c:	f3af 8000 	nop.w

00002860 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
    2860:	b082      	sub	sp, #8
    2862:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
    2864:	9b01      	ldr	r3, [sp, #4]
    2866:	9a01      	ldr	r2, [sp, #4]
    2868:	601a      	str	r2, [r3, #0]
}
    286a:	b002      	add	sp, #8
    286c:	4770      	bx	lr
    286e:	bf00      	nop

00002870 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
    2870:	b500      	push	{lr}
    2872:	b083      	sub	sp, #12
    2874:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    2876:	f7fe f823 	bl	8c0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
    287a:	9b01      	ldr	r3, [sp, #4]
    287c:	689b      	ldr	r3, [r3, #8]
    287e:	2b00      	cmp	r3, #0
    2880:	bf14      	ite	ne
    2882:	2300      	movne	r3, #0
    2884:	2301      	moveq	r3, #1
    2886:	b2db      	uxtb	r3, r3
}
    2888:	4618      	mov	r0, r3
    288a:	b003      	add	sp, #12
    288c:	f85d fb04 	ldr.w	pc, [sp], #4

00002890 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
    2890:	b508      	push	{r3, lr}

  chSysLock();
    2892:	f7ff ffbd 	bl	2810 <chSysLock>
}
    2896:	bd08      	pop	{r3, pc}
    2898:	f3af 8000 	nop.w
    289c:	f3af 8000 	nop.w

000028a0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
    28a0:	b508      	push	{r3, lr}

  chSysUnlock();
    28a2:	f7ff ffbd 	bl	2820 <chSysUnlock>
}
    28a6:	bd08      	pop	{r3, pc}
    28a8:	f3af 8000 	nop.w
    28ac:	f3af 8000 	nop.w

000028b0 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    28b0:	b500      	push	{lr}
    28b2:	b083      	sub	sp, #12
    28b4:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
    28b6:	9801      	ldr	r0, [sp, #4]
    28b8:	f7ff ffd2 	bl	2860 <chEvtObjectInit>
}
    28bc:	b003      	add	sp, #12
    28be:	f85d fb04 	ldr.w	pc, [sp], #4
    28c2:	bf00      	nop
    28c4:	f3af 8000 	nop.w
    28c8:	f3af 8000 	nop.w
    28cc:	f3af 8000 	nop.w

000028d0 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    28d0:	b500      	push	{lr}
    28d2:	b083      	sub	sp, #12
    28d4:	9001      	str	r0, [sp, #4]
    28d6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
    28d8:	9801      	ldr	r0, [sp, #4]
    28da:	9900      	ldr	r1, [sp, #0]
    28dc:	f7ff f968 	bl	1bb0 <chEvtBroadcastFlagsI>
}
    28e0:	b003      	add	sp, #12
    28e2:	f85d fb04 	ldr.w	pc, [sp], #4
    28e6:	bf00      	nop
    28e8:	f3af 8000 	nop.w
    28ec:	f3af 8000 	nop.w

000028f0 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    28f0:	b500      	push	{lr}
    28f2:	b085      	sub	sp, #20
    28f4:	9003      	str	r0, [sp, #12]
    28f6:	9102      	str	r1, [sp, #8]
    28f8:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    28fa:	9b03      	ldr	r3, [sp, #12]
    28fc:	3330      	adds	r3, #48	; 0x30
    28fe:	4618      	mov	r0, r3
    2900:	9902      	ldr	r1, [sp, #8]
    2902:	9a01      	ldr	r2, [sp, #4]
    2904:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2908:	f7ff fd3a 	bl	2380 <chOQWriteTimeout>
    290c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
    290e:	4618      	mov	r0, r3
    2910:	b005      	add	sp, #20
    2912:	f85d fb04 	ldr.w	pc, [sp], #4
    2916:	bf00      	nop
    2918:	f3af 8000 	nop.w
    291c:	f3af 8000 	nop.w

00002920 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    2920:	b500      	push	{lr}
    2922:	b085      	sub	sp, #20
    2924:	9003      	str	r0, [sp, #12]
    2926:	9102      	str	r1, [sp, #8]
    2928:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    292a:	9b03      	ldr	r3, [sp, #12]
    292c:	330c      	adds	r3, #12
    292e:	4618      	mov	r0, r3
    2930:	9902      	ldr	r1, [sp, #8]
    2932:	9a01      	ldr	r2, [sp, #4]
    2934:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2938:	f7ff fc22 	bl	2180 <chIQReadTimeout>
    293c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
    293e:	4618      	mov	r0, r3
    2940:	b005      	add	sp, #20
    2942:	f85d fb04 	ldr.w	pc, [sp], #4
    2946:	bf00      	nop
    2948:	f3af 8000 	nop.w
    294c:	f3af 8000 	nop.w

00002950 <put>:

static msg_t put(void *ip, uint8_t b) {
    2950:	b500      	push	{lr}
    2952:	b083      	sub	sp, #12
    2954:	9001      	str	r0, [sp, #4]
    2956:	460b      	mov	r3, r1
    2958:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    295c:	9b01      	ldr	r3, [sp, #4]
    295e:	f103 0230 	add.w	r2, r3, #48	; 0x30
    2962:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2966:	4610      	mov	r0, r2
    2968:	4619      	mov	r1, r3
    296a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    296e:	f7ff fc8f 	bl	2290 <chOQPutTimeout>
    2972:	4603      	mov	r3, r0
}
    2974:	4618      	mov	r0, r3
    2976:	b003      	add	sp, #12
    2978:	f85d fb04 	ldr.w	pc, [sp], #4
    297c:	f3af 8000 	nop.w

00002980 <get>:

static msg_t get(void *ip) {
    2980:	b500      	push	{lr}
    2982:	b083      	sub	sp, #12
    2984:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    2986:	9b01      	ldr	r3, [sp, #4]
    2988:	330c      	adds	r3, #12
    298a:	4618      	mov	r0, r3
    298c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2990:	f7ff fbae 	bl	20f0 <chIQGetTimeout>
    2994:	4603      	mov	r3, r0
}
    2996:	4618      	mov	r0, r3
    2998:	b003      	add	sp, #12
    299a:	f85d fb04 	ldr.w	pc, [sp], #4
    299e:	bf00      	nop

000029a0 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    29a0:	b500      	push	{lr}
    29a2:	b085      	sub	sp, #20
    29a4:	9003      	str	r0, [sp, #12]
    29a6:	460b      	mov	r3, r1
    29a8:	9201      	str	r2, [sp, #4]
    29aa:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    29ae:	9b03      	ldr	r3, [sp, #12]
    29b0:	f103 0230 	add.w	r2, r3, #48	; 0x30
    29b4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    29b8:	4610      	mov	r0, r2
    29ba:	4619      	mov	r1, r3
    29bc:	9a01      	ldr	r2, [sp, #4]
    29be:	f7ff fc67 	bl	2290 <chOQPutTimeout>
    29c2:	4603      	mov	r3, r0
}
    29c4:	4618      	mov	r0, r3
    29c6:	b005      	add	sp, #20
    29c8:	f85d fb04 	ldr.w	pc, [sp], #4
    29cc:	f3af 8000 	nop.w

000029d0 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    29d0:	b500      	push	{lr}
    29d2:	b083      	sub	sp, #12
    29d4:	9001      	str	r0, [sp, #4]
    29d6:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    29d8:	9b01      	ldr	r3, [sp, #4]
    29da:	330c      	adds	r3, #12
    29dc:	4618      	mov	r0, r3
    29de:	9900      	ldr	r1, [sp, #0]
    29e0:	f7ff fb86 	bl	20f0 <chIQGetTimeout>
    29e4:	4603      	mov	r3, r0
}
    29e6:	4618      	mov	r0, r3
    29e8:	b003      	add	sp, #12
    29ea:	f85d fb04 	ldr.w	pc, [sp], #4
    29ee:	bf00      	nop

000029f0 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    29f0:	b500      	push	{lr}
    29f2:	b085      	sub	sp, #20
    29f4:	9003      	str	r0, [sp, #12]
    29f6:	9102      	str	r1, [sp, #8]
    29f8:	9201      	str	r2, [sp, #4]
    29fa:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    29fc:	9b03      	ldr	r3, [sp, #12]
    29fe:	3330      	adds	r3, #48	; 0x30
    2a00:	4618      	mov	r0, r3
    2a02:	9902      	ldr	r1, [sp, #8]
    2a04:	9a01      	ldr	r2, [sp, #4]
    2a06:	9b00      	ldr	r3, [sp, #0]
    2a08:	f7ff fcba 	bl	2380 <chOQWriteTimeout>
    2a0c:	4603      	mov	r3, r0
}
    2a0e:	4618      	mov	r0, r3
    2a10:	b005      	add	sp, #20
    2a12:	f85d fb04 	ldr.w	pc, [sp], #4
    2a16:	bf00      	nop
    2a18:	f3af 8000 	nop.w
    2a1c:	f3af 8000 	nop.w

00002a20 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    2a20:	b500      	push	{lr}
    2a22:	b085      	sub	sp, #20
    2a24:	9003      	str	r0, [sp, #12]
    2a26:	9102      	str	r1, [sp, #8]
    2a28:	9201      	str	r2, [sp, #4]
    2a2a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    2a2c:	9b03      	ldr	r3, [sp, #12]
    2a2e:	330c      	adds	r3, #12
    2a30:	4618      	mov	r0, r3
    2a32:	9902      	ldr	r1, [sp, #8]
    2a34:	9a01      	ldr	r2, [sp, #4]
    2a36:	9b00      	ldr	r3, [sp, #0]
    2a38:	f7ff fba2 	bl	2180 <chIQReadTimeout>
    2a3c:	4603      	mov	r3, r0
}
    2a3e:	4618      	mov	r0, r3
    2a40:	b005      	add	sp, #20
    2a42:	f85d fb04 	ldr.w	pc, [sp], #4
    2a46:	bf00      	nop
    2a48:	f3af 8000 	nop.w
    2a4c:	f3af 8000 	nop.w

00002a50 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
    2a50:	b508      	push	{r3, lr}

  sd_lld_init();
    2a52:	f001 f975 	bl	3d40 <sd_lld_init>
}
    2a56:	bd08      	pop	{r3, pc}
    2a58:	f3af 8000 	nop.w
    2a5c:	f3af 8000 	nop.w

00002a60 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    2a60:	b500      	push	{lr}
    2a62:	b087      	sub	sp, #28
    2a64:	9005      	str	r0, [sp, #20]
    2a66:	9104      	str	r1, [sp, #16]
    2a68:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
    2a6a:	9b05      	ldr	r3, [sp, #20]
    2a6c:	4a13      	ldr	r2, [pc, #76]	; (2abc <sdObjectInit+0x5c>)
    2a6e:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
    2a70:	9b05      	ldr	r3, [sp, #20]
    2a72:	3304      	adds	r3, #4
    2a74:	4618      	mov	r0, r3
    2a76:	f7ff ff1b 	bl	28b0 <osalEventObjectInit>
  sdp->state = SD_STOP;
    2a7a:	9b05      	ldr	r3, [sp, #20]
    2a7c:	2201      	movs	r2, #1
    2a7e:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    2a80:	9b05      	ldr	r3, [sp, #20]
    2a82:	f103 020c 	add.w	r2, r3, #12
    2a86:	9b05      	ldr	r3, [sp, #20]
    2a88:	3354      	adds	r3, #84	; 0x54
    2a8a:	9905      	ldr	r1, [sp, #20]
    2a8c:	9100      	str	r1, [sp, #0]
    2a8e:	4610      	mov	r0, r2
    2a90:	4619      	mov	r1, r3
    2a92:	2220      	movs	r2, #32
    2a94:	9b04      	ldr	r3, [sp, #16]
    2a96:	f7ff facb 	bl	2030 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    2a9a:	9b05      	ldr	r3, [sp, #20]
    2a9c:	f103 0230 	add.w	r2, r3, #48	; 0x30
    2aa0:	9b05      	ldr	r3, [sp, #20]
    2aa2:	3374      	adds	r3, #116	; 0x74
    2aa4:	9905      	ldr	r1, [sp, #20]
    2aa6:	9100      	str	r1, [sp, #0]
    2aa8:	4610      	mov	r0, r2
    2aaa:	4619      	mov	r1, r3
    2aac:	2220      	movs	r2, #32
    2aae:	9b03      	ldr	r3, [sp, #12]
    2ab0:	f7ff fbc6 	bl	2240 <chOQObjectInit>
}
    2ab4:	b007      	add	sp, #28
    2ab6:	f85d fb04 	ldr.w	pc, [sp], #4
    2aba:	bf00      	nop
    2abc:	00004240 	.word	0x00004240

00002ac0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    2ac0:	b500      	push	{lr}
    2ac2:	b083      	sub	sp, #12
    2ac4:	9001      	str	r0, [sp, #4]
    2ac6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);
    2ac8:	9b01      	ldr	r3, [sp, #4]
    2aca:	2b00      	cmp	r3, #0
    2acc:	d102      	bne.n	2ad4 <sdStart+0x14>
    2ace:	480e      	ldr	r0, [pc, #56]	; (2b08 <sdStart+0x48>)
    2ad0:	f7fd fdee 	bl	6b0 <chSysHalt>

  osalSysLock();
    2ad4:	f7ff fedc 	bl	2890 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
    2ad8:	9b01      	ldr	r3, [sp, #4]
    2ada:	7a1b      	ldrb	r3, [r3, #8]
    2adc:	2b01      	cmp	r3, #1
    2ade:	d006      	beq.n	2aee <sdStart+0x2e>
    2ae0:	9b01      	ldr	r3, [sp, #4]
    2ae2:	7a1b      	ldrb	r3, [r3, #8]
    2ae4:	2b02      	cmp	r3, #2
    2ae6:	d002      	beq.n	2aee <sdStart+0x2e>
    2ae8:	4807      	ldr	r0, [pc, #28]	; (2b08 <sdStart+0x48>)
    2aea:	f7fd fde1 	bl	6b0 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
    2aee:	9801      	ldr	r0, [sp, #4]
    2af0:	9900      	ldr	r1, [sp, #0]
    2af2:	f001 f93d 	bl	3d70 <sd_lld_start>
  sdp->state = SD_READY;
    2af6:	9b01      	ldr	r3, [sp, #4]
    2af8:	2202      	movs	r2, #2
    2afa:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
    2afc:	f7ff fed0 	bl	28a0 <osalSysUnlock>
}
    2b00:	b003      	add	sp, #12
    2b02:	f85d fb04 	ldr.w	pc, [sp], #4
    2b06:	bf00      	nop
    2b08:	00004260 	.word	0x00004260
    2b0c:	f3af 8000 	nop.w

00002b10 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    2b10:	b500      	push	{lr}
    2b12:	b083      	sub	sp, #12
    2b14:	9001      	str	r0, [sp, #4]
    2b16:	460b      	mov	r3, r1
    2b18:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
    2b1c:	f7fd fed0 	bl	8c0 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
    2b20:	9b01      	ldr	r3, [sp, #4]
    2b22:	2b00      	cmp	r3, #0
    2b24:	d102      	bne.n	2b2c <sdIncomingDataI+0x1c>
    2b26:	4813      	ldr	r0, [pc, #76]	; (2b74 <sdIncomingDataI+0x64>)
    2b28:	f7fd fdc2 	bl	6b0 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
    2b2c:	9b01      	ldr	r3, [sp, #4]
    2b2e:	330c      	adds	r3, #12
    2b30:	4618      	mov	r0, r3
    2b32:	f7ff fe9d 	bl	2870 <chIQIsEmptyI>
    2b36:	4603      	mov	r3, r0
    2b38:	2b00      	cmp	r3, #0
    2b3a:	d005      	beq.n	2b48 <sdIncomingDataI+0x38>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    2b3c:	9b01      	ldr	r3, [sp, #4]
    2b3e:	3304      	adds	r3, #4
    2b40:	4618      	mov	r0, r3
    2b42:	2104      	movs	r1, #4
    2b44:	f7ff fec4 	bl	28d0 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
    2b48:	9b01      	ldr	r3, [sp, #4]
    2b4a:	f103 020c 	add.w	r2, r3, #12
    2b4e:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2b52:	4610      	mov	r0, r2
    2b54:	4619      	mov	r1, r3
    2b56:	f7ff fa93 	bl	2080 <chIQPutI>
    2b5a:	4603      	mov	r3, r0
    2b5c:	2b00      	cmp	r3, #0
    2b5e:	da05      	bge.n	2b6c <sdIncomingDataI+0x5c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    2b60:	9b01      	ldr	r3, [sp, #4]
    2b62:	3304      	adds	r3, #4
    2b64:	4618      	mov	r0, r3
    2b66:	2180      	movs	r1, #128	; 0x80
    2b68:	f7ff feb2 	bl	28d0 <osalEventBroadcastFlagsI>
}
    2b6c:	b003      	add	sp, #12
    2b6e:	f85d fb04 	ldr.w	pc, [sp], #4
    2b72:	bf00      	nop
    2b74:	00004280 	.word	0x00004280
    2b78:	f3af 8000 	nop.w
    2b7c:	f3af 8000 	nop.w

00002b80 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
    2b80:	b082      	sub	sp, #8
    2b82:	9001      	str	r0, [sp, #4]
    2b84:	9100      	str	r1, [sp, #0]

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
    2b86:	4911      	ldr	r1, [pc, #68]	; (2bcc <nvicEnableVector+0x4c>)
    2b88:	9b00      	ldr	r3, [sp, #0]
    2b8a:	b2db      	uxtb	r3, r3
    2b8c:	011b      	lsls	r3, r3, #4
    2b8e:	b2da      	uxtb	r2, r3
    2b90:	9b01      	ldr	r3, [sp, #4]
    2b92:	440b      	add	r3, r1
    2b94:	f503 7340 	add.w	r3, r3, #768	; 0x300
    2b98:	701a      	strb	r2, [r3, #0]
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
    2b9a:	4b0c      	ldr	r3, [pc, #48]	; (2bcc <nvicEnableVector+0x4c>)
    2b9c:	9a01      	ldr	r2, [sp, #4]
    2b9e:	0952      	lsrs	r2, r2, #5
    2ba0:	9901      	ldr	r1, [sp, #4]
    2ba2:	f001 011f 	and.w	r1, r1, #31
    2ba6:	2001      	movs	r0, #1
    2ba8:	fa00 f101 	lsl.w	r1, r0, r1
    2bac:	3260      	adds	r2, #96	; 0x60
    2bae:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
    2bb2:	4b06      	ldr	r3, [pc, #24]	; (2bcc <nvicEnableVector+0x4c>)
    2bb4:	9a01      	ldr	r2, [sp, #4]
    2bb6:	0952      	lsrs	r2, r2, #5
    2bb8:	9901      	ldr	r1, [sp, #4]
    2bba:	f001 011f 	and.w	r1, r1, #31
    2bbe:	2001      	movs	r0, #1
    2bc0:	fa00 f101 	lsl.w	r1, r0, r1
    2bc4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    2bc8:	b002      	add	sp, #8
    2bca:	4770      	bx	lr
    2bcc:	e000e100 	.word	0xe000e100

00002bd0 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
    2bd0:	4b0d      	ldr	r3, [pc, #52]	; (2c08 <hal_lld_backup_domain_init+0x38>)
    2bd2:	4a0d      	ldr	r2, [pc, #52]	; (2c08 <hal_lld_backup_domain_init+0x38>)
    2bd4:	6812      	ldr	r2, [r2, #0]
    2bd6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    2bda:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
    2bdc:	4b0b      	ldr	r3, [pc, #44]	; (2c0c <hal_lld_backup_domain_init+0x3c>)
    2bde:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    2be0:	f403 7340 	and.w	r3, r3, #768	; 0x300
    2be4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    2be8:	d006      	beq.n	2bf8 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
    2bea:	4b08      	ldr	r3, [pc, #32]	; (2c0c <hal_lld_backup_domain_init+0x3c>)
    2bec:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    2bf0:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
    2bf2:	4b06      	ldr	r3, [pc, #24]	; (2c0c <hal_lld_backup_domain_init+0x3c>)
    2bf4:	2200      	movs	r2, #0
    2bf6:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
    2bf8:	4b03      	ldr	r3, [pc, #12]	; (2c08 <hal_lld_backup_domain_init+0x38>)
    2bfa:	4a03      	ldr	r2, [pc, #12]	; (2c08 <hal_lld_backup_domain_init+0x38>)
    2bfc:	6852      	ldr	r2, [r2, #4]
    2bfe:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    2c02:	605a      	str	r2, [r3, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
    2c04:	4770      	bx	lr
    2c06:	bf00      	nop
    2c08:	40007000 	.word	0x40007000
    2c0c:	40023800 	.word	0x40023800

00002c10 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
    2c10:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
    2c12:	4b17      	ldr	r3, [pc, #92]	; (2c70 <hal_lld_init+0x60>)
    2c14:	691b      	ldr	r3, [r3, #16]
    2c16:	4b16      	ldr	r3, [pc, #88]	; (2c70 <hal_lld_init+0x60>)
    2c18:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2c1c:	611a      	str	r2, [r3, #16]
    2c1e:	4b14      	ldr	r3, [pc, #80]	; (2c70 <hal_lld_init+0x60>)
    2c20:	2200      	movs	r2, #0
    2c22:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
    2c24:	4b12      	ldr	r3, [pc, #72]	; (2c70 <hal_lld_init+0x60>)
    2c26:	695b      	ldr	r3, [r3, #20]
    2c28:	4b11      	ldr	r3, [pc, #68]	; (2c70 <hal_lld_init+0x60>)
    2c2a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2c2e:	615a      	str	r2, [r3, #20]
    2c30:	4b0f      	ldr	r3, [pc, #60]	; (2c70 <hal_lld_init+0x60>)
    2c32:	2200      	movs	r2, #0
    2c34:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
    2c36:	4b0e      	ldr	r3, [pc, #56]	; (2c70 <hal_lld_init+0x60>)
    2c38:	4a0d      	ldr	r2, [pc, #52]	; (2c70 <hal_lld_init+0x60>)
    2c3a:	6a12      	ldr	r2, [r2, #32]
    2c3c:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
    2c40:	621a      	str	r2, [r3, #32]
    2c42:	4b0b      	ldr	r3, [pc, #44]	; (2c70 <hal_lld_init+0x60>)
    2c44:	2200      	movs	r2, #0
    2c46:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
    2c48:	4b09      	ldr	r3, [pc, #36]	; (2c70 <hal_lld_init+0x60>)
    2c4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2c4c:	4b08      	ldr	r3, [pc, #32]	; (2c70 <hal_lld_init+0x60>)
    2c4e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2c52:	625a      	str	r2, [r3, #36]	; 0x24
    2c54:	4b06      	ldr	r3, [pc, #24]	; (2c70 <hal_lld_init+0x60>)
    2c56:	2200      	movs	r2, #0
    2c58:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
    2c5a:	4b05      	ldr	r3, [pc, #20]	; (2c70 <hal_lld_init+0x60>)
    2c5c:	4a04      	ldr	r2, [pc, #16]	; (2c70 <hal_lld_init+0x60>)
    2c5e:	6c12      	ldr	r2, [r2, #64]	; 0x40
    2c60:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    2c64:	641a      	str	r2, [r3, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
    2c66:	f7ff ffb3 	bl	2bd0 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
    2c6a:	f000 fb19 	bl	32a0 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
    2c6e:	bd08      	pop	{r3, pc}
    2c70:	40023800 	.word	0x40023800
    2c74:	f3af 8000 	nop.w
    2c78:	f3af 8000 	nop.w
    2c7c:	f3af 8000 	nop.w

00002c80 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
    2c80:	4b40      	ldr	r3, [pc, #256]	; (2d84 <stm32_clock_init+0x104>)
    2c82:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    2c86:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
    2c88:	4b3f      	ldr	r3, [pc, #252]	; (2d88 <stm32_clock_init+0x108>)
    2c8a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    2c8e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
    2c90:	4b3c      	ldr	r3, [pc, #240]	; (2d84 <stm32_clock_init+0x104>)
    2c92:	4a3c      	ldr	r2, [pc, #240]	; (2d84 <stm32_clock_init+0x104>)
    2c94:	6812      	ldr	r2, [r2, #0]
    2c96:	f042 0201 	orr.w	r2, r2, #1
    2c9a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
    2c9c:	bf00      	nop
    2c9e:	4b39      	ldr	r3, [pc, #228]	; (2d84 <stm32_clock_init+0x104>)
    2ca0:	681b      	ldr	r3, [r3, #0]
    2ca2:	f003 0302 	and.w	r3, r3, #2
    2ca6:	2b00      	cmp	r3, #0
    2ca8:	d0f9      	beq.n	2c9e <stm32_clock_init+0x1e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
    2caa:	4b36      	ldr	r3, [pc, #216]	; (2d84 <stm32_clock_init+0x104>)
    2cac:	4a35      	ldr	r2, [pc, #212]	; (2d84 <stm32_clock_init+0x104>)
    2cae:	6892      	ldr	r2, [r2, #8]
    2cb0:	f022 0203 	bic.w	r2, r2, #3
    2cb4:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
    2cb6:	4b33      	ldr	r3, [pc, #204]	; (2d84 <stm32_clock_init+0x104>)
    2cb8:	4a32      	ldr	r2, [pc, #200]	; (2d84 <stm32_clock_init+0x104>)
    2cba:	6892      	ldr	r2, [r2, #8]
    2cbc:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
    2cbe:	bf00      	nop
    2cc0:	4b30      	ldr	r3, [pc, #192]	; (2d84 <stm32_clock_init+0x104>)
    2cc2:	689b      	ldr	r3, [r3, #8]
    2cc4:	f003 030c 	and.w	r3, r3, #12
    2cc8:	2b00      	cmp	r3, #0
    2cca:	d1f9      	bne.n	2cc0 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
    2ccc:	4b2d      	ldr	r3, [pc, #180]	; (2d84 <stm32_clock_init+0x104>)
    2cce:	4a2d      	ldr	r2, [pc, #180]	; (2d84 <stm32_clock_init+0x104>)
    2cd0:	6812      	ldr	r2, [r2, #0]
    2cd2:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
    2cd6:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
    2cd8:	4b2a      	ldr	r3, [pc, #168]	; (2d84 <stm32_clock_init+0x104>)
    2cda:	2200      	movs	r2, #0
    2cdc:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
    2cde:	4b29      	ldr	r3, [pc, #164]	; (2d84 <stm32_clock_init+0x104>)
    2ce0:	4a28      	ldr	r2, [pc, #160]	; (2d84 <stm32_clock_init+0x104>)
    2ce2:	6812      	ldr	r2, [r2, #0]
    2ce4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    2ce8:	601a      	str	r2, [r3, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
    2cea:	bf00      	nop
    2cec:	4b25      	ldr	r3, [pc, #148]	; (2d84 <stm32_clock_init+0x104>)
    2cee:	681b      	ldr	r3, [r3, #0]
    2cf0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    2cf4:	2b00      	cmp	r3, #0
    2cf6:	d0f9      	beq.n	2cec <stm32_clock_init+0x6c>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
    2cf8:	4b22      	ldr	r3, [pc, #136]	; (2d84 <stm32_clock_init+0x104>)
    2cfa:	4a22      	ldr	r2, [pc, #136]	; (2d84 <stm32_clock_init+0x104>)
    2cfc:	6f52      	ldr	r2, [r2, #116]	; 0x74
    2cfe:	f042 0201 	orr.w	r2, r2, #1
    2d02:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
    2d04:	bf00      	nop
    2d06:	4b1f      	ldr	r3, [pc, #124]	; (2d84 <stm32_clock_init+0x104>)
    2d08:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    2d0a:	f003 0302 	and.w	r3, r3, #2
    2d0e:	2b00      	cmp	r3, #0
    2d10:	d0f9      	beq.n	2d06 <stm32_clock_init+0x86>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
    2d12:	4b1c      	ldr	r3, [pc, #112]	; (2d84 <stm32_clock_init+0x104>)
    2d14:	4a1d      	ldr	r2, [pc, #116]	; (2d8c <stm32_clock_init+0x10c>)
    2d16:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
    2d18:	4b1a      	ldr	r3, [pc, #104]	; (2d84 <stm32_clock_init+0x104>)
    2d1a:	4a1a      	ldr	r2, [pc, #104]	; (2d84 <stm32_clock_init+0x104>)
    2d1c:	6812      	ldr	r2, [r2, #0]
    2d1e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    2d22:	601a      	str	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
    2d24:	bf00      	nop
    2d26:	4b18      	ldr	r3, [pc, #96]	; (2d88 <stm32_clock_init+0x108>)
    2d28:	685b      	ldr	r3, [r3, #4]
    2d2a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    2d2e:	2b00      	cmp	r3, #0
    2d30:	d0f9      	beq.n	2d26 <stm32_clock_init+0xa6>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
    2d32:	bf00      	nop
    2d34:	4b13      	ldr	r3, [pc, #76]	; (2d84 <stm32_clock_init+0x104>)
    2d36:	681b      	ldr	r3, [r3, #0]
    2d38:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    2d3c:	2b00      	cmp	r3, #0
    2d3e:	d0f9      	beq.n	2d34 <stm32_clock_init+0xb4>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
    2d40:	4b10      	ldr	r3, [pc, #64]	; (2d84 <stm32_clock_init+0x104>)
    2d42:	4a13      	ldr	r2, [pc, #76]	; (2d90 <stm32_clock_init+0x110>)
    2d44:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
    2d46:	4b13      	ldr	r3, [pc, #76]	; (2d94 <stm32_clock_init+0x114>)
    2d48:	f240 7205 	movw	r2, #1797	; 0x705
    2d4c:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
    2d4e:	4b0d      	ldr	r3, [pc, #52]	; (2d84 <stm32_clock_init+0x104>)
    2d50:	4a0c      	ldr	r2, [pc, #48]	; (2d84 <stm32_clock_init+0x104>)
    2d52:	6892      	ldr	r2, [r2, #8]
    2d54:	f042 0202 	orr.w	r2, r2, #2
    2d58:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
    2d5a:	bf00      	nop
    2d5c:	4b09      	ldr	r3, [pc, #36]	; (2d84 <stm32_clock_init+0x104>)
    2d5e:	689b      	ldr	r3, [r3, #8]
    2d60:	f003 030c 	and.w	r3, r3, #12
    2d64:	2b08      	cmp	r3, #8
    2d66:	d1f9      	bne.n	2d5c <stm32_clock_init+0xdc>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
    2d68:	4b06      	ldr	r3, [pc, #24]	; (2d84 <stm32_clock_init+0x104>)
    2d6a:	4a06      	ldr	r2, [pc, #24]	; (2d84 <stm32_clock_init+0x104>)
    2d6c:	6c52      	ldr	r2, [r2, #68]	; 0x44
    2d6e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    2d72:	645a      	str	r2, [r3, #68]	; 0x44
    2d74:	4b03      	ldr	r3, [pc, #12]	; (2d84 <stm32_clock_init+0x104>)
    2d76:	4a03      	ldr	r2, [pc, #12]	; (2d84 <stm32_clock_init+0x104>)
    2d78:	6e52      	ldr	r2, [r2, #100]	; 0x64
    2d7a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    2d7e:	665a      	str	r2, [r3, #100]	; 0x64
}
    2d80:	4770      	bx	lr
    2d82:	bf00      	nop
    2d84:	40023800 	.word	0x40023800
    2d88:	40007000 	.word	0x40007000
    2d8c:	07405408 	.word	0x07405408
    2d90:	38089400 	.word	0x38089400
    2d94:	40023c00 	.word	0x40023c00
    2d98:	f3af 8000 	nop.w
    2d9c:	f3af 8000 	nop.w

00002da0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
    2da0:	b500      	push	{lr}
    2da2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2da4:	f7fe fd64 	bl	1870 <_stats_increase_irq>
    2da8:	f7fd fd4a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
    2dac:	4b0c      	ldr	r3, [pc, #48]	; (2de0 <Vector6C+0x40>)
    2dae:	681b      	ldr	r3, [r3, #0]
    2db0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2db4:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
    2db6:	4b0a      	ldr	r3, [pc, #40]	; (2de0 <Vector6C+0x40>)
    2db8:	9a01      	ldr	r2, [sp, #4]
    2dba:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[0].dma_func)
    2dbc:	4b09      	ldr	r3, [pc, #36]	; (2de4 <Vector6C+0x44>)
    2dbe:	681b      	ldr	r3, [r3, #0]
    2dc0:	2b00      	cmp	r3, #0
    2dc2:	d006      	beq.n	2dd2 <Vector6C+0x32>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
    2dc4:	4b07      	ldr	r3, [pc, #28]	; (2de4 <Vector6C+0x44>)
    2dc6:	681b      	ldr	r3, [r3, #0]
    2dc8:	4a06      	ldr	r2, [pc, #24]	; (2de4 <Vector6C+0x44>)
    2dca:	6852      	ldr	r2, [r2, #4]
    2dcc:	4610      	mov	r0, r2
    2dce:	9901      	ldr	r1, [sp, #4]
    2dd0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2dd2:	f7fd fd55 	bl	880 <_dbg_check_leave_isr>
    2dd6:	f7ff fc0b 	bl	25f0 <_port_irq_epilogue>
}
    2dda:	b003      	add	sp, #12
    2ddc:	f85d fb04 	ldr.w	pc, [sp], #4
    2de0:	40026000 	.word	0x40026000
    2de4:	20000e04 	.word	0x20000e04
    2de8:	f3af 8000 	nop.w
    2dec:	f3af 8000 	nop.w

00002df0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
    2df0:	b500      	push	{lr}
    2df2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2df4:	f7fe fd3c 	bl	1870 <_stats_increase_irq>
    2df8:	f7fd fd22 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
    2dfc:	4b0d      	ldr	r3, [pc, #52]	; (2e34 <Vector70+0x44>)
    2dfe:	681b      	ldr	r3, [r3, #0]
    2e00:	099b      	lsrs	r3, r3, #6
    2e02:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2e06:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
    2e08:	4b0a      	ldr	r3, [pc, #40]	; (2e34 <Vector70+0x44>)
    2e0a:	9a01      	ldr	r2, [sp, #4]
    2e0c:	0192      	lsls	r2, r2, #6
    2e0e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[1].dma_func)
    2e10:	4b09      	ldr	r3, [pc, #36]	; (2e38 <Vector70+0x48>)
    2e12:	689b      	ldr	r3, [r3, #8]
    2e14:	2b00      	cmp	r3, #0
    2e16:	d006      	beq.n	2e26 <Vector70+0x36>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
    2e18:	4b07      	ldr	r3, [pc, #28]	; (2e38 <Vector70+0x48>)
    2e1a:	689b      	ldr	r3, [r3, #8]
    2e1c:	4a06      	ldr	r2, [pc, #24]	; (2e38 <Vector70+0x48>)
    2e1e:	68d2      	ldr	r2, [r2, #12]
    2e20:	4610      	mov	r0, r2
    2e22:	9901      	ldr	r1, [sp, #4]
    2e24:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2e26:	f7fd fd2b 	bl	880 <_dbg_check_leave_isr>
    2e2a:	f7ff fbe1 	bl	25f0 <_port_irq_epilogue>
}
    2e2e:	b003      	add	sp, #12
    2e30:	f85d fb04 	ldr.w	pc, [sp], #4
    2e34:	40026000 	.word	0x40026000
    2e38:	20000e04 	.word	0x20000e04
    2e3c:	f3af 8000 	nop.w

00002e40 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
    2e40:	b500      	push	{lr}
    2e42:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2e44:	f7fe fd14 	bl	1870 <_stats_increase_irq>
    2e48:	f7fd fcfa 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
    2e4c:	4b0d      	ldr	r3, [pc, #52]	; (2e84 <Vector74+0x44>)
    2e4e:	681b      	ldr	r3, [r3, #0]
    2e50:	0c1b      	lsrs	r3, r3, #16
    2e52:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2e56:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
    2e58:	4b0a      	ldr	r3, [pc, #40]	; (2e84 <Vector74+0x44>)
    2e5a:	9a01      	ldr	r2, [sp, #4]
    2e5c:	0412      	lsls	r2, r2, #16
    2e5e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[2].dma_func)
    2e60:	4b09      	ldr	r3, [pc, #36]	; (2e88 <Vector74+0x48>)
    2e62:	691b      	ldr	r3, [r3, #16]
    2e64:	2b00      	cmp	r3, #0
    2e66:	d006      	beq.n	2e76 <Vector74+0x36>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
    2e68:	4b07      	ldr	r3, [pc, #28]	; (2e88 <Vector74+0x48>)
    2e6a:	691b      	ldr	r3, [r3, #16]
    2e6c:	4a06      	ldr	r2, [pc, #24]	; (2e88 <Vector74+0x48>)
    2e6e:	6952      	ldr	r2, [r2, #20]
    2e70:	4610      	mov	r0, r2
    2e72:	9901      	ldr	r1, [sp, #4]
    2e74:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2e76:	f7fd fd03 	bl	880 <_dbg_check_leave_isr>
    2e7a:	f7ff fbb9 	bl	25f0 <_port_irq_epilogue>
}
    2e7e:	b003      	add	sp, #12
    2e80:	f85d fb04 	ldr.w	pc, [sp], #4
    2e84:	40026000 	.word	0x40026000
    2e88:	20000e04 	.word	0x20000e04
    2e8c:	f3af 8000 	nop.w

00002e90 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
    2e90:	b500      	push	{lr}
    2e92:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2e94:	f7fe fcec 	bl	1870 <_stats_increase_irq>
    2e98:	f7fd fcd2 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
    2e9c:	4b0d      	ldr	r3, [pc, #52]	; (2ed4 <Vector78+0x44>)
    2e9e:	681b      	ldr	r3, [r3, #0]
    2ea0:	0d9b      	lsrs	r3, r3, #22
    2ea2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2ea6:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
    2ea8:	4b0a      	ldr	r3, [pc, #40]	; (2ed4 <Vector78+0x44>)
    2eaa:	9a01      	ldr	r2, [sp, #4]
    2eac:	0592      	lsls	r2, r2, #22
    2eae:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[3].dma_func)
    2eb0:	4b09      	ldr	r3, [pc, #36]	; (2ed8 <Vector78+0x48>)
    2eb2:	699b      	ldr	r3, [r3, #24]
    2eb4:	2b00      	cmp	r3, #0
    2eb6:	d006      	beq.n	2ec6 <Vector78+0x36>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
    2eb8:	4b07      	ldr	r3, [pc, #28]	; (2ed8 <Vector78+0x48>)
    2eba:	699b      	ldr	r3, [r3, #24]
    2ebc:	4a06      	ldr	r2, [pc, #24]	; (2ed8 <Vector78+0x48>)
    2ebe:	69d2      	ldr	r2, [r2, #28]
    2ec0:	4610      	mov	r0, r2
    2ec2:	9901      	ldr	r1, [sp, #4]
    2ec4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2ec6:	f7fd fcdb 	bl	880 <_dbg_check_leave_isr>
    2eca:	f7ff fb91 	bl	25f0 <_port_irq_epilogue>
}
    2ece:	b003      	add	sp, #12
    2ed0:	f85d fb04 	ldr.w	pc, [sp], #4
    2ed4:	40026000 	.word	0x40026000
    2ed8:	20000e04 	.word	0x20000e04
    2edc:	f3af 8000 	nop.w

00002ee0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
    2ee0:	b500      	push	{lr}
    2ee2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2ee4:	f7fe fcc4 	bl	1870 <_stats_increase_irq>
    2ee8:	f7fd fcaa 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
    2eec:	4b0c      	ldr	r3, [pc, #48]	; (2f20 <Vector7C+0x40>)
    2eee:	685b      	ldr	r3, [r3, #4]
    2ef0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2ef4:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
    2ef6:	4b0a      	ldr	r3, [pc, #40]	; (2f20 <Vector7C+0x40>)
    2ef8:	9a01      	ldr	r2, [sp, #4]
    2efa:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[4].dma_func)
    2efc:	4b09      	ldr	r3, [pc, #36]	; (2f24 <Vector7C+0x44>)
    2efe:	6a1b      	ldr	r3, [r3, #32]
    2f00:	2b00      	cmp	r3, #0
    2f02:	d006      	beq.n	2f12 <Vector7C+0x32>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
    2f04:	4b07      	ldr	r3, [pc, #28]	; (2f24 <Vector7C+0x44>)
    2f06:	6a1b      	ldr	r3, [r3, #32]
    2f08:	4a06      	ldr	r2, [pc, #24]	; (2f24 <Vector7C+0x44>)
    2f0a:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2f0c:	4610      	mov	r0, r2
    2f0e:	9901      	ldr	r1, [sp, #4]
    2f10:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2f12:	f7fd fcb5 	bl	880 <_dbg_check_leave_isr>
    2f16:	f7ff fb6b 	bl	25f0 <_port_irq_epilogue>
}
    2f1a:	b003      	add	sp, #12
    2f1c:	f85d fb04 	ldr.w	pc, [sp], #4
    2f20:	40026000 	.word	0x40026000
    2f24:	20000e04 	.word	0x20000e04
    2f28:	f3af 8000 	nop.w
    2f2c:	f3af 8000 	nop.w

00002f30 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
    2f30:	b500      	push	{lr}
    2f32:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2f34:	f7fe fc9c 	bl	1870 <_stats_increase_irq>
    2f38:	f7fd fc82 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
    2f3c:	4b0d      	ldr	r3, [pc, #52]	; (2f74 <Vector80+0x44>)
    2f3e:	685b      	ldr	r3, [r3, #4]
    2f40:	099b      	lsrs	r3, r3, #6
    2f42:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2f46:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
    2f48:	4b0a      	ldr	r3, [pc, #40]	; (2f74 <Vector80+0x44>)
    2f4a:	9a01      	ldr	r2, [sp, #4]
    2f4c:	0192      	lsls	r2, r2, #6
    2f4e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[5].dma_func)
    2f50:	4b09      	ldr	r3, [pc, #36]	; (2f78 <Vector80+0x48>)
    2f52:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2f54:	2b00      	cmp	r3, #0
    2f56:	d006      	beq.n	2f66 <Vector80+0x36>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
    2f58:	4b07      	ldr	r3, [pc, #28]	; (2f78 <Vector80+0x48>)
    2f5a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2f5c:	4a06      	ldr	r2, [pc, #24]	; (2f78 <Vector80+0x48>)
    2f5e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    2f60:	4610      	mov	r0, r2
    2f62:	9901      	ldr	r1, [sp, #4]
    2f64:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2f66:	f7fd fc8b 	bl	880 <_dbg_check_leave_isr>
    2f6a:	f7ff fb41 	bl	25f0 <_port_irq_epilogue>
}
    2f6e:	b003      	add	sp, #12
    2f70:	f85d fb04 	ldr.w	pc, [sp], #4
    2f74:	40026000 	.word	0x40026000
    2f78:	20000e04 	.word	0x20000e04
    2f7c:	f3af 8000 	nop.w

00002f80 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
    2f80:	b500      	push	{lr}
    2f82:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2f84:	f7fe fc74 	bl	1870 <_stats_increase_irq>
    2f88:	f7fd fc5a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
    2f8c:	4b0d      	ldr	r3, [pc, #52]	; (2fc4 <Vector84+0x44>)
    2f8e:	685b      	ldr	r3, [r3, #4]
    2f90:	0c1b      	lsrs	r3, r3, #16
    2f92:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2f96:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
    2f98:	4b0a      	ldr	r3, [pc, #40]	; (2fc4 <Vector84+0x44>)
    2f9a:	9a01      	ldr	r2, [sp, #4]
    2f9c:	0412      	lsls	r2, r2, #16
    2f9e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[6].dma_func)
    2fa0:	4b09      	ldr	r3, [pc, #36]	; (2fc8 <Vector84+0x48>)
    2fa2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2fa4:	2b00      	cmp	r3, #0
    2fa6:	d006      	beq.n	2fb6 <Vector84+0x36>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
    2fa8:	4b07      	ldr	r3, [pc, #28]	; (2fc8 <Vector84+0x48>)
    2faa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2fac:	4a06      	ldr	r2, [pc, #24]	; (2fc8 <Vector84+0x48>)
    2fae:	6b52      	ldr	r2, [r2, #52]	; 0x34
    2fb0:	4610      	mov	r0, r2
    2fb2:	9901      	ldr	r1, [sp, #4]
    2fb4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2fb6:	f7fd fc63 	bl	880 <_dbg_check_leave_isr>
    2fba:	f7ff fb19 	bl	25f0 <_port_irq_epilogue>
}
    2fbe:	b003      	add	sp, #12
    2fc0:	f85d fb04 	ldr.w	pc, [sp], #4
    2fc4:	40026000 	.word	0x40026000
    2fc8:	20000e04 	.word	0x20000e04
    2fcc:	f3af 8000 	nop.w

00002fd0 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
    2fd0:	b500      	push	{lr}
    2fd2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2fd4:	f7fe fc4c 	bl	1870 <_stats_increase_irq>
    2fd8:	f7fd fc32 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
    2fdc:	4b0d      	ldr	r3, [pc, #52]	; (3014 <VectorFC+0x44>)
    2fde:	685b      	ldr	r3, [r3, #4]
    2fe0:	0d9b      	lsrs	r3, r3, #22
    2fe2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2fe6:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
    2fe8:	4b0a      	ldr	r3, [pc, #40]	; (3014 <VectorFC+0x44>)
    2fea:	9a01      	ldr	r2, [sp, #4]
    2fec:	0592      	lsls	r2, r2, #22
    2fee:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[7].dma_func)
    2ff0:	4b09      	ldr	r3, [pc, #36]	; (3018 <VectorFC+0x48>)
    2ff2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    2ff4:	2b00      	cmp	r3, #0
    2ff6:	d006      	beq.n	3006 <VectorFC+0x36>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
    2ff8:	4b07      	ldr	r3, [pc, #28]	; (3018 <VectorFC+0x48>)
    2ffa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    2ffc:	4a06      	ldr	r2, [pc, #24]	; (3018 <VectorFC+0x48>)
    2ffe:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
    3000:	4610      	mov	r0, r2
    3002:	9901      	ldr	r1, [sp, #4]
    3004:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3006:	f7fd fc3b 	bl	880 <_dbg_check_leave_isr>
    300a:	f7ff faf1 	bl	25f0 <_port_irq_epilogue>
}
    300e:	b003      	add	sp, #12
    3010:	f85d fb04 	ldr.w	pc, [sp], #4
    3014:	40026000 	.word	0x40026000
    3018:	20000e04 	.word	0x20000e04
    301c:	f3af 8000 	nop.w

00003020 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
    3020:	b500      	push	{lr}
    3022:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3024:	f7fe fc24 	bl	1870 <_stats_increase_irq>
    3028:	f7fd fc0a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
    302c:	4b0c      	ldr	r3, [pc, #48]	; (3060 <Vector120+0x40>)
    302e:	681b      	ldr	r3, [r3, #0]
    3030:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3034:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
    3036:	4b0a      	ldr	r3, [pc, #40]	; (3060 <Vector120+0x40>)
    3038:	9a01      	ldr	r2, [sp, #4]
    303a:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[8].dma_func)
    303c:	4b09      	ldr	r3, [pc, #36]	; (3064 <Vector120+0x44>)
    303e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3040:	2b00      	cmp	r3, #0
    3042:	d006      	beq.n	3052 <Vector120+0x32>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
    3044:	4b07      	ldr	r3, [pc, #28]	; (3064 <Vector120+0x44>)
    3046:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3048:	4a06      	ldr	r2, [pc, #24]	; (3064 <Vector120+0x44>)
    304a:	6c52      	ldr	r2, [r2, #68]	; 0x44
    304c:	4610      	mov	r0, r2
    304e:	9901      	ldr	r1, [sp, #4]
    3050:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3052:	f7fd fc15 	bl	880 <_dbg_check_leave_isr>
    3056:	f7ff facb 	bl	25f0 <_port_irq_epilogue>
}
    305a:	b003      	add	sp, #12
    305c:	f85d fb04 	ldr.w	pc, [sp], #4
    3060:	40026400 	.word	0x40026400
    3064:	20000e04 	.word	0x20000e04
    3068:	f3af 8000 	nop.w
    306c:	f3af 8000 	nop.w

00003070 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
    3070:	b500      	push	{lr}
    3072:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3074:	f7fe fbfc 	bl	1870 <_stats_increase_irq>
    3078:	f7fd fbe2 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
    307c:	4b0d      	ldr	r3, [pc, #52]	; (30b4 <Vector124+0x44>)
    307e:	681b      	ldr	r3, [r3, #0]
    3080:	099b      	lsrs	r3, r3, #6
    3082:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3086:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
    3088:	4b0a      	ldr	r3, [pc, #40]	; (30b4 <Vector124+0x44>)
    308a:	9a01      	ldr	r2, [sp, #4]
    308c:	0192      	lsls	r2, r2, #6
    308e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[9].dma_func)
    3090:	4b09      	ldr	r3, [pc, #36]	; (30b8 <Vector124+0x48>)
    3092:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3094:	2b00      	cmp	r3, #0
    3096:	d006      	beq.n	30a6 <Vector124+0x36>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
    3098:	4b07      	ldr	r3, [pc, #28]	; (30b8 <Vector124+0x48>)
    309a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    309c:	4a06      	ldr	r2, [pc, #24]	; (30b8 <Vector124+0x48>)
    309e:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    30a0:	4610      	mov	r0, r2
    30a2:	9901      	ldr	r1, [sp, #4]
    30a4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    30a6:	f7fd fbeb 	bl	880 <_dbg_check_leave_isr>
    30aa:	f7ff faa1 	bl	25f0 <_port_irq_epilogue>
}
    30ae:	b003      	add	sp, #12
    30b0:	f85d fb04 	ldr.w	pc, [sp], #4
    30b4:	40026400 	.word	0x40026400
    30b8:	20000e04 	.word	0x20000e04
    30bc:	f3af 8000 	nop.w

000030c0 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
    30c0:	b500      	push	{lr}
    30c2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    30c4:	f7fe fbd4 	bl	1870 <_stats_increase_irq>
    30c8:	f7fd fbba 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
    30cc:	4b0d      	ldr	r3, [pc, #52]	; (3104 <Vector128+0x44>)
    30ce:	681b      	ldr	r3, [r3, #0]
    30d0:	0c1b      	lsrs	r3, r3, #16
    30d2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    30d6:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
    30d8:	4b0a      	ldr	r3, [pc, #40]	; (3104 <Vector128+0x44>)
    30da:	9a01      	ldr	r2, [sp, #4]
    30dc:	0412      	lsls	r2, r2, #16
    30de:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[10].dma_func)
    30e0:	4b09      	ldr	r3, [pc, #36]	; (3108 <Vector128+0x48>)
    30e2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    30e4:	2b00      	cmp	r3, #0
    30e6:	d006      	beq.n	30f6 <Vector128+0x36>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
    30e8:	4b07      	ldr	r3, [pc, #28]	; (3108 <Vector128+0x48>)
    30ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    30ec:	4a06      	ldr	r2, [pc, #24]	; (3108 <Vector128+0x48>)
    30ee:	6d52      	ldr	r2, [r2, #84]	; 0x54
    30f0:	4610      	mov	r0, r2
    30f2:	9901      	ldr	r1, [sp, #4]
    30f4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    30f6:	f7fd fbc3 	bl	880 <_dbg_check_leave_isr>
    30fa:	f7ff fa79 	bl	25f0 <_port_irq_epilogue>
}
    30fe:	b003      	add	sp, #12
    3100:	f85d fb04 	ldr.w	pc, [sp], #4
    3104:	40026400 	.word	0x40026400
    3108:	20000e04 	.word	0x20000e04
    310c:	f3af 8000 	nop.w

00003110 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
    3110:	b500      	push	{lr}
    3112:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3114:	f7fe fbac 	bl	1870 <_stats_increase_irq>
    3118:	f7fd fb92 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
    311c:	4b0d      	ldr	r3, [pc, #52]	; (3154 <Vector12C+0x44>)
    311e:	681b      	ldr	r3, [r3, #0]
    3120:	0d9b      	lsrs	r3, r3, #22
    3122:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3126:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
    3128:	4b0a      	ldr	r3, [pc, #40]	; (3154 <Vector12C+0x44>)
    312a:	9a01      	ldr	r2, [sp, #4]
    312c:	0592      	lsls	r2, r2, #22
    312e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[11].dma_func)
    3130:	4b09      	ldr	r3, [pc, #36]	; (3158 <Vector12C+0x48>)
    3132:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    3134:	2b00      	cmp	r3, #0
    3136:	d006      	beq.n	3146 <Vector12C+0x36>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
    3138:	4b07      	ldr	r3, [pc, #28]	; (3158 <Vector12C+0x48>)
    313a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    313c:	4a06      	ldr	r2, [pc, #24]	; (3158 <Vector12C+0x48>)
    313e:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
    3140:	4610      	mov	r0, r2
    3142:	9901      	ldr	r1, [sp, #4]
    3144:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3146:	f7fd fb9b 	bl	880 <_dbg_check_leave_isr>
    314a:	f7ff fa51 	bl	25f0 <_port_irq_epilogue>
}
    314e:	b003      	add	sp, #12
    3150:	f85d fb04 	ldr.w	pc, [sp], #4
    3154:	40026400 	.word	0x40026400
    3158:	20000e04 	.word	0x20000e04
    315c:	f3af 8000 	nop.w

00003160 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
    3160:	b500      	push	{lr}
    3162:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3164:	f7fe fb84 	bl	1870 <_stats_increase_irq>
    3168:	f7fd fb6a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
    316c:	4b0c      	ldr	r3, [pc, #48]	; (31a0 <Vector130+0x40>)
    316e:	685b      	ldr	r3, [r3, #4]
    3170:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3174:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
    3176:	4b0a      	ldr	r3, [pc, #40]	; (31a0 <Vector130+0x40>)
    3178:	9a01      	ldr	r2, [sp, #4]
    317a:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[12].dma_func)
    317c:	4b09      	ldr	r3, [pc, #36]	; (31a4 <Vector130+0x44>)
    317e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    3180:	2b00      	cmp	r3, #0
    3182:	d006      	beq.n	3192 <Vector130+0x32>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
    3184:	4b07      	ldr	r3, [pc, #28]	; (31a4 <Vector130+0x44>)
    3186:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    3188:	4a06      	ldr	r2, [pc, #24]	; (31a4 <Vector130+0x44>)
    318a:	6e52      	ldr	r2, [r2, #100]	; 0x64
    318c:	4610      	mov	r0, r2
    318e:	9901      	ldr	r1, [sp, #4]
    3190:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3192:	f7fd fb75 	bl	880 <_dbg_check_leave_isr>
    3196:	f7ff fa2b 	bl	25f0 <_port_irq_epilogue>
}
    319a:	b003      	add	sp, #12
    319c:	f85d fb04 	ldr.w	pc, [sp], #4
    31a0:	40026400 	.word	0x40026400
    31a4:	20000e04 	.word	0x20000e04
    31a8:	f3af 8000 	nop.w
    31ac:	f3af 8000 	nop.w

000031b0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
    31b0:	b500      	push	{lr}
    31b2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    31b4:	f7fe fb5c 	bl	1870 <_stats_increase_irq>
    31b8:	f7fd fb42 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
    31bc:	4b0d      	ldr	r3, [pc, #52]	; (31f4 <Vector150+0x44>)
    31be:	685b      	ldr	r3, [r3, #4]
    31c0:	099b      	lsrs	r3, r3, #6
    31c2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    31c6:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
    31c8:	4b0a      	ldr	r3, [pc, #40]	; (31f4 <Vector150+0x44>)
    31ca:	9a01      	ldr	r2, [sp, #4]
    31cc:	0192      	lsls	r2, r2, #6
    31ce:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[13].dma_func)
    31d0:	4b09      	ldr	r3, [pc, #36]	; (31f8 <Vector150+0x48>)
    31d2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    31d4:	2b00      	cmp	r3, #0
    31d6:	d006      	beq.n	31e6 <Vector150+0x36>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
    31d8:	4b07      	ldr	r3, [pc, #28]	; (31f8 <Vector150+0x48>)
    31da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    31dc:	4a06      	ldr	r2, [pc, #24]	; (31f8 <Vector150+0x48>)
    31de:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    31e0:	4610      	mov	r0, r2
    31e2:	9901      	ldr	r1, [sp, #4]
    31e4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    31e6:	f7fd fb4b 	bl	880 <_dbg_check_leave_isr>
    31ea:	f7ff fa01 	bl	25f0 <_port_irq_epilogue>
}
    31ee:	b003      	add	sp, #12
    31f0:	f85d fb04 	ldr.w	pc, [sp], #4
    31f4:	40026400 	.word	0x40026400
    31f8:	20000e04 	.word	0x20000e04
    31fc:	f3af 8000 	nop.w

00003200 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
    3200:	b500      	push	{lr}
    3202:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3204:	f7fe fb34 	bl	1870 <_stats_increase_irq>
    3208:	f7fd fb1a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
    320c:	4b0d      	ldr	r3, [pc, #52]	; (3244 <Vector154+0x44>)
    320e:	685b      	ldr	r3, [r3, #4]
    3210:	0c1b      	lsrs	r3, r3, #16
    3212:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3216:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
    3218:	4b0a      	ldr	r3, [pc, #40]	; (3244 <Vector154+0x44>)
    321a:	9a01      	ldr	r2, [sp, #4]
    321c:	0412      	lsls	r2, r2, #16
    321e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[14].dma_func)
    3220:	4b09      	ldr	r3, [pc, #36]	; (3248 <Vector154+0x48>)
    3222:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    3224:	2b00      	cmp	r3, #0
    3226:	d006      	beq.n	3236 <Vector154+0x36>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
    3228:	4b07      	ldr	r3, [pc, #28]	; (3248 <Vector154+0x48>)
    322a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    322c:	4a06      	ldr	r2, [pc, #24]	; (3248 <Vector154+0x48>)
    322e:	6f52      	ldr	r2, [r2, #116]	; 0x74
    3230:	4610      	mov	r0, r2
    3232:	9901      	ldr	r1, [sp, #4]
    3234:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3236:	f7fd fb23 	bl	880 <_dbg_check_leave_isr>
    323a:	f7ff f9d9 	bl	25f0 <_port_irq_epilogue>
}
    323e:	b003      	add	sp, #12
    3240:	f85d fb04 	ldr.w	pc, [sp], #4
    3244:	40026400 	.word	0x40026400
    3248:	20000e04 	.word	0x20000e04
    324c:	f3af 8000 	nop.w

00003250 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
    3250:	b500      	push	{lr}
    3252:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3254:	f7fe fb0c 	bl	1870 <_stats_increase_irq>
    3258:	f7fd faf2 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
    325c:	4b0d      	ldr	r3, [pc, #52]	; (3294 <Vector158+0x44>)
    325e:	685b      	ldr	r3, [r3, #4]
    3260:	0d9b      	lsrs	r3, r3, #22
    3262:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3266:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
    3268:	4b0a      	ldr	r3, [pc, #40]	; (3294 <Vector158+0x44>)
    326a:	9a01      	ldr	r2, [sp, #4]
    326c:	0592      	lsls	r2, r2, #22
    326e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[15].dma_func)
    3270:	4b09      	ldr	r3, [pc, #36]	; (3298 <Vector158+0x48>)
    3272:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    3274:	2b00      	cmp	r3, #0
    3276:	d006      	beq.n	3286 <Vector158+0x36>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
    3278:	4b07      	ldr	r3, [pc, #28]	; (3298 <Vector158+0x48>)
    327a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    327c:	4a06      	ldr	r2, [pc, #24]	; (3298 <Vector158+0x48>)
    327e:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
    3280:	4610      	mov	r0, r2
    3282:	9901      	ldr	r1, [sp, #4]
    3284:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3286:	f7fd fafb 	bl	880 <_dbg_check_leave_isr>
    328a:	f7ff f9b1 	bl	25f0 <_port_irq_epilogue>
}
    328e:	b003      	add	sp, #12
    3290:	f85d fb04 	ldr.w	pc, [sp], #4
    3294:	40026400 	.word	0x40026400
    3298:	20000e04 	.word	0x20000e04
    329c:	f3af 8000 	nop.w

000032a0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
    32a0:	b082      	sub	sp, #8
  unsigned i;

  dma_streams_mask = 0U;
    32a2:	4b16      	ldr	r3, [pc, #88]	; (32fc <dmaInit+0x5c>)
    32a4:	2200      	movs	r2, #0
    32a6:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    32a8:	2300      	movs	r3, #0
    32aa:	9301      	str	r3, [sp, #4]
    32ac:	e011      	b.n	32d2 <dmaInit+0x32>
    _stm32_dma_streams[i].stream->CR = 0U;
    32ae:	4914      	ldr	r1, [pc, #80]	; (3300 <dmaInit+0x60>)
    32b0:	9a01      	ldr	r2, [sp, #4]
    32b2:	4613      	mov	r3, r2
    32b4:	005b      	lsls	r3, r3, #1
    32b6:	4413      	add	r3, r2
    32b8:	009b      	lsls	r3, r3, #2
    32ba:	440b      	add	r3, r1
    32bc:	681b      	ldr	r3, [r3, #0]
    32be:	2200      	movs	r2, #0
    32c0:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
    32c2:	4b10      	ldr	r3, [pc, #64]	; (3304 <dmaInit+0x64>)
    32c4:	9a01      	ldr	r2, [sp, #4]
    32c6:	2100      	movs	r1, #0
    32c8:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    32cc:	9b01      	ldr	r3, [sp, #4]
    32ce:	3301      	adds	r3, #1
    32d0:	9301      	str	r3, [sp, #4]
    32d2:	9b01      	ldr	r3, [sp, #4]
    32d4:	2b0f      	cmp	r3, #15
    32d6:	d9ea      	bls.n	32ae <dmaInit+0xe>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
    32d8:	4b0b      	ldr	r3, [pc, #44]	; (3308 <dmaInit+0x68>)
    32da:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    32de:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
    32e0:	4b09      	ldr	r3, [pc, #36]	; (3308 <dmaInit+0x68>)
    32e2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    32e6:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
    32e8:	4b08      	ldr	r3, [pc, #32]	; (330c <dmaInit+0x6c>)
    32ea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    32ee:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
    32f0:	4b06      	ldr	r3, [pc, #24]	; (330c <dmaInit+0x6c>)
    32f2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    32f6:	60da      	str	r2, [r3, #12]
}
    32f8:	b002      	add	sp, #8
    32fa:	4770      	bx	lr
    32fc:	20000e00 	.word	0x20000e00
    3300:	00004290 	.word	0x00004290
    3304:	20000e04 	.word	0x20000e04
    3308:	40026000 	.word	0x40026000
    330c:	40026400 	.word	0x40026400

00003310 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    3310:	b082      	sub	sp, #8
    3312:	2320      	movs	r3, #32
    3314:	9301      	str	r3, [sp, #4]
    3316:	9b01      	ldr	r3, [sp, #4]
    3318:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    331c:	b002      	add	sp, #8
    331e:	4770      	bx	lr

00003320 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    3320:	b082      	sub	sp, #8
    3322:	2300      	movs	r3, #0
    3324:	9301      	str	r3, [sp, #4]
    3326:	9b01      	ldr	r3, [sp, #4]
    3328:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    332c:	b002      	add	sp, #8
    332e:	4770      	bx	lr

00003330 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    3330:	b508      	push	{r3, lr}

  port_lock();
    3332:	f7ff ffed 	bl	3310 <port_lock>
}
    3336:	bd08      	pop	{r3, pc}
    3338:	f3af 8000 	nop.w
    333c:	f3af 8000 	nop.w

00003340 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    3340:	b508      	push	{r3, lr}

  port_unlock();
    3342:	f7ff ffed 	bl	3320 <port_unlock>
}
    3346:	bd08      	pop	{r3, pc}
    3348:	f3af 8000 	nop.w
    334c:	f3af 8000 	nop.w

00003350 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    3350:	b508      	push	{r3, lr}

  port_lock_from_isr();
    3352:	f7ff ffed 	bl	3330 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    3356:	f7fe facb 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    335a:	f7fd fa41 	bl	7e0 <_dbg_check_lock_from_isr>
}
    335e:	bd08      	pop	{r3, pc}

00003360 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    3360:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    3362:	f7fd fa55 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    3366:	f7fe facb 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    336a:	f7ff ffe9 	bl	3340 <port_unlock_from_isr>
}
    336e:	bd08      	pop	{r3, pc}

00003370 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    3370:	b508      	push	{r3, lr}

  chSysLockFromISR();
    3372:	f7ff ffed 	bl	3350 <chSysLockFromISR>
}
    3376:	bd08      	pop	{r3, pc}
    3378:	f3af 8000 	nop.w
    337c:	f3af 8000 	nop.w

00003380 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    3380:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    3382:	f7ff ffed 	bl	3360 <chSysUnlockFromISR>
}
    3386:	bd08      	pop	{r3, pc}
    3388:	f3af 8000 	nop.w
    338c:	f3af 8000 	nop.w

00003390 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
    3390:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
    3392:	f7fd f99d 	bl	6d0 <chSysTimerHandlerI>
}
    3396:	bd08      	pop	{r3, pc}
    3398:	f3af 8000 	nop.w
    339c:	f3af 8000 	nop.w

000033a0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
    33a0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    33a2:	f7fe fa65 	bl	1870 <_stats_increase_irq>
    33a6:	f7fd fa4b 	bl	840 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    33aa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    33ae:	691b      	ldr	r3, [r3, #16]
    33b0:	f003 0302 	and.w	r3, r3, #2
    33b4:	2b00      	cmp	r3, #0
    33b6:	d009      	beq.n	33cc <VectorB0+0x2c>
    STM32_ST_TIM->SR = 0U;
    33b8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    33bc:	2200      	movs	r2, #0
    33be:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
    33c0:	f7ff ffd6 	bl	3370 <osalSysLockFromISR>
    osalOsTimerHandlerI();
    33c4:	f7ff ffe4 	bl	3390 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
    33c8:	f7ff ffda 	bl	3380 <osalSysUnlockFromISR>
  }

  OSAL_IRQ_EPILOGUE();
    33cc:	f7fd fa58 	bl	880 <_dbg_check_leave_isr>
    33d0:	f7ff f90e 	bl	25f0 <_port_irq_epilogue>
}
    33d4:	bd08      	pop	{r3, pc}
    33d6:	bf00      	nop
    33d8:	f3af 8000 	nop.w
    33dc:	f3af 8000 	nop.w

000033e0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
    33e0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
    33e2:	4b19      	ldr	r3, [pc, #100]	; (3448 <st_lld_init+0x68>)
    33e4:	4a18      	ldr	r2, [pc, #96]	; (3448 <st_lld_init+0x68>)
    33e6:	6c12      	ldr	r2, [r2, #64]	; 0x40
    33e8:	f042 0201 	orr.w	r2, r2, #1
    33ec:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
    33ee:	4b17      	ldr	r3, [pc, #92]	; (344c <st_lld_init+0x6c>)
    33f0:	4a16      	ldr	r2, [pc, #88]	; (344c <st_lld_init+0x6c>)
    33f2:	6892      	ldr	r2, [r2, #8]
    33f4:	f042 0201 	orr.w	r2, r2, #1
    33f8:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
    33fa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    33fe:	f242 02cf 	movw	r2, #8399	; 0x20cf
    3402:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
    3404:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3408:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    340c:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
    340e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3412:	2200      	movs	r2, #0
    3414:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
    3416:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    341a:	2200      	movs	r2, #0
    341c:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
    341e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3422:	2200      	movs	r2, #0
    3424:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
    3426:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    342a:	2200      	movs	r2, #0
    342c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
    342e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3432:	2201      	movs	r2, #1
    3434:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
    3436:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    343a:	2201      	movs	r2, #1
    343c:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
    343e:	201c      	movs	r0, #28
    3440:	2108      	movs	r1, #8
    3442:	f7ff fb9d 	bl	2b80 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    3446:	bd08      	pop	{r3, pc}
    3448:	40023800 	.word	0x40023800
    344c:	e0042000 	.word	0xe0042000

00003450 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    3450:	b082      	sub	sp, #8
    3452:	2320      	movs	r3, #32
    3454:	9301      	str	r3, [sp, #4]
    3456:	9b01      	ldr	r3, [sp, #4]
    3458:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    345c:	b002      	add	sp, #8
    345e:	4770      	bx	lr

00003460 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    3460:	b082      	sub	sp, #8
    3462:	2300      	movs	r3, #0
    3464:	9301      	str	r3, [sp, #4]
    3466:	9b01      	ldr	r3, [sp, #4]
    3468:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    346c:	b002      	add	sp, #8
    346e:	4770      	bx	lr

00003470 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    3470:	b508      	push	{r3, lr}

  port_lock();
    3472:	f7ff ffed 	bl	3450 <port_lock>
}
    3476:	bd08      	pop	{r3, pc}
    3478:	f3af 8000 	nop.w
    347c:	f3af 8000 	nop.w

00003480 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    3480:	b508      	push	{r3, lr}

  port_unlock();
    3482:	f7ff ffed 	bl	3460 <port_unlock>
}
    3486:	bd08      	pop	{r3, pc}
    3488:	f3af 8000 	nop.w
    348c:	f3af 8000 	nop.w

00003490 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    3490:	b508      	push	{r3, lr}

  port_lock_from_isr();
    3492:	f7ff ffed 	bl	3470 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    3496:	f7fe fa2b 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    349a:	f7fd f9a1 	bl	7e0 <_dbg_check_lock_from_isr>
}
    349e:	bd08      	pop	{r3, pc}

000034a0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    34a0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    34a2:	f7fd f9b5 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    34a6:	f7fe fa2b 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    34aa:	f7ff ffe9 	bl	3480 <port_unlock_from_isr>
}
    34ae:	bd08      	pop	{r3, pc}

000034b0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    34b0:	b508      	push	{r3, lr}

  chSysLockFromISR();
    34b2:	f7ff ffed 	bl	3490 <chSysLockFromISR>
}
    34b6:	bd08      	pop	{r3, pc}
    34b8:	f3af 8000 	nop.w
    34bc:	f3af 8000 	nop.w

000034c0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    34c0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    34c2:	f7ff ffed 	bl	34a0 <chSysUnlockFromISR>
}
    34c6:	bd08      	pop	{r3, pc}
    34c8:	f3af 8000 	nop.w
    34cc:	f3af 8000 	nop.w

000034d0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    34d0:	b500      	push	{lr}
    34d2:	b083      	sub	sp, #12
    34d4:	9001      	str	r0, [sp, #4]
    34d6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
    34d8:	9801      	ldr	r0, [sp, #4]
    34da:	9900      	ldr	r1, [sp, #0]
    34dc:	f7fe f898 	bl	1610 <chThdResumeI>
}
    34e0:	b003      	add	sp, #12
    34e2:	f85d fb04 	ldr.w	pc, [sp], #4
    34e6:	bf00      	nop
    34e8:	f3af 8000 	nop.w
    34ec:	f3af 8000 	nop.w

000034f0 <Vector88>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
    34f0:	b500      	push	{lr}
    34f2:	b083      	sub	sp, #12
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();
    34f4:	f7fe f9bc 	bl	1870 <_stats_increase_irq>
    34f8:	f7fd f9a2 	bl	840 <_dbg_check_enter_isr>

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
    34fc:	4b58      	ldr	r3, [pc, #352]	; (3660 <Vector88+0x170>)
    34fe:	681b      	ldr	r3, [r3, #0]
    3500:	9301      	str	r3, [sp, #4]
  ADC1->SR = 0;
    3502:	4b57      	ldr	r3, [pc, #348]	; (3660 <Vector88+0x170>)
    3504:	2200      	movs	r2, #0
    3506:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    3508:	9b01      	ldr	r3, [sp, #4]
    350a:	f003 0320 	and.w	r3, r3, #32
    350e:	2b00      	cmp	r3, #0
    3510:	d02d      	beq.n	356e <Vector88+0x7e>
    3512:	4b54      	ldr	r3, [pc, #336]	; (3664 <Vector88+0x174>)
    3514:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3516:	681b      	ldr	r3, [r3, #0]
    3518:	685b      	ldr	r3, [r3, #4]
    351a:	2b00      	cmp	r3, #0
    351c:	d027      	beq.n	356e <Vector88+0x7e>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
    351e:	4b51      	ldr	r3, [pc, #324]	; (3664 <Vector88+0x174>)
    3520:	691b      	ldr	r3, [r3, #16]
    3522:	2b00      	cmp	r3, #0
    3524:	d023      	beq.n	356e <Vector88+0x7e>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    3526:	484f      	ldr	r0, [pc, #316]	; (3664 <Vector88+0x174>)
    3528:	f000 f8fa 	bl	3720 <adc_lld_stop_conversion>
    352c:	4b4d      	ldr	r3, [pc, #308]	; (3664 <Vector88+0x174>)
    352e:	691b      	ldr	r3, [r3, #16]
    3530:	689b      	ldr	r3, [r3, #8]
    3532:	2b00      	cmp	r3, #0
    3534:	d00f      	beq.n	3556 <Vector88+0x66>
    3536:	4b4b      	ldr	r3, [pc, #300]	; (3664 <Vector88+0x174>)
    3538:	2205      	movs	r2, #5
    353a:	701a      	strb	r2, [r3, #0]
    353c:	4b49      	ldr	r3, [pc, #292]	; (3664 <Vector88+0x174>)
    353e:	691b      	ldr	r3, [r3, #16]
    3540:	689b      	ldr	r3, [r3, #8]
    3542:	4848      	ldr	r0, [pc, #288]	; (3664 <Vector88+0x174>)
    3544:	2101      	movs	r1, #1
    3546:	4798      	blx	r3
    3548:	4b46      	ldr	r3, [pc, #280]	; (3664 <Vector88+0x174>)
    354a:	781b      	ldrb	r3, [r3, #0]
    354c:	2b05      	cmp	r3, #5
    354e:	d102      	bne.n	3556 <Vector88+0x66>
    3550:	4b44      	ldr	r3, [pc, #272]	; (3664 <Vector88+0x174>)
    3552:	2202      	movs	r2, #2
    3554:	701a      	strb	r2, [r3, #0]
    3556:	4b43      	ldr	r3, [pc, #268]	; (3664 <Vector88+0x174>)
    3558:	2200      	movs	r2, #0
    355a:	611a      	str	r2, [r3, #16]
    355c:	f7ff ffa8 	bl	34b0 <osalSysLockFromISR>
    3560:	4841      	ldr	r0, [pc, #260]	; (3668 <Vector88+0x178>)
    3562:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3566:	f7ff ffb3 	bl	34d0 <osalThreadResumeI>
    356a:	f7ff ffa9 	bl	34c0 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC1 */

#if STM32_ADC_USE_ADC2
  sr = ADC2->SR;
    356e:	4b3f      	ldr	r3, [pc, #252]	; (366c <Vector88+0x17c>)
    3570:	681b      	ldr	r3, [r3, #0]
    3572:	9301      	str	r3, [sp, #4]
  ADC2->SR = 0;
    3574:	4b3d      	ldr	r3, [pc, #244]	; (366c <Vector88+0x17c>)
    3576:	2200      	movs	r2, #0
    3578:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD2.dmastp) > 0)) {
    357a:	9b01      	ldr	r3, [sp, #4]
    357c:	f003 0320 	and.w	r3, r3, #32
    3580:	2b00      	cmp	r3, #0
    3582:	d02d      	beq.n	35e0 <Vector88+0xf0>
    3584:	4b3a      	ldr	r3, [pc, #232]	; (3670 <Vector88+0x180>)
    3586:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3588:	681b      	ldr	r3, [r3, #0]
    358a:	685b      	ldr	r3, [r3, #4]
    358c:	2b00      	cmp	r3, #0
    358e:	d027      	beq.n	35e0 <Vector88+0xf0>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD2.grpp != NULL)
    3590:	4b37      	ldr	r3, [pc, #220]	; (3670 <Vector88+0x180>)
    3592:	691b      	ldr	r3, [r3, #16]
    3594:	2b00      	cmp	r3, #0
    3596:	d023      	beq.n	35e0 <Vector88+0xf0>
      _adc_isr_error_code(&ADCD2, ADC_ERR_OVERFLOW);
    3598:	4835      	ldr	r0, [pc, #212]	; (3670 <Vector88+0x180>)
    359a:	f000 f8c1 	bl	3720 <adc_lld_stop_conversion>
    359e:	4b34      	ldr	r3, [pc, #208]	; (3670 <Vector88+0x180>)
    35a0:	691b      	ldr	r3, [r3, #16]
    35a2:	689b      	ldr	r3, [r3, #8]
    35a4:	2b00      	cmp	r3, #0
    35a6:	d00f      	beq.n	35c8 <Vector88+0xd8>
    35a8:	4b31      	ldr	r3, [pc, #196]	; (3670 <Vector88+0x180>)
    35aa:	2205      	movs	r2, #5
    35ac:	701a      	strb	r2, [r3, #0]
    35ae:	4b30      	ldr	r3, [pc, #192]	; (3670 <Vector88+0x180>)
    35b0:	691b      	ldr	r3, [r3, #16]
    35b2:	689b      	ldr	r3, [r3, #8]
    35b4:	482e      	ldr	r0, [pc, #184]	; (3670 <Vector88+0x180>)
    35b6:	2101      	movs	r1, #1
    35b8:	4798      	blx	r3
    35ba:	4b2d      	ldr	r3, [pc, #180]	; (3670 <Vector88+0x180>)
    35bc:	781b      	ldrb	r3, [r3, #0]
    35be:	2b05      	cmp	r3, #5
    35c0:	d102      	bne.n	35c8 <Vector88+0xd8>
    35c2:	4b2b      	ldr	r3, [pc, #172]	; (3670 <Vector88+0x180>)
    35c4:	2202      	movs	r2, #2
    35c6:	701a      	strb	r2, [r3, #0]
    35c8:	4b29      	ldr	r3, [pc, #164]	; (3670 <Vector88+0x180>)
    35ca:	2200      	movs	r2, #0
    35cc:	611a      	str	r2, [r3, #16]
    35ce:	f7ff ff6f 	bl	34b0 <osalSysLockFromISR>
    35d2:	4828      	ldr	r0, [pc, #160]	; (3674 <Vector88+0x184>)
    35d4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    35d8:	f7ff ff7a 	bl	34d0 <osalThreadResumeI>
    35dc:	f7ff ff70 	bl	34c0 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC2 */

#if STM32_ADC_USE_ADC3
  sr = ADC3->SR;
    35e0:	4b25      	ldr	r3, [pc, #148]	; (3678 <Vector88+0x188>)
    35e2:	681b      	ldr	r3, [r3, #0]
    35e4:	9301      	str	r3, [sp, #4]
  ADC3->SR = 0;
    35e6:	4b24      	ldr	r3, [pc, #144]	; (3678 <Vector88+0x188>)
    35e8:	2200      	movs	r2, #0
    35ea:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD3.dmastp) > 0)) {
    35ec:	9b01      	ldr	r3, [sp, #4]
    35ee:	f003 0320 	and.w	r3, r3, #32
    35f2:	2b00      	cmp	r3, #0
    35f4:	d02d      	beq.n	3652 <Vector88+0x162>
    35f6:	4b21      	ldr	r3, [pc, #132]	; (367c <Vector88+0x18c>)
    35f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    35fa:	681b      	ldr	r3, [r3, #0]
    35fc:	685b      	ldr	r3, [r3, #4]
    35fe:	2b00      	cmp	r3, #0
    3600:	d027      	beq.n	3652 <Vector88+0x162>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD3.grpp != NULL)
    3602:	4b1e      	ldr	r3, [pc, #120]	; (367c <Vector88+0x18c>)
    3604:	691b      	ldr	r3, [r3, #16]
    3606:	2b00      	cmp	r3, #0
    3608:	d023      	beq.n	3652 <Vector88+0x162>
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
    360a:	481c      	ldr	r0, [pc, #112]	; (367c <Vector88+0x18c>)
    360c:	f000 f888 	bl	3720 <adc_lld_stop_conversion>
    3610:	4b1a      	ldr	r3, [pc, #104]	; (367c <Vector88+0x18c>)
    3612:	691b      	ldr	r3, [r3, #16]
    3614:	689b      	ldr	r3, [r3, #8]
    3616:	2b00      	cmp	r3, #0
    3618:	d00f      	beq.n	363a <Vector88+0x14a>
    361a:	4b18      	ldr	r3, [pc, #96]	; (367c <Vector88+0x18c>)
    361c:	2205      	movs	r2, #5
    361e:	701a      	strb	r2, [r3, #0]
    3620:	4b16      	ldr	r3, [pc, #88]	; (367c <Vector88+0x18c>)
    3622:	691b      	ldr	r3, [r3, #16]
    3624:	689b      	ldr	r3, [r3, #8]
    3626:	4815      	ldr	r0, [pc, #84]	; (367c <Vector88+0x18c>)
    3628:	2101      	movs	r1, #1
    362a:	4798      	blx	r3
    362c:	4b13      	ldr	r3, [pc, #76]	; (367c <Vector88+0x18c>)
    362e:	781b      	ldrb	r3, [r3, #0]
    3630:	2b05      	cmp	r3, #5
    3632:	d102      	bne.n	363a <Vector88+0x14a>
    3634:	4b11      	ldr	r3, [pc, #68]	; (367c <Vector88+0x18c>)
    3636:	2202      	movs	r2, #2
    3638:	701a      	strb	r2, [r3, #0]
    363a:	4b10      	ldr	r3, [pc, #64]	; (367c <Vector88+0x18c>)
    363c:	2200      	movs	r2, #0
    363e:	611a      	str	r2, [r3, #16]
    3640:	f7ff ff36 	bl	34b0 <osalSysLockFromISR>
    3644:	480e      	ldr	r0, [pc, #56]	; (3680 <Vector88+0x190>)
    3646:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    364a:	f7ff ff41 	bl	34d0 <osalThreadResumeI>
    364e:	f7ff ff37 	bl	34c0 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
    3652:	f7fd f915 	bl	880 <_dbg_check_leave_isr>
    3656:	f7fe ffcb 	bl	25f0 <_port_irq_epilogue>
}
    365a:	b003      	add	sp, #12
    365c:	f85d fb04 	ldr.w	pc, [sp], #4
    3660:	40012000 	.word	0x40012000
    3664:	20000e84 	.word	0x20000e84
    3668:	20000e98 	.word	0x20000e98
    366c:	40012100 	.word	0x40012100
    3670:	20000eb8 	.word	0x20000eb8
    3674:	20000ecc 	.word	0x20000ecc
    3678:	40012200 	.word	0x40012200
    367c:	20000eec 	.word	0x20000eec
    3680:	20000f00 	.word	0x20000f00
    3684:	f3af 8000 	nop.w
    3688:	f3af 8000 	nop.w
    368c:	f3af 8000 	nop.w

00003690 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
    3690:	b508      	push	{r3, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
    3692:	4814      	ldr	r0, [pc, #80]	; (36e4 <adc_lld_init+0x54>)
    3694:	f7ff f88c 	bl	27b0 <adcObjectInit>
  ADCD1.adc = ADC1;
    3698:	4b12      	ldr	r3, [pc, #72]	; (36e4 <adc_lld_init+0x54>)
    369a:	4a13      	ldr	r2, [pc, #76]	; (36e8 <adc_lld_init+0x58>)
    369c:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
    369e:	4b11      	ldr	r3, [pc, #68]	; (36e4 <adc_lld_init+0x54>)
    36a0:	4a12      	ldr	r2, [pc, #72]	; (36ec <adc_lld_init+0x5c>)
    36a2:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
    36a4:	4b0f      	ldr	r3, [pc, #60]	; (36e4 <adc_lld_init+0x54>)
    36a6:	4a12      	ldr	r2, [pc, #72]	; (36f0 <adc_lld_init+0x60>)
    36a8:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

#if STM32_ADC_USE_ADC2
  /* Driver initialization.*/
  adcObjectInit(&ADCD2);
    36aa:	4812      	ldr	r0, [pc, #72]	; (36f4 <adc_lld_init+0x64>)
    36ac:	f7ff f880 	bl	27b0 <adcObjectInit>
  ADCD2.adc = ADC2;
    36b0:	4b10      	ldr	r3, [pc, #64]	; (36f4 <adc_lld_init+0x64>)
    36b2:	4a11      	ldr	r2, [pc, #68]	; (36f8 <adc_lld_init+0x68>)
    36b4:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD2.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC2_DMA_STREAM);
    36b6:	4b0f      	ldr	r3, [pc, #60]	; (36f4 <adc_lld_init+0x64>)
    36b8:	4a10      	ldr	r2, [pc, #64]	; (36fc <adc_lld_init+0x6c>)
    36ba:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD2.dmamode = STM32_DMA_CR_CHSEL(ADC2_DMA_CHANNEL) |
    36bc:	4b0d      	ldr	r3, [pc, #52]	; (36f4 <adc_lld_init+0x64>)
    36be:	4a10      	ldr	r2, [pc, #64]	; (3700 <adc_lld_init+0x70>)
    36c0:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

#if STM32_ADC_USE_ADC3
  /* Driver initialization.*/
  adcObjectInit(&ADCD3);
    36c2:	4810      	ldr	r0, [pc, #64]	; (3704 <adc_lld_init+0x74>)
    36c4:	f7ff f874 	bl	27b0 <adcObjectInit>
  ADCD3.adc = ADC3;
    36c8:	4b0e      	ldr	r3, [pc, #56]	; (3704 <adc_lld_init+0x74>)
    36ca:	4a0f      	ldr	r2, [pc, #60]	; (3708 <adc_lld_init+0x78>)
    36cc:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD3.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC3_DMA_STREAM);
    36ce:	4b0d      	ldr	r3, [pc, #52]	; (3704 <adc_lld_init+0x74>)
    36d0:	4a0e      	ldr	r2, [pc, #56]	; (370c <adc_lld_init+0x7c>)
    36d2:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD3.dmamode = STM32_DMA_CR_CHSEL(ADC3_DMA_CHANNEL) |
    36d4:	4b0b      	ldr	r3, [pc, #44]	; (3704 <adc_lld_init+0x74>)
    36d6:	4a0e      	ldr	r2, [pc, #56]	; (3710 <adc_lld_init+0x80>)
    36d8:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled because sharing.*/
  nvicEnableVector(STM32_ADC_NUMBER, STM32_ADC_IRQ_PRIORITY);
    36da:	2012      	movs	r0, #18
    36dc:	2106      	movs	r1, #6
    36de:	f7ff fa4f 	bl	2b80 <nvicEnableVector>
}
    36e2:	bd08      	pop	{r3, pc}
    36e4:	20000e84 	.word	0x20000e84
    36e8:	40012000 	.word	0x40012000
    36ec:	00004320 	.word	0x00004320
    36f0:	00022c16 	.word	0x00022c16
    36f4:	20000eb8 	.word	0x20000eb8
    36f8:	40012100 	.word	0x40012100
    36fc:	00004308 	.word	0x00004308
    3700:	02022c16 	.word	0x02022c16
    3704:	20000eec 	.word	0x20000eec
    3708:	40012200 	.word	0x40012200
    370c:	000042fc 	.word	0x000042fc
    3710:	04022c16 	.word	0x04022c16
    3714:	f3af 8000 	nop.w
    3718:	f3af 8000 	nop.w
    371c:	f3af 8000 	nop.w

00003720 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
    3720:	b082      	sub	sp, #8
    3722:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
    3724:	9b01      	ldr	r3, [sp, #4]
    3726:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3728:	681b      	ldr	r3, [r3, #0]
    372a:	9a01      	ldr	r2, [sp, #4]
    372c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    372e:	6812      	ldr	r2, [r2, #0]
    3730:	6812      	ldr	r2, [r2, #0]
    3732:	f022 021f 	bic.w	r2, r2, #31
    3736:	601a      	str	r2, [r3, #0]
    3738:	bf00      	nop
    373a:	9b01      	ldr	r3, [sp, #4]
    373c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    373e:	681b      	ldr	r3, [r3, #0]
    3740:	681b      	ldr	r3, [r3, #0]
    3742:	f003 0301 	and.w	r3, r3, #1
    3746:	2b00      	cmp	r3, #0
    3748:	d1f7      	bne.n	373a <adc_lld_stop_conversion+0x1a>
    374a:	9b01      	ldr	r3, [sp, #4]
    374c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    374e:	685b      	ldr	r3, [r3, #4]
    3750:	9a01      	ldr	r2, [sp, #4]
    3752:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    3754:	7a12      	ldrb	r2, [r2, #8]
    3756:	213d      	movs	r1, #61	; 0x3d
    3758:	fa01 f202 	lsl.w	r2, r1, r2
    375c:	601a      	str	r2, [r3, #0]
  adcp->adc->CR1 = 0;
    375e:	9b01      	ldr	r3, [sp, #4]
    3760:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3762:	2200      	movs	r2, #0
    3764:	605a      	str	r2, [r3, #4]
  adcp->adc->CR2 = 0;
    3766:	9b01      	ldr	r3, [sp, #4]
    3768:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    376a:	2200      	movs	r2, #0
    376c:	609a      	str	r2, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
    376e:	9b01      	ldr	r3, [sp, #4]
    3770:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3772:	2201      	movs	r2, #1
    3774:	609a      	str	r2, [r3, #8]
}
    3776:	b002      	add	sp, #8
    3778:	4770      	bx	lr
    377a:	bf00      	nop
    377c:	f3af 8000 	nop.w

00003780 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
    3780:	b082      	sub	sp, #8
    3782:	9001      	str	r0, [sp, #4]
    3784:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
    3786:	9b00      	ldr	r3, [sp, #0]
    3788:	685a      	ldr	r2, [r3, #4]
    378a:	9b01      	ldr	r3, [sp, #4]
    378c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
    378e:	9b00      	ldr	r3, [sp, #0]
    3790:	689a      	ldr	r2, [r3, #8]
    3792:	9b01      	ldr	r3, [sp, #4]
    3794:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
    3796:	9b00      	ldr	r3, [sp, #0]
    3798:	68da      	ldr	r2, [r3, #12]
    379a:	9b01      	ldr	r3, [sp, #4]
    379c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
    379e:	9b00      	ldr	r3, [sp, #0]
    37a0:	691a      	ldr	r2, [r3, #16]
    37a2:	9b01      	ldr	r3, [sp, #4]
    37a4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
    37a6:	9b00      	ldr	r3, [sp, #0]
    37a8:	695a      	ldr	r2, [r3, #20]
    37aa:	9b01      	ldr	r3, [sp, #4]
    37ac:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
    37ae:	9b00      	ldr	r3, [sp, #0]
    37b0:	699a      	ldr	r2, [r3, #24]
    37b2:	9b01      	ldr	r3, [sp, #4]
    37b4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
    37b6:	9b00      	ldr	r3, [sp, #0]
    37b8:	681a      	ldr	r2, [r3, #0]
    37ba:	9b01      	ldr	r3, [sp, #4]
    37bc:	601a      	str	r2, [r3, #0]
}
    37be:	b002      	add	sp, #8
    37c0:	4770      	bx	lr
    37c2:	bf00      	nop
    37c4:	f3af 8000 	nop.w
    37c8:	f3af 8000 	nop.w
    37cc:	f3af 8000 	nop.w

000037d0 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    37d0:	b500      	push	{lr}
    37d2:	b083      	sub	sp, #12
    37d4:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
    37d6:	4a24      	ldr	r2, [pc, #144]	; (3868 <_pal_lld_init+0x98>)
    37d8:	4b23      	ldr	r3, [pc, #140]	; (3868 <_pal_lld_init+0x98>)
    37da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    37dc:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    37e0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    37e4:	6313      	str	r3, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
    37e6:	4a20      	ldr	r2, [pc, #128]	; (3868 <_pal_lld_init+0x98>)
    37e8:	4b1f      	ldr	r3, [pc, #124]	; (3868 <_pal_lld_init+0x98>)
    37ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    37ec:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    37f0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    37f4:	6513      	str	r3, [r2, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
    37f6:	9b01      	ldr	r3, [sp, #4]
    37f8:	481c      	ldr	r0, [pc, #112]	; (386c <_pal_lld_init+0x9c>)
    37fa:	4619      	mov	r1, r3
    37fc:	f7ff ffc0 	bl	3780 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
    3800:	9b01      	ldr	r3, [sp, #4]
    3802:	331c      	adds	r3, #28
    3804:	481a      	ldr	r0, [pc, #104]	; (3870 <_pal_lld_init+0xa0>)
    3806:	4619      	mov	r1, r3
    3808:	f7ff ffba 	bl	3780 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
    380c:	9b01      	ldr	r3, [sp, #4]
    380e:	3338      	adds	r3, #56	; 0x38
    3810:	4818      	ldr	r0, [pc, #96]	; (3874 <_pal_lld_init+0xa4>)
    3812:	4619      	mov	r1, r3
    3814:	f7ff ffb4 	bl	3780 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
    3818:	9b01      	ldr	r3, [sp, #4]
    381a:	3354      	adds	r3, #84	; 0x54
    381c:	4816      	ldr	r0, [pc, #88]	; (3878 <_pal_lld_init+0xa8>)
    381e:	4619      	mov	r1, r3
    3820:	f7ff ffae 	bl	3780 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
    3824:	9b01      	ldr	r3, [sp, #4]
    3826:	3370      	adds	r3, #112	; 0x70
    3828:	4814      	ldr	r0, [pc, #80]	; (387c <_pal_lld_init+0xac>)
    382a:	4619      	mov	r1, r3
    382c:	f7ff ffa8 	bl	3780 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
    3830:	9b01      	ldr	r3, [sp, #4]
    3832:	338c      	adds	r3, #140	; 0x8c
    3834:	4812      	ldr	r0, [pc, #72]	; (3880 <_pal_lld_init+0xb0>)
    3836:	4619      	mov	r1, r3
    3838:	f7ff ffa2 	bl	3780 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
    383c:	9b01      	ldr	r3, [sp, #4]
    383e:	33a8      	adds	r3, #168	; 0xa8
    3840:	4810      	ldr	r0, [pc, #64]	; (3884 <_pal_lld_init+0xb4>)
    3842:	4619      	mov	r1, r3
    3844:	f7ff ff9c 	bl	3780 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
    3848:	9b01      	ldr	r3, [sp, #4]
    384a:	33c4      	adds	r3, #196	; 0xc4
    384c:	480e      	ldr	r0, [pc, #56]	; (3888 <_pal_lld_init+0xb8>)
    384e:	4619      	mov	r1, r3
    3850:	f7ff ff96 	bl	3780 <initgpio>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
    3854:	9b01      	ldr	r3, [sp, #4]
    3856:	33e0      	adds	r3, #224	; 0xe0
    3858:	480c      	ldr	r0, [pc, #48]	; (388c <_pal_lld_init+0xbc>)
    385a:	4619      	mov	r1, r3
    385c:	f7ff ff90 	bl	3780 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
    3860:	b003      	add	sp, #12
    3862:	f85d fb04 	ldr.w	pc, [sp], #4
    3866:	bf00      	nop
    3868:	40023800 	.word	0x40023800
    386c:	40020000 	.word	0x40020000
    3870:	40020400 	.word	0x40020400
    3874:	40020800 	.word	0x40020800
    3878:	40020c00 	.word	0x40020c00
    387c:	40021000 	.word	0x40021000
    3880:	40021400 	.word	0x40021400
    3884:	40021800 	.word	0x40021800
    3888:	40021c00 	.word	0x40021c00
    388c:	40022000 	.word	0x40022000

00003890 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    3890:	b08e      	sub	sp, #56	; 0x38
    3892:	9003      	str	r0, [sp, #12]
    3894:	9102      	str	r1, [sp, #8]
    3896:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
    3898:	9b01      	ldr	r3, [sp, #4]
    389a:	f003 0303 	and.w	r3, r3, #3
    389e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
    38a0:	9b01      	ldr	r3, [sp, #4]
    38a2:	f003 0304 	and.w	r3, r3, #4
    38a6:	089b      	lsrs	r3, r3, #2
    38a8:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
    38aa:	9b01      	ldr	r3, [sp, #4]
    38ac:	f003 0318 	and.w	r3, r3, #24
    38b0:	08db      	lsrs	r3, r3, #3
    38b2:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
    38b4:	9b01      	ldr	r3, [sp, #4]
    38b6:	f003 0360 	and.w	r3, r3, #96	; 0x60
    38ba:	095b      	lsrs	r3, r3, #5
    38bc:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
    38be:	9b01      	ldr	r3, [sp, #4]
    38c0:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
    38c4:	09db      	lsrs	r3, r3, #7
    38c6:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
    38c8:	2300      	movs	r3, #0
    38ca:	9309      	str	r3, [sp, #36]	; 0x24
  while (TRUE) {
    if ((mask & 1) != 0) {
    38cc:	9b02      	ldr	r3, [sp, #8]
    38ce:	f003 0301 	and.w	r3, r3, #1
    38d2:	2b00      	cmp	r3, #0
    38d4:	d054      	beq.n	3980 <_pal_lld_setgroupmode+0xf0>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
    38d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    38d8:	f003 0307 	and.w	r3, r3, #7
    38dc:	009b      	lsls	r3, r3, #2
    38de:	9a08      	ldr	r2, [sp, #32]
    38e0:	fa02 f303 	lsl.w	r3, r2, r3
    38e4:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
    38e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    38e8:	f003 0307 	and.w	r3, r3, #7
    38ec:	009b      	lsls	r3, r3, #2
    38ee:	220f      	movs	r2, #15
    38f0:	fa02 f303 	lsl.w	r3, r2, r3
    38f4:	9306      	str	r3, [sp, #24]
      if (bit < 8)
    38f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    38f8:	2b07      	cmp	r3, #7
    38fa:	d809      	bhi.n	3910 <_pal_lld_setgroupmode+0x80>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
    38fc:	9b03      	ldr	r3, [sp, #12]
    38fe:	6a1a      	ldr	r2, [r3, #32]
    3900:	9b06      	ldr	r3, [sp, #24]
    3902:	43db      	mvns	r3, r3
    3904:	401a      	ands	r2, r3
    3906:	9b07      	ldr	r3, [sp, #28]
    3908:	431a      	orrs	r2, r3
    390a:	9b03      	ldr	r3, [sp, #12]
    390c:	621a      	str	r2, [r3, #32]
    390e:	e008      	b.n	3922 <_pal_lld_setgroupmode+0x92>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
    3910:	9b03      	ldr	r3, [sp, #12]
    3912:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    3914:	9b06      	ldr	r3, [sp, #24]
    3916:	43db      	mvns	r3, r3
    3918:	401a      	ands	r2, r3
    391a:	9b07      	ldr	r3, [sp, #28]
    391c:	431a      	orrs	r2, r3
    391e:	9b03      	ldr	r3, [sp, #12]
    3920:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
    3922:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3924:	2201      	movs	r2, #1
    3926:	fa02 f303 	lsl.w	r3, r2, r3
    392a:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
    392c:	9b03      	ldr	r3, [sp, #12]
    392e:	685a      	ldr	r2, [r3, #4]
    3930:	9b05      	ldr	r3, [sp, #20]
    3932:	43db      	mvns	r3, r3
    3934:	401a      	ands	r2, r3
    3936:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    3938:	431a      	orrs	r2, r3
    393a:	9b03      	ldr	r3, [sp, #12]
    393c:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
    393e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3940:	005b      	lsls	r3, r3, #1
    3942:	2203      	movs	r2, #3
    3944:	fa02 f303 	lsl.w	r3, r2, r3
    3948:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
    394a:	9b03      	ldr	r3, [sp, #12]
    394c:	689a      	ldr	r2, [r3, #8]
    394e:	9b04      	ldr	r3, [sp, #16]
    3950:	43db      	mvns	r3, r3
    3952:	401a      	ands	r2, r3
    3954:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3956:	431a      	orrs	r2, r3
    3958:	9b03      	ldr	r3, [sp, #12]
    395a:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
    395c:	9b03      	ldr	r3, [sp, #12]
    395e:	68da      	ldr	r2, [r3, #12]
    3960:	9b04      	ldr	r3, [sp, #16]
    3962:	43db      	mvns	r3, r3
    3964:	401a      	ands	r2, r3
    3966:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    3968:	431a      	orrs	r2, r3
    396a:	9b03      	ldr	r3, [sp, #12]
    396c:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
    396e:	9b03      	ldr	r3, [sp, #12]
    3970:	681a      	ldr	r2, [r3, #0]
    3972:	9b04      	ldr	r3, [sp, #16]
    3974:	43db      	mvns	r3, r3
    3976:	401a      	ands	r2, r3
    3978:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    397a:	431a      	orrs	r2, r3
    397c:	9b03      	ldr	r3, [sp, #12]
    397e:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
    3980:	9b02      	ldr	r3, [sp, #8]
    3982:	085b      	lsrs	r3, r3, #1
    3984:	9302      	str	r3, [sp, #8]
    if (!mask)
    3986:	9b02      	ldr	r3, [sp, #8]
    3988:	2b00      	cmp	r3, #0
    398a:	d100      	bne.n	398e <_pal_lld_setgroupmode+0xfe>
      return;
    398c:	e00f      	b.n	39ae <_pal_lld_setgroupmode+0x11e>
    otyper <<= 1;
    398e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    3990:	005b      	lsls	r3, r3, #1
    3992:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
    3994:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3996:	009b      	lsls	r3, r3, #2
    3998:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
    399a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    399c:	009b      	lsls	r3, r3, #2
    399e:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
    39a0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    39a2:	009b      	lsls	r3, r3, #2
    39a4:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
    39a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    39a8:	3301      	adds	r3, #1
    39aa:	9309      	str	r3, [sp, #36]	; 0x24
  }
    39ac:	e78e      	b.n	38cc <_pal_lld_setgroupmode+0x3c>
}
    39ae:	b00e      	add	sp, #56	; 0x38
    39b0:	4770      	bx	lr
    39b2:	bf00      	nop
    39b4:	f3af 8000 	nop.w
    39b8:	f3af 8000 	nop.w
    39bc:	f3af 8000 	nop.w

000039c0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    39c0:	b082      	sub	sp, #8
    39c2:	2320      	movs	r3, #32
    39c4:	9301      	str	r3, [sp, #4]
    39c6:	9b01      	ldr	r3, [sp, #4]
    39c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    39cc:	b002      	add	sp, #8
    39ce:	4770      	bx	lr

000039d0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    39d0:	b082      	sub	sp, #8
    39d2:	2300      	movs	r3, #0
    39d4:	9301      	str	r3, [sp, #4]
    39d6:	9b01      	ldr	r3, [sp, #4]
    39d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    39dc:	b002      	add	sp, #8
    39de:	4770      	bx	lr

000039e0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    39e0:	b508      	push	{r3, lr}

  port_lock();
    39e2:	f7ff ffed 	bl	39c0 <port_lock>
}
    39e6:	bd08      	pop	{r3, pc}
    39e8:	f3af 8000 	nop.w
    39ec:	f3af 8000 	nop.w

000039f0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    39f0:	b508      	push	{r3, lr}

  port_unlock();
    39f2:	f7ff ffed 	bl	39d0 <port_unlock>
}
    39f6:	bd08      	pop	{r3, pc}
    39f8:	f3af 8000 	nop.w
    39fc:	f3af 8000 	nop.w

00003a00 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    3a00:	b508      	push	{r3, lr}

  port_lock_from_isr();
    3a02:	f7ff ffed 	bl	39e0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    3a06:	f7fd ff73 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    3a0a:	f7fc fee9 	bl	7e0 <_dbg_check_lock_from_isr>
}
    3a0e:	bd08      	pop	{r3, pc}

00003a10 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    3a10:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    3a12:	f7fc fefd 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    3a16:	f7fd ff73 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    3a1a:	f7ff ffe9 	bl	39f0 <port_unlock_from_isr>
}
    3a1e:	bd08      	pop	{r3, pc}

00003a20 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
    3a20:	b500      	push	{lr}
    3a22:	b083      	sub	sp, #12
    3a24:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    3a26:	f7fc ff4b 	bl	8c0 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    3a2a:	9b01      	ldr	r3, [sp, #4]
    3a2c:	695a      	ldr	r2, [r3, #20]
    3a2e:	9b01      	ldr	r3, [sp, #4]
    3a30:	699b      	ldr	r3, [r3, #24]
    3a32:	429a      	cmp	r2, r3
    3a34:	d105      	bne.n	3a42 <chOQIsEmptyI+0x22>
    3a36:	9b01      	ldr	r3, [sp, #4]
    3a38:	689b      	ldr	r3, [r3, #8]
    3a3a:	2b00      	cmp	r3, #0
    3a3c:	d001      	beq.n	3a42 <chOQIsEmptyI+0x22>
    3a3e:	2301      	movs	r3, #1
    3a40:	e000      	b.n	3a44 <chOQIsEmptyI+0x24>
    3a42:	2300      	movs	r3, #0
    3a44:	f003 0301 	and.w	r3, r3, #1
    3a48:	b2db      	uxtb	r3, r3
}
    3a4a:	4618      	mov	r0, r3
    3a4c:	b003      	add	sp, #12
    3a4e:	f85d fb04 	ldr.w	pc, [sp], #4
    3a52:	bf00      	nop
    3a54:	f3af 8000 	nop.w
    3a58:	f3af 8000 	nop.w
    3a5c:	f3af 8000 	nop.w

00003a60 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    3a60:	b508      	push	{r3, lr}

  chSysLockFromISR();
    3a62:	f7ff ffcd 	bl	3a00 <chSysLockFromISR>
}
    3a66:	bd08      	pop	{r3, pc}
    3a68:	f3af 8000 	nop.w
    3a6c:	f3af 8000 	nop.w

00003a70 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    3a70:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    3a72:	f7ff ffcd 	bl	3a10 <chSysUnlockFromISR>
}
    3a76:	bd08      	pop	{r3, pc}
    3a78:	f3af 8000 	nop.w
    3a7c:	f3af 8000 	nop.w

00003a80 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    3a80:	b500      	push	{lr}
    3a82:	b083      	sub	sp, #12
    3a84:	9001      	str	r0, [sp, #4]
    3a86:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
    3a88:	9801      	ldr	r0, [sp, #4]
    3a8a:	9900      	ldr	r1, [sp, #0]
    3a8c:	f7fe f890 	bl	1bb0 <chEvtBroadcastFlagsI>
}
    3a90:	b003      	add	sp, #12
    3a92:	f85d fb04 	ldr.w	pc, [sp], #4
    3a96:	bf00      	nop
    3a98:	f3af 8000 	nop.w
    3a9c:	f3af 8000 	nop.w

00003aa0 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
    3aa0:	b084      	sub	sp, #16
    3aa2:	9001      	str	r0, [sp, #4]
    3aa4:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
    3aa6:	9b01      	ldr	r3, [sp, #4]
    3aa8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    3aac:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
    3aae:	9b01      	ldr	r3, [sp, #4]
    3ab0:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    3ab4:	4b1d      	ldr	r3, [pc, #116]	; (3b2c <usart_init+0x8c>)
    3ab6:	429a      	cmp	r2, r3
    3ab8:	d005      	beq.n	3ac6 <usart_init+0x26>
    3aba:	9b01      	ldr	r3, [sp, #4]
    3abc:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    3ac0:	4b1b      	ldr	r3, [pc, #108]	; (3b30 <usart_init+0x90>)
    3ac2:	429a      	cmp	r2, r3
    3ac4:	d107      	bne.n	3ad6 <usart_init+0x36>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
    3ac6:	9b00      	ldr	r3, [sp, #0]
    3ac8:	681b      	ldr	r3, [r3, #0]
    3aca:	4a1a      	ldr	r2, [pc, #104]	; (3b34 <usart_init+0x94>)
    3acc:	fbb2 f2f3 	udiv	r2, r2, r3
    3ad0:	9b03      	ldr	r3, [sp, #12]
    3ad2:	609a      	str	r2, [r3, #8]
    3ad4:	e006      	b.n	3ae4 <usart_init+0x44>
  else
    u->BRR = STM32_PCLK1 / config->speed;
    3ad6:	9b00      	ldr	r3, [sp, #0]
    3ad8:	681b      	ldr	r3, [r3, #0]
    3ada:	4a17      	ldr	r2, [pc, #92]	; (3b38 <usart_init+0x98>)
    3adc:	fbb2 f2f3 	udiv	r2, r2, r3
    3ae0:	9b03      	ldr	r3, [sp, #12]
    3ae2:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
    3ae4:	9b00      	ldr	r3, [sp, #0]
    3ae6:	88db      	ldrh	r3, [r3, #6]
    3ae8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    3aec:	b29b      	uxth	r3, r3
    3aee:	461a      	mov	r2, r3
    3af0:	9b03      	ldr	r3, [sp, #12]
    3af2:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
    3af4:	9b00      	ldr	r3, [sp, #0]
    3af6:	891b      	ldrh	r3, [r3, #8]
    3af8:	f043 0301 	orr.w	r3, r3, #1
    3afc:	b29b      	uxth	r3, r3
    3afe:	461a      	mov	r2, r3
    3b00:	9b03      	ldr	r3, [sp, #12]
    3b02:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
    3b04:	9b00      	ldr	r3, [sp, #0]
    3b06:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
    3b08:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
    3b0c:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
    3b10:	b29b      	uxth	r3, r3
    3b12:	461a      	mov	r2, r3
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
    3b14:	9b03      	ldr	r3, [sp, #12]
    3b16:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
    3b18:	9b03      	ldr	r3, [sp, #12]
    3b1a:	2200      	movs	r2, #0
    3b1c:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
    3b1e:	9b03      	ldr	r3, [sp, #12]
    3b20:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
    3b22:	9b03      	ldr	r3, [sp, #12]
    3b24:	685b      	ldr	r3, [r3, #4]
}
    3b26:	b004      	add	sp, #16
    3b28:	4770      	bx	lr
    3b2a:	bf00      	nop
    3b2c:	40011000 	.word	0x40011000
    3b30:	40011400 	.word	0x40011400
    3b34:	0501bd00 	.word	0x0501bd00
    3b38:	0280de80 	.word	0x0280de80
    3b3c:	f3af 8000 	nop.w

00003b40 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
    3b40:	b500      	push	{lr}
    3b42:	b085      	sub	sp, #20
    3b44:	9001      	str	r0, [sp, #4]
    3b46:	460b      	mov	r3, r1
    3b48:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
    3b4c:	2300      	movs	r3, #0
    3b4e:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
    3b50:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    3b54:	f003 0308 	and.w	r3, r3, #8
    3b58:	2b00      	cmp	r3, #0
    3b5a:	d003      	beq.n	3b64 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
    3b5c:	9b03      	ldr	r3, [sp, #12]
    3b5e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    3b62:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
    3b64:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    3b68:	f003 0301 	and.w	r3, r3, #1
    3b6c:	2b00      	cmp	r3, #0
    3b6e:	d003      	beq.n	3b78 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
    3b70:	9b03      	ldr	r3, [sp, #12]
    3b72:	f043 0320 	orr.w	r3, r3, #32
    3b76:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
    3b78:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    3b7c:	f003 0302 	and.w	r3, r3, #2
    3b80:	2b00      	cmp	r3, #0
    3b82:	d003      	beq.n	3b8c <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
    3b84:	9b03      	ldr	r3, [sp, #12]
    3b86:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    3b8a:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
    3b8c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    3b90:	f003 0304 	and.w	r3, r3, #4
    3b94:	2b00      	cmp	r3, #0
    3b96:	d003      	beq.n	3ba0 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
    3b98:	9b03      	ldr	r3, [sp, #12]
    3b9a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    3b9e:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
    3ba0:	9b01      	ldr	r3, [sp, #4]
    3ba2:	3304      	adds	r3, #4
    3ba4:	4618      	mov	r0, r3
    3ba6:	9903      	ldr	r1, [sp, #12]
    3ba8:	f7ff ff6a 	bl	3a80 <osalEventBroadcastFlagsI>
}
    3bac:	b005      	add	sp, #20
    3bae:	f85d fb04 	ldr.w	pc, [sp], #4
    3bb2:	bf00      	nop
    3bb4:	f3af 8000 	nop.w
    3bb8:	f3af 8000 	nop.w
    3bbc:	f3af 8000 	nop.w

00003bc0 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
    3bc0:	b500      	push	{lr}
    3bc2:	b087      	sub	sp, #28
    3bc4:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
    3bc6:	9b01      	ldr	r3, [sp, #4]
    3bc8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    3bcc:	9304      	str	r3, [sp, #16]
  uint16_t cr1 = u->CR1;
    3bce:	9b04      	ldr	r3, [sp, #16]
    3bd0:	68db      	ldr	r3, [r3, #12]
    3bd2:	f8ad 300e 	strh.w	r3, [sp, #14]
  uint16_t sr = u->SR;
    3bd6:	9b04      	ldr	r3, [sp, #16]
    3bd8:	681b      	ldr	r3, [r3, #0]
    3bda:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    3bde:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3be2:	f403 7380 	and.w	r3, r3, #256	; 0x100
    3be6:	2b00      	cmp	r3, #0
    3be8:	d00e      	beq.n	3c08 <serve_interrupt+0x48>
    osalSysLockFromISR();
    3bea:	f7ff ff39 	bl	3a60 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    3bee:	9b01      	ldr	r3, [sp, #4]
    3bf0:	3304      	adds	r3, #4
    3bf2:	4618      	mov	r0, r3
    3bf4:	f44f 7100 	mov.w	r1, #512	; 0x200
    3bf8:	f7ff ff42 	bl	3a80 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
    3bfc:	9b04      	ldr	r3, [sp, #16]
    3bfe:	f46f 7280 	mvn.w	r2, #256	; 0x100
    3c02:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
    3c04:	f7ff ff34 	bl	3a70 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  osalSysLockFromISR();
    3c08:	f7ff ff2a 	bl	3a60 <osalSysLockFromISR>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
    3c0c:	e01f      	b.n	3c4e <serve_interrupt+0x8e>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
    3c0e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3c12:	f003 030f 	and.w	r3, r3, #15
    3c16:	2b00      	cmp	r3, #0
    3c18:	d005      	beq.n	3c26 <serve_interrupt+0x66>
      set_error(sdp, sr);
    3c1a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3c1e:	9801      	ldr	r0, [sp, #4]
    3c20:	4619      	mov	r1, r3
    3c22:	f7ff ff8d 	bl	3b40 <set_error>
    b = u->DR;
    3c26:	9b04      	ldr	r3, [sp, #16]
    3c28:	685b      	ldr	r3, [r3, #4]
    3c2a:	f88d 300d 	strb.w	r3, [sp, #13]
    if (sr & USART_SR_RXNE)
    3c2e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3c32:	f003 0320 	and.w	r3, r3, #32
    3c36:	2b00      	cmp	r3, #0
    3c38:	d005      	beq.n	3c46 <serve_interrupt+0x86>
      sdIncomingDataI(sdp, b);
    3c3a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    3c3e:	9801      	ldr	r0, [sp, #4]
    3c40:	4619      	mov	r1, r3
    3c42:	f7fe ff65 	bl	2b10 <sdIncomingDataI>
    sr = u->SR;
    3c46:	9b04      	ldr	r3, [sp, #16]
    3c48:	681b      	ldr	r3, [r3, #0]
    3c4a:	f8ad 3016 	strh.w	r3, [sp, #22]
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
    3c4e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3c52:	f003 032f 	and.w	r3, r3, #47	; 0x2f
    3c56:	2b00      	cmp	r3, #0
    3c58:	d1d9      	bne.n	3c0e <serve_interrupt+0x4e>
    b = u->DR;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
  }
  osalSysUnlockFromISR();
    3c5a:	f7ff ff09 	bl	3a70 <osalSysUnlockFromISR>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    3c5e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    3c62:	f003 0380 	and.w	r3, r3, #128	; 0x80
    3c66:	2b00      	cmp	r3, #0
    3c68:	d024      	beq.n	3cb4 <serve_interrupt+0xf4>
    3c6a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3c6e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    3c72:	2b00      	cmp	r3, #0
    3c74:	d01e      	beq.n	3cb4 <serve_interrupt+0xf4>
    msg_t b;
    osalSysLockFromISR();
    3c76:	f7ff fef3 	bl	3a60 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
    3c7a:	9b01      	ldr	r3, [sp, #4]
    3c7c:	3330      	adds	r3, #48	; 0x30
    3c7e:	4618      	mov	r0, r3
    3c80:	f7fe fb4e 	bl	2320 <chOQGetI>
    3c84:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
    3c86:	9b02      	ldr	r3, [sp, #8]
    3c88:	2b00      	cmp	r3, #0
    3c8a:	da0e      	bge.n	3caa <serve_interrupt+0xea>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    3c8c:	9b01      	ldr	r3, [sp, #4]
    3c8e:	3304      	adds	r3, #4
    3c90:	4618      	mov	r0, r3
    3c92:	2108      	movs	r1, #8
    3c94:	f7ff fef4 	bl	3a80 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    3c98:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    3c9c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    3ca0:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    3ca4:	9b04      	ldr	r3, [sp, #16]
    3ca6:	60da      	str	r2, [r3, #12]
    3ca8:	e002      	b.n	3cb0 <serve_interrupt+0xf0>
    }
    else
      u->DR = b;
    3caa:	9a02      	ldr	r2, [sp, #8]
    3cac:	9b04      	ldr	r3, [sp, #16]
    3cae:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
    3cb0:	f7ff fede 	bl	3a70 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    3cb4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3cb8:	f003 0340 	and.w	r3, r3, #64	; 0x40
    3cbc:	2b00      	cmp	r3, #0
    3cbe:	d01b      	beq.n	3cf8 <serve_interrupt+0x138>
    osalSysLockFromISR();
    3cc0:	f7ff fece 	bl	3a60 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
    3cc4:	9b01      	ldr	r3, [sp, #4]
    3cc6:	3330      	adds	r3, #48	; 0x30
    3cc8:	4618      	mov	r0, r3
    3cca:	f7ff fea9 	bl	3a20 <chOQIsEmptyI>
    3cce:	4603      	mov	r3, r0
    3cd0:	2b00      	cmp	r3, #0
    3cd2:	d005      	beq.n	3ce0 <serve_interrupt+0x120>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    3cd4:	9b01      	ldr	r3, [sp, #4]
    3cd6:	3304      	adds	r3, #4
    3cd8:	4618      	mov	r0, r3
    3cda:	2110      	movs	r1, #16
    3cdc:	f7ff fed0 	bl	3a80 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
    3ce0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    3ce4:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    3ce8:	9b04      	ldr	r3, [sp, #16]
    3cea:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
    3cec:	9b04      	ldr	r3, [sp, #16]
    3cee:	f06f 0240 	mvn.w	r2, #64	; 0x40
    3cf2:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
    3cf4:	f7ff febc 	bl	3a70 <osalSysUnlockFromISR>
  }
}
    3cf8:	b007      	add	sp, #28
    3cfa:	f85d fb04 	ldr.w	pc, [sp], #4
    3cfe:	bf00      	nop

00003d00 <notify3>:
  USART2->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {
    3d00:	b082      	sub	sp, #8
    3d02:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE;
    3d04:	4b03      	ldr	r3, [pc, #12]	; (3d14 <notify3+0x14>)
    3d06:	4a03      	ldr	r2, [pc, #12]	; (3d14 <notify3+0x14>)
    3d08:	68d2      	ldr	r2, [r2, #12]
    3d0a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    3d0e:	60da      	str	r2, [r3, #12]
}
    3d10:	b002      	add	sp, #8
    3d12:	4770      	bx	lr
    3d14:	40004800 	.word	0x40004800
    3d18:	f3af 8000 	nop.w
    3d1c:	f3af 8000 	nop.w

00003d20 <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
    3d20:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    3d22:	f7fd fda5 	bl	1870 <_stats_increase_irq>
    3d26:	f7fc fd8b 	bl	840 <_dbg_check_enter_isr>

  serve_interrupt(&SD3);
    3d2a:	4804      	ldr	r0, [pc, #16]	; (3d3c <VectorDC+0x1c>)
    3d2c:	f7ff ff48 	bl	3bc0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
    3d30:	f7fc fda6 	bl	880 <_dbg_check_leave_isr>
    3d34:	f7fe fc5c 	bl	25f0 <_port_irq_epilogue>
}
    3d38:	bd08      	pop	{r3, pc}
    3d3a:	bf00      	nop
    3d3c:	20000f20 	.word	0x20000f20

00003d40 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
    3d40:	b508      	push	{r3, lr}
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
    3d42:	4805      	ldr	r0, [pc, #20]	; (3d58 <sd_lld_init+0x18>)
    3d44:	2100      	movs	r1, #0
    3d46:	4a05      	ldr	r2, [pc, #20]	; (3d5c <sd_lld_init+0x1c>)
    3d48:	f7fe fe8a 	bl	2a60 <sdObjectInit>
  SD3.usart = USART3;
    3d4c:	4b02      	ldr	r3, [pc, #8]	; (3d58 <sd_lld_init+0x18>)
    3d4e:	4a04      	ldr	r2, [pc, #16]	; (3d60 <sd_lld_init+0x20>)
    3d50:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
    3d54:	bd08      	pop	{r3, pc}
    3d56:	bf00      	nop
    3d58:	20000f20 	.word	0x20000f20
    3d5c:	00003d01 	.word	0x00003d01
    3d60:	40004800 	.word	0x40004800
    3d64:	f3af 8000 	nop.w
    3d68:	f3af 8000 	nop.w
    3d6c:	f3af 8000 	nop.w

00003d70 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
    3d70:	b500      	push	{lr}
    3d72:	b083      	sub	sp, #12
    3d74:	9001      	str	r0, [sp, #4]
    3d76:	9100      	str	r1, [sp, #0]

  if (config == NULL)
    3d78:	9b00      	ldr	r3, [sp, #0]
    3d7a:	2b00      	cmp	r3, #0
    3d7c:	d101      	bne.n	3d82 <sd_lld_start+0x12>
    config = &default_config;
    3d7e:	4b0d      	ldr	r3, [pc, #52]	; (3db4 <sd_lld_start+0x44>)
    3d80:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
    3d82:	9b01      	ldr	r3, [sp, #4]
    3d84:	7a1b      	ldrb	r3, [r3, #8]
    3d86:	2b01      	cmp	r3, #1
    3d88:	d10d      	bne.n	3da6 <sd_lld_start+0x36>
      rccEnableUSART2(FALSE);
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
    3d8a:	9a01      	ldr	r2, [sp, #4]
    3d8c:	4b0a      	ldr	r3, [pc, #40]	; (3db8 <sd_lld_start+0x48>)
    3d8e:	429a      	cmp	r2, r3
    3d90:	d109      	bne.n	3da6 <sd_lld_start+0x36>
      rccEnableUSART3(FALSE);
    3d92:	4b0a      	ldr	r3, [pc, #40]	; (3dbc <sd_lld_start+0x4c>)
    3d94:	4a09      	ldr	r2, [pc, #36]	; (3dbc <sd_lld_start+0x4c>)
    3d96:	6c12      	ldr	r2, [r2, #64]	; 0x40
    3d98:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
    3d9c:	641a      	str	r2, [r3, #64]	; 0x40
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
    3d9e:	2027      	movs	r0, #39	; 0x27
    3da0:	210c      	movs	r1, #12
    3da2:	f7fe feed 	bl	2b80 <nvicEnableVector>
      rccEnableUART8(FALSE);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
    3da6:	9801      	ldr	r0, [sp, #4]
    3da8:	9900      	ldr	r1, [sp, #0]
    3daa:	f7ff fe79 	bl	3aa0 <usart_init>
}
    3dae:	b003      	add	sp, #12
    3db0:	f85d fb04 	ldr.w	pc, [sp], #4
    3db4:	00004350 	.word	0x00004350
    3db8:	20000f20 	.word	0x20000f20
    3dbc:	40023800 	.word	0x40023800

00003dc0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
    3dc0:	b508      	push	{r3, lr}

  stm32_clock_init();
    3dc2:	f7fe ff5d 	bl	2c80 <stm32_clock_init>
}
    3dc6:	bd08      	pop	{r3, pc}
    3dc8:	f3af 8000 	nop.w
    3dcc:	f3af 8000 	nop.w

00003dd0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
    3dd0:	4770      	bx	lr
    3dd2:	bf00      	nop
    3dd4:	f3af 8000 	nop.w
    3dd8:	f3af 8000 	nop.w
    3ddc:	f3af 8000 	nop.w

00003de0 <main>:
#include "main.h"

uint8_t cca_exp_io_mode;


int main(void) {
    3de0:	b500      	push	{lr}
    3de2:	b085      	sub	sp, #20
	halInit();
    3de4:	f7fe fc44 	bl	2670 <halInit>
	chSysInit();
    3de8:	f7fc fc1a 	bl	620 <chSysInit>
	thread_t *listener,*writer;
	
	
	palWriteGroup(GPIOD,0xFFFFU,0,0x0000U);//all ports low
    3dec:	4b16      	ldr	r3, [pc, #88]	; (3e48 <main+0x68>)
    3dee:	4a17      	ldr	r2, [pc, #92]	; (3e4c <main+0x6c>)
    3df0:	619a      	str	r2, [r3, #24]
	chThdSetPriority(NORMALPRIO);
    3df2:	2040      	movs	r0, #64	; 0x40
    3df4:	f7fd fb74 	bl	14e0 <chThdSetPriority>
	init_IO();
    3df8:	f000 f832 	bl	3e60 <init_IO>
	init_protocol();
    3dfc:	f000 f868 	bl	3ed0 <init_protocol>
    listener = chThdCreateStatic(serialListen, sizeof(serialListen), LOWPRIO, rxListen, NULL);
    3e00:	2300      	movs	r3, #0
    3e02:	9300      	str	r3, [sp, #0]
    3e04:	4812      	ldr	r0, [pc, #72]	; (3e50 <main+0x70>)
    3e06:	f44f 71b4 	mov.w	r1, #360	; 0x168
    3e0a:	2202      	movs	r2, #2
    3e0c:	4b11      	ldr	r3, [pc, #68]	; (3e54 <main+0x74>)
    3e0e:	f7fd fb37 	bl	1480 <chThdCreateStatic>
    3e12:	9003      	str	r0, [sp, #12]
    writer = chThdCreateStatic(serialTalk, sizeof(serialTalk), LOWPRIO, txWrite, NULL);
    3e14:	2300      	movs	r3, #0
    3e16:	9300      	str	r3, [sp, #0]
    3e18:	480f      	ldr	r0, [pc, #60]	; (3e58 <main+0x78>)
    3e1a:	f44f 71b4 	mov.w	r1, #360	; 0x168
    3e1e:	2202      	movs	r2, #2
    3e20:	4b0e      	ldr	r3, [pc, #56]	; (3e5c <main+0x7c>)
    3e22:	f7fd fb2d 	bl	1480 <chThdCreateStatic>
    3e26:	9002      	str	r0, [sp, #8]
    
	while(!0)
	{
		palWriteGroup(GPIOD,0xFFFFU,0,0xFFFFU);//all ports high
    3e28:	4b07      	ldr	r3, [pc, #28]	; (3e48 <main+0x68>)
    3e2a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    3e2e:	619a      	str	r2, [r3, #24]
		chThdSleepMilliseconds(1000);
    3e30:	f242 7010 	movw	r0, #10000	; 0x2710
    3e34:	f7fd fb8c 	bl	1550 <chThdSleep>
		palWriteGroup(GPIOD,0xFFFFU,0,0x0000U);
    3e38:	4b03      	ldr	r3, [pc, #12]	; (3e48 <main+0x68>)
    3e3a:	4a04      	ldr	r2, [pc, #16]	; (3e4c <main+0x6c>)
    3e3c:	619a      	str	r2, [r3, #24]
		chThdSleepMilliseconds(1000);
    3e3e:	f242 7010 	movw	r0, #10000	; 0x2710
    3e42:	f7fd fb85 	bl	1550 <chThdSleep>
	}
    3e46:	e7ef      	b.n	3e28 <main+0x48>
    3e48:	40020c00 	.word	0x40020c00
    3e4c:	ffff0000 	.word	0xffff0000
    3e50:	20000fb8 	.word	0x20000fb8
    3e54:	00003f21 	.word	0x00003f21
    3e58:	20001120 	.word	0x20001120
    3e5c:	00003f61 	.word	0x00003f61

00003e60 <init_IO>:
	return 0;/*never reach here*/
}


void init_IO(void)
{
    3e60:	b508      	push	{r3, lr}
	//adc_configure();
	//btn b portlarn (16 tane) pull up input olarak a
	palSetGroupMode(GPIOB, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
    3e62:	4814      	ldr	r0, [pc, #80]	; (3eb4 <init_IO+0x54>)
    3e64:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3e68:	2220      	movs	r2, #32
    3e6a:	f7ff fd11 	bl	3890 <_pal_lld_setgroupmode>
	
	//set_cca_exp_io_mode();
	
	if( cca_exp_io_mode == CCA_EXP_IO_MODE_OUTPUT)
    3e6e:	4b12      	ldr	r3, [pc, #72]	; (3eb8 <init_IO+0x58>)
    3e70:	781b      	ldrb	r3, [r3, #0]
    3e72:	2b00      	cmp	r3, #0
    3e74:	d10c      	bne.n	3e90 <init_IO+0x30>
	{
		palSetGroupMode(GPIOD, PAL_GROUP_MASK(16), 0, PAL_MODE_OUTPUT_PUSHPULL);
    3e76:	4811      	ldr	r0, [pc, #68]	; (3ebc <init_IO+0x5c>)
    3e78:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3e7c:	2201      	movs	r2, #1
    3e7e:	f7ff fd07 	bl	3890 <_pal_lld_setgroupmode>
		palSetGroupMode(GPIOE, PAL_GROUP_MASK(16), 0, PAL_MODE_OUTPUT_PUSHPULL);
    3e82:	480f      	ldr	r0, [pc, #60]	; (3ec0 <init_IO+0x60>)
    3e84:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3e88:	2201      	movs	r2, #1
    3e8a:	f7ff fd01 	bl	3890 <_pal_lld_setgroupmode>
    3e8e:	e00f      	b.n	3eb0 <init_IO+0x50>
	}
	else if( cca_exp_io_mode == CCA_EXP_IO_MODE_INPUT)
    3e90:	4b09      	ldr	r3, [pc, #36]	; (3eb8 <init_IO+0x58>)
    3e92:	781b      	ldrb	r3, [r3, #0]
    3e94:	2b01      	cmp	r3, #1
    3e96:	d10b      	bne.n	3eb0 <init_IO+0x50>
	{
		palSetGroupMode(GPIOD, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
    3e98:	4808      	ldr	r0, [pc, #32]	; (3ebc <init_IO+0x5c>)
    3e9a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3e9e:	2220      	movs	r2, #32
    3ea0:	f7ff fcf6 	bl	3890 <_pal_lld_setgroupmode>
		palSetGroupMode(GPIOE, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
    3ea4:	4806      	ldr	r0, [pc, #24]	; (3ec0 <init_IO+0x60>)
    3ea6:	f64f 71ff 	movw	r1, #65535	; 0xffff
    3eaa:	2220      	movs	r2, #32
    3eac:	f7ff fcf0 	bl	3890 <_pal_lld_setgroupmode>
	}
	else
	{
		;// Never reach here
	}
	return;
    3eb0:	bf00      	nop
}
    3eb2:	bd08      	pop	{r3, pc}
    3eb4:	40020400 	.word	0x40020400
    3eb8:	20001288 	.word	0x20001288
    3ebc:	40020c00 	.word	0x40020c00
    3ec0:	40021000 	.word	0x40021000
    3ec4:	f3af 8000 	nop.w
    3ec8:	f3af 8000 	nop.w
    3ecc:	f3af 8000 	nop.w

00003ed0 <init_protocol>:

/*MEMORYPOOL_DECL(mpool, 64, NULL);//say ka olmal belli deil
msg_t protocol_01_buffer[64];*/

void init_protocol(void)
{
    3ed0:	b508      	push	{r3, lr}
	chMBObjectInit(&serialMbox, txMailboxArea, 16);
    3ed2:	480c      	ldr	r0, [pc, #48]	; (3f04 <init_protocol+0x34>)
    3ed4:	490c      	ldr	r1, [pc, #48]	; (3f08 <init_protocol+0x38>)
    3ed6:	2210      	movs	r2, #16
    3ed8:	f7fd ff12 	bl	1d00 <chMBObjectInit>
	//chPoolLoadArray(&mpool,protocol_01_buffer,64);
	/*palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(7));
	palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(7));
	sdStart(&SD1, NULL);*///sd1 onun bunun ocuu mu neden almyo insan delirtiyo ?
	palSetPadMode(GPIOB, 10, PAL_MODE_ALTERNATE(7)); // used function : USART3_TX
    3edc:	480b      	ldr	r0, [pc, #44]	; (3f0c <init_protocol+0x3c>)
    3ede:	f44f 6180 	mov.w	r1, #1024	; 0x400
    3ee2:	f240 3282 	movw	r2, #898	; 0x382
    3ee6:	f7ff fcd3 	bl	3890 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOB, 11, PAL_MODE_ALTERNATE(7)); // used function : USART3_RX
    3eea:	4808      	ldr	r0, [pc, #32]	; (3f0c <init_protocol+0x3c>)
    3eec:	f44f 6100 	mov.w	r1, #2048	; 0x800
    3ef0:	f240 3282 	movw	r2, #898	; 0x382
    3ef4:	f7ff fccc 	bl	3890 <_pal_lld_setgroupmode>

	sdStart(&SD3, NULL);
    3ef8:	4805      	ldr	r0, [pc, #20]	; (3f10 <init_protocol+0x40>)
    3efa:	2100      	movs	r1, #0
    3efc:	f7fe fde0 	bl	2ac0 <sdStart>
	return;
    3f00:	bf00      	nop
}
    3f02:	bd08      	pop	{r3, pc}
    3f04:	200012cc 	.word	0x200012cc
    3f08:	2000128c 	.word	0x2000128c
    3f0c:	40020400 	.word	0x40020400
    3f10:	20000f20 	.word	0x20000f20
    3f14:	f3af 8000 	nop.w
    3f18:	f3af 8000 	nop.w
    3f1c:	f3af 8000 	nop.w

00003f20 <rxListen>:

void *rxListen(void *arg)
{
    3f20:	b500      	push	{lr}
    3f22:	b085      	sub	sp, #20
    3f24:	9001      	str	r0, [sp, #4]
	uint8_t buffer;
	while(!0)
	{
		//buffer = (msg_t *)chPoolAlloc(&mpool);
		sdRead(&SD3, &buffer, 1);
    3f26:	f10d 030f 	add.w	r3, sp, #15
    3f2a:	4809      	ldr	r0, [pc, #36]	; (3f50 <rxListen+0x30>)
    3f2c:	4619      	mov	r1, r3
    3f2e:	2201      	movs	r2, #1
    3f30:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3f34:	f7fe f924 	bl	2180 <chIQReadTimeout>
		chMBPost(&serialMbox, (msg_t) buffer, 10);
    3f38:	f89d 300f 	ldrb.w	r3, [sp, #15]
    3f3c:	4805      	ldr	r0, [pc, #20]	; (3f54 <rxListen+0x34>)
    3f3e:	4619      	mov	r1, r3
    3f40:	220a      	movs	r2, #10
    3f42:	f7fd ff15 	bl	1d70 <chMBPost>
		chThdSleepMilliseconds(100);
    3f46:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    3f4a:	f7fd fb01 	bl	1550 <chThdSleep>
	}
    3f4e:	e7ea      	b.n	3f26 <rxListen+0x6>
    3f50:	20000f2c 	.word	0x20000f2c
    3f54:	200012cc 	.word	0x200012cc
    3f58:	f3af 8000 	nop.w
    3f5c:	f3af 8000 	nop.w

00003f60 <txWrite>:
	return NULL;
}

void *txWrite(void *arg)
{
    3f60:	b500      	push	{lr}
    3f62:	b085      	sub	sp, #20
    3f64:	9001      	str	r0, [sp, #4]
	uint8_t toSend;
	while(!0)
	{
		if(chMBFetch(&serialMbox, &toSend, 1000) == MSG_OK)
    3f66:	f10d 030f 	add.w	r3, sp, #15
    3f6a:	480b      	ldr	r0, [pc, #44]	; (3f98 <txWrite+0x38>)
    3f6c:	4619      	mov	r1, r3
    3f6e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    3f72:	f7fd ff4d 	bl	1e10 <chMBFetch>
    3f76:	4603      	mov	r3, r0
    3f78:	2b00      	cmp	r3, #0
    3f7a:	d108      	bne.n	3f8e <txWrite+0x2e>
		{
			sdWrite(&SD3, &toSend,1);
    3f7c:	f10d 030f 	add.w	r3, sp, #15
    3f80:	4806      	ldr	r0, [pc, #24]	; (3f9c <txWrite+0x3c>)
    3f82:	4619      	mov	r1, r3
    3f84:	2201      	movs	r2, #1
    3f86:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3f8a:	f7fe f9f9 	bl	2380 <chOQWriteTimeout>
		}
		//toSend = (msg_t)*ptrtoSend;
		//chPoolFree(&mpool, &toSend);
		chThdSleepMilliseconds(500);
    3f8e:	f241 3088 	movw	r0, #5000	; 0x1388
    3f92:	f7fd fadd 	bl	1550 <chThdSleep>
	}
    3f96:	e7e6      	b.n	3f66 <txWrite+0x6>
    3f98:	200012cc 	.word	0x200012cc
    3f9c:	20000f50 	.word	0x20000f50
    3fa0:	656c6469 	.word	0x656c6469
	...
    3fb0:	31235653 	.word	0x31235653
    3fb4:	00000000 	.word	0x00000000
    3fb8:	32235653 	.word	0x32235653
    3fbc:	00000000 	.word	0x00000000
    3fc0:	33235653 	.word	0x33235653
    3fc4:	00000000 	.word	0x00000000
    3fc8:	34235653 	.word	0x34235653
    3fcc:	00000000 	.word	0x00000000
    3fd0:	35235653 	.word	0x35235653
    3fd4:	00000000 	.word	0x00000000
    3fd8:	36235653 	.word	0x36235653
    3fdc:	00000000 	.word	0x00000000
    3fe0:	37235653 	.word	0x37235653
    3fe4:	00000000 	.word	0x00000000
    3fe8:	38235653 	.word	0x38235653
    3fec:	00000000 	.word	0x00000000
    3ff0:	39235653 	.word	0x39235653
    3ff4:	00000000 	.word	0x00000000
    3ff8:	31235653 	.word	0x31235653
    3ffc:	00000030 	.word	0x00000030
    4000:	31235653 	.word	0x31235653
    4004:	00000031 	.word	0x00000031
	...
    4010:	63617473 	.word	0x63617473
    4014:	766f206b 	.word	0x766f206b
    4018:	6c667265 	.word	0x6c667265
    401c:	0000776f 	.word	0x0000776f

00004020 <__func__.6011>:
    4020:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

00004030 <__func__.6628>:
    4030:	54566863 65536f44 00004974 00000000     chVTDoSetI......

00004040 <__func__.6636>:
    4040:	54566863 65526f44 49746573 00000000     chVTDoResetI....

00004050 <__func__.6625>:
    4050:	63536863 61655268 00497964 00000000     chSchReadyI.....

00004060 <__func__.6637>:
    4060:	68546863 65724364 49657461 00000000     chThdCreateI....

00004070 <__func__.5925>:
    4070:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004080 <__func__.6653>:
    4080:	68546863 74655364 6f697250 79746972     chThdSetPriority
	...

000040a0 <__func__.6096>:
    40a0:	68546863 656c5364 00537065 00000000     chThdSleepS.....

000040b0 <__func__.6681>:
    40b0:	68546863 69784564 00005374 00000000     chThdExitS......

000040c0 <__func__.6703>:
    40c0:	68546863 73655264 49656d75 00000000     chThdResumeI....

000040d0 <__func__.6108>:
    40d0:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
    40e0:	00497478 00000000 00000000 00000000     xtI.............

000040f0 <ch_debug>:
    40f0:	6e69616d 18021600 08600404 1814100c     main......`.....
    4100:	2221201c 00000000 00000000 00000000     . !"............

00004110 <__func__.6621>:
    4110:	65536863 6a624f6d 49746365 0074696e     chSemObjectInit.

00004120 <__func__.6652>:
    4120:	65536863 6961576d 6d695474 74756f65     chSemWaitTimeout
    4130:	00000053 00000000 00000000 00000000     S...............

00004140 <__func__.6660>:
    4140:	65536863 6769536d 496c616e 00000000     chSemSignalI....

00004150 <__func__.6620>:
    4150:	744d6863 6a624f78 49746365 0074696e     chMtxObjectInit.

00004160 <__func__.6645>:
    4160:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
    4170:	49736761 00000000 00000000 00000000     agsI............

00004180 <__func__.6662>:
    4180:	76456863 67695374 496c616e 00000000     chEvtSignalI....

00004190 <__func__.6622>:
    4190:	424d6863 656a624f 6e497463 00007469     chMBObjectInit..

000041a0 <__func__.5925>:
    41a0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000041b0 <__func__.6642>:
    41b0:	424d6863 74736f50 00000053 00000000     chMBPostS.......

000041c0 <__func__.6678>:
    41c0:	424d6863 63746546 00005368 00000000     chMBFetchS......

000041d0 <__func__.5925>:
    41d0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000041e0 <__func__.6648>:
    41e0:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.

000041f0 <__func__.6684>:
    41f0:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

00004210 <__func__.5925>:
    4210:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004220 <__func__.7143>:
    4220:	74537473 41747261 6d72616c 00000000     stStartAlarm....

00004230 <__func__.7150>:
    4230:	65537473 616c4174 00006d72 00000000     stSetAlarm......

00004240 <vmt>:
    4240:	000028f1 00002921 00002951 00002981     .(..!)..Q)...)..
    4250:	000029a1 000029d1 000029f1 00002a21     .)...)...)..!*..

00004260 <__func__.7188>:
    4260:	74536473 00747261 00000000 00000000     sdStart.........

00004270 <__func__.5925>:
    4270:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004280 <__func__.7197>:
    4280:	6e496473 696d6f63 6144676e 00496174     sdIncomingDataI.

00004290 <_stm32_dma_streams>:
    4290:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
    42a0:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
    42b0:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
    42c0:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
    42d0:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
    42e0:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
    42f0:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
    4300:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
    4310:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
    4320:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
    4330:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
    4340:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

00004350 <default_config>:
    4350:	00002580 40000000 00000000 00000000     .%.....@........

00004360 <pal_default_config>:
    4360:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
    4370:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
    4380:	00000240 ffffffff 55514515 0000ffff     @........EQU....
    4390:	04000000 00000040 02208001 00000000     ....@..... .....
    43a0:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
    43b0:	00060600 55000100 00000000 ffffffff     .......U........
    43c0:	00555055 00000fff 00000000 00000000     UPU.............
    43d0:	00000040 00000000 ffffffff 00000000     @...............
    43e0:	0000ffff 00000000 00000000 00000000     ................
    43f0:	00000000 ffffffff 00000000 0000ffff     ................
	...
    4410:	ffffffff 00000000 0000ffff 00000000     ................
	...
    442c:	ffffffff 00000000 0000ffff 00000000     ................
	...
    4448:	ffffffff 00000000 0000ffff 00000000     ................
    4458:	00000000                                ....
