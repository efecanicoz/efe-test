
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

000001c0 <Reset_Handler>:
     1c0:	b672      	cpsid	i
     1c2:	4821      	ldr	r0, [pc, #132]	; (248 <endfiniloop+0x4>)
     1c4:	f380 8809 	msr	PSP, r0
     1c8:	2002      	movs	r0, #2
     1ca:	f380 8814 	msr	CONTROL, r0
     1ce:	f3bf 8f6f 	isb	sy
     1d2:	f000 f94d 	bl	470 <__core_init>
     1d6:	f004 f9f3 	bl	45c0 <__early_init>
     1da:	481c      	ldr	r0, [pc, #112]	; (24c <endfiniloop+0x8>)
     1dc:	491c      	ldr	r1, [pc, #112]	; (250 <endfiniloop+0xc>)
     1de:	4a1d      	ldr	r2, [pc, #116]	; (254 <endfiniloop+0x10>)

000001e0 <msloop>:
     1e0:	4291      	cmp	r1, r2
     1e2:	bf3c      	itt	cc
     1e4:	f841 0b04 	strcc.w	r0, [r1], #4
     1e8:	e7fa      	bcc.n	1e0 <msloop>
     1ea:	491b      	ldr	r1, [pc, #108]	; (258 <endfiniloop+0x14>)
     1ec:	4a16      	ldr	r2, [pc, #88]	; (248 <endfiniloop+0x4>)

000001ee <psloop>:
     1ee:	4291      	cmp	r1, r2
     1f0:	bf3c      	itt	cc
     1f2:	f841 0b04 	strcc.w	r0, [r1], #4
     1f6:	e7fa      	bcc.n	1ee <psloop>
     1f8:	4918      	ldr	r1, [pc, #96]	; (25c <endfiniloop+0x18>)
     1fa:	4a19      	ldr	r2, [pc, #100]	; (260 <endfiniloop+0x1c>)
     1fc:	4b19      	ldr	r3, [pc, #100]	; (264 <endfiniloop+0x20>)

000001fe <dloop>:
     1fe:	429a      	cmp	r2, r3
     200:	bf3e      	ittt	cc
     202:	f851 0b04 	ldrcc.w	r0, [r1], #4
     206:	f842 0b04 	strcc.w	r0, [r2], #4
     20a:	e7f8      	bcc.n	1fe <dloop>
     20c:	2000      	movs	r0, #0
     20e:	4916      	ldr	r1, [pc, #88]	; (268 <endfiniloop+0x24>)
     210:	4a16      	ldr	r2, [pc, #88]	; (26c <endfiniloop+0x28>)

00000212 <bloop>:
     212:	4291      	cmp	r1, r2
     214:	bf3c      	itt	cc
     216:	f841 0b04 	strcc.w	r0, [r1], #4
     21a:	e7fa      	bcc.n	212 <bloop>
     21c:	f000 f930 	bl	480 <__late_init>
     220:	4c13      	ldr	r4, [pc, #76]	; (270 <endfiniloop+0x2c>)
     222:	4d14      	ldr	r5, [pc, #80]	; (274 <endfiniloop+0x30>)

00000224 <initloop>:
     224:	42ac      	cmp	r4, r5
     226:	da03      	bge.n	230 <endinitloop>
     228:	f854 1b04 	ldr.w	r1, [r4], #4
     22c:	4788      	blx	r1
     22e:	e7f9      	b.n	224 <initloop>

00000230 <endinitloop>:
     230:	f000 f846 	bl	2c0 <main>
     234:	4c10      	ldr	r4, [pc, #64]	; (278 <endfiniloop+0x34>)
     236:	4d11      	ldr	r5, [pc, #68]	; (27c <endfiniloop+0x38>)

00000238 <finiloop>:
     238:	42ac      	cmp	r4, r5
     23a:	da03      	bge.n	244 <endfiniloop>
     23c:	f854 1b04 	ldr.w	r1, [r4], #4
     240:	4788      	blx	r1
     242:	e7f9      	b.n	238 <finiloop>

00000244 <endfiniloop>:
     244:	f000 b924 	b.w	490 <__default_exit>
     248:	20000800 	.word	0x20000800
     24c:	55555555 	.word	0x55555555
     250:	20000000 	.word	0x20000000
     254:	20000400 	.word	0x20000400
     258:	20000400 	.word	0x20000400
     25c:	00004b20 	.word	0x00004b20
     260:	20000800 	.word	0x20000800
     264:	20000800 	.word	0x20000800
     268:	20000800 	.word	0x20000800
     26c:	20001278 	.word	0x20001278
     270:	000001c0 	.word	0x000001c0
     274:	000001c0 	.word	0x000001c0
     278:	000001c0 	.word	0x000001c0
     27c:	000001c0 	.word	0x000001c0

00000280 <_port_switch>:
     280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     284:	f8c1 d00c 	str.w	sp, [r1, #12]
     288:	f8d0 d00c 	ldr.w	sp, [r0, #12]
     28c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00000290 <_port_thread_start>:
     290:	f000 fb66 	bl	960 <_dbg_check_unlock>
     294:	f001 fc4c 	bl	1b30 <_stats_stop_measure_crit_thd>
     298:	2300      	movs	r3, #0
     29a:	f383 8811 	msr	BASEPRI, r3
     29e:	4628      	mov	r0, r5
     2a0:	47a0      	blx	r4
     2a2:	2000      	movs	r0, #0
     2a4:	f001 fa4c 	bl	1740 <chThdExit>

000002a8 <_port_switch_from_isr>:
     2a8:	f001 fc3a 	bl	1b20 <_stats_start_measure_crit_thd>
     2ac:	f000 fb40 	bl	930 <_dbg_check_lock>
     2b0:	f001 f826 	bl	1300 <chSchDoReschedule>
     2b4:	f000 fb54 	bl	960 <_dbg_check_unlock>
     2b8:	f001 fc3a 	bl	1b30 <_stats_stop_measure_crit_thd>

000002bc <_port_exit_from_isr>:
     2bc:	df00      	svc	0
     2be:	e7fe      	b.n	2be <_port_exit_from_isr+0x2>

000002c0 <main>:
#include "main.h"

uint8_t cca_exp_io_mode;


int main(void) {
     2c0:	b500      	push	{lr}
     2c2:	b085      	sub	sp, #20
	halInit();
     2c4:	f002 fdd4 	bl	2e70 <halInit>
	chSysInit();
     2c8:	f000 fa82 	bl	7d0 <chSysInit>
	thread_t *listener,*writer;
	
	
	palWriteGroup(GPIOD,0xFFFFU,0,0x0000U);//all ports low
     2cc:	4b10      	ldr	r3, [pc, #64]	; (310 <main+0x50>)
     2ce:	4a11      	ldr	r2, [pc, #68]	; (314 <main+0x54>)
     2d0:	619a      	str	r2, [r3, #24]
	chThdSetPriority(NORMALPRIO);
     2d2:	2040      	movs	r0, #64	; 0x40
     2d4:	f001 f9ec 	bl	16b0 <chThdSetPriority>
	init_IO();
     2d8:	f000 f82a 	bl	330 <init_IO>
	init_protocol();
     2dc:	f000 f860 	bl	3a0 <init_protocol>
    listener = chThdCreateStatic(serialListen, sizeof(serialListen), LOWPRIO, rxListen, NULL);
     2e0:	2300      	movs	r3, #0
     2e2:	9300      	str	r3, [sp, #0]
     2e4:	480c      	ldr	r0, [pc, #48]	; (318 <main+0x58>)
     2e6:	f44f 7194 	mov.w	r1, #296	; 0x128
     2ea:	2202      	movs	r2, #2
     2ec:	4b0b      	ldr	r3, [pc, #44]	; (31c <main+0x5c>)
     2ee:	f001 f9af 	bl	1650 <chThdCreateStatic>
     2f2:	9003      	str	r0, [sp, #12]
    writer = chThdCreateStatic(serialTalk, sizeof(serialTalk), LOWPRIO, txWrite, NULL);
     2f4:	2300      	movs	r3, #0
     2f6:	9300      	str	r3, [sp, #0]
     2f8:	4809      	ldr	r0, [pc, #36]	; (320 <main+0x60>)
     2fa:	f44f 7194 	mov.w	r1, #296	; 0x128
     2fe:	2202      	movs	r2, #2
     300:	4b08      	ldr	r3, [pc, #32]	; (324 <main+0x64>)
     302:	f001 f9a5 	bl	1650 <chThdCreateStatic>
     306:	9002      	str	r0, [sp, #8]
    chThdWait(listener);
     308:	9803      	ldr	r0, [sp, #12]
     30a:	f001 fa69 	bl	17e0 <chThdWait>
	{/*
		palWriteGroup(GPIOD,0x000FU,0,0x000FU);//all ports high
		chThdSleepMilliseconds(1000);
		palWriteGroup(GPIOD,0x000FU,0,0x0000U);
		chThdSleepMilliseconds(1000);*/
	}
     30e:	e7fe      	b.n	30e <main+0x4e>
     310:	40020c00 	.word	0x40020c00
     314:	ffff0000 	.word	0xffff0000
     318:	20000800 	.word	0x20000800
     31c:	000003f1 	.word	0x000003f1
     320:	20000928 	.word	0x20000928
     324:	00000451 	.word	0x00000451
     328:	f3af 8000 	nop.w
     32c:	f3af 8000 	nop.w

00000330 <init_IO>:
	return 0;/*never reach here*/
}


void init_IO(void)
{
     330:	b508      	push	{r3, lr}
	//adc_configure();
	//bütün b portlarını (16 tane) pull up input olarak aç
	palSetGroupMode(GPIOB, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
     332:	4814      	ldr	r0, [pc, #80]	; (384 <init_IO+0x54>)
     334:	f64f 71ff 	movw	r1, #65535	; 0xffff
     338:	2220      	movs	r2, #32
     33a:	f003 fea9 	bl	4090 <_pal_lld_setgroupmode>
	
	//set_cca_exp_io_mode();
	
	if( cca_exp_io_mode == CCA_EXP_IO_MODE_OUTPUT)
     33e:	4b12      	ldr	r3, [pc, #72]	; (388 <init_IO+0x58>)
     340:	781b      	ldrb	r3, [r3, #0]
     342:	2b00      	cmp	r3, #0
     344:	d10c      	bne.n	360 <init_IO+0x30>
	{
		palSetGroupMode(GPIOD, PAL_GROUP_MASK(16), 0, PAL_MODE_OUTPUT_PUSHPULL);
     346:	4811      	ldr	r0, [pc, #68]	; (38c <init_IO+0x5c>)
     348:	f64f 71ff 	movw	r1, #65535	; 0xffff
     34c:	2201      	movs	r2, #1
     34e:	f003 fe9f 	bl	4090 <_pal_lld_setgroupmode>
		palSetGroupMode(GPIOE, PAL_GROUP_MASK(16), 0, PAL_MODE_OUTPUT_PUSHPULL);
     352:	480f      	ldr	r0, [pc, #60]	; (390 <init_IO+0x60>)
     354:	f64f 71ff 	movw	r1, #65535	; 0xffff
     358:	2201      	movs	r2, #1
     35a:	f003 fe99 	bl	4090 <_pal_lld_setgroupmode>
     35e:	e00f      	b.n	380 <init_IO+0x50>
	}
	else if( cca_exp_io_mode == CCA_EXP_IO_MODE_INPUT)
     360:	4b09      	ldr	r3, [pc, #36]	; (388 <init_IO+0x58>)
     362:	781b      	ldrb	r3, [r3, #0]
     364:	2b01      	cmp	r3, #1
     366:	d10b      	bne.n	380 <init_IO+0x50>
	{
		palSetGroupMode(GPIOD, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
     368:	4808      	ldr	r0, [pc, #32]	; (38c <init_IO+0x5c>)
     36a:	f64f 71ff 	movw	r1, #65535	; 0xffff
     36e:	2220      	movs	r2, #32
     370:	f003 fe8e 	bl	4090 <_pal_lld_setgroupmode>
		palSetGroupMode(GPIOE, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
     374:	4806      	ldr	r0, [pc, #24]	; (390 <init_IO+0x60>)
     376:	f64f 71ff 	movw	r1, #65535	; 0xffff
     37a:	2220      	movs	r2, #32
     37c:	f003 fe88 	bl	4090 <_pal_lld_setgroupmode>
	}
	else
	{
		;// Never reach here
	}
	return;
     380:	bf00      	nop
}
     382:	bd08      	pop	{r3, pc}
     384:	40020400 	.word	0x40020400
     388:	20000a50 	.word	0x20000a50
     38c:	40020c00 	.word	0x40020c00
     390:	40021000 	.word	0x40021000
     394:	f3af 8000 	nop.w
     398:	f3af 8000 	nop.w
     39c:	f3af 8000 	nop.w

000003a0 <init_protocol>:
/*MEMORYPOOL_DECL(mpool, 64, NULL);//sayı kaç olmalı belli değil
msg_t protocol_01_buffer[64];*/
msg_t buffer;

void init_protocol(void)
{
     3a0:	b508      	push	{r3, lr}
	chMBObjectInit(&serialMbox, txMailboxArea, 16);
     3a2:	480c      	ldr	r0, [pc, #48]	; (3d4 <init_protocol+0x34>)
     3a4:	490c      	ldr	r1, [pc, #48]	; (3d8 <init_protocol+0x38>)
     3a6:	2210      	movs	r2, #16
     3a8:	f002 f812 	bl	23d0 <chMBObjectInit>
	//chPoolLoadArray(&mpool,protocol_01_buffer,64);
	palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(7));
     3ac:	480b      	ldr	r0, [pc, #44]	; (3dc <init_protocol+0x3c>)
     3ae:	f44f 7100 	mov.w	r1, #512	; 0x200
     3b2:	f240 3282 	movw	r2, #898	; 0x382
     3b6:	f003 fe6b 	bl	4090 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(7));
     3ba:	4808      	ldr	r0, [pc, #32]	; (3dc <init_protocol+0x3c>)
     3bc:	f44f 6180 	mov.w	r1, #1024	; 0x400
     3c0:	f240 3282 	movw	r2, #898	; 0x382
     3c4:	f003 fe64 	bl	4090 <_pal_lld_setgroupmode>
	sdStart(&SD1, NULL);
     3c8:	4805      	ldr	r0, [pc, #20]	; (3e0 <init_protocol+0x40>)
     3ca:	2100      	movs	r1, #0
     3cc:	f002 ff78 	bl	32c0 <sdStart>
	return;
     3d0:	bf00      	nop
}
     3d2:	bd08      	pop	{r3, pc}
     3d4:	20000a94 	.word	0x20000a94
     3d8:	20000a54 	.word	0x20000a54
     3dc:	40020000 	.word	0x40020000
     3e0:	200011e0 	.word	0x200011e0
     3e4:	f3af 8000 	nop.w
     3e8:	f3af 8000 	nop.w
     3ec:	f3af 8000 	nop.w

000003f0 <rxListen>:

void *rxListen(void *arg)
{
     3f0:	b500      	push	{lr}
     3f2:	b083      	sub	sp, #12
     3f4:	9001      	str	r0, [sp, #4]
	//msg_t *buffer;
	while(!0)
	{
		//buffer = (msg_t *)chPoolAlloc(&mpool);
		sdRead(&SD1, (uint8_t *)&buffer, 2);
     3f6:	4810      	ldr	r0, [pc, #64]	; (438 <__main_stack_size__+0x38>)
     3f8:	4910      	ldr	r1, [pc, #64]	; (43c <__main_stack_size__+0x3c>)
     3fa:	2202      	movs	r2, #2
     3fc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     400:	f002 f9d6 	bl	27b0 <chIQReadTimeout>
		palWriteGroup(GPIOD,0xFFFFU,0,buffer);
     404:	4b0e      	ldr	r3, [pc, #56]	; (440 <__main_stack_size__+0x40>)
     406:	4a0d      	ldr	r2, [pc, #52]	; (43c <__main_stack_size__+0x3c>)
     408:	6812      	ldr	r2, [r2, #0]
     40a:	43d2      	mvns	r2, r2
     40c:	0411      	lsls	r1, r2, #16
     40e:	4a0b      	ldr	r2, [pc, #44]	; (43c <__main_stack_size__+0x3c>)
     410:	6812      	ldr	r2, [r2, #0]
     412:	b292      	uxth	r2, r2
     414:	430a      	orrs	r2, r1
     416:	619a      	str	r2, [r3, #24]
		chThdSleepMilliseconds(100);
     418:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
     41c:	f001 f980 	bl	1720 <chThdSleep>
		sdWrite(&SD1, (uint8_t *)&buffer,2);
     420:	4808      	ldr	r0, [pc, #32]	; (444 <__main_stack_size__+0x44>)
     422:	4906      	ldr	r1, [pc, #24]	; (43c <__main_stack_size__+0x3c>)
     424:	2202      	movs	r2, #2
     426:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     42a:	f002 fac1 	bl	29b0 <chOQWriteTimeout>
		chThdSleepMilliseconds(100);
     42e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
     432:	f001 f975 	bl	1720 <chThdSleep>
		//chMBPost(&serialMbox, buffer, TIME_IMMEDIATE);
	}
     436:	e7de      	b.n	3f6 <rxListen+0x6>
     438:	200011ec 	.word	0x200011ec
     43c:	20000abc 	.word	0x20000abc
     440:	40020c00 	.word	0x40020c00
     444:	20001210 	.word	0x20001210
     448:	f3af 8000 	nop.w
     44c:	f3af 8000 	nop.w

00000450 <txWrite>:
	return NULL;
}

void *txWrite(void *arg)
{
     450:	b500      	push	{lr}
     452:	b085      	sub	sp, #20
     454:	9001      	str	r0, [sp, #4]
	uint8_t *toSend;
	while(!0)
	{
		//sdWrite(&SD1, (uint8_t *)buffer,2);
		
		if(chMBFetch(&serialMbox, toSend, TIME_IMMEDIATE) == MSG_OK)
     456:	4805      	ldr	r0, [pc, #20]	; (46c <txWrite+0x1c>)
     458:	9903      	ldr	r1, [sp, #12]
     45a:	2200      	movs	r2, #0
     45c:	f001 fff0 	bl	2440 <chMBFetch>
		{
		}
		//toSend = (msg_t)*ptrtoSend;
		//chPoolFree(&mpool, &toSend);
		chThdSleepMilliseconds(500);
     460:	f241 3088 	movw	r0, #5000	; 0x1388
     464:	f001 f95c 	bl	1720 <chThdSleep>
		
	}
     468:	e7f5      	b.n	456 <txWrite+0x6>
     46a:	bf00      	nop
     46c:	20000a94 	.word	0x20000a94

00000470 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
     470:	4770      	bx	lr
     472:	bf00      	nop
     474:	f3af 8000 	nop.w
     478:	f3af 8000 	nop.w
     47c:	f3af 8000 	nop.w

00000480 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
     480:	4770      	bx	lr
     482:	bf00      	nop
     484:	f3af 8000 	nop.w
     488:	f3af 8000 	nop.w
     48c:	f3af 8000 	nop.w

00000490 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
     490:	e7fe      	b.n	490 <__default_exit>
     492:	bf00      	nop
     494:	f3af 8000 	nop.w
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w

000004a0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
     4a0:	e7fe      	b.n	4a0 <_unhandled_exception>
     4a2:	bf00      	nop
     4a4:	f3af 8000 	nop.w
     4a8:	f3af 8000 	nop.w
     4ac:	f3af 8000 	nop.w

000004b0 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
     4b0:	b084      	sub	sp, #16
     4b2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
     4b4:	9b01      	ldr	r3, [sp, #4]
     4b6:	f003 0307 	and.w	r3, r3, #7
     4ba:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
     4bc:	4b0a      	ldr	r3, [pc, #40]	; (4e8 <NVIC_SetPriorityGrouping+0x38>)
     4be:	68db      	ldr	r3, [r3, #12]
     4c0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
     4c2:	9a02      	ldr	r2, [sp, #8]
     4c4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
     4c8:	4013      	ands	r3, r2
     4ca:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
     4cc:	9b03      	ldr	r3, [sp, #12]
     4ce:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
     4d0:	9b02      	ldr	r3, [sp, #8]
     4d2:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
     4d4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
     4d8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     4dc:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
     4de:	4b02      	ldr	r3, [pc, #8]	; (4e8 <NVIC_SetPriorityGrouping+0x38>)
     4e0:	9a02      	ldr	r2, [sp, #8]
     4e2:	60da      	str	r2, [r3, #12]
}
     4e4:	b004      	add	sp, #16
     4e6:	4770      	bx	lr
     4e8:	e000ed00 	.word	0xe000ed00
     4ec:	f3af 8000 	nop.w

000004f0 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
     4f0:	b082      	sub	sp, #8
     4f2:	4603      	mov	r3, r0
     4f4:	9100      	str	r1, [sp, #0]
     4f6:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
     4fa:	f99d 3007 	ldrsb.w	r3, [sp, #7]
     4fe:	2b00      	cmp	r3, #0
     500:	da0c      	bge.n	51c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     502:	490c      	ldr	r1, [pc, #48]	; (534 <NVIC_SetPriority+0x44>)
     504:	f89d 3007 	ldrb.w	r3, [sp, #7]
     508:	f003 030f 	and.w	r3, r3, #15
     50c:	3b04      	subs	r3, #4
     50e:	9a00      	ldr	r2, [sp, #0]
     510:	b2d2      	uxtb	r2, r2
     512:	0112      	lsls	r2, r2, #4
     514:	b2d2      	uxtb	r2, r2
     516:	440b      	add	r3, r1
     518:	761a      	strb	r2, [r3, #24]
     51a:	e009      	b.n	530 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     51c:	4906      	ldr	r1, [pc, #24]	; (538 <NVIC_SetPriority+0x48>)
     51e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
     522:	9a00      	ldr	r2, [sp, #0]
     524:	b2d2      	uxtb	r2, r2
     526:	0112      	lsls	r2, r2, #4
     528:	b2d2      	uxtb	r2, r2
     52a:	440b      	add	r3, r1
     52c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
     530:	b002      	add	sp, #8
     532:	4770      	bx	lr
     534:	e000ed00 	.word	0xe000ed00
     538:	e000e100 	.word	0xe000e100
     53c:	f3af 8000 	nop.w

00000540 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
     540:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
     542:	4b0e      	ldr	r3, [pc, #56]	; (57c <port_init+0x3c>)
     544:	2200      	movs	r2, #0
     546:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
     548:	2003      	movs	r0, #3
     54a:	f7ff ffb1 	bl	4b0 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
     54e:	4b0c      	ldr	r3, [pc, #48]	; (580 <port_init+0x40>)
     550:	4a0b      	ldr	r2, [pc, #44]	; (580 <port_init+0x40>)
     552:	68d2      	ldr	r2, [r2, #12]
     554:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
     558:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
     55a:	4b0a      	ldr	r3, [pc, #40]	; (584 <port_init+0x44>)
     55c:	4a09      	ldr	r2, [pc, #36]	; (584 <port_init+0x44>)
     55e:	6812      	ldr	r2, [r2, #0]
     560:	f042 0201 	orr.w	r2, r2, #1
     564:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
     566:	f06f 0004 	mvn.w	r0, #4
     56a:	2101      	movs	r1, #1
     56c:	f7ff ffc0 	bl	4f0 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
     570:	f06f 0001 	mvn.w	r0, #1
     574:	2102      	movs	r1, #2
     576:	f7ff ffbb 	bl	4f0 <NVIC_SetPriority>
}
     57a:	bd08      	pop	{r3, pc}
     57c:	e000ed00 	.word	0xe000ed00
     580:	e000edf0 	.word	0xe000edf0
     584:	e0001000 	.word	0xe0001000
     588:	f3af 8000 	nop.w
     58c:	f3af 8000 	nop.w

00000590 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     590:	b082      	sub	sp, #8
     592:	2320      	movs	r3, #32
     594:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     596:	9b01      	ldr	r3, [sp, #4]
     598:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     59c:	b002      	add	sp, #8
     59e:	4770      	bx	lr

000005a0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     5a0:	b082      	sub	sp, #8
     5a2:	2300      	movs	r3, #0
     5a4:	9301      	str	r3, [sp, #4]
     5a6:	9b01      	ldr	r3, [sp, #4]
     5a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     5ac:	b002      	add	sp, #8
     5ae:	4770      	bx	lr

000005b0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     5b0:	b508      	push	{r3, lr}

  port_lock();
     5b2:	f7ff ffed 	bl	590 <port_lock>
}
     5b6:	bd08      	pop	{r3, pc}
     5b8:	f3af 8000 	nop.w
     5bc:	f3af 8000 	nop.w

000005c0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     5c0:	b508      	push	{r3, lr}

  port_unlock();
     5c2:	f7ff ffed 	bl	5a0 <port_unlock>
}
     5c6:	bd08      	pop	{r3, pc}
     5c8:	f3af 8000 	nop.w
     5cc:	f3af 8000 	nop.w

000005d0 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
     5d0:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
     5d2:	4770      	bx	lr
     5d4:	f3af 8000 	nop.w
     5d8:	f3af 8000 	nop.w
     5dc:	f3af 8000 	nop.w

000005e0 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
     5e0:	b082      	sub	sp, #8
     5e2:	2300      	movs	r3, #0
     5e4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     5e6:	9b01      	ldr	r3, [sp, #4]
     5e8:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
     5ec:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
     5ee:	b002      	add	sp, #8
     5f0:	4770      	bx	lr
     5f2:	bf00      	nop
     5f4:	f3af 8000 	nop.w
     5f8:	f3af 8000 	nop.w
     5fc:	f3af 8000 	nop.w

00000600 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
     600:	4770      	bx	lr
     602:	bf00      	nop
     604:	f3af 8000 	nop.w
     608:	f3af 8000 	nop.w
     60c:	f3af 8000 	nop.w

00000610 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     610:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     614:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     616:	4618      	mov	r0, r3
     618:	4770      	bx	lr
     61a:	bf00      	nop
     61c:	f3af 8000 	nop.w

00000620 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
     620:	b508      	push	{r3, lr}

  stStopAlarm();
     622:	f002 fc8d 	bl	2f40 <stStopAlarm>
}
     626:	bd08      	pop	{r3, pc}
     628:	f3af 8000 	nop.w
     62c:	f3af 8000 	nop.w

00000630 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
     630:	b500      	push	{lr}
     632:	b083      	sub	sp, #12
     634:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
     636:	9801      	ldr	r0, [sp, #4]
     638:	f002 fc8a 	bl	2f50 <stSetAlarm>
}
     63c:	b003      	add	sp, #12
     63e:	f85d fb04 	ldr.w	pc, [sp], #4
     642:	bf00      	nop
     644:	f3af 8000 	nop.w
     648:	f3af 8000 	nop.w
     64c:	f3af 8000 	nop.w

00000650 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     650:	b508      	push	{r3, lr}

  return stGetCounter();
     652:	f7ff ffdd 	bl	610 <st_lld_get_counter>
     656:	4603      	mov	r3, r0
}
     658:	4618      	mov	r0, r3
     65a:	bd08      	pop	{r3, pc}
     65c:	f3af 8000 	nop.w

00000660 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
     660:	b508      	push	{r3, lr}

  _dbg_check_enable();
     662:	f000 f94d 	bl	900 <_dbg_check_enable>
  port_enable();
     666:	f7ff ffbb 	bl	5e0 <port_enable>
}
     66a:	bd08      	pop	{r3, pc}
     66c:	f3af 8000 	nop.w

00000670 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
     670:	b508      	push	{r3, lr}

  port_lock_from_isr();
     672:	f7ff ff9d 	bl	5b0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
     676:	f001 fa63 	bl	1b40 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
     67a:	f000 f989 	bl	990 <_dbg_check_lock_from_isr>
}
     67e:	bd08      	pop	{r3, pc}

00000680 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
     680:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
     682:	f000 f99d 	bl	9c0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
     686:	f001 fa63 	bl	1b50 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
     68a:	f7ff ff99 	bl	5c0 <port_unlock_from_isr>
}
     68e:	bd08      	pop	{r3, pc}

00000690 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     690:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     692:	f7ff ffdd 	bl	650 <port_timer_get_time>
     696:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     698:	4618      	mov	r0, r3
     69a:	bd08      	pop	{r3, pc}
     69c:	f3af 8000 	nop.w

000006a0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
     6a0:	b500      	push	{lr}
     6a2:	b085      	sub	sp, #20

  chDbgCheckClassI();
     6a4:	f000 f9e4 	bl	a70 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
     6a8:	4b33      	ldr	r3, [pc, #204]	; (778 <chVTDoTickI+0xd8>)
     6aa:	69db      	ldr	r3, [r3, #28]
     6ac:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
     6ae:	f7ff ffef 	bl	690 <chVTGetSystemTimeX>
     6b2:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
     6b4:	e02a      	b.n	70c <chVTDoTickI+0x6c>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
     6b6:	4b30      	ldr	r3, [pc, #192]	; (778 <chVTDoTickI+0xd8>)
     6b8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     6ba:	9b03      	ldr	r3, [sp, #12]
     6bc:	689b      	ldr	r3, [r3, #8]
     6be:	441a      	add	r2, r3
     6c0:	4b2d      	ldr	r3, [pc, #180]	; (778 <chVTDoTickI+0xd8>)
     6c2:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     6c4:	9b03      	ldr	r3, [sp, #12]
     6c6:	681b      	ldr	r3, [r3, #0]
     6c8:	4a2c      	ldr	r2, [pc, #176]	; (77c <chVTDoTickI+0xdc>)
     6ca:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
     6cc:	9b03      	ldr	r3, [sp, #12]
     6ce:	681a      	ldr	r2, [r3, #0]
     6d0:	4b29      	ldr	r3, [pc, #164]	; (778 <chVTDoTickI+0xd8>)
     6d2:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
     6d4:	9b03      	ldr	r3, [sp, #12]
     6d6:	68db      	ldr	r3, [r3, #12]
     6d8:	9300      	str	r3, [sp, #0]
    vtp->vt_func = NULL;
     6da:	9b03      	ldr	r3, [sp, #12]
     6dc:	2200      	movs	r2, #0
     6de:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
     6e0:	4b25      	ldr	r3, [pc, #148]	; (778 <chVTDoTickI+0xd8>)
     6e2:	69da      	ldr	r2, [r3, #28]
     6e4:	4b25      	ldr	r3, [pc, #148]	; (77c <chVTDoTickI+0xdc>)
     6e6:	429a      	cmp	r2, r3
     6e8:	d101      	bne.n	6ee <chVTDoTickI+0x4e>
      port_timer_stop_alarm();
     6ea:	f7ff ff99 	bl	620 <port_timer_stop_alarm>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
     6ee:	f7ff ffc7 	bl	680 <chSysUnlockFromISR>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
     6f2:	9b03      	ldr	r3, [sp, #12]
     6f4:	691a      	ldr	r2, [r3, #16]
     6f6:	9b00      	ldr	r3, [sp, #0]
     6f8:	4610      	mov	r0, r2
     6fa:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
     6fc:	f7ff ffb8 	bl	670 <chSysLockFromISR>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
     700:	4b1d      	ldr	r3, [pc, #116]	; (778 <chVTDoTickI+0xd8>)
     702:	69db      	ldr	r3, [r3, #28]
     704:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
     706:	f7ff ffc3 	bl	690 <chVTGetSystemTimeX>
     70a:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
     70c:	9b03      	ldr	r3, [sp, #12]
     70e:	689a      	ldr	r2, [r3, #8]
     710:	4b19      	ldr	r3, [pc, #100]	; (778 <chVTDoTickI+0xd8>)
     712:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     714:	9902      	ldr	r1, [sp, #8]
     716:	1acb      	subs	r3, r1, r3
     718:	429a      	cmp	r2, r3
     71a:	d9cc      	bls.n	6b6 <chVTDoTickI+0x16>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
     71c:	4b16      	ldr	r3, [pc, #88]	; (778 <chVTDoTickI+0xd8>)
     71e:	69da      	ldr	r2, [r3, #28]
     720:	4b16      	ldr	r3, [pc, #88]	; (77c <chVTDoTickI+0xdc>)
     722:	429a      	cmp	r2, r3
     724:	d100      	bne.n	728 <chVTDoTickI+0x88>
    return;
     726:	e023      	b.n	770 <chVTDoTickI+0xd0>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
     728:	4b13      	ldr	r3, [pc, #76]	; (778 <chVTDoTickI+0xd8>)
     72a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     72c:	9b03      	ldr	r3, [sp, #12]
     72e:	689b      	ldr	r3, [r3, #8]
     730:	441a      	add	r2, r3
     732:	9b02      	ldr	r3, [sp, #8]
     734:	1ad3      	subs	r3, r2, r3
     736:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
     738:	9b01      	ldr	r3, [sp, #4]
     73a:	2b01      	cmp	r3, #1
     73c:	d801      	bhi.n	742 <chVTDoTickI+0xa2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
     73e:	2302      	movs	r3, #2
     740:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
     742:	9a02      	ldr	r2, [sp, #8]
     744:	9b01      	ldr	r3, [sp, #4]
     746:	4413      	add	r3, r2
     748:	4618      	mov	r0, r3
     74a:	f7ff ff71 	bl	630 <port_timer_set_alarm>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
     74e:	f7ff ff9f 	bl	690 <chVTGetSystemTimeX>
     752:	4602      	mov	r2, r0
     754:	4b08      	ldr	r3, [pc, #32]	; (778 <chVTDoTickI+0xd8>)
     756:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     758:	1ad2      	subs	r2, r2, r3
     75a:	9902      	ldr	r1, [sp, #8]
     75c:	9b01      	ldr	r3, [sp, #4]
     75e:	4419      	add	r1, r3
     760:	4b05      	ldr	r3, [pc, #20]	; (778 <chVTDoTickI+0xd8>)
     762:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     764:	1acb      	subs	r3, r1, r3
     766:	429a      	cmp	r2, r3
     768:	d902      	bls.n	770 <chVTDoTickI+0xd0>
     76a:	4805      	ldr	r0, [pc, #20]	; (780 <chVTDoTickI+0xe0>)
     76c:	f000 f878 	bl	860 <chSysHalt>
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     770:	b005      	add	sp, #20
     772:	f85d fb04 	ldr.w	pc, [sp], #4
     776:	bf00      	nop
     778:	20000ac0 	.word	0x20000ac0
     77c:	20000adc 	.word	0x20000adc
     780:	00004660 	.word	0x00004660
     784:	f3af 8000 	nop.w
     788:	f3af 8000 	nop.w
     78c:	f3af 8000 	nop.w

00000790 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
     790:	b082      	sub	sp, #8
     792:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
     794:	4b02      	ldr	r3, [pc, #8]	; (7a0 <chRegSetThreadName+0x10>)
     796:	699b      	ldr	r3, [r3, #24]
     798:	9a01      	ldr	r2, [sp, #4]
     79a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
     79c:	b002      	add	sp, #8
     79e:	4770      	bx	lr
     7a0:	20000ac0 	.word	0x20000ac0
     7a4:	f3af 8000 	nop.w
     7a8:	f3af 8000 	nop.w
     7ac:	f3af 8000 	nop.w

000007b0 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
     7b0:	b082      	sub	sp, #8
     7b2:	9001      	str	r0, [sp, #4]
     7b4:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
     7b6:	9b01      	ldr	r3, [sp, #4]
     7b8:	9a00      	ldr	r2, [sp, #0]
     7ba:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
     7bc:	b002      	add	sp, #8
     7be:	4770      	bx	lr

000007c0 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
     7c0:	b500      	push	{lr}
     7c2:	b083      	sub	sp, #12
     7c4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
     7c6:	f7ff ff1b 	bl	600 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
  }
     7ca:	e7fc      	b.n	7c6 <_idle_thread+0x6>
     7cc:	f3af 8000 	nop.w

000007d0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
     7d0:	b500      	push	{lr}
     7d2:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
     7d4:	f7ff feb4 	bl	540 <port_init>
  _scheduler_init();
     7d8:	f000 fbc2 	bl	f60 <_scheduler_init>
  _vt_init();
     7dc:	f000 f9f8 	bl	bd0 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
     7e0:	f001 f8de 	bl	19a0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
     7e4:	f002 f97c 	bl	2ae0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
     7e8:	f002 f9ca 	bl	2b80 <_heap_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  _stats_init();
     7ec:	f001 f950 	bl	1a90 <_stats_init>
#endif
#if CH_DBG_ENABLE_TRACE == TRUE
  _dbg_trace_init();
     7f0:	f000 f96e 	bl	ad0 <_dbg_trace_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
     7f4:	4812      	ldr	r0, [pc, #72]	; (840 <chSysInit+0x70>)
     7f6:	2140      	movs	r1, #64	; 0x40
     7f8:	f000 fe8a 	bl	1510 <_thread_init>
     7fc:	4602      	mov	r2, r0
     7fe:	4b11      	ldr	r3, [pc, #68]	; (844 <chSysInit+0x74>)
     800:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
     802:	4b10      	ldr	r3, [pc, #64]	; (844 <chSysInit+0x74>)
     804:	699b      	ldr	r3, [r3, #24]
     806:	2201      	movs	r2, #1
     808:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
     80c:	4b0d      	ldr	r3, [pc, #52]	; (844 <chSysInit+0x74>)
     80e:	699b      	ldr	r3, [r3, #24]
     810:	4a0d      	ldr	r2, [pc, #52]	; (848 <chSysInit+0x78>)
     812:	61da      	str	r2, [r3, #28]
#endif
  chSysEnable();
     814:	f7ff ff24 	bl	660 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
     818:	480c      	ldr	r0, [pc, #48]	; (84c <chSysInit+0x7c>)
     81a:	f7ff ffb9 	bl	790 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
     81e:	2300      	movs	r3, #0
     820:	9300      	str	r3, [sp, #0]
     822:	480b      	ldr	r0, [pc, #44]	; (850 <chSysInit+0x80>)
     824:	21f8      	movs	r1, #248	; 0xf8
     826:	2201      	movs	r2, #1
     828:	4b0a      	ldr	r3, [pc, #40]	; (854 <chSysInit+0x84>)
     82a:	f000 ff11 	bl	1650 <chThdCreateStatic>
     82e:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
     830:	9803      	ldr	r0, [sp, #12]
     832:	4909      	ldr	r1, [pc, #36]	; (858 <chSysInit+0x88>)
     834:	f7ff ffbc 	bl	7b0 <chRegSetThreadNameX>
  }
#endif
}
     838:	b005      	add	sp, #20
     83a:	f85d fb04 	ldr.w	pc, [sp], #4
     83e:	bf00      	nop
     840:	20000f00 	.word	0x20000f00
     844:	20000ac0 	.word	0x20000ac0
     848:	20000400 	.word	0x20000400
     84c:	00004760 	.word	0x00004760
     850:	20000fa0 	.word	0x20000fa0
     854:	000007c1 	.word	0x000007c1
     858:	000045e0 	.word	0x000045e0
     85c:	f3af 8000 	nop.w

00000860 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
     860:	b500      	push	{lr}
     862:	b083      	sub	sp, #12
     864:	9001      	str	r0, [sp, #4]

  port_disable();
     866:	f7ff feb3 	bl	5d0 <port_disable>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
     86a:	4b02      	ldr	r3, [pc, #8]	; (874 <chSysHalt+0x14>)
     86c:	9a01      	ldr	r2, [sp, #4]
     86e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
     870:	e7fe      	b.n	870 <chSysHalt+0x10>
     872:	bf00      	nop
     874:	20000ac0 	.word	0x20000ac0
     878:	f3af 8000 	nop.w
     87c:	f3af 8000 	nop.w

00000880 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     880:	b508      	push	{r3, lr}

  chDbgCheckClassI();
     882:	f000 f8f5 	bl	a70 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
     886:	f7ff ff0b 	bl	6a0 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
     88a:	bd08      	pop	{r3, pc}
     88c:	f3af 8000 	nop.w

00000890 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     890:	b082      	sub	sp, #8
     892:	2320      	movs	r3, #32
     894:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     896:	9b01      	ldr	r3, [sp, #4]
     898:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     89c:	b002      	add	sp, #8
     89e:	4770      	bx	lr

000008a0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     8a0:	b082      	sub	sp, #8
     8a2:	2300      	movs	r3, #0
     8a4:	9301      	str	r3, [sp, #4]
     8a6:	9b01      	ldr	r3, [sp, #4]
     8a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     8ac:	b002      	add	sp, #8
     8ae:	4770      	bx	lr

000008b0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     8b0:	b508      	push	{r3, lr}

  port_lock();
     8b2:	f7ff ffed 	bl	890 <port_lock>
}
     8b6:	bd08      	pop	{r3, pc}
     8b8:	f3af 8000 	nop.w
     8bc:	f3af 8000 	nop.w

000008c0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     8c0:	b508      	push	{r3, lr}

  port_unlock();
     8c2:	f7ff ffed 	bl	8a0 <port_unlock>
}
     8c6:	bd08      	pop	{r3, pc}
     8c8:	f3af 8000 	nop.w
     8cc:	f3af 8000 	nop.w

000008d0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     8d0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     8d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     8d6:	4618      	mov	r0, r3
     8d8:	4770      	bx	lr
     8da:	bf00      	nop
     8dc:	f3af 8000 	nop.w

000008e0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     8e0:	b508      	push	{r3, lr}

  return stGetCounter();
     8e2:	f7ff fff5 	bl	8d0 <st_lld_get_counter>
     8e6:	4603      	mov	r3, r0
}
     8e8:	4618      	mov	r0, r3
     8ea:	bd08      	pop	{r3, pc}
     8ec:	f3af 8000 	nop.w

000008f0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     8f0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     8f2:	f7ff fff5 	bl	8e0 <port_timer_get_time>
     8f6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     8f8:	4618      	mov	r0, r3
     8fa:	bd08      	pop	{r3, pc}
     8fc:	f3af 8000 	nop.w

00000900 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
     900:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     902:	4b06      	ldr	r3, [pc, #24]	; (91c <_dbg_check_enable+0x1c>)
     904:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     906:	2b00      	cmp	r3, #0
     908:	d103      	bne.n	912 <_dbg_check_enable+0x12>
     90a:	4b04      	ldr	r3, [pc, #16]	; (91c <_dbg_check_enable+0x1c>)
     90c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     90e:	2b00      	cmp	r3, #0
     910:	d002      	beq.n	918 <_dbg_check_enable+0x18>
    chSysHalt("SV#3");
     912:	4803      	ldr	r0, [pc, #12]	; (920 <_dbg_check_enable+0x20>)
     914:	f7ff ffa4 	bl	860 <chSysHalt>
  }
}
     918:	bd08      	pop	{r3, pc}
     91a:	bf00      	nop
     91c:	20000ac0 	.word	0x20000ac0
     920:	00004600 	.word	0x00004600
     924:	f3af 8000 	nop.w
     928:	f3af 8000 	nop.w
     92c:	f3af 8000 	nop.w

00000930 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
     930:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     932:	4b07      	ldr	r3, [pc, #28]	; (950 <_dbg_check_lock+0x20>)
     934:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     936:	2b00      	cmp	r3, #0
     938:	d103      	bne.n	942 <_dbg_check_lock+0x12>
     93a:	4b05      	ldr	r3, [pc, #20]	; (950 <_dbg_check_lock+0x20>)
     93c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     93e:	2b00      	cmp	r3, #0
     940:	d002      	beq.n	948 <_dbg_check_lock+0x18>
    chSysHalt("SV#4");
     942:	4804      	ldr	r0, [pc, #16]	; (954 <_dbg_check_lock+0x24>)
     944:	f7ff ff8c 	bl	860 <chSysHalt>
  }
  _dbg_enter_lock();
     948:	4b01      	ldr	r3, [pc, #4]	; (950 <_dbg_check_lock+0x20>)
     94a:	2201      	movs	r2, #1
     94c:	635a      	str	r2, [r3, #52]	; 0x34
}
     94e:	bd08      	pop	{r3, pc}
     950:	20000ac0 	.word	0x20000ac0
     954:	00004608 	.word	0x00004608
     958:	f3af 8000 	nop.w
     95c:	f3af 8000 	nop.w

00000960 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
     960:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     962:	4b07      	ldr	r3, [pc, #28]	; (980 <_dbg_check_unlock+0x20>)
     964:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     966:	2b00      	cmp	r3, #0
     968:	d103      	bne.n	972 <_dbg_check_unlock+0x12>
     96a:	4b05      	ldr	r3, [pc, #20]	; (980 <_dbg_check_unlock+0x20>)
     96c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     96e:	2b00      	cmp	r3, #0
     970:	dc02      	bgt.n	978 <_dbg_check_unlock+0x18>
    chSysHalt("SV#5");
     972:	4804      	ldr	r0, [pc, #16]	; (984 <_dbg_check_unlock+0x24>)
     974:	f7ff ff74 	bl	860 <chSysHalt>
  }
  _dbg_leave_lock();
     978:	4b01      	ldr	r3, [pc, #4]	; (980 <_dbg_check_unlock+0x20>)
     97a:	2200      	movs	r2, #0
     97c:	635a      	str	r2, [r3, #52]	; 0x34
}
     97e:	bd08      	pop	{r3, pc}
     980:	20000ac0 	.word	0x20000ac0
     984:	00004610 	.word	0x00004610
     988:	f3af 8000 	nop.w
     98c:	f3af 8000 	nop.w

00000990 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
     990:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     992:	4b07      	ldr	r3, [pc, #28]	; (9b0 <_dbg_check_lock_from_isr+0x20>)
     994:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     996:	2b00      	cmp	r3, #0
     998:	dd03      	ble.n	9a2 <_dbg_check_lock_from_isr+0x12>
     99a:	4b05      	ldr	r3, [pc, #20]	; (9b0 <_dbg_check_lock_from_isr+0x20>)
     99c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     99e:	2b00      	cmp	r3, #0
     9a0:	d002      	beq.n	9a8 <_dbg_check_lock_from_isr+0x18>
    chSysHalt("SV#6");
     9a2:	4804      	ldr	r0, [pc, #16]	; (9b4 <_dbg_check_lock_from_isr+0x24>)
     9a4:	f7ff ff5c 	bl	860 <chSysHalt>
  }
  _dbg_enter_lock();
     9a8:	4b01      	ldr	r3, [pc, #4]	; (9b0 <_dbg_check_lock_from_isr+0x20>)
     9aa:	2201      	movs	r2, #1
     9ac:	635a      	str	r2, [r3, #52]	; 0x34
}
     9ae:	bd08      	pop	{r3, pc}
     9b0:	20000ac0 	.word	0x20000ac0
     9b4:	00004618 	.word	0x00004618
     9b8:	f3af 8000 	nop.w
     9bc:	f3af 8000 	nop.w

000009c0 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
     9c0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     9c2:	4b07      	ldr	r3, [pc, #28]	; (9e0 <_dbg_check_unlock_from_isr+0x20>)
     9c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     9c6:	2b00      	cmp	r3, #0
     9c8:	dd03      	ble.n	9d2 <_dbg_check_unlock_from_isr+0x12>
     9ca:	4b05      	ldr	r3, [pc, #20]	; (9e0 <_dbg_check_unlock_from_isr+0x20>)
     9cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     9ce:	2b00      	cmp	r3, #0
     9d0:	dc02      	bgt.n	9d8 <_dbg_check_unlock_from_isr+0x18>
    chSysHalt("SV#7");
     9d2:	4804      	ldr	r0, [pc, #16]	; (9e4 <_dbg_check_unlock_from_isr+0x24>)
     9d4:	f7ff ff44 	bl	860 <chSysHalt>
  }
  _dbg_leave_lock();
     9d8:	4b01      	ldr	r3, [pc, #4]	; (9e0 <_dbg_check_unlock_from_isr+0x20>)
     9da:	2200      	movs	r2, #0
     9dc:	635a      	str	r2, [r3, #52]	; 0x34
}
     9de:	bd08      	pop	{r3, pc}
     9e0:	20000ac0 	.word	0x20000ac0
     9e4:	00004620 	.word	0x00004620
     9e8:	f3af 8000 	nop.w
     9ec:	f3af 8000 	nop.w

000009f0 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
     9f0:	b508      	push	{r3, lr}

  port_lock_from_isr();
     9f2:	f7ff ff5d 	bl	8b0 <port_lock_from_isr>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     9f6:	4b09      	ldr	r3, [pc, #36]	; (a1c <_dbg_check_enter_isr+0x2c>)
     9f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     9fa:	2b00      	cmp	r3, #0
     9fc:	db03      	blt.n	a06 <_dbg_check_enter_isr+0x16>
     9fe:	4b07      	ldr	r3, [pc, #28]	; (a1c <_dbg_check_enter_isr+0x2c>)
     a00:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     a02:	2b00      	cmp	r3, #0
     a04:	d002      	beq.n	a0c <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
     a06:	4806      	ldr	r0, [pc, #24]	; (a20 <_dbg_check_enter_isr+0x30>)
     a08:	f7ff ff2a 	bl	860 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
     a0c:	4b03      	ldr	r3, [pc, #12]	; (a1c <_dbg_check_enter_isr+0x2c>)
     a0e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     a10:	1c5a      	adds	r2, r3, #1
     a12:	4b02      	ldr	r3, [pc, #8]	; (a1c <_dbg_check_enter_isr+0x2c>)
     a14:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
     a16:	f7ff ff53 	bl	8c0 <port_unlock_from_isr>
}
     a1a:	bd08      	pop	{r3, pc}
     a1c:	20000ac0 	.word	0x20000ac0
     a20:	00004628 	.word	0x00004628
     a24:	f3af 8000 	nop.w
     a28:	f3af 8000 	nop.w
     a2c:	f3af 8000 	nop.w

00000a30 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
     a30:	b508      	push	{r3, lr}

  port_lock_from_isr();
     a32:	f7ff ff3d 	bl	8b0 <port_lock_from_isr>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     a36:	4b09      	ldr	r3, [pc, #36]	; (a5c <_dbg_check_leave_isr+0x2c>)
     a38:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     a3a:	2b00      	cmp	r3, #0
     a3c:	dd03      	ble.n	a46 <_dbg_check_leave_isr+0x16>
     a3e:	4b07      	ldr	r3, [pc, #28]	; (a5c <_dbg_check_leave_isr+0x2c>)
     a40:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     a42:	2b00      	cmp	r3, #0
     a44:	d002      	beq.n	a4c <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
     a46:	4806      	ldr	r0, [pc, #24]	; (a60 <_dbg_check_leave_isr+0x30>)
     a48:	f7ff ff0a 	bl	860 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
     a4c:	4b03      	ldr	r3, [pc, #12]	; (a5c <_dbg_check_leave_isr+0x2c>)
     a4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     a50:	1e5a      	subs	r2, r3, #1
     a52:	4b02      	ldr	r3, [pc, #8]	; (a5c <_dbg_check_leave_isr+0x2c>)
     a54:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
     a56:	f7ff ff33 	bl	8c0 <port_unlock_from_isr>
}
     a5a:	bd08      	pop	{r3, pc}
     a5c:	20000ac0 	.word	0x20000ac0
     a60:	00004630 	.word	0x00004630
     a64:	f3af 8000 	nop.w
     a68:	f3af 8000 	nop.w
     a6c:	f3af 8000 	nop.w

00000a70 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
     a70:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     a72:	4b06      	ldr	r3, [pc, #24]	; (a8c <chDbgCheckClassI+0x1c>)
     a74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     a76:	2b00      	cmp	r3, #0
     a78:	db03      	blt.n	a82 <chDbgCheckClassI+0x12>
     a7a:	4b04      	ldr	r3, [pc, #16]	; (a8c <chDbgCheckClassI+0x1c>)
     a7c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     a7e:	2b00      	cmp	r3, #0
     a80:	dc02      	bgt.n	a88 <chDbgCheckClassI+0x18>
    chSysHalt("SV#10");
     a82:	4803      	ldr	r0, [pc, #12]	; (a90 <chDbgCheckClassI+0x20>)
     a84:	f7ff feec 	bl	860 <chSysHalt>
  }
}
     a88:	bd08      	pop	{r3, pc}
     a8a:	bf00      	nop
     a8c:	20000ac0 	.word	0x20000ac0
     a90:	00004638 	.word	0x00004638
     a94:	f3af 8000 	nop.w
     a98:	f3af 8000 	nop.w
     a9c:	f3af 8000 	nop.w

00000aa0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
     aa0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     aa2:	4b06      	ldr	r3, [pc, #24]	; (abc <chDbgCheckClassS+0x1c>)
     aa4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     aa6:	2b00      	cmp	r3, #0
     aa8:	d103      	bne.n	ab2 <chDbgCheckClassS+0x12>
     aaa:	4b04      	ldr	r3, [pc, #16]	; (abc <chDbgCheckClassS+0x1c>)
     aac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     aae:	2b00      	cmp	r3, #0
     ab0:	dc02      	bgt.n	ab8 <chDbgCheckClassS+0x18>
    chSysHalt("SV#11");
     ab2:	4803      	ldr	r0, [pc, #12]	; (ac0 <chDbgCheckClassS+0x20>)
     ab4:	f7ff fed4 	bl	860 <chSysHalt>
  }
}
     ab8:	bd08      	pop	{r3, pc}
     aba:	bf00      	nop
     abc:	20000ac0 	.word	0x20000ac0
     ac0:	00004640 	.word	0x00004640
     ac4:	f3af 8000 	nop.w
     ac8:	f3af 8000 	nop.w
     acc:	f3af 8000 	nop.w

00000ad0 <_dbg_trace_init>:
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
     ad0:	4b03      	ldr	r3, [pc, #12]	; (ae0 <_dbg_trace_init+0x10>)
     ad2:	2240      	movs	r2, #64	; 0x40
     ad4:	639a      	str	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
     ad6:	4b02      	ldr	r3, [pc, #8]	; (ae0 <_dbg_trace_init+0x10>)
     ad8:	4a02      	ldr	r2, [pc, #8]	; (ae4 <_dbg_trace_init+0x14>)
     ada:	63da      	str	r2, [r3, #60]	; 0x3c
}
     adc:	4770      	bx	lr
     ade:	bf00      	nop
     ae0:	20000ac0 	.word	0x20000ac0
     ae4:	20000b00 	.word	0x20000b00
     ae8:	f3af 8000 	nop.w
     aec:	f3af 8000 	nop.w

00000af0 <_dbg_trace>:
 *
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {
     af0:	b510      	push	{r4, lr}
     af2:	b082      	sub	sp, #8
     af4:	9001      	str	r0, [sp, #4]

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
     af6:	4b13      	ldr	r3, [pc, #76]	; (b44 <_dbg_trace+0x54>)
     af8:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
     afa:	f7ff fef9 	bl	8f0 <chVTGetSystemTimeX>
     afe:	4603      	mov	r3, r0
     b00:	6023      	str	r3, [r4, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
     b02:	4b10      	ldr	r3, [pc, #64]	; (b44 <_dbg_trace+0x54>)
     b04:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     b06:	4a0f      	ldr	r2, [pc, #60]	; (b44 <_dbg_trace+0x54>)
     b08:	6992      	ldr	r2, [r2, #24]
     b0a:	605a      	str	r2, [r3, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
     b0c:	4b0d      	ldr	r3, [pc, #52]	; (b44 <_dbg_trace+0x54>)
     b0e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     b10:	9a01      	ldr	r2, [sp, #4]
     b12:	6a52      	ldr	r2, [r2, #36]	; 0x24
     b14:	609a      	str	r2, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
     b16:	4b0b      	ldr	r3, [pc, #44]	; (b44 <_dbg_trace+0x54>)
     b18:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     b1a:	9a01      	ldr	r2, [sp, #4]
     b1c:	f892 2020 	ldrb.w	r2, [r2, #32]
     b20:	731a      	strb	r2, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
     b22:	4b08      	ldr	r3, [pc, #32]	; (b44 <_dbg_trace+0x54>)
     b24:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     b26:	f103 0210 	add.w	r2, r3, #16
     b2a:	4b06      	ldr	r3, [pc, #24]	; (b44 <_dbg_trace+0x54>)
     b2c:	63da      	str	r2, [r3, #60]	; 0x3c
     b2e:	4b05      	ldr	r3, [pc, #20]	; (b44 <_dbg_trace+0x54>)
     b30:	6bda      	ldr	r2, [r3, #60]	; 0x3c
     b32:	4b05      	ldr	r3, [pc, #20]	; (b48 <_dbg_trace+0x58>)
     b34:	429a      	cmp	r2, r3
     b36:	d302      	bcc.n	b3e <_dbg_trace+0x4e>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
     b38:	4b02      	ldr	r3, [pc, #8]	; (b44 <_dbg_trace+0x54>)
     b3a:	4a04      	ldr	r2, [pc, #16]	; (b4c <_dbg_trace+0x5c>)
     b3c:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
     b3e:	b002      	add	sp, #8
     b40:	bd10      	pop	{r4, pc}
     b42:	bf00      	nop
     b44:	20000ac0 	.word	0x20000ac0
     b48:	20000f00 	.word	0x20000f00
     b4c:	20000b00 	.word	0x20000b00

00000b50 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     b50:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     b54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     b56:	4618      	mov	r0, r3
     b58:	4770      	bx	lr
     b5a:	bf00      	nop
     b5c:	f3af 8000 	nop.w

00000b60 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
     b60:	b500      	push	{lr}
     b62:	b083      	sub	sp, #12
     b64:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
     b66:	9801      	ldr	r0, [sp, #4]
     b68:	f002 f9d2 	bl	2f10 <stStartAlarm>
}
     b6c:	b003      	add	sp, #12
     b6e:	f85d fb04 	ldr.w	pc, [sp], #4
     b72:	bf00      	nop
     b74:	f3af 8000 	nop.w
     b78:	f3af 8000 	nop.w
     b7c:	f3af 8000 	nop.w

00000b80 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
     b80:	b508      	push	{r3, lr}

  stStopAlarm();
     b82:	f002 f9dd 	bl	2f40 <stStopAlarm>
}
     b86:	bd08      	pop	{r3, pc}
     b88:	f3af 8000 	nop.w
     b8c:	f3af 8000 	nop.w

00000b90 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
     b90:	b500      	push	{lr}
     b92:	b083      	sub	sp, #12
     b94:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
     b96:	9801      	ldr	r0, [sp, #4]
     b98:	f002 f9da 	bl	2f50 <stSetAlarm>
}
     b9c:	b003      	add	sp, #12
     b9e:	f85d fb04 	ldr.w	pc, [sp], #4
     ba2:	bf00      	nop
     ba4:	f3af 8000 	nop.w
     ba8:	f3af 8000 	nop.w
     bac:	f3af 8000 	nop.w

00000bb0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     bb0:	b508      	push	{r3, lr}

  return stGetCounter();
     bb2:	f7ff ffcd 	bl	b50 <st_lld_get_counter>
     bb6:	4603      	mov	r3, r0
}
     bb8:	4618      	mov	r0, r3
     bba:	bd08      	pop	{r3, pc}
     bbc:	f3af 8000 	nop.w

00000bc0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     bc0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     bc2:	f7ff fff5 	bl	bb0 <port_timer_get_time>
     bc6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     bc8:	4618      	mov	r0, r3
     bca:	bd08      	pop	{r3, pc}
     bcc:	f3af 8000 	nop.w

00000bd0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
     bd0:	4b06      	ldr	r3, [pc, #24]	; (bec <_vt_init+0x1c>)
     bd2:	4a07      	ldr	r2, [pc, #28]	; (bf0 <_vt_init+0x20>)
     bd4:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
     bd6:	4b05      	ldr	r3, [pc, #20]	; (bec <_vt_init+0x1c>)
     bd8:	4a05      	ldr	r2, [pc, #20]	; (bf0 <_vt_init+0x20>)
     bda:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
     bdc:	4b03      	ldr	r3, [pc, #12]	; (bec <_vt_init+0x1c>)
     bde:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     be2:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
     be4:	4b01      	ldr	r3, [pc, #4]	; (bec <_vt_init+0x1c>)
     be6:	2200      	movs	r2, #0
     be8:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     bea:	4770      	bx	lr
     bec:	20000ac0 	.word	0x20000ac0
     bf0:	20000adc 	.word	0x20000adc
     bf4:	f3af 8000 	nop.w
     bf8:	f3af 8000 	nop.w
     bfc:	f3af 8000 	nop.w

00000c00 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
     c00:	b500      	push	{lr}
     c02:	b089      	sub	sp, #36	; 0x24
     c04:	9003      	str	r0, [sp, #12]
     c06:	9102      	str	r1, [sp, #8]
     c08:	9201      	str	r2, [sp, #4]
     c0a:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
     c0c:	f7ff ff30 	bl	a70 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
     c10:	9b03      	ldr	r3, [sp, #12]
     c12:	2b00      	cmp	r3, #0
     c14:	d005      	beq.n	c22 <chVTDoSetI+0x22>
     c16:	9b01      	ldr	r3, [sp, #4]
     c18:	2b00      	cmp	r3, #0
     c1a:	d002      	beq.n	c22 <chVTDoSetI+0x22>
     c1c:	9b02      	ldr	r3, [sp, #8]
     c1e:	2b00      	cmp	r3, #0
     c20:	d102      	bne.n	c28 <chVTDoSetI+0x28>
     c22:	483a      	ldr	r0, [pc, #232]	; (d0c <chVTDoSetI+0x10c>)
     c24:	f7ff fe1c 	bl	860 <chSysHalt>

  vtp->vt_par = par;
     c28:	9b03      	ldr	r3, [sp, #12]
     c2a:	9a00      	ldr	r2, [sp, #0]
     c2c:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
     c2e:	9b03      	ldr	r3, [sp, #12]
     c30:	9a01      	ldr	r2, [sp, #4]
     c32:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
     c34:	f7ff ffc4 	bl	bc0 <chVTGetSystemTimeX>
     c38:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
     c3a:	9b02      	ldr	r3, [sp, #8]
     c3c:	2b01      	cmp	r3, #1
     c3e:	d801      	bhi.n	c44 <chVTDoSetI+0x44>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
     c40:	2302      	movs	r3, #2
     c42:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
     c44:	4b32      	ldr	r3, [pc, #200]	; (d10 <chVTDoSetI+0x110>)
     c46:	69da      	ldr	r2, [r3, #28]
     c48:	4b32      	ldr	r3, [pc, #200]	; (d14 <chVTDoSetI+0x114>)
     c4a:	429a      	cmp	r2, r3
     c4c:	d119      	bne.n	c82 <chVTDoSetI+0x82>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
     c4e:	4b30      	ldr	r3, [pc, #192]	; (d10 <chVTDoSetI+0x110>)
     c50:	9a05      	ldr	r2, [sp, #20]
     c52:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
     c54:	4b2e      	ldr	r3, [pc, #184]	; (d10 <chVTDoSetI+0x110>)
     c56:	9a03      	ldr	r2, [sp, #12]
     c58:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
     c5a:	4b2d      	ldr	r3, [pc, #180]	; (d10 <chVTDoSetI+0x110>)
     c5c:	9a03      	ldr	r2, [sp, #12]
     c5e:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
     c60:	9b03      	ldr	r3, [sp, #12]
     c62:	4a2c      	ldr	r2, [pc, #176]	; (d14 <chVTDoSetI+0x114>)
     c64:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
     c66:	9b03      	ldr	r3, [sp, #12]
     c68:	4a2a      	ldr	r2, [pc, #168]	; (d14 <chVTDoSetI+0x114>)
     c6a:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
     c6c:	9b03      	ldr	r3, [sp, #12]
     c6e:	9a02      	ldr	r2, [sp, #8]
     c70:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
     c72:	4b27      	ldr	r3, [pc, #156]	; (d10 <chVTDoSetI+0x110>)
     c74:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     c76:	9b02      	ldr	r3, [sp, #8]
     c78:	4413      	add	r3, r2
     c7a:	4618      	mov	r0, r3
     c7c:	f7ff ff70 	bl	b60 <port_timer_start_alarm>

      return;
     c80:	e040      	b.n	d04 <chVTDoSetI+0x104>
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
     c82:	9a05      	ldr	r2, [sp, #20]
     c84:	9b02      	ldr	r3, [sp, #8]
     c86:	441a      	add	r2, r3
     c88:	4b21      	ldr	r3, [pc, #132]	; (d10 <chVTDoSetI+0x110>)
     c8a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     c8c:	1ad3      	subs	r3, r2, r3
     c8e:	9306      	str	r3, [sp, #24]
    if (delta < ch.vtlist.vt_next->vt_delta) {
     c90:	4b1f      	ldr	r3, [pc, #124]	; (d10 <chVTDoSetI+0x110>)
     c92:	69db      	ldr	r3, [r3, #28]
     c94:	689a      	ldr	r2, [r3, #8]
     c96:	9b06      	ldr	r3, [sp, #24]
     c98:	429a      	cmp	r2, r3
     c9a:	d906      	bls.n	caa <chVTDoSetI+0xaa>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
     c9c:	4b1c      	ldr	r3, [pc, #112]	; (d10 <chVTDoSetI+0x110>)
     c9e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     ca0:	9b06      	ldr	r3, [sp, #24]
     ca2:	4413      	add	r3, r2
     ca4:	4618      	mov	r0, r3
     ca6:	f7ff ff73 	bl	b90 <port_timer_set_alarm>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
     caa:	4b19      	ldr	r3, [pc, #100]	; (d10 <chVTDoSetI+0x110>)
     cac:	69db      	ldr	r3, [r3, #28]
     cae:	9307      	str	r3, [sp, #28]
  while (p->vt_delta < delta) {
     cb0:	e007      	b.n	cc2 <chVTDoSetI+0xc2>
    delta -= p->vt_delta;
     cb2:	9b07      	ldr	r3, [sp, #28]
     cb4:	689b      	ldr	r3, [r3, #8]
     cb6:	9a06      	ldr	r2, [sp, #24]
     cb8:	1ad3      	subs	r3, r2, r3
     cba:	9306      	str	r3, [sp, #24]
    p = p->vt_next;
     cbc:	9b07      	ldr	r3, [sp, #28]
     cbe:	681b      	ldr	r3, [r3, #0]
     cc0:	9307      	str	r3, [sp, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
     cc2:	9b07      	ldr	r3, [sp, #28]
     cc4:	689a      	ldr	r2, [r3, #8]
     cc6:	9b06      	ldr	r3, [sp, #24]
     cc8:	429a      	cmp	r2, r3
     cca:	d3f2      	bcc.n	cb2 <chVTDoSetI+0xb2>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
     ccc:	9b03      	ldr	r3, [sp, #12]
     cce:	9a07      	ldr	r2, [sp, #28]
     cd0:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
     cd2:	9b03      	ldr	r3, [sp, #12]
     cd4:	681b      	ldr	r3, [r3, #0]
     cd6:	685a      	ldr	r2, [r3, #4]
     cd8:	9b03      	ldr	r3, [sp, #12]
     cda:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
     cdc:	9b03      	ldr	r3, [sp, #12]
     cde:	685b      	ldr	r3, [r3, #4]
     ce0:	9a03      	ldr	r2, [sp, #12]
     ce2:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
     ce4:	9b07      	ldr	r3, [sp, #28]
     ce6:	9a03      	ldr	r2, [sp, #12]
     ce8:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
     cea:	9b03      	ldr	r3, [sp, #12]
     cec:	9a06      	ldr	r2, [sp, #24]
     cee:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
     cf0:	9b07      	ldr	r3, [sp, #28]
     cf2:	689a      	ldr	r2, [r3, #8]
     cf4:	9b06      	ldr	r3, [sp, #24]
     cf6:	1ad2      	subs	r2, r2, r3
     cf8:	9b07      	ldr	r3, [sp, #28]
     cfa:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
     cfc:	4b04      	ldr	r3, [pc, #16]	; (d10 <chVTDoSetI+0x110>)
     cfe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     d02:	625a      	str	r2, [r3, #36]	; 0x24
}
     d04:	b009      	add	sp, #36	; 0x24
     d06:	f85d fb04 	ldr.w	pc, [sp], #4
     d0a:	bf00      	nop
     d0c:	00004670 	.word	0x00004670
     d10:	20000ac0 	.word	0x20000ac0
     d14:	20000adc 	.word	0x20000adc
     d18:	f3af 8000 	nop.w
     d1c:	f3af 8000 	nop.w

00000d20 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
     d20:	b500      	push	{lr}
     d22:	b085      	sub	sp, #20
     d24:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     d26:	f7ff fea3 	bl	a70 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
     d2a:	9b01      	ldr	r3, [sp, #4]
     d2c:	2b00      	cmp	r3, #0
     d2e:	d102      	bne.n	d36 <chVTDoResetI+0x16>
     d30:	4836      	ldr	r0, [pc, #216]	; (e0c <chVTDoResetI+0xec>)
     d32:	f7ff fd95 	bl	860 <chSysHalt>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
     d36:	9b01      	ldr	r3, [sp, #4]
     d38:	68db      	ldr	r3, [r3, #12]
     d3a:	2b00      	cmp	r3, #0
     d3c:	d102      	bne.n	d44 <chVTDoResetI+0x24>
     d3e:	4833      	ldr	r0, [pc, #204]	; (e0c <chVTDoResetI+0xec>)
     d40:	f7ff fd8e 	bl	860 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
     d44:	4b32      	ldr	r3, [pc, #200]	; (e10 <chVTDoResetI+0xf0>)
     d46:	69da      	ldr	r2, [r3, #28]
     d48:	9b01      	ldr	r3, [sp, #4]
     d4a:	429a      	cmp	r2, r3
     d4c:	d01c      	beq.n	d88 <chVTDoResetI+0x68>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
     d4e:	9b01      	ldr	r3, [sp, #4]
     d50:	685b      	ldr	r3, [r3, #4]
     d52:	9a01      	ldr	r2, [sp, #4]
     d54:	6812      	ldr	r2, [r2, #0]
     d56:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
     d58:	9b01      	ldr	r3, [sp, #4]
     d5a:	681b      	ldr	r3, [r3, #0]
     d5c:	9a01      	ldr	r2, [sp, #4]
     d5e:	6852      	ldr	r2, [r2, #4]
     d60:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
     d62:	9b01      	ldr	r3, [sp, #4]
     d64:	2200      	movs	r2, #0
     d66:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
     d68:	9b01      	ldr	r3, [sp, #4]
     d6a:	681a      	ldr	r2, [r3, #0]
     d6c:	4b29      	ldr	r3, [pc, #164]	; (e14 <chVTDoResetI+0xf4>)
     d6e:	429a      	cmp	r2, r3
     d70:	d009      	beq.n	d86 <chVTDoResetI+0x66>
      vtp->vt_next->vt_delta += vtp->vt_delta;
     d72:	9b01      	ldr	r3, [sp, #4]
     d74:	681b      	ldr	r3, [r3, #0]
     d76:	9a01      	ldr	r2, [sp, #4]
     d78:	6812      	ldr	r2, [r2, #0]
     d7a:	6891      	ldr	r1, [r2, #8]
     d7c:	9a01      	ldr	r2, [sp, #4]
     d7e:	6892      	ldr	r2, [r2, #8]
     d80:	440a      	add	r2, r1
     d82:	609a      	str	r2, [r3, #8]

    return;
     d84:	e03e      	b.n	e04 <chVTDoResetI+0xe4>
     d86:	e03d      	b.n	e04 <chVTDoResetI+0xe4>
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
     d88:	9b01      	ldr	r3, [sp, #4]
     d8a:	681a      	ldr	r2, [r3, #0]
     d8c:	4b20      	ldr	r3, [pc, #128]	; (e10 <chVTDoResetI+0xf0>)
     d8e:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     d90:	4b1f      	ldr	r3, [pc, #124]	; (e10 <chVTDoResetI+0xf0>)
     d92:	69db      	ldr	r3, [r3, #28]
     d94:	4a1f      	ldr	r2, [pc, #124]	; (e14 <chVTDoResetI+0xf4>)
     d96:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
     d98:	9b01      	ldr	r3, [sp, #4]
     d9a:	2200      	movs	r2, #0
     d9c:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
     d9e:	4b1c      	ldr	r3, [pc, #112]	; (e10 <chVTDoResetI+0xf0>)
     da0:	69da      	ldr	r2, [r3, #28]
     da2:	4b1c      	ldr	r3, [pc, #112]	; (e14 <chVTDoResetI+0xf4>)
     da4:	429a      	cmp	r2, r3
     da6:	d102      	bne.n	dae <chVTDoResetI+0x8e>
    port_timer_stop_alarm();
     da8:	f7ff feea 	bl	b80 <port_timer_stop_alarm>

    return;
     dac:	e02a      	b.n	e04 <chVTDoResetI+0xe4>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
     dae:	4b18      	ldr	r3, [pc, #96]	; (e10 <chVTDoResetI+0xf0>)
     db0:	69db      	ldr	r3, [r3, #28]
     db2:	4a17      	ldr	r2, [pc, #92]	; (e10 <chVTDoResetI+0xf0>)
     db4:	69d2      	ldr	r2, [r2, #28]
     db6:	6891      	ldr	r1, [r2, #8]
     db8:	9a01      	ldr	r2, [sp, #4]
     dba:	6892      	ldr	r2, [r2, #8]
     dbc:	440a      	add	r2, r1
     dbe:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
     dc0:	f7ff fefe 	bl	bc0 <chVTGetSystemTimeX>
     dc4:	4602      	mov	r2, r0
     dc6:	4b12      	ldr	r3, [pc, #72]	; (e10 <chVTDoResetI+0xf0>)
     dc8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     dca:	1ad3      	subs	r3, r2, r3
     dcc:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
     dce:	4b10      	ldr	r3, [pc, #64]	; (e10 <chVTDoResetI+0xf0>)
     dd0:	69db      	ldr	r3, [r3, #28]
     dd2:	689a      	ldr	r2, [r3, #8]
     dd4:	9b02      	ldr	r3, [sp, #8]
     dd6:	429a      	cmp	r2, r3
     dd8:	d800      	bhi.n	ddc <chVTDoResetI+0xbc>
    return;
     dda:	e013      	b.n	e04 <chVTDoResetI+0xe4>
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
     ddc:	4b0c      	ldr	r3, [pc, #48]	; (e10 <chVTDoResetI+0xf0>)
     dde:	69db      	ldr	r3, [r3, #28]
     de0:	689a      	ldr	r2, [r3, #8]
     de2:	9b02      	ldr	r3, [sp, #8]
     de4:	1ad3      	subs	r3, r2, r3
     de6:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
     de8:	9b03      	ldr	r3, [sp, #12]
     dea:	2b01      	cmp	r3, #1
     dec:	d801      	bhi.n	df2 <chVTDoResetI+0xd2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
     dee:	2302      	movs	r3, #2
     df0:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
     df2:	4b07      	ldr	r3, [pc, #28]	; (e10 <chVTDoResetI+0xf0>)
     df4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     df6:	9b02      	ldr	r3, [sp, #8]
     df8:	441a      	add	r2, r3
     dfa:	9b03      	ldr	r3, [sp, #12]
     dfc:	4413      	add	r3, r2
     dfe:	4618      	mov	r0, r3
     e00:	f7ff fec6 	bl	b90 <port_timer_set_alarm>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     e04:	b005      	add	sp, #20
     e06:	f85d fb04 	ldr.w	pc, [sp], #4
     e0a:	bf00      	nop
     e0c:	00004680 	.word	0x00004680
     e10:	20000ac0 	.word	0x20000ac0
     e14:	20000adc 	.word	0x20000adc
     e18:	f3af 8000 	nop.w
     e1c:	f3af 8000 	nop.w

00000e20 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     e20:	b082      	sub	sp, #8
     e22:	2320      	movs	r3, #32
     e24:	9301      	str	r3, [sp, #4]
     e26:	9b01      	ldr	r3, [sp, #4]
     e28:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     e2c:	b002      	add	sp, #8
     e2e:	4770      	bx	lr

00000e30 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     e30:	b082      	sub	sp, #8
     e32:	2300      	movs	r3, #0
     e34:	9301      	str	r3, [sp, #4]
     e36:	9b01      	ldr	r3, [sp, #4]
     e38:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     e3c:	b002      	add	sp, #8
     e3e:	4770      	bx	lr

00000e40 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     e40:	b508      	push	{r3, lr}

  port_lock();
     e42:	f7ff ffed 	bl	e20 <port_lock>
}
     e46:	bd08      	pop	{r3, pc}
     e48:	f3af 8000 	nop.w
     e4c:	f3af 8000 	nop.w

00000e50 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     e50:	b508      	push	{r3, lr}

  port_unlock();
     e52:	f7ff ffed 	bl	e30 <port_unlock>
}
     e56:	bd08      	pop	{r3, pc}
     e58:	f3af 8000 	nop.w
     e5c:	f3af 8000 	nop.w

00000e60 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
     e60:	b082      	sub	sp, #8
     e62:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
     e64:	9b01      	ldr	r3, [sp, #4]
     e66:	9a01      	ldr	r2, [sp, #4]
     e68:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
     e6a:	9b01      	ldr	r3, [sp, #4]
     e6c:	9a01      	ldr	r2, [sp, #4]
     e6e:	605a      	str	r2, [r3, #4]
}
     e70:	b002      	add	sp, #8
     e72:	4770      	bx	lr
     e74:	f3af 8000 	nop.w
     e78:	f3af 8000 	nop.w
     e7c:	f3af 8000 	nop.w

00000e80 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
     e80:	b084      	sub	sp, #16
     e82:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
     e84:	9b01      	ldr	r3, [sp, #4]
     e86:	681b      	ldr	r3, [r3, #0]
     e88:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
     e8a:	9b03      	ldr	r3, [sp, #12]
     e8c:	681a      	ldr	r2, [r3, #0]
     e8e:	9b01      	ldr	r3, [sp, #4]
     e90:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
     e92:	9b01      	ldr	r3, [sp, #4]
     e94:	681b      	ldr	r3, [r3, #0]
     e96:	9a01      	ldr	r2, [sp, #4]
     e98:	605a      	str	r2, [r3, #4]

  return tp;
     e9a:	9b03      	ldr	r3, [sp, #12]
}
     e9c:	4618      	mov	r0, r3
     e9e:	b004      	add	sp, #16
     ea0:	4770      	bx	lr
     ea2:	bf00      	nop
     ea4:	f3af 8000 	nop.w
     ea8:	f3af 8000 	nop.w
     eac:	f3af 8000 	nop.w

00000eb0 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
     eb0:	b082      	sub	sp, #8
     eb2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
     eb4:	9b01      	ldr	r3, [sp, #4]
     eb6:	685b      	ldr	r3, [r3, #4]
     eb8:	9a01      	ldr	r2, [sp, #4]
     eba:	6812      	ldr	r2, [r2, #0]
     ebc:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
     ebe:	9b01      	ldr	r3, [sp, #4]
     ec0:	681b      	ldr	r3, [r3, #0]
     ec2:	9a01      	ldr	r2, [sp, #4]
     ec4:	6852      	ldr	r2, [r2, #4]
     ec6:	605a      	str	r2, [r3, #4]

  return tp;
     ec8:	9b01      	ldr	r3, [sp, #4]
}
     eca:	4618      	mov	r0, r3
     ecc:	b002      	add	sp, #8
     ece:	4770      	bx	lr

00000ed0 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
     ed0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
     ed2:	f7ff fdcd 	bl	a70 <chDbgCheckClassI>

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
     ed6:	4b06      	ldr	r3, [pc, #24]	; (ef0 <chSchIsRescRequiredI+0x20>)
     ed8:	681b      	ldr	r3, [r3, #0]
     eda:	689a      	ldr	r2, [r3, #8]
     edc:	4b04      	ldr	r3, [pc, #16]	; (ef0 <chSchIsRescRequiredI+0x20>)
     ede:	699b      	ldr	r3, [r3, #24]
     ee0:	689b      	ldr	r3, [r3, #8]
     ee2:	429a      	cmp	r2, r3
     ee4:	bf94      	ite	ls
     ee6:	2300      	movls	r3, #0
     ee8:	2301      	movhi	r3, #1
     eea:	b2db      	uxtb	r3, r3
}
     eec:	4618      	mov	r0, r3
     eee:	bd08      	pop	{r3, pc}
     ef0:	20000ac0 	.word	0x20000ac0
     ef4:	f3af 8000 	nop.w
     ef8:	f3af 8000 	nop.w
     efc:	f3af 8000 	nop.w

00000f00 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
     f00:	b508      	push	{r3, lr}

  port_lock_from_isr();
     f02:	f7ff ff9d 	bl	e40 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
     f06:	f000 fe1b 	bl	1b40 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
     f0a:	f7ff fd41 	bl	990 <_dbg_check_lock_from_isr>
}
     f0e:	bd08      	pop	{r3, pc}

00000f10 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
     f10:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
     f12:	f7ff fd55 	bl	9c0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
     f16:	f000 fe1b 	bl	1b50 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
     f1a:	f7ff ff99 	bl	e50 <port_unlock_from_isr>
}
     f1e:	bd08      	pop	{r3, pc}

00000f20 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
     f20:	b500      	push	{lr}
     f22:	b083      	sub	sp, #12
     f24:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     f26:	f7ff fda3 	bl	a70 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
     f2a:	9b01      	ldr	r3, [sp, #4]
     f2c:	68db      	ldr	r3, [r3, #12]
     f2e:	2b00      	cmp	r3, #0
     f30:	bf0c      	ite	eq
     f32:	2300      	moveq	r3, #0
     f34:	2301      	movne	r3, #1
     f36:	b2db      	uxtb	r3, r3
}
     f38:	4618      	mov	r0, r3
     f3a:	b003      	add	sp, #12
     f3c:	f85d fb04 	ldr.w	pc, [sp], #4

00000f40 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
     f40:	b500      	push	{lr}
     f42:	b083      	sub	sp, #12
     f44:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     f46:	f7ff fd93 	bl	a70 <chDbgCheckClassI>

  sp->s_cnt++;
     f4a:	9b01      	ldr	r3, [sp, #4]
     f4c:	689b      	ldr	r3, [r3, #8]
     f4e:	1c5a      	adds	r2, r3, #1
     f50:	9b01      	ldr	r3, [sp, #4]
     f52:	609a      	str	r2, [r3, #8]
}
     f54:	b003      	add	sp, #12
     f56:	f85d fb04 	ldr.w	pc, [sp], #4
     f5a:	bf00      	nop
     f5c:	f3af 8000 	nop.w

00000f60 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
     f60:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
     f62:	4806      	ldr	r0, [pc, #24]	; (f7c <_scheduler_init+0x1c>)
     f64:	f7ff ff7c 	bl	e60 <queue_init>
  ch.rlist.r_prio = NOPRIO;
     f68:	4b04      	ldr	r3, [pc, #16]	; (f7c <_scheduler_init+0x1c>)
     f6a:	2200      	movs	r2, #0
     f6c:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
     f6e:	4b03      	ldr	r3, [pc, #12]	; (f7c <_scheduler_init+0x1c>)
     f70:	4a02      	ldr	r2, [pc, #8]	; (f7c <_scheduler_init+0x1c>)
     f72:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
     f74:	4b01      	ldr	r3, [pc, #4]	; (f7c <_scheduler_init+0x1c>)
     f76:	4a01      	ldr	r2, [pc, #4]	; (f7c <_scheduler_init+0x1c>)
     f78:	615a      	str	r2, [r3, #20]
#endif
}
     f7a:	bd08      	pop	{r3, pc}
     f7c:	20000ac0 	.word	0x20000ac0

00000f80 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     f80:	b500      	push	{lr}
     f82:	b085      	sub	sp, #20
     f84:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
     f86:	f7ff fd73 	bl	a70 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
     f8a:	9b01      	ldr	r3, [sp, #4]
     f8c:	2b00      	cmp	r3, #0
     f8e:	d102      	bne.n	f96 <chSchReadyI+0x16>
     f90:	4818      	ldr	r0, [pc, #96]	; (ff4 <chSchReadyI+0x74>)
     f92:	f7ff fc65 	bl	860 <chSysHalt>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
     f96:	9b01      	ldr	r3, [sp, #4]
     f98:	f893 3020 	ldrb.w	r3, [r3, #32]
     f9c:	2b00      	cmp	r3, #0
     f9e:	d004      	beq.n	faa <chSchReadyI+0x2a>
     fa0:	9b01      	ldr	r3, [sp, #4]
     fa2:	f893 3020 	ldrb.w	r3, [r3, #32]
     fa6:	2b0f      	cmp	r3, #15
     fa8:	d102      	bne.n	fb0 <chSchReadyI+0x30>
     faa:	4812      	ldr	r0, [pc, #72]	; (ff4 <chSchReadyI+0x74>)
     fac:	f7ff fc58 	bl	860 <chSysHalt>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     fb0:	9b01      	ldr	r3, [sp, #4]
     fb2:	2200      	movs	r2, #0
     fb4:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
     fb8:	4b0f      	ldr	r3, [pc, #60]	; (ff8 <chSchReadyI+0x78>)
     fba:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
     fbc:	9b03      	ldr	r3, [sp, #12]
     fbe:	681b      	ldr	r3, [r3, #0]
     fc0:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
     fc2:	9b03      	ldr	r3, [sp, #12]
     fc4:	689a      	ldr	r2, [r3, #8]
     fc6:	9b01      	ldr	r3, [sp, #4]
     fc8:	689b      	ldr	r3, [r3, #8]
     fca:	429a      	cmp	r2, r3
     fcc:	d2f6      	bcs.n	fbc <chSchReadyI+0x3c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     fce:	9b01      	ldr	r3, [sp, #4]
     fd0:	9a03      	ldr	r2, [sp, #12]
     fd2:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
     fd4:	9b03      	ldr	r3, [sp, #12]
     fd6:	685a      	ldr	r2, [r3, #4]
     fd8:	9b01      	ldr	r3, [sp, #4]
     fda:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
     fdc:	9b01      	ldr	r3, [sp, #4]
     fde:	685b      	ldr	r3, [r3, #4]
     fe0:	9a01      	ldr	r2, [sp, #4]
     fe2:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
     fe4:	9b03      	ldr	r3, [sp, #12]
     fe6:	9a01      	ldr	r2, [sp, #4]
     fe8:	605a      	str	r2, [r3, #4]

  return tp;
     fea:	9b01      	ldr	r3, [sp, #4]
}
     fec:	4618      	mov	r0, r3
     fee:	b005      	add	sp, #20
     ff0:	f85d fb04 	ldr.w	pc, [sp], #4
     ff4:	00004690 	.word	0x00004690
     ff8:	20000ac0 	.word	0x20000ac0
     ffc:	f3af 8000 	nop.w

00001000 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
    1000:	b510      	push	{r4, lr}
    1002:	b084      	sub	sp, #16
    1004:	4603      	mov	r3, r0
    1006:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();
    100a:	f7ff fd49 	bl	aa0 <chDbgCheckClassS>

  otp = currp;
    100e:	4b19      	ldr	r3, [pc, #100]	; (1074 <__ram5_size__+0x74>)
    1010:	699b      	ldr	r3, [r3, #24]
    1012:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
    1014:	9b03      	ldr	r3, [sp, #12]
    1016:	f89d 2007 	ldrb.w	r2, [sp, #7]
    101a:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
    101e:	4815      	ldr	r0, [pc, #84]	; (1074 <__ram5_size__+0x74>)
    1020:	f7ff ff2e 	bl	e80 <queue_fifo_remove>
    1024:	4602      	mov	r2, r0
    1026:	4b13      	ldr	r3, [pc, #76]	; (1074 <__ram5_size__+0x74>)
    1028:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
    102a:	4b12      	ldr	r3, [pc, #72]	; (1074 <__ram5_size__+0x74>)
    102c:	699b      	ldr	r3, [r3, #24]
    102e:	2201      	movs	r2, #1
    1030:	f883 2020 	strb.w	r2, [r3, #32]
  chSysSwitch(currp, otp);
    1034:	9803      	ldr	r0, [sp, #12]
    1036:	f7ff fd5b 	bl	af0 <_dbg_trace>
    103a:	4b0e      	ldr	r3, [pc, #56]	; (1074 <__ram5_size__+0x74>)
    103c:	699b      	ldr	r3, [r3, #24]
    103e:	4618      	mov	r0, r3
    1040:	9903      	ldr	r1, [sp, #12]
    1042:	f000 fd4d 	bl	1ae0 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    1046:	f3ef 8309 	mrs	r3, PSP
    104a:	461c      	mov	r4, r3
  return(result);
    104c:	4623      	mov	r3, r4
    104e:	9302      	str	r3, [sp, #8]
    1050:	9b02      	ldr	r3, [sp, #8]
    1052:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    1056:	9b03      	ldr	r3, [sp, #12]
    1058:	69db      	ldr	r3, [r3, #28]
    105a:	429a      	cmp	r2, r3
    105c:	d202      	bcs.n	1064 <__ram5_size__+0x64>
    105e:	4806      	ldr	r0, [pc, #24]	; (1078 <__ram5_size__+0x78>)
    1060:	f7ff fbfe 	bl	860 <chSysHalt>
    1064:	4b03      	ldr	r3, [pc, #12]	; (1074 <__ram5_size__+0x74>)
    1066:	699b      	ldr	r3, [r3, #24]
    1068:	4618      	mov	r0, r3
    106a:	9903      	ldr	r1, [sp, #12]
    106c:	f7ff f908 	bl	280 <_port_switch>
}
    1070:	b004      	add	sp, #16
    1072:	bd10      	pop	{r4, pc}
    1074:	20000ac0 	.word	0x20000ac0
    1078:	00004650 	.word	0x00004650
    107c:	f3af 8000 	nop.w

00001080 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
    1080:	b500      	push	{lr}
    1082:	b085      	sub	sp, #20
    1084:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
    1086:	9b01      	ldr	r3, [sp, #4]
    1088:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
    108a:	f7ff ff39 	bl	f00 <chSysLockFromISR>
  switch (tp->p_state) {
    108e:	9b03      	ldr	r3, [sp, #12]
    1090:	f893 3020 	ldrb.w	r3, [r3, #32]
    1094:	2b07      	cmp	r3, #7
    1096:	d824      	bhi.n	10e2 <wakeup+0x62>
    1098:	a201      	add	r2, pc, #4	; (adr r2, 10a0 <wakeup+0x20>)
    109a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    109e:	bf00      	nop
    10a0:	000010c1 	.word	0x000010c1
    10a4:	000010e3 	.word	0x000010e3
    10a8:	000010e3 	.word	0x000010e3
    10ac:	000010c7 	.word	0x000010c7
    10b0:	000010db 	.word	0x000010db
    10b4:	000010d1 	.word	0x000010d1
    10b8:	000010e3 	.word	0x000010e3
    10bc:	000010db 	.word	0x000010db
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    10c0:	f7ff ff26 	bl	f10 <chSysUnlockFromISR>
    return;
    10c4:	e017      	b.n	10f6 <wakeup+0x76>
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    10c6:	9b03      	ldr	r3, [sp, #12]
    10c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    10ca:	2200      	movs	r2, #0
    10cc:	601a      	str	r2, [r3, #0]
    break;
    10ce:	e009      	b.n	10e4 <wakeup+0x64>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
    10d0:	9b03      	ldr	r3, [sp, #12]
    10d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    10d4:	4618      	mov	r0, r3
    10d6:	f7ff ff33 	bl	f40 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
    10da:	9803      	ldr	r0, [sp, #12]
    10dc:	f7ff fee8 	bl	eb0 <queue_dequeue>
    break;
    10e0:	e000      	b.n	10e4 <wakeup+0x64>
  default:
    /* Any other state, nothing to do.*/
    break;
    10e2:	bf00      	nop
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
    10e4:	9b03      	ldr	r3, [sp, #12]
    10e6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    10ea:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
    10ec:	9803      	ldr	r0, [sp, #12]
    10ee:	f7ff ff47 	bl	f80 <chSchReadyI>
  chSysUnlockFromISR();
    10f2:	f7ff ff0d 	bl	f10 <chSysUnlockFromISR>
}
    10f6:	b005      	add	sp, #20
    10f8:	f85d fb04 	ldr.w	pc, [sp], #4
    10fc:	f3af 8000 	nop.w

00001100 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
    1100:	b500      	push	{lr}
    1102:	b089      	sub	sp, #36	; 0x24
    1104:	4603      	mov	r3, r0
    1106:	9100      	str	r1, [sp, #0]
    1108:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
    110c:	f7ff fcc8 	bl	aa0 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
    1110:	9b00      	ldr	r3, [sp, #0]
    1112:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1116:	d019      	beq.n	114c <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
    1118:	4b12      	ldr	r3, [pc, #72]	; (1164 <chSchGoSleepTimeoutS+0x64>)
    111a:	699b      	ldr	r3, [r3, #24]
    111c:	aa03      	add	r2, sp, #12
    111e:	4610      	mov	r0, r2
    1120:	9900      	ldr	r1, [sp, #0]
    1122:	4a11      	ldr	r2, [pc, #68]	; (1168 <chSchGoSleepTimeoutS+0x68>)
    1124:	f7ff fd6c 	bl	c00 <chVTDoSetI>
    chSchGoSleepS(newstate);
    1128:	f89d 3007 	ldrb.w	r3, [sp, #7]
    112c:	4618      	mov	r0, r3
    112e:	f7ff ff67 	bl	1000 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
    1132:	ab03      	add	r3, sp, #12
    1134:	4618      	mov	r0, r3
    1136:	f7ff fef3 	bl	f20 <chVTIsArmedI>
    113a:	4603      	mov	r3, r0
    113c:	2b00      	cmp	r3, #0
    113e:	d004      	beq.n	114a <chSchGoSleepTimeoutS+0x4a>
      chVTDoResetI(&vt);
    1140:	ab03      	add	r3, sp, #12
    1142:	4618      	mov	r0, r3
    1144:	f7ff fdec 	bl	d20 <chVTDoResetI>
    1148:	e005      	b.n	1156 <chSchGoSleepTimeoutS+0x56>
    114a:	e004      	b.n	1156 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
    114c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1150:	4618      	mov	r0, r3
    1152:	f7ff ff55 	bl	1000 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
    1156:	4b03      	ldr	r3, [pc, #12]	; (1164 <chSchGoSleepTimeoutS+0x64>)
    1158:	699b      	ldr	r3, [r3, #24]
    115a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
    115c:	4618      	mov	r0, r3
    115e:	b009      	add	sp, #36	; 0x24
    1160:	f85d fb04 	ldr.w	pc, [sp], #4
    1164:	20000ac0 	.word	0x20000ac0
    1168:	00001081 	.word	0x00001081
    116c:	f3af 8000 	nop.w

00001170 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
    1170:	b510      	push	{r4, lr}
    1172:	b084      	sub	sp, #16
    1174:	9001      	str	r0, [sp, #4]
    1176:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
    1178:	f7ff fc92 	bl	aa0 <chDbgCheckClassS>

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
    117c:	9b01      	ldr	r3, [sp, #4]
    117e:	9a00      	ldr	r2, [sp, #0]
    1180:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    1182:	9b01      	ldr	r3, [sp, #4]
    1184:	689a      	ldr	r2, [r3, #8]
    1186:	4b19      	ldr	r3, [pc, #100]	; (11ec <chSchWakeupS+0x7c>)
    1188:	699b      	ldr	r3, [r3, #24]
    118a:	689b      	ldr	r3, [r3, #8]
    118c:	429a      	cmp	r2, r3
    118e:	d803      	bhi.n	1198 <chSchWakeupS+0x28>
    (void) chSchReadyI(ntp);
    1190:	9801      	ldr	r0, [sp, #4]
    1192:	f7ff fef5 	bl	f80 <chSchReadyI>
    1196:	e026      	b.n	11e6 <chSchWakeupS+0x76>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    1198:	4b14      	ldr	r3, [pc, #80]	; (11ec <chSchWakeupS+0x7c>)
    119a:	699b      	ldr	r3, [r3, #24]
    119c:	4618      	mov	r0, r3
    119e:	f7ff feef 	bl	f80 <chSchReadyI>
    11a2:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
    11a4:	4b11      	ldr	r3, [pc, #68]	; (11ec <chSchWakeupS+0x7c>)
    11a6:	9a01      	ldr	r2, [sp, #4]
    11a8:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    11aa:	9b01      	ldr	r3, [sp, #4]
    11ac:	2201      	movs	r2, #1
    11ae:	f883 2020 	strb.w	r2, [r3, #32]
    chSysSwitch(ntp, otp);
    11b2:	9803      	ldr	r0, [sp, #12]
    11b4:	f7ff fc9c 	bl	af0 <_dbg_trace>
    11b8:	9801      	ldr	r0, [sp, #4]
    11ba:	9903      	ldr	r1, [sp, #12]
    11bc:	f000 fc90 	bl	1ae0 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    11c0:	f3ef 8309 	mrs	r3, PSP
    11c4:	461c      	mov	r4, r3
  return(result);
    11c6:	4623      	mov	r3, r4
    11c8:	9302      	str	r3, [sp, #8]
    11ca:	9b02      	ldr	r3, [sp, #8]
    11cc:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    11d0:	9b03      	ldr	r3, [sp, #12]
    11d2:	69db      	ldr	r3, [r3, #28]
    11d4:	429a      	cmp	r2, r3
    11d6:	d202      	bcs.n	11de <chSchWakeupS+0x6e>
    11d8:	4805      	ldr	r0, [pc, #20]	; (11f0 <chSchWakeupS+0x80>)
    11da:	f7ff fb41 	bl	860 <chSysHalt>
    11de:	9801      	ldr	r0, [sp, #4]
    11e0:	9903      	ldr	r1, [sp, #12]
    11e2:	f7ff f84d 	bl	280 <_port_switch>
  }
}
    11e6:	b004      	add	sp, #16
    11e8:	bd10      	pop	{r4, pc}
    11ea:	bf00      	nop
    11ec:	20000ac0 	.word	0x20000ac0
    11f0:	00004650 	.word	0x00004650
    11f4:	f3af 8000 	nop.w
    11f8:	f3af 8000 	nop.w
    11fc:	f3af 8000 	nop.w

00001200 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
    1200:	b508      	push	{r3, lr}

  chDbgCheckClassS();
    1202:	f7ff fc4d 	bl	aa0 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
    1206:	f7ff fe63 	bl	ed0 <chSchIsRescRequiredI>
    120a:	4603      	mov	r3, r0
    120c:	2b00      	cmp	r3, #0
    120e:	d001      	beq.n	1214 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
    1210:	f000 f81e 	bl	1250 <chSchDoRescheduleAhead>
  }
}
    1214:	bd08      	pop	{r3, pc}
    1216:	bf00      	nop
    1218:	f3af 8000 	nop.w
    121c:	f3af 8000 	nop.w

00001220 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
    1220:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
    1222:	4b09      	ldr	r3, [pc, #36]	; (1248 <chSchIsPreemptionRequired+0x28>)
    1224:	681b      	ldr	r3, [r3, #0]
    1226:	689b      	ldr	r3, [r3, #8]
    1228:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
    122a:	4b07      	ldr	r3, [pc, #28]	; (1248 <chSchIsPreemptionRequired+0x28>)
    122c:	699b      	ldr	r3, [r3, #24]
    122e:	689b      	ldr	r3, [r3, #8]
    1230:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
    1232:	9a01      	ldr	r2, [sp, #4]
    1234:	9b00      	ldr	r3, [sp, #0]
    1236:	429a      	cmp	r2, r3
    1238:	bf94      	ite	ls
    123a:	2300      	movls	r3, #0
    123c:	2301      	movhi	r3, #1
    123e:	b2db      	uxtb	r3, r3
#endif
}
    1240:	4618      	mov	r0, r3
    1242:	b002      	add	sp, #8
    1244:	4770      	bx	lr
    1246:	bf00      	nop
    1248:	20000ac0 	.word	0x20000ac0
    124c:	f3af 8000 	nop.w

00001250 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
    1250:	b510      	push	{r4, lr}
    1252:	b084      	sub	sp, #16
  thread_t *otp, *cp;

  otp = currp;
    1254:	4b25      	ldr	r3, [pc, #148]	; (12ec <chSchDoRescheduleAhead+0x9c>)
    1256:	699b      	ldr	r3, [r3, #24]
    1258:	9302      	str	r3, [sp, #8]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
    125a:	4824      	ldr	r0, [pc, #144]	; (12ec <chSchDoRescheduleAhead+0x9c>)
    125c:	f7ff fe10 	bl	e80 <queue_fifo_remove>
    1260:	4602      	mov	r2, r0
    1262:	4b22      	ldr	r3, [pc, #136]	; (12ec <chSchDoRescheduleAhead+0x9c>)
    1264:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
    1266:	4b21      	ldr	r3, [pc, #132]	; (12ec <chSchDoRescheduleAhead+0x9c>)
    1268:	699b      	ldr	r3, [r3, #24]
    126a:	2201      	movs	r2, #1
    126c:	f883 2020 	strb.w	r2, [r3, #32]

  otp->p_state = CH_STATE_READY;
    1270:	9b02      	ldr	r3, [sp, #8]
    1272:	2200      	movs	r2, #0
    1274:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
    1278:	4b1c      	ldr	r3, [pc, #112]	; (12ec <chSchDoRescheduleAhead+0x9c>)
    127a:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
    127c:	9b03      	ldr	r3, [sp, #12]
    127e:	681b      	ldr	r3, [r3, #0]
    1280:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio > otp->p_prio);
    1282:	9b03      	ldr	r3, [sp, #12]
    1284:	689a      	ldr	r2, [r3, #8]
    1286:	9b02      	ldr	r3, [sp, #8]
    1288:	689b      	ldr	r3, [r3, #8]
    128a:	429a      	cmp	r2, r3
    128c:	d8f6      	bhi.n	127c <chSchDoRescheduleAhead+0x2c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
    128e:	9b02      	ldr	r3, [sp, #8]
    1290:	9a03      	ldr	r2, [sp, #12]
    1292:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
    1294:	9b03      	ldr	r3, [sp, #12]
    1296:	685a      	ldr	r2, [r3, #4]
    1298:	9b02      	ldr	r3, [sp, #8]
    129a:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
    129c:	9b02      	ldr	r3, [sp, #8]
    129e:	685b      	ldr	r3, [r3, #4]
    12a0:	9a02      	ldr	r2, [sp, #8]
    12a2:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
    12a4:	9b03      	ldr	r3, [sp, #12]
    12a6:	9a02      	ldr	r2, [sp, #8]
    12a8:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
    12aa:	9802      	ldr	r0, [sp, #8]
    12ac:	f7ff fc20 	bl	af0 <_dbg_trace>
    12b0:	4b0e      	ldr	r3, [pc, #56]	; (12ec <chSchDoRescheduleAhead+0x9c>)
    12b2:	699b      	ldr	r3, [r3, #24]
    12b4:	4618      	mov	r0, r3
    12b6:	9902      	ldr	r1, [sp, #8]
    12b8:	f000 fc12 	bl	1ae0 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    12bc:	f3ef 8309 	mrs	r3, PSP
    12c0:	461c      	mov	r4, r3
  return(result);
    12c2:	4623      	mov	r3, r4
    12c4:	9301      	str	r3, [sp, #4]
    12c6:	9b01      	ldr	r3, [sp, #4]
    12c8:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    12cc:	9b02      	ldr	r3, [sp, #8]
    12ce:	69db      	ldr	r3, [r3, #28]
    12d0:	429a      	cmp	r2, r3
    12d2:	d202      	bcs.n	12da <chSchDoRescheduleAhead+0x8a>
    12d4:	4806      	ldr	r0, [pc, #24]	; (12f0 <chSchDoRescheduleAhead+0xa0>)
    12d6:	f7ff fac3 	bl	860 <chSysHalt>
    12da:	4b04      	ldr	r3, [pc, #16]	; (12ec <chSchDoRescheduleAhead+0x9c>)
    12dc:	699b      	ldr	r3, [r3, #24]
    12de:	4618      	mov	r0, r3
    12e0:	9902      	ldr	r1, [sp, #8]
    12e2:	f7fe ffcd 	bl	280 <_port_switch>
}
    12e6:	b004      	add	sp, #16
    12e8:	bd10      	pop	{r4, pc}
    12ea:	bf00      	nop
    12ec:	20000ac0 	.word	0x20000ac0
    12f0:	00004650 	.word	0x00004650
    12f4:	f3af 8000 	nop.w
    12f8:	f3af 8000 	nop.w
    12fc:	f3af 8000 	nop.w

00001300 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    1300:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
    1302:	f7ff ffa5 	bl	1250 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
    1306:	bd08      	pop	{r3, pc}
    1308:	f3af 8000 	nop.w
    130c:	f3af 8000 	nop.w

00001310 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1310:	b082      	sub	sp, #8
    1312:	2320      	movs	r3, #32
    1314:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    1316:	9b01      	ldr	r3, [sp, #4]
    1318:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    131c:	b002      	add	sp, #8
    131e:	4770      	bx	lr

00001320 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1320:	b082      	sub	sp, #8
    1322:	2300      	movs	r3, #0
    1324:	9301      	str	r3, [sp, #4]
    1326:	9b01      	ldr	r3, [sp, #4]
    1328:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    132c:	b002      	add	sp, #8
    132e:	4770      	bx	lr

00001330 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
    1330:	b082      	sub	sp, #8
    1332:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
    1334:	9b01      	ldr	r3, [sp, #4]
    1336:	9a01      	ldr	r2, [sp, #4]
    1338:	601a      	str	r2, [r3, #0]
}
    133a:	b002      	add	sp, #8
    133c:	4770      	bx	lr
    133e:	bf00      	nop

00001340 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
    1340:	b082      	sub	sp, #8
    1342:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
    1344:	9b01      	ldr	r3, [sp, #4]
    1346:	681a      	ldr	r2, [r3, #0]
    1348:	9b01      	ldr	r3, [sp, #4]
    134a:	429a      	cmp	r2, r3
    134c:	bf0c      	ite	eq
    134e:	2300      	moveq	r3, #0
    1350:	2301      	movne	r3, #1
    1352:	b2db      	uxtb	r3, r3
}
    1354:	4618      	mov	r0, r3
    1356:	b002      	add	sp, #8
    1358:	4770      	bx	lr
    135a:	bf00      	nop
    135c:	f3af 8000 	nop.w

00001360 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1360:	b082      	sub	sp, #8
    1362:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1364:	9b01      	ldr	r3, [sp, #4]
    1366:	9a01      	ldr	r2, [sp, #4]
    1368:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    136a:	9b01      	ldr	r3, [sp, #4]
    136c:	9a01      	ldr	r2, [sp, #4]
    136e:	605a      	str	r2, [r3, #4]
}
    1370:	b002      	add	sp, #8
    1372:	4770      	bx	lr
    1374:	f3af 8000 	nop.w
    1378:	f3af 8000 	nop.w
    137c:	f3af 8000 	nop.w

00001380 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
    1380:	b082      	sub	sp, #8
    1382:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
    1384:	9b01      	ldr	r3, [sp, #4]
    1386:	681a      	ldr	r2, [r3, #0]
    1388:	9b01      	ldr	r3, [sp, #4]
    138a:	429a      	cmp	r2, r3
    138c:	bf0c      	ite	eq
    138e:	2300      	moveq	r3, #0
    1390:	2301      	movne	r3, #1
    1392:	b2db      	uxtb	r3, r3
}
    1394:	4618      	mov	r0, r3
    1396:	b002      	add	sp, #8
    1398:	4770      	bx	lr
    139a:	bf00      	nop
    139c:	f3af 8000 	nop.w

000013a0 <list_insert>:

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {
    13a0:	b082      	sub	sp, #8
    13a2:	9001      	str	r0, [sp, #4]
    13a4:	9100      	str	r1, [sp, #0]

  tp->p_next = tlp->p_next;
    13a6:	9b00      	ldr	r3, [sp, #0]
    13a8:	681a      	ldr	r2, [r3, #0]
    13aa:	9b01      	ldr	r3, [sp, #4]
    13ac:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
    13ae:	9b00      	ldr	r3, [sp, #0]
    13b0:	9a01      	ldr	r2, [sp, #4]
    13b2:	601a      	str	r2, [r3, #0]
}
    13b4:	b002      	add	sp, #8
    13b6:	4770      	bx	lr
    13b8:	f3af 8000 	nop.w
    13bc:	f3af 8000 	nop.w

000013c0 <list_remove>:

static inline thread_t *list_remove(threads_list_t *tlp) {
    13c0:	b084      	sub	sp, #16
    13c2:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
    13c4:	9b01      	ldr	r3, [sp, #4]
    13c6:	681b      	ldr	r3, [r3, #0]
    13c8:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
    13ca:	9b03      	ldr	r3, [sp, #12]
    13cc:	681a      	ldr	r2, [r3, #0]
    13ce:	9b01      	ldr	r3, [sp, #4]
    13d0:	601a      	str	r2, [r3, #0]

  return tp;
    13d2:	9b03      	ldr	r3, [sp, #12]
}
    13d4:	4618      	mov	r0, r3
    13d6:	b004      	add	sp, #16
    13d8:	4770      	bx	lr
    13da:	bf00      	nop
    13dc:	f3af 8000 	nop.w

000013e0 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
    13e0:	b082      	sub	sp, #8
    13e2:	9001      	str	r0, [sp, #4]
    13e4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
    13e6:	9b01      	ldr	r3, [sp, #4]
    13e8:	9a00      	ldr	r2, [sp, #0]
    13ea:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
    13ec:	9b00      	ldr	r3, [sp, #0]
    13ee:	685a      	ldr	r2, [r3, #4]
    13f0:	9b01      	ldr	r3, [sp, #4]
    13f2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    13f4:	9b01      	ldr	r3, [sp, #4]
    13f6:	685b      	ldr	r3, [r3, #4]
    13f8:	9a01      	ldr	r2, [sp, #4]
    13fa:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
    13fc:	9b00      	ldr	r3, [sp, #0]
    13fe:	9a01      	ldr	r2, [sp, #4]
    1400:	605a      	str	r2, [r3, #4]
}
    1402:	b002      	add	sp, #8
    1404:	4770      	bx	lr
    1406:	bf00      	nop
    1408:	f3af 8000 	nop.w
    140c:	f3af 8000 	nop.w

00001410 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
    1410:	b084      	sub	sp, #16
    1412:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
    1414:	9b01      	ldr	r3, [sp, #4]
    1416:	681b      	ldr	r3, [r3, #0]
    1418:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
    141a:	9b03      	ldr	r3, [sp, #12]
    141c:	681a      	ldr	r2, [r3, #0]
    141e:	9b01      	ldr	r3, [sp, #4]
    1420:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1422:	9b01      	ldr	r3, [sp, #4]
    1424:	681b      	ldr	r3, [r3, #0]
    1426:	9a01      	ldr	r2, [sp, #4]
    1428:	605a      	str	r2, [r3, #4]

  return tp;
    142a:	9b03      	ldr	r3, [sp, #12]
}
    142c:	4618      	mov	r0, r3
    142e:	b004      	add	sp, #16
    1430:	4770      	bx	lr
    1432:	bf00      	nop
    1434:	f3af 8000 	nop.w
    1438:	f3af 8000 	nop.w
    143c:	f3af 8000 	nop.w

00001440 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1440:	b508      	push	{r3, lr}

  port_lock();
    1442:	f7ff ff65 	bl	1310 <port_lock>
  _stats_start_measure_crit_thd();
    1446:	f000 fb6b 	bl	1b20 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    144a:	f7ff fa71 	bl	930 <_dbg_check_lock>
}
    144e:	bd08      	pop	{r3, pc}

00001450 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1450:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1452:	f7ff fa85 	bl	960 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1456:	f000 fb6b 	bl	1b30 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    145a:	4b09      	ldr	r3, [pc, #36]	; (1480 <chSysUnlock+0x30>)
    145c:	681a      	ldr	r2, [r3, #0]
    145e:	4b08      	ldr	r3, [pc, #32]	; (1480 <chSysUnlock+0x30>)
    1460:	429a      	cmp	r2, r3
    1462:	d00a      	beq.n	147a <chSysUnlock+0x2a>
    1464:	4b06      	ldr	r3, [pc, #24]	; (1480 <chSysUnlock+0x30>)
    1466:	699b      	ldr	r3, [r3, #24]
    1468:	689a      	ldr	r2, [r3, #8]
    146a:	4b05      	ldr	r3, [pc, #20]	; (1480 <chSysUnlock+0x30>)
    146c:	681b      	ldr	r3, [r3, #0]
    146e:	689b      	ldr	r3, [r3, #8]
    1470:	429a      	cmp	r2, r3
    1472:	d202      	bcs.n	147a <chSysUnlock+0x2a>
    1474:	4803      	ldr	r0, [pc, #12]	; (1484 <chSysUnlock+0x34>)
    1476:	f7ff f9f3 	bl	860 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    147a:	f7ff ff51 	bl	1320 <port_unlock>
}
    147e:	bd08      	pop	{r3, pc}
    1480:	20000ac0 	.word	0x20000ac0
    1484:	000046b0 	.word	0x000046b0
    1488:	f3af 8000 	nop.w
    148c:	f3af 8000 	nop.w

00001490 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
    1490:	b500      	push	{lr}
    1492:	b083      	sub	sp, #12
    1494:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
    1496:	9b01      	ldr	r3, [sp, #4]
    1498:	2b00      	cmp	r3, #0
    149a:	d102      	bne.n	14a2 <chThdSleepS+0x12>
    149c:	4804      	ldr	r0, [pc, #16]	; (14b0 <chThdSleepS+0x20>)
    149e:	f7ff f9df 	bl	860 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
    14a2:	2008      	movs	r0, #8
    14a4:	9901      	ldr	r1, [sp, #4]
    14a6:	f7ff fe2b 	bl	1100 <chSchGoSleepTimeoutS>
}
    14aa:	b003      	add	sp, #12
    14ac:	f85d fb04 	ldr.w	pc, [sp], #4
    14b0:	000046e0 	.word	0x000046e0
    14b4:	f3af 8000 	nop.w
    14b8:	f3af 8000 	nop.w
    14bc:	f3af 8000 	nop.w

000014c0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    14c0:	b500      	push	{lr}
    14c2:	b085      	sub	sp, #20
    14c4:	9001      	str	r0, [sp, #4]
    14c6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
    14c8:	9801      	ldr	r0, [sp, #4]
    14ca:	f7ff ff59 	bl	1380 <queue_notempty>
    14ce:	4603      	mov	r3, r0
    14d0:	f083 0301 	eor.w	r3, r3, #1
    14d4:	b2db      	uxtb	r3, r3
    14d6:	2b00      	cmp	r3, #0
    14d8:	d002      	beq.n	14e0 <chThdDoDequeueNextI+0x20>
    14da:	480c      	ldr	r0, [pc, #48]	; (150c <chThdDoDequeueNextI+0x4c>)
    14dc:	f7ff f9c0 	bl	860 <chSysHalt>

  tp = queue_fifo_remove(tqp);
    14e0:	9801      	ldr	r0, [sp, #4]
    14e2:	f7ff ff95 	bl	1410 <queue_fifo_remove>
    14e6:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
    14e8:	9b03      	ldr	r3, [sp, #12]
    14ea:	f893 3020 	ldrb.w	r3, [r3, #32]
    14ee:	2b04      	cmp	r3, #4
    14f0:	d002      	beq.n	14f8 <chThdDoDequeueNextI+0x38>
    14f2:	4806      	ldr	r0, [pc, #24]	; (150c <chThdDoDequeueNextI+0x4c>)
    14f4:	f7ff f9b4 	bl	860 <chSysHalt>

  tp->p_u.rdymsg = msg;
    14f8:	9b03      	ldr	r3, [sp, #12]
    14fa:	9a00      	ldr	r2, [sp, #0]
    14fc:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
    14fe:	9803      	ldr	r0, [sp, #12]
    1500:	f7ff fd3e 	bl	f80 <chSchReadyI>
}
    1504:	b005      	add	sp, #20
    1506:	f85d fb04 	ldr.w	pc, [sp], #4
    150a:	bf00      	nop
    150c:	00004720 	.word	0x00004720

00001510 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
    1510:	b500      	push	{lr}
    1512:	b083      	sub	sp, #12
    1514:	9001      	str	r0, [sp, #4]
    1516:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
    1518:	9b01      	ldr	r3, [sp, #4]
    151a:	9a00      	ldr	r2, [sp, #0]
    151c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
    151e:	9b01      	ldr	r3, [sp, #4]
    1520:	2202      	movs	r2, #2
    1522:	f883 2020 	strb.w	r2, [r3, #32]
  tp->p_flags = CH_FLAG_MODE_STATIC;
    1526:	9b01      	ldr	r3, [sp, #4]
    1528:	2200      	movs	r2, #0
    152a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
    152e:	9b01      	ldr	r3, [sp, #4]
    1530:	9a00      	ldr	r2, [sp, #0]
    1532:	641a      	str	r2, [r3, #64]	; 0x40
  tp->p_mtxlist = NULL;
    1534:	9b01      	ldr	r3, [sp, #4]
    1536:	2200      	movs	r2, #0
    1538:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
    153a:	9b01      	ldr	r3, [sp, #4]
    153c:	2200      	movs	r2, #0
    153e:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
    1540:	9b01      	ldr	r3, [sp, #4]
    1542:	2201      	movs	r2, #1
    1544:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
    1548:	9b01      	ldr	r3, [sp, #4]
    154a:	2200      	movs	r2, #0
    154c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
    154e:	9b01      	ldr	r3, [sp, #4]
    1550:	4a15      	ldr	r2, [pc, #84]	; (15a8 <_thread_init+0x98>)
    1552:	611a      	str	r2, [r3, #16]
    1554:	4b14      	ldr	r3, [pc, #80]	; (15a8 <_thread_init+0x98>)
    1556:	695a      	ldr	r2, [r3, #20]
    1558:	9b01      	ldr	r3, [sp, #4]
    155a:	615a      	str	r2, [r3, #20]
    155c:	9b01      	ldr	r3, [sp, #4]
    155e:	695b      	ldr	r3, [r3, #20]
    1560:	9a01      	ldr	r2, [sp, #4]
    1562:	611a      	str	r2, [r3, #16]
    1564:	4b10      	ldr	r3, [pc, #64]	; (15a8 <_thread_init+0x98>)
    1566:	9a01      	ldr	r2, [sp, #4]
    1568:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
    156a:	9b01      	ldr	r3, [sp, #4]
    156c:	3328      	adds	r3, #40	; 0x28
    156e:	4618      	mov	r0, r3
    1570:	f7ff fede 	bl	1330 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
    1574:	9b01      	ldr	r3, [sp, #4]
    1576:	332c      	adds	r3, #44	; 0x2c
    1578:	4618      	mov	r0, r3
    157a:	f7ff fef1 	bl	1360 <queue_init>
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
    157e:	9b01      	ldr	r3, [sp, #4]
    1580:	f103 0260 	add.w	r2, r3, #96	; 0x60
    1584:	9b01      	ldr	r3, [sp, #4]
    1586:	61da      	str	r2, [r3, #28]
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->p_stats);
    1588:	9b01      	ldr	r3, [sp, #4]
    158a:	3348      	adds	r3, #72	; 0x48
    158c:	4618      	mov	r0, r3
    158e:	f000 fa27 	bl	19e0 <chTMObjectInit>
  chTMStartMeasurementX(&tp->p_stats);
    1592:	9b01      	ldr	r3, [sp, #4]
    1594:	3348      	adds	r3, #72	; 0x48
    1596:	4618      	mov	r0, r3
    1598:	f000 fa3a 	bl	1a10 <chTMStartMeasurementX>
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
    159c:	9b01      	ldr	r3, [sp, #4]
}
    159e:	4618      	mov	r0, r3
    15a0:	b003      	add	sp, #12
    15a2:	f85d fb04 	ldr.w	pc, [sp], #4
    15a6:	bf00      	nop
    15a8:	20000ac0 	.word	0x20000ac0
    15ac:	f3af 8000 	nop.w

000015b0 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
    15b0:	b084      	sub	sp, #16
    15b2:	9003      	str	r0, [sp, #12]
    15b4:	9102      	str	r1, [sp, #8]
    15b6:	4613      	mov	r3, r2
    15b8:	f88d 3007 	strb.w	r3, [sp, #7]

  while (startp < endp) {
    15bc:	e005      	b.n	15ca <_thread_memfill+0x1a>
    *startp++ = v;
    15be:	9b03      	ldr	r3, [sp, #12]
    15c0:	1c5a      	adds	r2, r3, #1
    15c2:	9203      	str	r2, [sp, #12]
    15c4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    15c8:	701a      	strb	r2, [r3, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    15ca:	9a03      	ldr	r2, [sp, #12]
    15cc:	9b02      	ldr	r3, [sp, #8]
    15ce:	429a      	cmp	r2, r3
    15d0:	d3f5      	bcc.n	15be <_thread_memfill+0xe>
    *startp++ = v;
  }
}
    15d2:	b004      	add	sp, #16
    15d4:	4770      	bx	lr
    15d6:	bf00      	nop
    15d8:	f3af 8000 	nop.w
    15dc:	f3af 8000 	nop.w

000015e0 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
    15e0:	b500      	push	{lr}
    15e2:	b087      	sub	sp, #28
    15e4:	9003      	str	r0, [sp, #12]
    15e6:	9102      	str	r1, [sp, #8]
    15e8:	9201      	str	r2, [sp, #4]
    15ea:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
    15ec:	9b03      	ldr	r3, [sp, #12]
    15ee:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
    15f0:	f7ff fa3e 	bl	a70 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
    15f4:	9b03      	ldr	r3, [sp, #12]
    15f6:	2b00      	cmp	r3, #0
    15f8:	d008      	beq.n	160c <chThdCreateI+0x2c>
    15fa:	9b02      	ldr	r3, [sp, #8]
    15fc:	2be7      	cmp	r3, #231	; 0xe7
    15fe:	d905      	bls.n	160c <chThdCreateI+0x2c>
    1600:	9b01      	ldr	r3, [sp, #4]
    1602:	2b7f      	cmp	r3, #127	; 0x7f
    1604:	d802      	bhi.n	160c <chThdCreateI+0x2c>
    1606:	9b00      	ldr	r3, [sp, #0]
    1608:	2b00      	cmp	r3, #0
    160a:	d102      	bne.n	1612 <chThdCreateI+0x32>
    160c:	480e      	ldr	r0, [pc, #56]	; (1648 <chThdCreateI+0x68>)
    160e:	f7ff f927 	bl	860 <chSysHalt>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    1612:	9b02      	ldr	r3, [sp, #8]
    1614:	3b24      	subs	r3, #36	; 0x24
    1616:	9a03      	ldr	r2, [sp, #12]
    1618:	441a      	add	r2, r3
    161a:	9b05      	ldr	r3, [sp, #20]
    161c:	60da      	str	r2, [r3, #12]
    161e:	9b05      	ldr	r3, [sp, #20]
    1620:	68db      	ldr	r3, [r3, #12]
    1622:	9a00      	ldr	r2, [sp, #0]
    1624:	601a      	str	r2, [r3, #0]
    1626:	9b05      	ldr	r3, [sp, #20]
    1628:	68db      	ldr	r3, [r3, #12]
    162a:	9a08      	ldr	r2, [sp, #32]
    162c:	605a      	str	r2, [r3, #4]
    162e:	9b05      	ldr	r3, [sp, #20]
    1630:	68db      	ldr	r3, [r3, #12]
    1632:	4a06      	ldr	r2, [pc, #24]	; (164c <chThdCreateI+0x6c>)
    1634:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
    1636:	9805      	ldr	r0, [sp, #20]
    1638:	9901      	ldr	r1, [sp, #4]
    163a:	f7ff ff69 	bl	1510 <_thread_init>
    163e:	4603      	mov	r3, r0
}
    1640:	4618      	mov	r0, r3
    1642:	b007      	add	sp, #28
    1644:	f85d fb04 	ldr.w	pc, [sp], #4
    1648:	000046a0 	.word	0x000046a0
    164c:	00000291 	.word	0x00000291

00001650 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
    1650:	b500      	push	{lr}
    1652:	b089      	sub	sp, #36	; 0x24
    1654:	9005      	str	r0, [sp, #20]
    1656:	9104      	str	r1, [sp, #16]
    1658:	9203      	str	r2, [sp, #12]
    165a:	9302      	str	r3, [sp, #8]
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
    165c:	9b05      	ldr	r3, [sp, #20]
    165e:	3360      	adds	r3, #96	; 0x60
    1660:	9805      	ldr	r0, [sp, #20]
    1662:	4619      	mov	r1, r3
    1664:	22ff      	movs	r2, #255	; 0xff
    1666:	f7ff ffa3 	bl	15b0 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
    166a:	9b05      	ldr	r3, [sp, #20]
    166c:	f103 0260 	add.w	r2, r3, #96	; 0x60
    1670:	9905      	ldr	r1, [sp, #20]
    1672:	9b04      	ldr	r3, [sp, #16]
    1674:	440b      	add	r3, r1
    1676:	4610      	mov	r0, r2
    1678:	4619      	mov	r1, r3
    167a:	2255      	movs	r2, #85	; 0x55
    167c:	f7ff ff98 	bl	15b0 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
    1680:	f7ff fede 	bl	1440 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
    1684:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1686:	9300      	str	r3, [sp, #0]
    1688:	9805      	ldr	r0, [sp, #20]
    168a:	9904      	ldr	r1, [sp, #16]
    168c:	9a03      	ldr	r2, [sp, #12]
    168e:	9b02      	ldr	r3, [sp, #8]
    1690:	f7ff ffa6 	bl	15e0 <chThdCreateI>
    1694:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
    1696:	9807      	ldr	r0, [sp, #28]
    1698:	2100      	movs	r1, #0
    169a:	f7ff fd69 	bl	1170 <chSchWakeupS>
  chSysUnlock();
    169e:	f7ff fed7 	bl	1450 <chSysUnlock>

  return tp;
    16a2:	9b07      	ldr	r3, [sp, #28]
}
    16a4:	4618      	mov	r0, r3
    16a6:	b009      	add	sp, #36	; 0x24
    16a8:	f85d fb04 	ldr.w	pc, [sp], #4
    16ac:	f3af 8000 	nop.w

000016b0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
    16b0:	b500      	push	{lr}
    16b2:	b085      	sub	sp, #20
    16b4:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
    16b6:	9b01      	ldr	r3, [sp, #4]
    16b8:	2b7f      	cmp	r3, #127	; 0x7f
    16ba:	d902      	bls.n	16c2 <chThdSetPriority+0x12>
    16bc:	4813      	ldr	r0, [pc, #76]	; (170c <chThdSetPriority+0x5c>)
    16be:	f7ff f8cf 	bl	860 <chSysHalt>

  chSysLock();
    16c2:	f7ff febd 	bl	1440 <chSysLock>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
    16c6:	4b12      	ldr	r3, [pc, #72]	; (1710 <chThdSetPriority+0x60>)
    16c8:	699b      	ldr	r3, [r3, #24]
    16ca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    16cc:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
    16ce:	4b10      	ldr	r3, [pc, #64]	; (1710 <chThdSetPriority+0x60>)
    16d0:	699b      	ldr	r3, [r3, #24]
    16d2:	689a      	ldr	r2, [r3, #8]
    16d4:	4b0e      	ldr	r3, [pc, #56]	; (1710 <chThdSetPriority+0x60>)
    16d6:	699b      	ldr	r3, [r3, #24]
    16d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    16da:	429a      	cmp	r2, r3
    16dc:	d005      	beq.n	16ea <chThdSetPriority+0x3a>
    16de:	4b0c      	ldr	r3, [pc, #48]	; (1710 <chThdSetPriority+0x60>)
    16e0:	699b      	ldr	r3, [r3, #24]
    16e2:	689a      	ldr	r2, [r3, #8]
    16e4:	9b01      	ldr	r3, [sp, #4]
    16e6:	429a      	cmp	r2, r3
    16e8:	d203      	bcs.n	16f2 <chThdSetPriority+0x42>
    currp->p_prio = newprio;
    16ea:	4b09      	ldr	r3, [pc, #36]	; (1710 <chThdSetPriority+0x60>)
    16ec:	699b      	ldr	r3, [r3, #24]
    16ee:	9a01      	ldr	r2, [sp, #4]
    16f0:	609a      	str	r2, [r3, #8]
  }
  currp->p_realprio = newprio;
    16f2:	4b07      	ldr	r3, [pc, #28]	; (1710 <chThdSetPriority+0x60>)
    16f4:	699b      	ldr	r3, [r3, #24]
    16f6:	9a01      	ldr	r2, [sp, #4]
    16f8:	641a      	str	r2, [r3, #64]	; 0x40
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
    16fa:	f7ff fd81 	bl	1200 <chSchRescheduleS>
  chSysUnlock();
    16fe:	f7ff fea7 	bl	1450 <chSysUnlock>

  return oldprio;
    1702:	9b03      	ldr	r3, [sp, #12]
}
    1704:	4618      	mov	r0, r3
    1706:	b005      	add	sp, #20
    1708:	f85d fb04 	ldr.w	pc, [sp], #4
    170c:	000046c0 	.word	0x000046c0
    1710:	20000ac0 	.word	0x20000ac0
    1714:	f3af 8000 	nop.w
    1718:	f3af 8000 	nop.w
    171c:	f3af 8000 	nop.w

00001720 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
    1720:	b500      	push	{lr}
    1722:	b083      	sub	sp, #12
    1724:	9001      	str	r0, [sp, #4]

  chSysLock();
    1726:	f7ff fe8b 	bl	1440 <chSysLock>
  chThdSleepS(time);
    172a:	9801      	ldr	r0, [sp, #4]
    172c:	f7ff feb0 	bl	1490 <chThdSleepS>
  chSysUnlock();
    1730:	f7ff fe8e 	bl	1450 <chSysUnlock>
}
    1734:	b003      	add	sp, #12
    1736:	f85d fb04 	ldr.w	pc, [sp], #4
    173a:	bf00      	nop
    173c:	f3af 8000 	nop.w

00001740 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
    1740:	b500      	push	{lr}
    1742:	b083      	sub	sp, #12
    1744:	9001      	str	r0, [sp, #4]

  chSysLock();
    1746:	f7ff fe7b 	bl	1440 <chSysLock>
  chThdExitS(msg);
    174a:	9801      	ldr	r0, [sp, #4]
    174c:	f000 f808 	bl	1760 <chThdExitS>
  /* The thread never returns here.*/
}
    1750:	b003      	add	sp, #12
    1752:	f85d fb04 	ldr.w	pc, [sp], #4
    1756:	bf00      	nop
    1758:	f3af 8000 	nop.w
    175c:	f3af 8000 	nop.w

00001760 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
    1760:	b500      	push	{lr}
    1762:	b085      	sub	sp, #20
    1764:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
    1766:	4b19      	ldr	r3, [pc, #100]	; (17cc <chThdExitS+0x6c>)
    1768:	699b      	ldr	r3, [r3, #24]
    176a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
    176c:	9b03      	ldr	r3, [sp, #12]
    176e:	9a01      	ldr	r2, [sp, #4]
    1770:	625a      	str	r2, [r3, #36]	; 0x24
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    1772:	e008      	b.n	1786 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->p_waiting));
    1774:	9b03      	ldr	r3, [sp, #12]
    1776:	3328      	adds	r3, #40	; 0x28
    1778:	4618      	mov	r0, r3
    177a:	f7ff fe21 	bl	13c0 <list_remove>
    177e:	4603      	mov	r3, r0
    1780:	4618      	mov	r0, r3
    1782:	f7ff fbfd 	bl	f80 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    1786:	9b03      	ldr	r3, [sp, #12]
    1788:	3328      	adds	r3, #40	; 0x28
    178a:	4618      	mov	r0, r3
    178c:	f7ff fdd8 	bl	1340 <list_notempty>
    1790:	4603      	mov	r3, r0
    1792:	2b00      	cmp	r3, #0
    1794:	d1ee      	bne.n	1774 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    1796:	9b03      	ldr	r3, [sp, #12]
    1798:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    179c:	f003 0303 	and.w	r3, r3, #3
    17a0:	2b00      	cmp	r3, #0
    17a2:	d109      	bne.n	17b8 <chThdExitS+0x58>
    REG_REMOVE(tp);
    17a4:	9b03      	ldr	r3, [sp, #12]
    17a6:	695b      	ldr	r3, [r3, #20]
    17a8:	9a03      	ldr	r2, [sp, #12]
    17aa:	6912      	ldr	r2, [r2, #16]
    17ac:	611a      	str	r2, [r3, #16]
    17ae:	9b03      	ldr	r3, [sp, #12]
    17b0:	691b      	ldr	r3, [r3, #16]
    17b2:	9a03      	ldr	r2, [sp, #12]
    17b4:	6952      	ldr	r2, [r2, #20]
    17b6:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
    17b8:	200f      	movs	r0, #15
    17ba:	f7ff fc21 	bl	1000 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
    17be:	4804      	ldr	r0, [pc, #16]	; (17d0 <chThdExitS+0x70>)
    17c0:	f7ff f84e 	bl	860 <chSysHalt>
}
    17c4:	b005      	add	sp, #20
    17c6:	f85d fb04 	ldr.w	pc, [sp], #4
    17ca:	bf00      	nop
    17cc:	20000ac0 	.word	0x20000ac0
    17d0:	000046f0 	.word	0x000046f0
    17d4:	f3af 8000 	nop.w
    17d8:	f3af 8000 	nop.w
    17dc:	f3af 8000 	nop.w

000017e0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
    17e0:	b500      	push	{lr}
    17e2:	b085      	sub	sp, #20
    17e4:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL);
    17e6:	9b01      	ldr	r3, [sp, #4]
    17e8:	2b00      	cmp	r3, #0
    17ea:	d102      	bne.n	17f2 <chThdWait+0x12>
    17ec:	4818      	ldr	r0, [pc, #96]	; (1850 <chThdWait+0x70>)
    17ee:	f7ff f837 	bl	860 <chSysHalt>

  chSysLock();
    17f2:	f7ff fe25 	bl	1440 <chSysLock>
  chDbgAssert(tp != currp, "waiting self");
    17f6:	4b17      	ldr	r3, [pc, #92]	; (1854 <chThdWait+0x74>)
    17f8:	699a      	ldr	r2, [r3, #24]
    17fa:	9b01      	ldr	r3, [sp, #4]
    17fc:	429a      	cmp	r2, r3
    17fe:	d102      	bne.n	1806 <chThdWait+0x26>
    1800:	4813      	ldr	r0, [pc, #76]	; (1850 <chThdWait+0x70>)
    1802:	f7ff f82d 	bl	860 <chSysHalt>
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
    1806:	9b01      	ldr	r3, [sp, #4]
    1808:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    180c:	2b00      	cmp	r3, #0
    180e:	d102      	bne.n	1816 <chThdWait+0x36>
    1810:	480f      	ldr	r0, [pc, #60]	; (1850 <chThdWait+0x70>)
    1812:	f7ff f825 	bl	860 <chSysHalt>
#endif
  if (tp->p_state != CH_STATE_FINAL) {
    1816:	9b01      	ldr	r3, [sp, #4]
    1818:	f893 3020 	ldrb.w	r3, [r3, #32]
    181c:	2b0f      	cmp	r3, #15
    181e:	d00a      	beq.n	1836 <chThdWait+0x56>
    list_insert(currp, &tp->p_waiting);
    1820:	4b0c      	ldr	r3, [pc, #48]	; (1854 <chThdWait+0x74>)
    1822:	699a      	ldr	r2, [r3, #24]
    1824:	9b01      	ldr	r3, [sp, #4]
    1826:	3328      	adds	r3, #40	; 0x28
    1828:	4610      	mov	r0, r2
    182a:	4619      	mov	r1, r3
    182c:	f7ff fdb8 	bl	13a0 <list_insert>
    chSchGoSleepS(CH_STATE_WTEXIT);
    1830:	2009      	movs	r0, #9
    1832:	f7ff fbe5 	bl	1000 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
    1836:	9b01      	ldr	r3, [sp, #4]
    1838:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    183a:	9303      	str	r3, [sp, #12]
  chSysUnlock();
    183c:	f7ff fe08 	bl	1450 <chSysUnlock>

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
    1840:	9801      	ldr	r0, [sp, #4]
    1842:	f000 f9c5 	bl	1bd0 <chThdRelease>
#endif

  return msg;
    1846:	9b03      	ldr	r3, [sp, #12]
}
    1848:	4618      	mov	r0, r3
    184a:	b005      	add	sp, #20
    184c:	f85d fb04 	ldr.w	pc, [sp], #4
    1850:	00004700 	.word	0x00004700
    1854:	20000ac0 	.word	0x20000ac0
    1858:	f3af 8000 	nop.w
    185c:	f3af 8000 	nop.w

00001860 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    1860:	b500      	push	{lr}
    1862:	b085      	sub	sp, #20
    1864:	9001      	str	r0, [sp, #4]
    1866:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
    1868:	9b01      	ldr	r3, [sp, #4]
    186a:	681b      	ldr	r3, [r3, #0]
    186c:	2b00      	cmp	r3, #0
    186e:	d013      	beq.n	1898 <chThdResumeI+0x38>
    thread_t *tp = *trp;
    1870:	9b01      	ldr	r3, [sp, #4]
    1872:	681b      	ldr	r3, [r3, #0]
    1874:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
    1876:	9b03      	ldr	r3, [sp, #12]
    1878:	f893 3020 	ldrb.w	r3, [r3, #32]
    187c:	2b03      	cmp	r3, #3
    187e:	d002      	beq.n	1886 <chThdResumeI+0x26>
    1880:	4807      	ldr	r0, [pc, #28]	; (18a0 <chThdResumeI+0x40>)
    1882:	f7fe ffed 	bl	860 <chSysHalt>
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    1886:	9b01      	ldr	r3, [sp, #4]
    1888:	2200      	movs	r2, #0
    188a:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
    188c:	9b03      	ldr	r3, [sp, #12]
    188e:	9a00      	ldr	r2, [sp, #0]
    1890:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    1892:	9803      	ldr	r0, [sp, #12]
    1894:	f7ff fb74 	bl	f80 <chSchReadyI>
  }
}
    1898:	b005      	add	sp, #20
    189a:	f85d fb04 	ldr.w	pc, [sp], #4
    189e:	bf00      	nop
    18a0:	00004710 	.word	0x00004710
    18a4:	f3af 8000 	nop.w
    18a8:	f3af 8000 	nop.w
    18ac:	f3af 8000 	nop.w

000018b0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
    18b0:	b500      	push	{lr}
    18b2:	b083      	sub	sp, #12
    18b4:	9001      	str	r0, [sp, #4]
    18b6:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
    18b8:	9b00      	ldr	r3, [sp, #0]
    18ba:	2b00      	cmp	r3, #0
    18bc:	d102      	bne.n	18c4 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
    18be:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    18c2:	e00a      	b.n	18da <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
    18c4:	4b07      	ldr	r3, [pc, #28]	; (18e4 <chThdEnqueueTimeoutS+0x34>)
    18c6:	699b      	ldr	r3, [r3, #24]
    18c8:	4618      	mov	r0, r3
    18ca:	9901      	ldr	r1, [sp, #4]
    18cc:	f7ff fd88 	bl	13e0 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    18d0:	2004      	movs	r0, #4
    18d2:	9900      	ldr	r1, [sp, #0]
    18d4:	f7ff fc14 	bl	1100 <chSchGoSleepTimeoutS>
    18d8:	4603      	mov	r3, r0
}
    18da:	4618      	mov	r0, r3
    18dc:	b003      	add	sp, #12
    18de:	f85d fb04 	ldr.w	pc, [sp], #4
    18e2:	bf00      	nop
    18e4:	20000ac0 	.word	0x20000ac0
    18e8:	f3af 8000 	nop.w
    18ec:	f3af 8000 	nop.w

000018f0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    18f0:	b500      	push	{lr}
    18f2:	b083      	sub	sp, #12
    18f4:	9001      	str	r0, [sp, #4]
    18f6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
    18f8:	9801      	ldr	r0, [sp, #4]
    18fa:	f7ff fd41 	bl	1380 <queue_notempty>
    18fe:	4603      	mov	r3, r0
    1900:	2b00      	cmp	r3, #0
    1902:	d003      	beq.n	190c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
    1904:	9801      	ldr	r0, [sp, #4]
    1906:	9900      	ldr	r1, [sp, #0]
    1908:	f7ff fdda 	bl	14c0 <chThdDoDequeueNextI>
  }
}
    190c:	b003      	add	sp, #12
    190e:	f85d fb04 	ldr.w	pc, [sp], #4
    1912:	bf00      	nop
    1914:	f3af 8000 	nop.w
    1918:	f3af 8000 	nop.w
    191c:	f3af 8000 	nop.w

00001920 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
    1920:	4b01      	ldr	r3, [pc, #4]	; (1928 <port_rt_get_counter_value+0x8>)
    1922:	685b      	ldr	r3, [r3, #4]
}
    1924:	4618      	mov	r0, r3
    1926:	4770      	bx	lr
    1928:	e0001000 	.word	0xe0001000
    192c:	f3af 8000 	nop.w

00001930 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
    1930:	b084      	sub	sp, #16
    1932:	9003      	str	r0, [sp, #12]
    1934:	9102      	str	r1, [sp, #8]
    1936:	9201      	str	r2, [sp, #4]

  tmp->n++;
    1938:	9b03      	ldr	r3, [sp, #12]
    193a:	68db      	ldr	r3, [r3, #12]
    193c:	1c5a      	adds	r2, r3, #1
    193e:	9b03      	ldr	r3, [sp, #12]
    1940:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
    1942:	9b03      	ldr	r3, [sp, #12]
    1944:	689b      	ldr	r3, [r3, #8]
    1946:	9a02      	ldr	r2, [sp, #8]
    1948:	1ad2      	subs	r2, r2, r3
    194a:	9b01      	ldr	r3, [sp, #4]
    194c:	1ad2      	subs	r2, r2, r3
    194e:	9b03      	ldr	r3, [sp, #12]
    1950:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
    1952:	9b03      	ldr	r3, [sp, #12]
    1954:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
    1958:	9b03      	ldr	r3, [sp, #12]
    195a:	689b      	ldr	r3, [r3, #8]
    195c:	461a      	mov	r2, r3
    195e:	f04f 0300 	mov.w	r3, #0
    1962:	1812      	adds	r2, r2, r0
    1964:	eb43 0301 	adc.w	r3, r3, r1
    1968:	9903      	ldr	r1, [sp, #12]
    196a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
    196e:	9b03      	ldr	r3, [sp, #12]
    1970:	689a      	ldr	r2, [r3, #8]
    1972:	9b03      	ldr	r3, [sp, #12]
    1974:	685b      	ldr	r3, [r3, #4]
    1976:	429a      	cmp	r2, r3
    1978:	d904      	bls.n	1984 <tm_stop+0x54>
    tmp->worst = tmp->last;
    197a:	9b03      	ldr	r3, [sp, #12]
    197c:	689a      	ldr	r2, [r3, #8]
    197e:	9b03      	ldr	r3, [sp, #12]
    1980:	605a      	str	r2, [r3, #4]
    1982:	e009      	b.n	1998 <tm_stop+0x68>
  }
  else if (tmp->last < tmp->best) {
    1984:	9b03      	ldr	r3, [sp, #12]
    1986:	689a      	ldr	r2, [r3, #8]
    1988:	9b03      	ldr	r3, [sp, #12]
    198a:	681b      	ldr	r3, [r3, #0]
    198c:	429a      	cmp	r2, r3
    198e:	d203      	bcs.n	1998 <tm_stop+0x68>
    tmp->best = tmp->last;
    1990:	9b03      	ldr	r3, [sp, #12]
    1992:	689a      	ldr	r2, [r3, #8]
    1994:	9b03      	ldr	r3, [sp, #12]
    1996:	601a      	str	r2, [r3, #0]
  }
  /*lint -restore*/
}
    1998:	b004      	add	sp, #16
    199a:	4770      	bx	lr
    199c:	f3af 8000 	nop.w

000019a0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
    19a0:	b500      	push	{lr}
    19a2:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
    19a4:	4b0b      	ldr	r3, [pc, #44]	; (19d4 <_tm_init+0x34>)
    19a6:	2200      	movs	r2, #0
    19a8:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
  chTMObjectInit(&tm);
    19ac:	466b      	mov	r3, sp
    19ae:	4618      	mov	r0, r3
    19b0:	f000 f816 	bl	19e0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
    19b4:	466b      	mov	r3, sp
    19b6:	4618      	mov	r0, r3
    19b8:	f000 f82a 	bl	1a10 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
    19bc:	466b      	mov	r3, sp
    19be:	4618      	mov	r0, r3
    19c0:	f000 f836 	bl	1a30 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
    19c4:	9a02      	ldr	r2, [sp, #8]
    19c6:	4b03      	ldr	r3, [pc, #12]	; (19d4 <_tm_init+0x34>)
    19c8:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
}
    19cc:	b007      	add	sp, #28
    19ce:	f85d fb04 	ldr.w	pc, [sp], #4
    19d2:	bf00      	nop
    19d4:	20000ac0 	.word	0x20000ac0
    19d8:	f3af 8000 	nop.w
    19dc:	f3af 8000 	nop.w

000019e0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
    19e0:	b082      	sub	sp, #8
    19e2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
    19e4:	9b01      	ldr	r3, [sp, #4]
    19e6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    19ea:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
    19ec:	9b01      	ldr	r3, [sp, #4]
    19ee:	2200      	movs	r2, #0
    19f0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
    19f2:	9b01      	ldr	r3, [sp, #4]
    19f4:	2200      	movs	r2, #0
    19f6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
    19f8:	9b01      	ldr	r3, [sp, #4]
    19fa:	2200      	movs	r2, #0
    19fc:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
    19fe:	9901      	ldr	r1, [sp, #4]
    1a00:	f04f 0200 	mov.w	r2, #0
    1a04:	f04f 0300 	mov.w	r3, #0
    1a08:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
    1a0c:	b002      	add	sp, #8
    1a0e:	4770      	bx	lr

00001a10 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
    1a10:	b500      	push	{lr}
    1a12:	b083      	sub	sp, #12
    1a14:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
    1a16:	f7ff ff83 	bl	1920 <port_rt_get_counter_value>
    1a1a:	4602      	mov	r2, r0
    1a1c:	9b01      	ldr	r3, [sp, #4]
    1a1e:	609a      	str	r2, [r3, #8]
}
    1a20:	b003      	add	sp, #12
    1a22:	f85d fb04 	ldr.w	pc, [sp], #4
    1a26:	bf00      	nop
    1a28:	f3af 8000 	nop.w
    1a2c:	f3af 8000 	nop.w

00001a30 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
    1a30:	b500      	push	{lr}
    1a32:	b083      	sub	sp, #12
    1a34:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
    1a36:	f7ff ff73 	bl	1920 <port_rt_get_counter_value>
    1a3a:	4602      	mov	r2, r0
    1a3c:	4b05      	ldr	r3, [pc, #20]	; (1a54 <chTMStopMeasurementX+0x24>)
    1a3e:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
    1a42:	9801      	ldr	r0, [sp, #4]
    1a44:	4611      	mov	r1, r2
    1a46:	461a      	mov	r2, r3
    1a48:	f7ff ff72 	bl	1930 <tm_stop>
}
    1a4c:	b003      	add	sp, #12
    1a4e:	f85d fb04 	ldr.w	pc, [sp], #4
    1a52:	bf00      	nop
    1a54:	20000ac0 	.word	0x20000ac0
    1a58:	f3af 8000 	nop.w
    1a5c:	f3af 8000 	nop.w

00001a60 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
    1a60:	b500      	push	{lr}
    1a62:	b083      	sub	sp, #12
    1a64:	9001      	str	r0, [sp, #4]
    1a66:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
    1a68:	f7ff ff5a 	bl	1920 <port_rt_get_counter_value>
    1a6c:	4602      	mov	r2, r0
    1a6e:	9b00      	ldr	r3, [sp, #0]
    1a70:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
    1a72:	9b00      	ldr	r3, [sp, #0]
    1a74:	689b      	ldr	r3, [r3, #8]
    1a76:	9801      	ldr	r0, [sp, #4]
    1a78:	4619      	mov	r1, r3
    1a7a:	2200      	movs	r2, #0
    1a7c:	f7ff ff58 	bl	1930 <tm_stop>
}
    1a80:	b003      	add	sp, #12
    1a82:	f85d fb04 	ldr.w	pc, [sp], #4
    1a86:	bf00      	nop
    1a88:	f3af 8000 	nop.w
    1a8c:	f3af 8000 	nop.w

00001a90 <_stats_init>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
    1a90:	b508      	push	{r3, lr}

  ch.kernel_stats.n_irq = (ucnt_t)0;
    1a92:	4b07      	ldr	r3, [pc, #28]	; (1ab0 <_stats_init+0x20>)
    1a94:	2200      	movs	r2, #0
    1a96:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
    1a9a:	4b05      	ldr	r3, [pc, #20]	; (1ab0 <_stats_init+0x20>)
    1a9c:	2200      	movs	r2, #0
    1a9e:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
    1aa2:	4804      	ldr	r0, [pc, #16]	; (1ab4 <_stats_init+0x24>)
    1aa4:	f7ff ff9c 	bl	19e0 <chTMObjectInit>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
    1aa8:	4803      	ldr	r0, [pc, #12]	; (1ab8 <_stats_init+0x28>)
    1aaa:	f7ff ff99 	bl	19e0 <chTMObjectInit>
}
    1aae:	bd08      	pop	{r3, pc}
    1ab0:	20000ac0 	.word	0x20000ac0
    1ab4:	20000f70 	.word	0x20000f70
    1ab8:	20000f88 	.word	0x20000f88
    1abc:	f3af 8000 	nop.w

00001ac0 <_stats_increase_irq>:
/**
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {

  ch.kernel_stats.n_irq++;
    1ac0:	4b03      	ldr	r3, [pc, #12]	; (1ad0 <_stats_increase_irq+0x10>)
    1ac2:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
    1ac6:	1c5a      	adds	r2, r3, #1
    1ac8:	4b01      	ldr	r3, [pc, #4]	; (1ad0 <_stats_increase_irq+0x10>)
    1aca:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
}
    1ace:	4770      	bx	lr
    1ad0:	20000ac0 	.word	0x20000ac0
    1ad4:	f3af 8000 	nop.w
    1ad8:	f3af 8000 	nop.w
    1adc:	f3af 8000 	nop.w

00001ae0 <_stats_ctxswc>:
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
    1ae0:	b500      	push	{lr}
    1ae2:	b083      	sub	sp, #12
    1ae4:	9001      	str	r0, [sp, #4]
    1ae6:	9100      	str	r1, [sp, #0]

  ch.kernel_stats.n_ctxswc++;
    1ae8:	4b09      	ldr	r3, [pc, #36]	; (1b10 <_stats_ctxswc+0x30>)
    1aea:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
    1aee:	1c5a      	adds	r2, r3, #1
    1af0:	4b07      	ldr	r3, [pc, #28]	; (1b10 <_stats_ctxswc+0x30>)
    1af2:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
    1af6:	9b00      	ldr	r3, [sp, #0]
    1af8:	f103 0248 	add.w	r2, r3, #72	; 0x48
    1afc:	9b01      	ldr	r3, [sp, #4]
    1afe:	3348      	adds	r3, #72	; 0x48
    1b00:	4610      	mov	r0, r2
    1b02:	4619      	mov	r1, r3
    1b04:	f7ff ffac 	bl	1a60 <chTMChainMeasurementToX>
}
    1b08:	b003      	add	sp, #12
    1b0a:	f85d fb04 	ldr.w	pc, [sp], #4
    1b0e:	bf00      	nop
    1b10:	20000ac0 	.word	0x20000ac0
    1b14:	f3af 8000 	nop.w
    1b18:	f3af 8000 	nop.w
    1b1c:	f3af 8000 	nop.w

00001b20 <_stats_start_measure_crit_thd>:

/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {
    1b20:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
    1b22:	4802      	ldr	r0, [pc, #8]	; (1b2c <_stats_start_measure_crit_thd+0xc>)
    1b24:	f7ff ff74 	bl	1a10 <chTMStartMeasurementX>
}
    1b28:	bd08      	pop	{r3, pc}
    1b2a:	bf00      	nop
    1b2c:	20000f70 	.word	0x20000f70

00001b30 <_stats_stop_measure_crit_thd>:

/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {
    1b30:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
    1b32:	4802      	ldr	r0, [pc, #8]	; (1b3c <_stats_stop_measure_crit_thd+0xc>)
    1b34:	f7ff ff7c 	bl	1a30 <chTMStopMeasurementX>
}
    1b38:	bd08      	pop	{r3, pc}
    1b3a:	bf00      	nop
    1b3c:	20000f70 	.word	0x20000f70

00001b40 <_stats_start_measure_crit_isr>:

/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {
    1b40:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
    1b42:	4802      	ldr	r0, [pc, #8]	; (1b4c <_stats_start_measure_crit_isr+0xc>)
    1b44:	f7ff ff64 	bl	1a10 <chTMStartMeasurementX>
}
    1b48:	bd08      	pop	{r3, pc}
    1b4a:	bf00      	nop
    1b4c:	20000f88 	.word	0x20000f88

00001b50 <_stats_stop_measure_crit_isr>:

/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {
    1b50:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
    1b52:	4802      	ldr	r0, [pc, #8]	; (1b5c <_stats_stop_measure_crit_isr+0xc>)
    1b54:	f7ff ff6c 	bl	1a30 <chTMStopMeasurementX>
}
    1b58:	bd08      	pop	{r3, pc}
    1b5a:	bf00      	nop
    1b5c:	20000f88 	.word	0x20000f88

00001b60 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1b60:	b082      	sub	sp, #8
    1b62:	2320      	movs	r3, #32
    1b64:	9301      	str	r3, [sp, #4]
    1b66:	9b01      	ldr	r3, [sp, #4]
    1b68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1b6c:	b002      	add	sp, #8
    1b6e:	4770      	bx	lr

00001b70 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1b70:	b082      	sub	sp, #8
    1b72:	2300      	movs	r3, #0
    1b74:	9301      	str	r3, [sp, #4]
    1b76:	9b01      	ldr	r3, [sp, #4]
    1b78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1b7c:	b002      	add	sp, #8
    1b7e:	4770      	bx	lr

00001b80 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1b80:	b508      	push	{r3, lr}

  port_lock();
    1b82:	f7ff ffed 	bl	1b60 <port_lock>
  _stats_start_measure_crit_thd();
    1b86:	f7ff ffcb 	bl	1b20 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1b8a:	f7fe fed1 	bl	930 <_dbg_check_lock>
}
    1b8e:	bd08      	pop	{r3, pc}

00001b90 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1b90:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1b92:	f7fe fee5 	bl	960 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1b96:	f7ff ffcb 	bl	1b30 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    1b9a:	4b09      	ldr	r3, [pc, #36]	; (1bc0 <chSysUnlock+0x30>)
    1b9c:	681a      	ldr	r2, [r3, #0]
    1b9e:	4b08      	ldr	r3, [pc, #32]	; (1bc0 <chSysUnlock+0x30>)
    1ba0:	429a      	cmp	r2, r3
    1ba2:	d00a      	beq.n	1bba <chSysUnlock+0x2a>
    1ba4:	4b06      	ldr	r3, [pc, #24]	; (1bc0 <chSysUnlock+0x30>)
    1ba6:	699b      	ldr	r3, [r3, #24]
    1ba8:	689a      	ldr	r2, [r3, #8]
    1baa:	4b05      	ldr	r3, [pc, #20]	; (1bc0 <chSysUnlock+0x30>)
    1bac:	681b      	ldr	r3, [r3, #0]
    1bae:	689b      	ldr	r3, [r3, #8]
    1bb0:	429a      	cmp	r2, r3
    1bb2:	d202      	bcs.n	1bba <chSysUnlock+0x2a>
    1bb4:	4803      	ldr	r0, [pc, #12]	; (1bc4 <chSysUnlock+0x34>)
    1bb6:	f7fe fe53 	bl	860 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    1bba:	f7ff ffd9 	bl	1b70 <port_unlock>
}
    1bbe:	bd08      	pop	{r3, pc}
    1bc0:	20000ac0 	.word	0x20000ac0
    1bc4:	00004740 	.word	0x00004740
    1bc8:	f3af 8000 	nop.w
    1bcc:	f3af 8000 	nop.w

00001bd0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
    1bd0:	b500      	push	{lr}
    1bd2:	b085      	sub	sp, #20
    1bd4:	9001      	str	r0, [sp, #4]
  trefs_t refs;

  chSysLock();
    1bd6:	f7ff ffd3 	bl	1b80 <chSysLock>
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
    1bda:	9b01      	ldr	r3, [sp, #4]
    1bdc:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    1be0:	2b00      	cmp	r3, #0
    1be2:	d102      	bne.n	1bea <chThdRelease+0x1a>
    1be4:	4823      	ldr	r0, [pc, #140]	; (1c74 <chThdRelease+0xa4>)
    1be6:	f7fe fe3b 	bl	860 <chSysHalt>
  tp->p_refs--;
    1bea:	9b01      	ldr	r3, [sp, #4]
    1bec:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    1bf0:	3b01      	subs	r3, #1
    1bf2:	b2da      	uxtb	r2, r3
    1bf4:	9b01      	ldr	r3, [sp, #4]
    1bf6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  refs = tp->p_refs;
    1bfa:	9b01      	ldr	r3, [sp, #4]
    1bfc:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    1c00:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
    1c04:	f7ff ffc4 	bl	1b90 <chSysUnlock>

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    1c08:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1c0c:	2b00      	cmp	r3, #0
    1c0e:	d12d      	bne.n	1c6c <chThdRelease+0x9c>
    1c10:	9b01      	ldr	r3, [sp, #4]
    1c12:	f893 3020 	ldrb.w	r3, [r3, #32]
    1c16:	2b0f      	cmp	r3, #15
    1c18:	d128      	bne.n	1c6c <chThdRelease+0x9c>
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
    1c1a:	9b01      	ldr	r3, [sp, #4]
    1c1c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    1c20:	f003 0303 	and.w	r3, r3, #3
    1c24:	2b01      	cmp	r3, #1
    1c26:	d002      	beq.n	1c2e <chThdRelease+0x5e>
    1c28:	2b02      	cmp	r3, #2
    1c2a:	d00e      	beq.n	1c4a <chThdRelease+0x7a>
      break;
#endif
    default:
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    1c2c:	e01e      	b.n	1c6c <chThdRelease+0x9c>
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
    1c2e:	9b01      	ldr	r3, [sp, #4]
    1c30:	695b      	ldr	r3, [r3, #20]
    1c32:	9a01      	ldr	r2, [sp, #4]
    1c34:	6912      	ldr	r2, [r2, #16]
    1c36:	611a      	str	r2, [r3, #16]
    1c38:	9b01      	ldr	r3, [sp, #4]
    1c3a:	691b      	ldr	r3, [r3, #16]
    1c3c:	9a01      	ldr	r2, [sp, #4]
    1c3e:	6952      	ldr	r2, [r2, #20]
    1c40:	615a      	str	r2, [r3, #20]
#endif
      chHeapFree(tp);
    1c42:	9801      	ldr	r0, [sp, #4]
    1c44:	f000 ffb4 	bl	2bb0 <chHeapFree>
      break;
    1c48:	e010      	b.n	1c6c <chThdRelease+0x9c>
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
    1c4a:	9b01      	ldr	r3, [sp, #4]
    1c4c:	695b      	ldr	r3, [r3, #20]
    1c4e:	9a01      	ldr	r2, [sp, #4]
    1c50:	6912      	ldr	r2, [r2, #16]
    1c52:	611a      	str	r2, [r3, #16]
    1c54:	9b01      	ldr	r3, [sp, #4]
    1c56:	691b      	ldr	r3, [r3, #16]
    1c58:	9a01      	ldr	r2, [sp, #4]
    1c5a:	6952      	ldr	r2, [r2, #20]
    1c5c:	615a      	str	r2, [r3, #20]
#endif
      chPoolFree(tp->p_mpool, tp);
    1c5e:	9b01      	ldr	r3, [sp, #4]
    1c60:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    1c62:	4618      	mov	r0, r3
    1c64:	9901      	ldr	r1, [sp, #4]
    1c66:	f001 f87b 	bl	2d60 <chPoolFree>
      break;
    1c6a:	bf00      	nop
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
}
    1c6c:	b005      	add	sp, #20
    1c6e:	f85d fb04 	ldr.w	pc, [sp], #4
    1c72:	bf00      	nop
    1c74:	00004750 	.word	0x00004750
    1c78:	f3af 8000 	nop.w
    1c7c:	f3af 8000 	nop.w

00001c80 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1c80:	b082      	sub	sp, #8
    1c82:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1c84:	9b01      	ldr	r3, [sp, #4]
    1c86:	9a01      	ldr	r2, [sp, #4]
    1c88:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    1c8a:	9b01      	ldr	r3, [sp, #4]
    1c8c:	9a01      	ldr	r2, [sp, #4]
    1c8e:	605a      	str	r2, [r3, #4]
}
    1c90:	b002      	add	sp, #8
    1c92:	4770      	bx	lr
    1c94:	f3af 8000 	nop.w
    1c98:	f3af 8000 	nop.w
    1c9c:	f3af 8000 	nop.w

00001ca0 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
    1ca0:	b082      	sub	sp, #8
    1ca2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
    1ca4:	9b01      	ldr	r3, [sp, #4]
    1ca6:	681a      	ldr	r2, [r3, #0]
    1ca8:	9b01      	ldr	r3, [sp, #4]
    1caa:	429a      	cmp	r2, r3
    1cac:	bf14      	ite	ne
    1cae:	2300      	movne	r3, #0
    1cb0:	2301      	moveq	r3, #1
    1cb2:	b2db      	uxtb	r3, r3
}
    1cb4:	4618      	mov	r0, r3
    1cb6:	b002      	add	sp, #8
    1cb8:	4770      	bx	lr
    1cba:	bf00      	nop
    1cbc:	f3af 8000 	nop.w

00001cc0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
    1cc0:	b082      	sub	sp, #8
    1cc2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
    1cc4:	9b01      	ldr	r3, [sp, #4]
    1cc6:	681a      	ldr	r2, [r3, #0]
    1cc8:	9b01      	ldr	r3, [sp, #4]
    1cca:	429a      	cmp	r2, r3
    1ccc:	bf0c      	ite	eq
    1cce:	2300      	moveq	r3, #0
    1cd0:	2301      	movne	r3, #1
    1cd2:	b2db      	uxtb	r3, r3
}
    1cd4:	4618      	mov	r0, r3
    1cd6:	b002      	add	sp, #8
    1cd8:	4770      	bx	lr
    1cda:	bf00      	nop
    1cdc:	f3af 8000 	nop.w

00001ce0 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
    1ce0:	b082      	sub	sp, #8
    1ce2:	9001      	str	r0, [sp, #4]
    1ce4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
    1ce6:	9b01      	ldr	r3, [sp, #4]
    1ce8:	9a00      	ldr	r2, [sp, #0]
    1cea:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
    1cec:	9b00      	ldr	r3, [sp, #0]
    1cee:	685a      	ldr	r2, [r3, #4]
    1cf0:	9b01      	ldr	r3, [sp, #4]
    1cf2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    1cf4:	9b01      	ldr	r3, [sp, #4]
    1cf6:	685b      	ldr	r3, [r3, #4]
    1cf8:	9a01      	ldr	r2, [sp, #4]
    1cfa:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
    1cfc:	9b00      	ldr	r3, [sp, #0]
    1cfe:	9a01      	ldr	r2, [sp, #4]
    1d00:	605a      	str	r2, [r3, #4]
}
    1d02:	b002      	add	sp, #8
    1d04:	4770      	bx	lr
    1d06:	bf00      	nop
    1d08:	f3af 8000 	nop.w
    1d0c:	f3af 8000 	nop.w

00001d10 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
    1d10:	b084      	sub	sp, #16
    1d12:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
    1d14:	9b01      	ldr	r3, [sp, #4]
    1d16:	681b      	ldr	r3, [r3, #0]
    1d18:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
    1d1a:	9b03      	ldr	r3, [sp, #12]
    1d1c:	681a      	ldr	r2, [r3, #0]
    1d1e:	9b01      	ldr	r3, [sp, #4]
    1d20:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1d22:	9b01      	ldr	r3, [sp, #4]
    1d24:	681b      	ldr	r3, [r3, #0]
    1d26:	9a01      	ldr	r2, [sp, #4]
    1d28:	605a      	str	r2, [r3, #4]

  return tp;
    1d2a:	9b03      	ldr	r3, [sp, #12]
}
    1d2c:	4618      	mov	r0, r3
    1d2e:	b004      	add	sp, #16
    1d30:	4770      	bx	lr
    1d32:	bf00      	nop
    1d34:	f3af 8000 	nop.w
    1d38:	f3af 8000 	nop.w
    1d3c:	f3af 8000 	nop.w

00001d40 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
    1d40:	b500      	push	{lr}
    1d42:	b083      	sub	sp, #12
    1d44:	9001      	str	r0, [sp, #4]
    1d46:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
    1d48:	9b01      	ldr	r3, [sp, #4]
    1d4a:	2b00      	cmp	r3, #0
    1d4c:	d002      	beq.n	1d54 <chSemObjectInit+0x14>
    1d4e:	9b00      	ldr	r3, [sp, #0]
    1d50:	2b00      	cmp	r3, #0
    1d52:	da02      	bge.n	1d5a <chSemObjectInit+0x1a>
    1d54:	4806      	ldr	r0, [pc, #24]	; (1d70 <chSemObjectInit+0x30>)
    1d56:	f7fe fd83 	bl	860 <chSysHalt>

  queue_init(&sp->s_queue);
    1d5a:	9b01      	ldr	r3, [sp, #4]
    1d5c:	4618      	mov	r0, r3
    1d5e:	f7ff ff8f 	bl	1c80 <queue_init>
  sp->s_cnt = n;
    1d62:	9b01      	ldr	r3, [sp, #4]
    1d64:	9a00      	ldr	r2, [sp, #0]
    1d66:	609a      	str	r2, [r3, #8]
}
    1d68:	b003      	add	sp, #12
    1d6a:	f85d fb04 	ldr.w	pc, [sp], #4
    1d6e:	bf00      	nop
    1d70:	00004780 	.word	0x00004780
    1d74:	f3af 8000 	nop.w
    1d78:	f3af 8000 	nop.w
    1d7c:	f3af 8000 	nop.w

00001d80 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
    1d80:	b500      	push	{lr}
    1d82:	b083      	sub	sp, #12
    1d84:	9001      	str	r0, [sp, #4]
    1d86:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
    1d88:	f7fe fe8a 	bl	aa0 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
    1d8c:	9b01      	ldr	r3, [sp, #4]
    1d8e:	2b00      	cmp	r3, #0
    1d90:	d102      	bne.n	1d98 <chSemWaitTimeoutS+0x18>
    1d92:	4826      	ldr	r0, [pc, #152]	; (1e2c <chSemWaitTimeoutS+0xac>)
    1d94:	f7fe fd64 	bl	860 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
    1d98:	9b01      	ldr	r3, [sp, #4]
    1d9a:	689b      	ldr	r3, [r3, #8]
    1d9c:	2b00      	cmp	r3, #0
    1d9e:	db09      	blt.n	1db4 <chSemWaitTimeoutS+0x34>
    1da0:	9b01      	ldr	r3, [sp, #4]
    1da2:	4618      	mov	r0, r3
    1da4:	f7ff ff7c 	bl	1ca0 <queue_isempty>
    1da8:	4603      	mov	r3, r0
    1daa:	f083 0301 	eor.w	r3, r3, #1
    1dae:	b2db      	uxtb	r3, r3
    1db0:	2b00      	cmp	r3, #0
    1db2:	d010      	beq.n	1dd6 <chSemWaitTimeoutS+0x56>
    1db4:	9b01      	ldr	r3, [sp, #4]
    1db6:	689b      	ldr	r3, [r3, #8]
    1db8:	2b00      	cmp	r3, #0
    1dba:	da09      	bge.n	1dd0 <chSemWaitTimeoutS+0x50>
    1dbc:	9b01      	ldr	r3, [sp, #4]
    1dbe:	4618      	mov	r0, r3
    1dc0:	f7ff ff7e 	bl	1cc0 <queue_notempty>
    1dc4:	4603      	mov	r3, r0
    1dc6:	f083 0301 	eor.w	r3, r3, #1
    1dca:	b2db      	uxtb	r3, r3
    1dcc:	2b00      	cmp	r3, #0
    1dce:	d002      	beq.n	1dd6 <chSemWaitTimeoutS+0x56>
    1dd0:	4816      	ldr	r0, [pc, #88]	; (1e2c <chSemWaitTimeoutS+0xac>)
    1dd2:	f7fe fd45 	bl	860 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    1dd6:	9b01      	ldr	r3, [sp, #4]
    1dd8:	689b      	ldr	r3, [r3, #8]
    1dda:	1e5a      	subs	r2, r3, #1
    1ddc:	9b01      	ldr	r3, [sp, #4]
    1dde:	609a      	str	r2, [r3, #8]
    1de0:	9b01      	ldr	r3, [sp, #4]
    1de2:	689b      	ldr	r3, [r3, #8]
    1de4:	2b00      	cmp	r3, #0
    1de6:	da1b      	bge.n	1e20 <chSemWaitTimeoutS+0xa0>
    if (TIME_IMMEDIATE == time) {
    1de8:	9b00      	ldr	r3, [sp, #0]
    1dea:	2b00      	cmp	r3, #0
    1dec:	d107      	bne.n	1dfe <chSemWaitTimeoutS+0x7e>
      sp->s_cnt++;
    1dee:	9b01      	ldr	r3, [sp, #4]
    1df0:	689b      	ldr	r3, [r3, #8]
    1df2:	1c5a      	adds	r2, r3, #1
    1df4:	9b01      	ldr	r3, [sp, #4]
    1df6:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
    1df8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1dfc:	e011      	b.n	1e22 <chSemWaitTimeoutS+0xa2>
    }
    currp->p_u.wtsemp = sp;
    1dfe:	4b0c      	ldr	r3, [pc, #48]	; (1e30 <chSemWaitTimeoutS+0xb0>)
    1e00:	699b      	ldr	r3, [r3, #24]
    1e02:	9a01      	ldr	r2, [sp, #4]
    1e04:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->s_queue);
    1e06:	4b0a      	ldr	r3, [pc, #40]	; (1e30 <chSemWaitTimeoutS+0xb0>)
    1e08:	699a      	ldr	r2, [r3, #24]
    1e0a:	9b01      	ldr	r3, [sp, #4]
    1e0c:	4610      	mov	r0, r2
    1e0e:	4619      	mov	r1, r3
    1e10:	f7ff ff66 	bl	1ce0 <queue_insert>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
    1e14:	2005      	movs	r0, #5
    1e16:	9900      	ldr	r1, [sp, #0]
    1e18:	f7ff f972 	bl	1100 <chSchGoSleepTimeoutS>
    1e1c:	4603      	mov	r3, r0
    1e1e:	e000      	b.n	1e22 <chSemWaitTimeoutS+0xa2>
  }

  return MSG_OK;
    1e20:	2300      	movs	r3, #0
}
    1e22:	4618      	mov	r0, r3
    1e24:	b003      	add	sp, #12
    1e26:	f85d fb04 	ldr.w	pc, [sp], #4
    1e2a:	bf00      	nop
    1e2c:	00004790 	.word	0x00004790
    1e30:	20000ac0 	.word	0x20000ac0
    1e34:	f3af 8000 	nop.w
    1e38:	f3af 8000 	nop.w
    1e3c:	f3af 8000 	nop.w

00001e40 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    1e40:	b500      	push	{lr}
    1e42:	b085      	sub	sp, #20
    1e44:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1e46:	f7fe fe13 	bl	a70 <chDbgCheckClassI>
  chDbgCheck(sp != NULL);
    1e4a:	9b01      	ldr	r3, [sp, #4]
    1e4c:	2b00      	cmp	r3, #0
    1e4e:	d102      	bne.n	1e56 <chSemSignalI+0x16>
    1e50:	481c      	ldr	r0, [pc, #112]	; (1ec4 <chSemSignalI+0x84>)
    1e52:	f7fe fd05 	bl	860 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
    1e56:	9b01      	ldr	r3, [sp, #4]
    1e58:	689b      	ldr	r3, [r3, #8]
    1e5a:	2b00      	cmp	r3, #0
    1e5c:	db09      	blt.n	1e72 <chSemSignalI+0x32>
    1e5e:	9b01      	ldr	r3, [sp, #4]
    1e60:	4618      	mov	r0, r3
    1e62:	f7ff ff1d 	bl	1ca0 <queue_isempty>
    1e66:	4603      	mov	r3, r0
    1e68:	f083 0301 	eor.w	r3, r3, #1
    1e6c:	b2db      	uxtb	r3, r3
    1e6e:	2b00      	cmp	r3, #0
    1e70:	d010      	beq.n	1e94 <chSemSignalI+0x54>
    1e72:	9b01      	ldr	r3, [sp, #4]
    1e74:	689b      	ldr	r3, [r3, #8]
    1e76:	2b00      	cmp	r3, #0
    1e78:	da09      	bge.n	1e8e <chSemSignalI+0x4e>
    1e7a:	9b01      	ldr	r3, [sp, #4]
    1e7c:	4618      	mov	r0, r3
    1e7e:	f7ff ff1f 	bl	1cc0 <queue_notempty>
    1e82:	4603      	mov	r3, r0
    1e84:	f083 0301 	eor.w	r3, r3, #1
    1e88:	b2db      	uxtb	r3, r3
    1e8a:	2b00      	cmp	r3, #0
    1e8c:	d002      	beq.n	1e94 <chSemSignalI+0x54>
    1e8e:	480d      	ldr	r0, [pc, #52]	; (1ec4 <chSemSignalI+0x84>)
    1e90:	f7fe fce6 	bl	860 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
    1e94:	9b01      	ldr	r3, [sp, #4]
    1e96:	689b      	ldr	r3, [r3, #8]
    1e98:	1c5a      	adds	r2, r3, #1
    1e9a:	9b01      	ldr	r3, [sp, #4]
    1e9c:	609a      	str	r2, [r3, #8]
    1e9e:	9b01      	ldr	r3, [sp, #4]
    1ea0:	689b      	ldr	r3, [r3, #8]
    1ea2:	2b00      	cmp	r3, #0
    1ea4:	dc0a      	bgt.n	1ebc <chSemSignalI+0x7c>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    1ea6:	9b01      	ldr	r3, [sp, #4]
    1ea8:	4618      	mov	r0, r3
    1eaa:	f7ff ff31 	bl	1d10 <queue_fifo_remove>
    1eae:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
    1eb0:	9b03      	ldr	r3, [sp, #12]
    1eb2:	2200      	movs	r2, #0
    1eb4:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    1eb6:	9803      	ldr	r0, [sp, #12]
    1eb8:	f7ff f862 	bl	f80 <chSchReadyI>
  }
}
    1ebc:	b005      	add	sp, #20
    1ebe:	f85d fb04 	ldr.w	pc, [sp], #4
    1ec2:	bf00      	nop
    1ec4:	000047b0 	.word	0x000047b0
    1ec8:	f3af 8000 	nop.w
    1ecc:	f3af 8000 	nop.w

00001ed0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1ed0:	b082      	sub	sp, #8
    1ed2:	2320      	movs	r3, #32
    1ed4:	9301      	str	r3, [sp, #4]
    1ed6:	9b01      	ldr	r3, [sp, #4]
    1ed8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1edc:	b002      	add	sp, #8
    1ede:	4770      	bx	lr

00001ee0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1ee0:	b082      	sub	sp, #8
    1ee2:	2300      	movs	r3, #0
    1ee4:	9301      	str	r3, [sp, #4]
    1ee6:	9b01      	ldr	r3, [sp, #4]
    1ee8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1eec:	b002      	add	sp, #8
    1eee:	4770      	bx	lr

00001ef0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1ef0:	b082      	sub	sp, #8
    1ef2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1ef4:	9b01      	ldr	r3, [sp, #4]
    1ef6:	9a01      	ldr	r2, [sp, #4]
    1ef8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    1efa:	9b01      	ldr	r3, [sp, #4]
    1efc:	9a01      	ldr	r2, [sp, #4]
    1efe:	605a      	str	r2, [r3, #4]
}
    1f00:	b002      	add	sp, #8
    1f02:	4770      	bx	lr
    1f04:	f3af 8000 	nop.w
    1f08:	f3af 8000 	nop.w
    1f0c:	f3af 8000 	nop.w

00001f10 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
    1f10:	b082      	sub	sp, #8
    1f12:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
    1f14:	9b01      	ldr	r3, [sp, #4]
    1f16:	681a      	ldr	r2, [r3, #0]
    1f18:	9b01      	ldr	r3, [sp, #4]
    1f1a:	429a      	cmp	r2, r3
    1f1c:	bf0c      	ite	eq
    1f1e:	2300      	moveq	r3, #0
    1f20:	2301      	movne	r3, #1
    1f22:	b2db      	uxtb	r3, r3
}
    1f24:	4618      	mov	r0, r3
    1f26:	b002      	add	sp, #8
    1f28:	4770      	bx	lr
    1f2a:	bf00      	nop
    1f2c:	f3af 8000 	nop.w

00001f30 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
    1f30:	b084      	sub	sp, #16
    1f32:	9001      	str	r0, [sp, #4]
    1f34:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
    1f36:	9b00      	ldr	r3, [sp, #0]
    1f38:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
    1f3a:	9b03      	ldr	r3, [sp, #12]
    1f3c:	681b      	ldr	r3, [r3, #0]
    1f3e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    1f40:	9a03      	ldr	r2, [sp, #12]
    1f42:	9b00      	ldr	r3, [sp, #0]
    1f44:	429a      	cmp	r2, r3
    1f46:	d005      	beq.n	1f54 <queue_prio_insert+0x24>
    1f48:	9b03      	ldr	r3, [sp, #12]
    1f4a:	689a      	ldr	r2, [r3, #8]
    1f4c:	9b01      	ldr	r3, [sp, #4]
    1f4e:	689b      	ldr	r3, [r3, #8]
    1f50:	429a      	cmp	r2, r3
    1f52:	d2f2      	bcs.n	1f3a <queue_prio_insert+0xa>
  tp->p_next = cp;
    1f54:	9b01      	ldr	r3, [sp, #4]
    1f56:	9a03      	ldr	r2, [sp, #12]
    1f58:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
    1f5a:	9b03      	ldr	r3, [sp, #12]
    1f5c:	685a      	ldr	r2, [r3, #4]
    1f5e:	9b01      	ldr	r3, [sp, #4]
    1f60:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    1f62:	9b01      	ldr	r3, [sp, #4]
    1f64:	685b      	ldr	r3, [r3, #4]
    1f66:	9a01      	ldr	r2, [sp, #4]
    1f68:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
    1f6a:	9b03      	ldr	r3, [sp, #12]
    1f6c:	9a01      	ldr	r2, [sp, #4]
    1f6e:	605a      	str	r2, [r3, #4]
}
    1f70:	b004      	add	sp, #16
    1f72:	4770      	bx	lr
    1f74:	f3af 8000 	nop.w
    1f78:	f3af 8000 	nop.w
    1f7c:	f3af 8000 	nop.w

00001f80 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
    1f80:	b084      	sub	sp, #16
    1f82:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
    1f84:	9b01      	ldr	r3, [sp, #4]
    1f86:	681b      	ldr	r3, [r3, #0]
    1f88:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
    1f8a:	9b03      	ldr	r3, [sp, #12]
    1f8c:	681a      	ldr	r2, [r3, #0]
    1f8e:	9b01      	ldr	r3, [sp, #4]
    1f90:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1f92:	9b01      	ldr	r3, [sp, #4]
    1f94:	681b      	ldr	r3, [r3, #0]
    1f96:	9a01      	ldr	r2, [sp, #4]
    1f98:	605a      	str	r2, [r3, #4]

  return tp;
    1f9a:	9b03      	ldr	r3, [sp, #12]
}
    1f9c:	4618      	mov	r0, r3
    1f9e:	b004      	add	sp, #16
    1fa0:	4770      	bx	lr
    1fa2:	bf00      	nop
    1fa4:	f3af 8000 	nop.w
    1fa8:	f3af 8000 	nop.w
    1fac:	f3af 8000 	nop.w

00001fb0 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
    1fb0:	b082      	sub	sp, #8
    1fb2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
    1fb4:	9b01      	ldr	r3, [sp, #4]
    1fb6:	685b      	ldr	r3, [r3, #4]
    1fb8:	9a01      	ldr	r2, [sp, #4]
    1fba:	6812      	ldr	r2, [r2, #0]
    1fbc:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
    1fbe:	9b01      	ldr	r3, [sp, #4]
    1fc0:	681b      	ldr	r3, [r3, #0]
    1fc2:	9a01      	ldr	r2, [sp, #4]
    1fc4:	6852      	ldr	r2, [r2, #4]
    1fc6:	605a      	str	r2, [r3, #4]

  return tp;
    1fc8:	9b01      	ldr	r3, [sp, #4]
}
    1fca:	4618      	mov	r0, r3
    1fcc:	b002      	add	sp, #8
    1fce:	4770      	bx	lr

00001fd0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1fd0:	b508      	push	{r3, lr}

  port_lock();
    1fd2:	f7ff ff7d 	bl	1ed0 <port_lock>
  _stats_start_measure_crit_thd();
    1fd6:	f7ff fda3 	bl	1b20 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1fda:	f7fe fca9 	bl	930 <_dbg_check_lock>
}
    1fde:	bd08      	pop	{r3, pc}

00001fe0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1fe0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1fe2:	f7fe fcbd 	bl	960 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1fe6:	f7ff fda3 	bl	1b30 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    1fea:	4b09      	ldr	r3, [pc, #36]	; (2010 <chSysUnlock+0x30>)
    1fec:	681a      	ldr	r2, [r3, #0]
    1fee:	4b08      	ldr	r3, [pc, #32]	; (2010 <chSysUnlock+0x30>)
    1ff0:	429a      	cmp	r2, r3
    1ff2:	d00a      	beq.n	200a <chSysUnlock+0x2a>
    1ff4:	4b06      	ldr	r3, [pc, #24]	; (2010 <chSysUnlock+0x30>)
    1ff6:	699b      	ldr	r3, [r3, #24]
    1ff8:	689a      	ldr	r2, [r3, #8]
    1ffa:	4b05      	ldr	r3, [pc, #20]	; (2010 <chSysUnlock+0x30>)
    1ffc:	681b      	ldr	r3, [r3, #0]
    1ffe:	689b      	ldr	r3, [r3, #8]
    2000:	429a      	cmp	r2, r3
    2002:	d202      	bcs.n	200a <chSysUnlock+0x2a>
    2004:	4803      	ldr	r0, [pc, #12]	; (2014 <chSysUnlock+0x34>)
    2006:	f7fe fc2b 	bl	860 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    200a:	f7ff ff69 	bl	1ee0 <port_unlock>
}
    200e:	bd08      	pop	{r3, pc}
    2010:	20000ac0 	.word	0x20000ac0
    2014:	000047d0 	.word	0x000047d0
    2018:	f3af 8000 	nop.w
    201c:	f3af 8000 	nop.w

00002020 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
    2020:	b500      	push	{lr}
    2022:	b083      	sub	sp, #12
    2024:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
    2026:	f7fe fd3b 	bl	aa0 <chDbgCheckClassS>

  return queue_notempty(&mp->m_queue);
    202a:	9b01      	ldr	r3, [sp, #4]
    202c:	4618      	mov	r0, r3
    202e:	f7ff ff6f 	bl	1f10 <queue_notempty>
    2032:	4603      	mov	r3, r0
}
    2034:	4618      	mov	r0, r3
    2036:	b003      	add	sp, #12
    2038:	f85d fb04 	ldr.w	pc, [sp], #4
    203c:	f3af 8000 	nop.w

00002040 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
    2040:	b500      	push	{lr}
    2042:	b083      	sub	sp, #12
    2044:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
    2046:	9b01      	ldr	r3, [sp, #4]
    2048:	2b00      	cmp	r3, #0
    204a:	d102      	bne.n	2052 <chMtxObjectInit+0x12>
    204c:	4806      	ldr	r0, [pc, #24]	; (2068 <chMtxObjectInit+0x28>)
    204e:	f7fe fc07 	bl	860 <chSysHalt>

  queue_init(&mp->m_queue);
    2052:	9b01      	ldr	r3, [sp, #4]
    2054:	4618      	mov	r0, r3
    2056:	f7ff ff4b 	bl	1ef0 <queue_init>
  mp->m_owner = NULL;
    205a:	9b01      	ldr	r3, [sp, #4]
    205c:	2200      	movs	r2, #0
    205e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
    2060:	b003      	add	sp, #12
    2062:	f85d fb04 	ldr.w	pc, [sp], #4
    2066:	bf00      	nop
    2068:	000047c0 	.word	0x000047c0
    206c:	f3af 8000 	nop.w

00002070 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
    2070:	b500      	push	{lr}
    2072:	b083      	sub	sp, #12
    2074:	9001      	str	r0, [sp, #4]

  chSysLock();
    2076:	f7ff ffab 	bl	1fd0 <chSysLock>
  chMtxLockS(mp);
    207a:	9801      	ldr	r0, [sp, #4]
    207c:	f000 f808 	bl	2090 <chMtxLockS>
  chSysUnlock();
    2080:	f7ff ffae 	bl	1fe0 <chSysUnlock>
}
    2084:	b003      	add	sp, #12
    2086:	f85d fb04 	ldr.w	pc, [sp], #4
    208a:	bf00      	nop
    208c:	f3af 8000 	nop.w

00002090 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
    2090:	b500      	push	{lr}
    2092:	b085      	sub	sp, #20
    2094:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
    2096:	4b3c      	ldr	r3, [pc, #240]	; (2188 <chMtxLockS+0xf8>)
    2098:	699b      	ldr	r3, [r3, #24]
    209a:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
    209c:	f7fe fd00 	bl	aa0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
    20a0:	9b01      	ldr	r3, [sp, #4]
    20a2:	2b00      	cmp	r3, #0
    20a4:	d102      	bne.n	20ac <chMtxLockS+0x1c>
    20a6:	4839      	ldr	r0, [pc, #228]	; (218c <chMtxLockS+0xfc>)
    20a8:	f7fe fbda 	bl	860 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
    20ac:	9b01      	ldr	r3, [sp, #4]
    20ae:	689b      	ldr	r3, [r3, #8]
    20b0:	2b00      	cmp	r3, #0
    20b2:	d05b      	beq.n	216c <chMtxLockS+0xdc>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;
    20b4:	9b01      	ldr	r3, [sp, #4]
    20b6:	689b      	ldr	r3, [r3, #8]
    20b8:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
    20ba:	e034      	b.n	2126 <chMtxLockS+0x96>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
    20bc:	9b02      	ldr	r3, [sp, #8]
    20be:	689a      	ldr	r2, [r3, #8]
    20c0:	9b03      	ldr	r3, [sp, #12]
    20c2:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
    20c4:	9b03      	ldr	r3, [sp, #12]
    20c6:	f893 3020 	ldrb.w	r3, [r3, #32]
    20ca:	2b06      	cmp	r3, #6
    20cc:	d004      	beq.n	20d8 <chMtxLockS+0x48>
    20ce:	2b07      	cmp	r3, #7
    20d0:	d011      	beq.n	20f6 <chMtxLockS+0x66>
    20d2:	2b00      	cmp	r3, #0
    20d4:	d01a      	beq.n	210c <chMtxLockS+0x7c>
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
          break;
        default:
          /* Nothing to do for other states.*/
          break;
    20d6:	e025      	b.n	2124 <chMtxLockS+0x94>

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
    20d8:	9803      	ldr	r0, [sp, #12]
    20da:	f7ff ff69 	bl	1fb0 <queue_dequeue>
    20de:	4602      	mov	r2, r0
    20e0:	9b03      	ldr	r3, [sp, #12]
    20e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    20e4:	4610      	mov	r0, r2
    20e6:	4619      	mov	r1, r3
    20e8:	f7ff ff22 	bl	1f30 <queue_prio_insert>
          tp = tp->p_u.wtmtxp->m_owner;
    20ec:	9b03      	ldr	r3, [sp, #12]
    20ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    20f0:	689b      	ldr	r3, [r3, #8]
    20f2:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
    20f4:	e017      	b.n	2126 <chMtxLockS+0x96>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
    20f6:	9803      	ldr	r0, [sp, #12]
    20f8:	f7ff ff5a 	bl	1fb0 <queue_dequeue>
    20fc:	4602      	mov	r2, r0
    20fe:	9b03      	ldr	r3, [sp, #12]
    2100:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2102:	4610      	mov	r0, r2
    2104:	4619      	mov	r1, r3
    2106:	f7ff ff13 	bl	1f30 <queue_prio_insert>
          break;
    210a:	e00b      	b.n	2124 <chMtxLockS+0x94>
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
    210c:	9b03      	ldr	r3, [sp, #12]
    210e:	2201      	movs	r2, #1
    2110:	f883 2020 	strb.w	r2, [r3, #32]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
    2114:	9803      	ldr	r0, [sp, #12]
    2116:	f7ff ff4b 	bl	1fb0 <queue_dequeue>
    211a:	4603      	mov	r3, r0
    211c:	4618      	mov	r0, r3
    211e:	f7fe ff2f 	bl	f80 <chSchReadyI>
          break;
    2122:	bf00      	nop
        default:
          /* Nothing to do for other states.*/
          break;
        }
        break;
    2124:	e005      	b.n	2132 <chMtxLockS+0xa2>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
    2126:	9b03      	ldr	r3, [sp, #12]
    2128:	689a      	ldr	r2, [r3, #8]
    212a:	9b02      	ldr	r3, [sp, #8]
    212c:	689b      	ldr	r3, [r3, #8]
    212e:	429a      	cmp	r2, r3
    2130:	d3c4      	bcc.n	20bc <chMtxLockS+0x2c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
    2132:	9b01      	ldr	r3, [sp, #4]
    2134:	9802      	ldr	r0, [sp, #8]
    2136:	4619      	mov	r1, r3
    2138:	f7ff fefa 	bl	1f30 <queue_prio_insert>
      ctp->p_u.wtmtxp = mp;
    213c:	9b02      	ldr	r3, [sp, #8]
    213e:	9a01      	ldr	r2, [sp, #4]
    2140:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
    2142:	2006      	movs	r0, #6
    2144:	f7fe ff5c 	bl	1000 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->m_owner == ctp, "not owner");
    2148:	9b01      	ldr	r3, [sp, #4]
    214a:	689a      	ldr	r2, [r3, #8]
    214c:	9b02      	ldr	r3, [sp, #8]
    214e:	429a      	cmp	r2, r3
    2150:	d002      	beq.n	2158 <chMtxLockS+0xc8>
    2152:	480e      	ldr	r0, [pc, #56]	; (218c <chMtxLockS+0xfc>)
    2154:	f7fe fb84 	bl	860 <chSysHalt>
      chDbgAssert(ctp->p_mtxlist == mp, "not owned");
    2158:	9b02      	ldr	r3, [sp, #8]
    215a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    215c:	9b01      	ldr	r3, [sp, #4]
    215e:	429a      	cmp	r2, r3
    2160:	d003      	beq.n	216a <chMtxLockS+0xda>
    2162:	480a      	ldr	r0, [pc, #40]	; (218c <chMtxLockS+0xfc>)
    2164:	f7fe fb7c 	bl	860 <chSysHalt>
    2168:	e00a      	b.n	2180 <chMtxLockS+0xf0>
    216a:	e009      	b.n	2180 <chMtxLockS+0xf0>
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    216c:	9b01      	ldr	r3, [sp, #4]
    216e:	9a02      	ldr	r2, [sp, #8]
    2170:	609a      	str	r2, [r3, #8]
    mp->m_next = ctp->p_mtxlist;
    2172:	9b02      	ldr	r3, [sp, #8]
    2174:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    2176:	9b01      	ldr	r3, [sp, #4]
    2178:	60da      	str	r2, [r3, #12]
    ctp->p_mtxlist = mp;
    217a:	9b02      	ldr	r3, [sp, #8]
    217c:	9a01      	ldr	r2, [sp, #4]
    217e:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
    2180:	b005      	add	sp, #20
    2182:	f85d fb04 	ldr.w	pc, [sp], #4
    2186:	bf00      	nop
    2188:	20000ac0 	.word	0x20000ac0
    218c:	000047e0 	.word	0x000047e0

00002190 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
    2190:	b500      	push	{lr}
    2192:	b087      	sub	sp, #28
    2194:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
    2196:	4b35      	ldr	r3, [pc, #212]	; (226c <chMtxUnlock+0xdc>)
    2198:	699b      	ldr	r3, [r3, #24]
    219a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
    219c:	9b01      	ldr	r3, [sp, #4]
    219e:	2b00      	cmp	r3, #0
    21a0:	d102      	bne.n	21a8 <chMtxUnlock+0x18>
    21a2:	4833      	ldr	r0, [pc, #204]	; (2270 <chMtxUnlock+0xe0>)
    21a4:	f7fe fb5c 	bl	860 <chSysHalt>

  chSysLock();
    21a8:	f7ff ff12 	bl	1fd0 <chSysLock>

  chDbgAssert(ctp->p_mtxlist != NULL, "owned mutexes list empty");
    21ac:	9b03      	ldr	r3, [sp, #12]
    21ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    21b0:	2b00      	cmp	r3, #0
    21b2:	d102      	bne.n	21ba <chMtxUnlock+0x2a>
    21b4:	482e      	ldr	r0, [pc, #184]	; (2270 <chMtxUnlock+0xe0>)
    21b6:	f7fe fb53 	bl	860 <chSysHalt>
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp, "ownership failure");
    21ba:	9b03      	ldr	r3, [sp, #12]
    21bc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    21be:	689a      	ldr	r2, [r3, #8]
    21c0:	9b03      	ldr	r3, [sp, #12]
    21c2:	429a      	cmp	r2, r3
    21c4:	d002      	beq.n	21cc <chMtxUnlock+0x3c>
    21c6:	482a      	ldr	r0, [pc, #168]	; (2270 <chMtxUnlock+0xe0>)
    21c8:	f7fe fb4a 	bl	860 <chSysHalt>
  chDbgAssert(mp->m_cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->m_cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");
    21cc:	9b03      	ldr	r3, [sp, #12]
    21ce:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    21d0:	9b01      	ldr	r3, [sp, #4]
    21d2:	429a      	cmp	r2, r3
    21d4:	d002      	beq.n	21dc <chMtxUnlock+0x4c>
    21d6:	4826      	ldr	r0, [pc, #152]	; (2270 <chMtxUnlock+0xe0>)
    21d8:	f7fe fb42 	bl	860 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
    21dc:	9b01      	ldr	r3, [sp, #4]
    21de:	68da      	ldr	r2, [r3, #12]
    21e0:	9b03      	ldr	r3, [sp, #12]
    21e2:	63da      	str	r2, [r3, #60]	; 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    21e4:	9801      	ldr	r0, [sp, #4]
    21e6:	f7ff ff1b 	bl	2020 <chMtxQueueNotEmptyS>
    21ea:	4603      	mov	r3, r0
    21ec:	2b00      	cmp	r3, #0
    21ee:	d034      	beq.n	225a <chMtxUnlock+0xca>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
    21f0:	9b03      	ldr	r3, [sp, #12]
    21f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    21f4:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
    21f6:	9b03      	ldr	r3, [sp, #12]
    21f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    21fa:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
    21fc:	e012      	b.n	2224 <chMtxUnlock+0x94>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    21fe:	9805      	ldr	r0, [sp, #20]
    2200:	f7ff ff0e 	bl	2020 <chMtxQueueNotEmptyS>
    2204:	4603      	mov	r3, r0
    2206:	2b00      	cmp	r3, #0
    2208:	d009      	beq.n	221e <chMtxUnlock+0x8e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
    220a:	9b05      	ldr	r3, [sp, #20]
    220c:	681b      	ldr	r3, [r3, #0]
    220e:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    2210:	9b04      	ldr	r3, [sp, #16]
    2212:	429a      	cmp	r2, r3
    2214:	d903      	bls.n	221e <chMtxUnlock+0x8e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
    2216:	9b05      	ldr	r3, [sp, #20]
    2218:	681b      	ldr	r3, [r3, #0]
    221a:	689b      	ldr	r3, [r3, #8]
    221c:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
    221e:	9b05      	ldr	r3, [sp, #20]
    2220:	68db      	ldr	r3, [r3, #12]
    2222:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
    2224:	9b05      	ldr	r3, [sp, #20]
    2226:	2b00      	cmp	r3, #0
    2228:	d1e9      	bne.n	21fe <chMtxUnlock+0x6e>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
    222a:	9b03      	ldr	r3, [sp, #12]
    222c:	9a04      	ldr	r2, [sp, #16]
    222e:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
    2230:	9b01      	ldr	r3, [sp, #4]
    2232:	4618      	mov	r0, r3
    2234:	f7ff fea4 	bl	1f80 <queue_fifo_remove>
    2238:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
    223a:	9b01      	ldr	r3, [sp, #4]
    223c:	9a02      	ldr	r2, [sp, #8]
    223e:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
    2240:	9b02      	ldr	r3, [sp, #8]
    2242:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    2244:	9b01      	ldr	r3, [sp, #4]
    2246:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
    2248:	9b02      	ldr	r3, [sp, #8]
    224a:	9a01      	ldr	r2, [sp, #4]
    224c:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
    224e:	9802      	ldr	r0, [sp, #8]
    2250:	f7fe fe96 	bl	f80 <chSchReadyI>
      chSchRescheduleS();
    2254:	f7fe ffd4 	bl	1200 <chSchRescheduleS>
    2258:	e002      	b.n	2260 <chMtxUnlock+0xd0>
    }
    else {
      mp->m_owner = NULL;
    225a:	9b01      	ldr	r3, [sp, #4]
    225c:	2200      	movs	r2, #0
    225e:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
    2260:	f7ff febe 	bl	1fe0 <chSysUnlock>
}
    2264:	b007      	add	sp, #28
    2266:	f85d fb04 	ldr.w	pc, [sp], #4
    226a:	bf00      	nop
    226c:	20000ac0 	.word	0x20000ac0
    2270:	000047f0 	.word	0x000047f0
    2274:	f3af 8000 	nop.w
    2278:	f3af 8000 	nop.w
    227c:	f3af 8000 	nop.w

00002280 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    2280:	b500      	push	{lr}
    2282:	b085      	sub	sp, #20
    2284:	9001      	str	r0, [sp, #4]
    2286:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
    2288:	f7fe fbf2 	bl	a70 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
    228c:	9b01      	ldr	r3, [sp, #4]
    228e:	2b00      	cmp	r3, #0
    2290:	d102      	bne.n	2298 <chEvtBroadcastFlagsI+0x18>
    2292:	4814      	ldr	r0, [pc, #80]	; (22e4 <chEvtBroadcastFlagsI+0x64>)
    2294:	f7fe fae4 	bl	860 <chSysHalt>

  elp = esp->es_next;
    2298:	9b01      	ldr	r3, [sp, #4]
    229a:	681b      	ldr	r3, [r3, #0]
    229c:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    229e:	e01a      	b.n	22d6 <chEvtBroadcastFlagsI+0x56>
  /*lint -restore*/
    elp->el_flags |= flags;
    22a0:	9b03      	ldr	r3, [sp, #12]
    22a2:	68da      	ldr	r2, [r3, #12]
    22a4:	9b00      	ldr	r3, [sp, #0]
    22a6:	431a      	orrs	r2, r3
    22a8:	9b03      	ldr	r3, [sp, #12]
    22aa:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    22ac:	9b00      	ldr	r3, [sp, #0]
    22ae:	2b00      	cmp	r3, #0
    22b0:	d006      	beq.n	22c0 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
    22b2:	9b03      	ldr	r3, [sp, #12]
    22b4:	68da      	ldr	r2, [r3, #12]
    22b6:	9b03      	ldr	r3, [sp, #12]
    22b8:	691b      	ldr	r3, [r3, #16]
    22ba:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    22bc:	2b00      	cmp	r3, #0
    22be:	d007      	beq.n	22d0 <chEvtBroadcastFlagsI+0x50>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    22c0:	9b03      	ldr	r3, [sp, #12]
    22c2:	685a      	ldr	r2, [r3, #4]
    22c4:	9b03      	ldr	r3, [sp, #12]
    22c6:	689b      	ldr	r3, [r3, #8]
    22c8:	4610      	mov	r0, r2
    22ca:	4619      	mov	r1, r3
    22cc:	f000 f810 	bl	22f0 <chEvtSignalI>
    }
    elp = elp->el_next;
    22d0:	9b03      	ldr	r3, [sp, #12]
    22d2:	681b      	ldr	r3, [r3, #0]
    22d4:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    22d6:	9a03      	ldr	r2, [sp, #12]
    22d8:	9b01      	ldr	r3, [sp, #4]
    22da:	429a      	cmp	r2, r3
    22dc:	d1e0      	bne.n	22a0 <chEvtBroadcastFlagsI+0x20>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
    22de:	b005      	add	sp, #20
    22e0:	f85d fb04 	ldr.w	pc, [sp], #4
    22e4:	00004800 	.word	0x00004800
    22e8:	f3af 8000 	nop.w
    22ec:	f3af 8000 	nop.w

000022f0 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
    22f0:	b500      	push	{lr}
    22f2:	b083      	sub	sp, #12
    22f4:	9001      	str	r0, [sp, #4]
    22f6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
    22f8:	f7fe fbba 	bl	a70 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
    22fc:	9b01      	ldr	r3, [sp, #4]
    22fe:	2b00      	cmp	r3, #0
    2300:	d102      	bne.n	2308 <chEvtSignalI+0x18>
    2302:	4816      	ldr	r0, [pc, #88]	; (235c <chEvtSignalI+0x6c>)
    2304:	f7fe faac 	bl	860 <chSysHalt>

  tp->p_epending |= events;
    2308:	9b01      	ldr	r3, [sp, #4]
    230a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    230c:	9b00      	ldr	r3, [sp, #0]
    230e:	431a      	orrs	r2, r3
    2310:	9b01      	ldr	r3, [sp, #4]
    2312:	639a      	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    2314:	9b01      	ldr	r3, [sp, #4]
    2316:	f893 3020 	ldrb.w	r3, [r3, #32]
    231a:	2b0a      	cmp	r3, #10
    231c:	d106      	bne.n	232c <chEvtSignalI+0x3c>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    231e:	9b01      	ldr	r3, [sp, #4]
    2320:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    2322:	9b01      	ldr	r3, [sp, #4]
    2324:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2326:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    2328:	2b00      	cmp	r3, #0
    232a:	d10d      	bne.n	2348 <chEvtSignalI+0x58>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
    232c:	9b01      	ldr	r3, [sp, #4]
    232e:	f893 3020 	ldrb.w	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    2332:	2b0b      	cmp	r3, #11
    2334:	d10e      	bne.n	2354 <chEvtSignalI+0x64>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    2336:	9b01      	ldr	r3, [sp, #4]
    2338:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    233a:	9b01      	ldr	r3, [sp, #4]
    233c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    233e:	401a      	ands	r2, r3
    2340:	9b01      	ldr	r3, [sp, #4]
    2342:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
    2344:	429a      	cmp	r2, r3
    2346:	d105      	bne.n	2354 <chEvtSignalI+0x64>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
    2348:	9b01      	ldr	r3, [sp, #4]
    234a:	2200      	movs	r2, #0
    234c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    234e:	9801      	ldr	r0, [sp, #4]
    2350:	f7fe fe16 	bl	f80 <chSchReadyI>
  }
}
    2354:	b003      	add	sp, #12
    2356:	f85d fb04 	ldr.w	pc, [sp], #4
    235a:	bf00      	nop
    235c:	00004820 	.word	0x00004820

00002360 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2360:	b082      	sub	sp, #8
    2362:	2320      	movs	r3, #32
    2364:	9301      	str	r3, [sp, #4]
    2366:	9b01      	ldr	r3, [sp, #4]
    2368:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    236c:	b002      	add	sp, #8
    236e:	4770      	bx	lr

00002370 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2370:	b082      	sub	sp, #8
    2372:	2300      	movs	r3, #0
    2374:	9301      	str	r3, [sp, #4]
    2376:	9b01      	ldr	r3, [sp, #4]
    2378:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    237c:	b002      	add	sp, #8
    237e:	4770      	bx	lr

00002380 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    2380:	b508      	push	{r3, lr}

  port_lock();
    2382:	f7ff ffed 	bl	2360 <port_lock>
  _stats_start_measure_crit_thd();
    2386:	f7ff fbcb 	bl	1b20 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    238a:	f7fe fad1 	bl	930 <_dbg_check_lock>
}
    238e:	bd08      	pop	{r3, pc}

00002390 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2390:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2392:	f7fe fae5 	bl	960 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2396:	f7ff fbcb 	bl	1b30 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    239a:	4b09      	ldr	r3, [pc, #36]	; (23c0 <chSysUnlock+0x30>)
    239c:	681a      	ldr	r2, [r3, #0]
    239e:	4b08      	ldr	r3, [pc, #32]	; (23c0 <chSysUnlock+0x30>)
    23a0:	429a      	cmp	r2, r3
    23a2:	d00a      	beq.n	23ba <chSysUnlock+0x2a>
    23a4:	4b06      	ldr	r3, [pc, #24]	; (23c0 <chSysUnlock+0x30>)
    23a6:	699b      	ldr	r3, [r3, #24]
    23a8:	689a      	ldr	r2, [r3, #8]
    23aa:	4b05      	ldr	r3, [pc, #20]	; (23c0 <chSysUnlock+0x30>)
    23ac:	681b      	ldr	r3, [r3, #0]
    23ae:	689b      	ldr	r3, [r3, #8]
    23b0:	429a      	cmp	r2, r3
    23b2:	d202      	bcs.n	23ba <chSysUnlock+0x2a>
    23b4:	4803      	ldr	r0, [pc, #12]	; (23c4 <chSysUnlock+0x34>)
    23b6:	f7fe fa53 	bl	860 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    23ba:	f7ff ffd9 	bl	2370 <port_unlock>
}
    23be:	bd08      	pop	{r3, pc}
    23c0:	20000ac0 	.word	0x20000ac0
    23c4:	00004840 	.word	0x00004840
    23c8:	f3af 8000 	nop.w
    23cc:	f3af 8000 	nop.w

000023d0 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
    23d0:	b500      	push	{lr}
    23d2:	b085      	sub	sp, #20
    23d4:	9003      	str	r0, [sp, #12]
    23d6:	9102      	str	r1, [sp, #8]
    23d8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
    23da:	9b03      	ldr	r3, [sp, #12]
    23dc:	2b00      	cmp	r3, #0
    23de:	d005      	beq.n	23ec <chMBObjectInit+0x1c>
    23e0:	9b02      	ldr	r3, [sp, #8]
    23e2:	2b00      	cmp	r3, #0
    23e4:	d002      	beq.n	23ec <chMBObjectInit+0x1c>
    23e6:	9b01      	ldr	r3, [sp, #4]
    23e8:	2b00      	cmp	r3, #0
    23ea:	dc02      	bgt.n	23f2 <chMBObjectInit+0x22>
    23ec:	4810      	ldr	r0, [pc, #64]	; (2430 <chMBObjectInit+0x60>)
    23ee:	f7fe fa37 	bl	860 <chSysHalt>

  mbp->mb_buffer = buf;
    23f2:	9b03      	ldr	r3, [sp, #12]
    23f4:	9a02      	ldr	r2, [sp, #8]
    23f6:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
    23f8:	9b03      	ldr	r3, [sp, #12]
    23fa:	9a02      	ldr	r2, [sp, #8]
    23fc:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
    23fe:	9b03      	ldr	r3, [sp, #12]
    2400:	9a02      	ldr	r2, [sp, #8]
    2402:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
    2404:	9b01      	ldr	r3, [sp, #4]
    2406:	009b      	lsls	r3, r3, #2
    2408:	9a02      	ldr	r2, [sp, #8]
    240a:	441a      	add	r2, r3
    240c:	9b03      	ldr	r3, [sp, #12]
    240e:	605a      	str	r2, [r3, #4]
  chSemObjectInit(&mbp->mb_emptysem, n);
    2410:	9b03      	ldr	r3, [sp, #12]
    2412:	331c      	adds	r3, #28
    2414:	4618      	mov	r0, r3
    2416:	9901      	ldr	r1, [sp, #4]
    2418:	f7ff fc92 	bl	1d40 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
    241c:	9b03      	ldr	r3, [sp, #12]
    241e:	3310      	adds	r3, #16
    2420:	4618      	mov	r0, r3
    2422:	2100      	movs	r1, #0
    2424:	f7ff fc8c 	bl	1d40 <chSemObjectInit>
}
    2428:	b005      	add	sp, #20
    242a:	f85d fb04 	ldr.w	pc, [sp], #4
    242e:	bf00      	nop
    2430:	00004830 	.word	0x00004830
    2434:	f3af 8000 	nop.w
    2438:	f3af 8000 	nop.w
    243c:	f3af 8000 	nop.w

00002440 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    2440:	b500      	push	{lr}
    2442:	b087      	sub	sp, #28
    2444:	9003      	str	r0, [sp, #12]
    2446:	9102      	str	r1, [sp, #8]
    2448:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
    244a:	f7ff ff99 	bl	2380 <chSysLock>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    244e:	9803      	ldr	r0, [sp, #12]
    2450:	9902      	ldr	r1, [sp, #8]
    2452:	9a01      	ldr	r2, [sp, #4]
    2454:	f000 f80c 	bl	2470 <chMBFetchS>
    2458:	9005      	str	r0, [sp, #20]
  chSysUnlock();
    245a:	f7ff ff99 	bl	2390 <chSysUnlock>

  return rdymsg;
    245e:	9b05      	ldr	r3, [sp, #20]
}
    2460:	4618      	mov	r0, r3
    2462:	b007      	add	sp, #28
    2464:	f85d fb04 	ldr.w	pc, [sp], #4
    2468:	f3af 8000 	nop.w
    246c:	f3af 8000 	nop.w

00002470 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    2470:	b500      	push	{lr}
    2472:	b087      	sub	sp, #28
    2474:	9003      	str	r0, [sp, #12]
    2476:	9102      	str	r1, [sp, #8]
    2478:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
    247a:	f7fe fb11 	bl	aa0 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
    247e:	9b03      	ldr	r3, [sp, #12]
    2480:	2b00      	cmp	r3, #0
    2482:	d002      	beq.n	248a <chMBFetchS+0x1a>
    2484:	9b02      	ldr	r3, [sp, #8]
    2486:	2b00      	cmp	r3, #0
    2488:	d102      	bne.n	2490 <chMBFetchS+0x20>
    248a:	4815      	ldr	r0, [pc, #84]	; (24e0 <chMBFetchS+0x70>)
    248c:	f7fe f9e8 	bl	860 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
    2490:	9b03      	ldr	r3, [sp, #12]
    2492:	3310      	adds	r3, #16
    2494:	4618      	mov	r0, r3
    2496:	9901      	ldr	r1, [sp, #4]
    2498:	f7ff fc72 	bl	1d80 <chSemWaitTimeoutS>
    249c:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
    249e:	9b05      	ldr	r3, [sp, #20]
    24a0:	2b00      	cmp	r3, #0
    24a2:	d118      	bne.n	24d6 <chMBFetchS+0x66>
    *msgp = *mbp->mb_rdptr++;
    24a4:	9b03      	ldr	r3, [sp, #12]
    24a6:	68db      	ldr	r3, [r3, #12]
    24a8:	1d19      	adds	r1, r3, #4
    24aa:	9a03      	ldr	r2, [sp, #12]
    24ac:	60d1      	str	r1, [r2, #12]
    24ae:	681a      	ldr	r2, [r3, #0]
    24b0:	9b02      	ldr	r3, [sp, #8]
    24b2:	601a      	str	r2, [r3, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
    24b4:	9b03      	ldr	r3, [sp, #12]
    24b6:	68da      	ldr	r2, [r3, #12]
    24b8:	9b03      	ldr	r3, [sp, #12]
    24ba:	685b      	ldr	r3, [r3, #4]
    24bc:	429a      	cmp	r2, r3
    24be:	d303      	bcc.n	24c8 <chMBFetchS+0x58>
      mbp->mb_rdptr = mbp->mb_buffer;
    24c0:	9b03      	ldr	r3, [sp, #12]
    24c2:	681a      	ldr	r2, [r3, #0]
    24c4:	9b03      	ldr	r3, [sp, #12]
    24c6:	60da      	str	r2, [r3, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
    24c8:	9b03      	ldr	r3, [sp, #12]
    24ca:	331c      	adds	r3, #28
    24cc:	4618      	mov	r0, r3
    24ce:	f7ff fcb7 	bl	1e40 <chSemSignalI>
    chSchRescheduleS();
    24d2:	f7fe fe95 	bl	1200 <chSchRescheduleS>
  }

  return rdymsg;
    24d6:	9b05      	ldr	r3, [sp, #20]
}
    24d8:	4618      	mov	r0, r3
    24da:	b007      	add	sp, #28
    24dc:	f85d fb04 	ldr.w	pc, [sp], #4
    24e0:	00004850 	.word	0x00004850
    24e4:	f3af 8000 	nop.w
    24e8:	f3af 8000 	nop.w
    24ec:	f3af 8000 	nop.w

000024f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    24f0:	b082      	sub	sp, #8
    24f2:	2320      	movs	r3, #32
    24f4:	9301      	str	r3, [sp, #4]
    24f6:	9b01      	ldr	r3, [sp, #4]
    24f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    24fc:	b002      	add	sp, #8
    24fe:	4770      	bx	lr

00002500 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2500:	b082      	sub	sp, #8
    2502:	2300      	movs	r3, #0
    2504:	9301      	str	r3, [sp, #4]
    2506:	9b01      	ldr	r3, [sp, #4]
    2508:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    250c:	b002      	add	sp, #8
    250e:	4770      	bx	lr

00002510 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    2510:	b082      	sub	sp, #8
    2512:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    2514:	9b01      	ldr	r3, [sp, #4]
    2516:	9a01      	ldr	r2, [sp, #4]
    2518:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    251a:	9b01      	ldr	r3, [sp, #4]
    251c:	9a01      	ldr	r2, [sp, #4]
    251e:	605a      	str	r2, [r3, #4]
}
    2520:	b002      	add	sp, #8
    2522:	4770      	bx	lr
    2524:	f3af 8000 	nop.w
    2528:	f3af 8000 	nop.w
    252c:	f3af 8000 	nop.w

00002530 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    2530:	b508      	push	{r3, lr}

  port_lock();
    2532:	f7ff ffdd 	bl	24f0 <port_lock>
  _stats_start_measure_crit_thd();
    2536:	f7ff faf3 	bl	1b20 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    253a:	f7fe f9f9 	bl	930 <_dbg_check_lock>
}
    253e:	bd08      	pop	{r3, pc}

00002540 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2540:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2542:	f7fe fa0d 	bl	960 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2546:	f7ff faf3 	bl	1b30 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    254a:	4b09      	ldr	r3, [pc, #36]	; (2570 <chSysUnlock+0x30>)
    254c:	681a      	ldr	r2, [r3, #0]
    254e:	4b08      	ldr	r3, [pc, #32]	; (2570 <chSysUnlock+0x30>)
    2550:	429a      	cmp	r2, r3
    2552:	d00a      	beq.n	256a <chSysUnlock+0x2a>
    2554:	4b06      	ldr	r3, [pc, #24]	; (2570 <chSysUnlock+0x30>)
    2556:	699b      	ldr	r3, [r3, #24]
    2558:	689a      	ldr	r2, [r3, #8]
    255a:	4b05      	ldr	r3, [pc, #20]	; (2570 <chSysUnlock+0x30>)
    255c:	681b      	ldr	r3, [r3, #0]
    255e:	689b      	ldr	r3, [r3, #8]
    2560:	429a      	cmp	r2, r3
    2562:	d202      	bcs.n	256a <chSysUnlock+0x2a>
    2564:	4803      	ldr	r0, [pc, #12]	; (2574 <chSysUnlock+0x34>)
    2566:	f7fe f97b 	bl	860 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    256a:	f7ff ffc9 	bl	2500 <port_unlock>
}
    256e:	bd08      	pop	{r3, pc}
    2570:	20000ac0 	.word	0x20000ac0
    2574:	00004860 	.word	0x00004860
    2578:	f3af 8000 	nop.w
    257c:	f3af 8000 	nop.w

00002580 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
    2580:	b500      	push	{lr}
    2582:	b083      	sub	sp, #12
    2584:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
    2586:	9801      	ldr	r0, [sp, #4]
    2588:	f7ff ffc2 	bl	2510 <queue_init>
}
    258c:	b003      	add	sp, #12
    258e:	f85d fb04 	ldr.w	pc, [sp], #4
    2592:	bf00      	nop
    2594:	f3af 8000 	nop.w
    2598:	f3af 8000 	nop.w
    259c:	f3af 8000 	nop.w

000025a0 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
    25a0:	b500      	push	{lr}
    25a2:	b083      	sub	sp, #12
    25a4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    25a6:	f7fe fa63 	bl	a70 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
    25aa:	9b01      	ldr	r3, [sp, #4]
    25ac:	689b      	ldr	r3, [r3, #8]
    25ae:	2b00      	cmp	r3, #0
    25b0:	bf14      	ite	ne
    25b2:	2300      	movne	r3, #0
    25b4:	2301      	moveq	r3, #1
    25b6:	b2db      	uxtb	r3, r3
}
    25b8:	4618      	mov	r0, r3
    25ba:	b003      	add	sp, #12
    25bc:	f85d fb04 	ldr.w	pc, [sp], #4

000025c0 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
    25c0:	b500      	push	{lr}
    25c2:	b083      	sub	sp, #12
    25c4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    25c6:	f7fe fa53 	bl	a70 <chDbgCheckClassI>

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
    25ca:	9b01      	ldr	r3, [sp, #4]
    25cc:	695a      	ldr	r2, [r3, #20]
    25ce:	9b01      	ldr	r3, [sp, #4]
    25d0:	699b      	ldr	r3, [r3, #24]
    25d2:	429a      	cmp	r2, r3
    25d4:	d105      	bne.n	25e2 <chIQIsFullI+0x22>
    25d6:	9b01      	ldr	r3, [sp, #4]
    25d8:	689b      	ldr	r3, [r3, #8]
    25da:	2b00      	cmp	r3, #0
    25dc:	d001      	beq.n	25e2 <chIQIsFullI+0x22>
    25de:	2301      	movs	r3, #1
    25e0:	e000      	b.n	25e4 <chIQIsFullI+0x24>
    25e2:	2300      	movs	r3, #0
    25e4:	f003 0301 	and.w	r3, r3, #1
    25e8:	b2db      	uxtb	r3, r3
}
    25ea:	4618      	mov	r0, r3
    25ec:	b003      	add	sp, #12
    25ee:	f85d fb04 	ldr.w	pc, [sp], #4
    25f2:	bf00      	nop
    25f4:	f3af 8000 	nop.w
    25f8:	f3af 8000 	nop.w
    25fc:	f3af 8000 	nop.w

00002600 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
    2600:	b500      	push	{lr}
    2602:	b083      	sub	sp, #12
    2604:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    2606:	f7fe fa33 	bl	a70 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    260a:	9b01      	ldr	r3, [sp, #4]
    260c:	695a      	ldr	r2, [r3, #20]
    260e:	9b01      	ldr	r3, [sp, #4]
    2610:	699b      	ldr	r3, [r3, #24]
    2612:	429a      	cmp	r2, r3
    2614:	d105      	bne.n	2622 <chOQIsEmptyI+0x22>
    2616:	9b01      	ldr	r3, [sp, #4]
    2618:	689b      	ldr	r3, [r3, #8]
    261a:	2b00      	cmp	r3, #0
    261c:	d001      	beq.n	2622 <chOQIsEmptyI+0x22>
    261e:	2301      	movs	r3, #1
    2620:	e000      	b.n	2624 <chOQIsEmptyI+0x24>
    2622:	2300      	movs	r3, #0
    2624:	f003 0301 	and.w	r3, r3, #1
    2628:	b2db      	uxtb	r3, r3
}
    262a:	4618      	mov	r0, r3
    262c:	b003      	add	sp, #12
    262e:	f85d fb04 	ldr.w	pc, [sp], #4
    2632:	bf00      	nop
    2634:	f3af 8000 	nop.w
    2638:	f3af 8000 	nop.w
    263c:	f3af 8000 	nop.w

00002640 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
    2640:	b500      	push	{lr}
    2642:	b083      	sub	sp, #12
    2644:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    2646:	f7fe fa13 	bl	a70 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
    264a:	9b01      	ldr	r3, [sp, #4]
    264c:	689b      	ldr	r3, [r3, #8]
    264e:	2b00      	cmp	r3, #0
    2650:	bf14      	ite	ne
    2652:	2300      	movne	r3, #0
    2654:	2301      	moveq	r3, #1
    2656:	b2db      	uxtb	r3, r3
}
    2658:	4618      	mov	r0, r3
    265a:	b003      	add	sp, #12
    265c:	f85d fb04 	ldr.w	pc, [sp], #4

00002660 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
    2660:	b500      	push	{lr}
    2662:	b085      	sub	sp, #20
    2664:	9003      	str	r0, [sp, #12]
    2666:	9102      	str	r1, [sp, #8]
    2668:	9201      	str	r2, [sp, #4]
    266a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
    266c:	9b03      	ldr	r3, [sp, #12]
    266e:	4618      	mov	r0, r3
    2670:	f7ff ff86 	bl	2580 <chThdQueueObjectInit>
  iqp->q_counter = 0;
    2674:	9b03      	ldr	r3, [sp, #12]
    2676:	2200      	movs	r2, #0
    2678:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
    267a:	9b03      	ldr	r3, [sp, #12]
    267c:	9a02      	ldr	r2, [sp, #8]
    267e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
    2680:	9b03      	ldr	r3, [sp, #12]
    2682:	9a02      	ldr	r2, [sp, #8]
    2684:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
    2686:	9b03      	ldr	r3, [sp, #12]
    2688:	9a02      	ldr	r2, [sp, #8]
    268a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
    268c:	9a02      	ldr	r2, [sp, #8]
    268e:	9b01      	ldr	r3, [sp, #4]
    2690:	441a      	add	r2, r3
    2692:	9b03      	ldr	r3, [sp, #12]
    2694:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
    2696:	9b03      	ldr	r3, [sp, #12]
    2698:	9a00      	ldr	r2, [sp, #0]
    269a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
    269c:	9b03      	ldr	r3, [sp, #12]
    269e:	9a06      	ldr	r2, [sp, #24]
    26a0:	621a      	str	r2, [r3, #32]
}
    26a2:	b005      	add	sp, #20
    26a4:	f85d fb04 	ldr.w	pc, [sp], #4
    26a8:	f3af 8000 	nop.w
    26ac:	f3af 8000 	nop.w

000026b0 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
    26b0:	b500      	push	{lr}
    26b2:	b083      	sub	sp, #12
    26b4:	9001      	str	r0, [sp, #4]
    26b6:	460b      	mov	r3, r1
    26b8:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();
    26bc:	f7fe f9d8 	bl	a70 <chDbgCheckClassI>

  if (chIQIsFullI(iqp)) {
    26c0:	9801      	ldr	r0, [sp, #4]
    26c2:	f7ff ff7d 	bl	25c0 <chIQIsFullI>
    26c6:	4603      	mov	r3, r0
    26c8:	2b00      	cmp	r3, #0
    26ca:	d002      	beq.n	26d2 <chIQPutI+0x22>
    return Q_FULL;
    26cc:	f06f 0303 	mvn.w	r3, #3
    26d0:	e01c      	b.n	270c <chIQPutI+0x5c>
  }

  iqp->q_counter++;
    26d2:	9b01      	ldr	r3, [sp, #4]
    26d4:	689b      	ldr	r3, [r3, #8]
    26d6:	1c5a      	adds	r2, r3, #1
    26d8:	9b01      	ldr	r3, [sp, #4]
    26da:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
    26dc:	9b01      	ldr	r3, [sp, #4]
    26de:	695b      	ldr	r3, [r3, #20]
    26e0:	1c59      	adds	r1, r3, #1
    26e2:	9a01      	ldr	r2, [sp, #4]
    26e4:	6151      	str	r1, [r2, #20]
    26e6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    26ea:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
    26ec:	9b01      	ldr	r3, [sp, #4]
    26ee:	695a      	ldr	r2, [r3, #20]
    26f0:	9b01      	ldr	r3, [sp, #4]
    26f2:	691b      	ldr	r3, [r3, #16]
    26f4:	429a      	cmp	r2, r3
    26f6:	d303      	bcc.n	2700 <chIQPutI+0x50>
    iqp->q_wrptr = iqp->q_buffer;
    26f8:	9b01      	ldr	r3, [sp, #4]
    26fa:	68da      	ldr	r2, [r3, #12]
    26fc:	9b01      	ldr	r3, [sp, #4]
    26fe:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
    2700:	9b01      	ldr	r3, [sp, #4]
    2702:	4618      	mov	r0, r3
    2704:	2100      	movs	r1, #0
    2706:	f7ff f8f3 	bl	18f0 <chThdDequeueNextI>

  return Q_OK;
    270a:	2300      	movs	r3, #0
}
    270c:	4618      	mov	r0, r3
    270e:	b003      	add	sp, #12
    2710:	f85d fb04 	ldr.w	pc, [sp], #4
    2714:	f3af 8000 	nop.w
    2718:	f3af 8000 	nop.w
    271c:	f3af 8000 	nop.w

00002720 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
    2720:	b500      	push	{lr}
    2722:	b085      	sub	sp, #20
    2724:	9001      	str	r0, [sp, #4]
    2726:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
    2728:	f7ff ff02 	bl	2530 <chSysLock>
  if (iqp->q_notify != NULL) {
    272c:	9b01      	ldr	r3, [sp, #4]
    272e:	69db      	ldr	r3, [r3, #28]
    2730:	2b00      	cmp	r3, #0
    2732:	d004      	beq.n	273e <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
    2734:	9b01      	ldr	r3, [sp, #4]
    2736:	69db      	ldr	r3, [r3, #28]
    2738:	9801      	ldr	r0, [sp, #4]
    273a:	4798      	blx	r3
  }

  while (chIQIsEmptyI(iqp)) {
    273c:	e00d      	b.n	275a <chIQGetTimeout+0x3a>
    273e:	e00c      	b.n	275a <chIQGetTimeout+0x3a>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
    2740:	9b01      	ldr	r3, [sp, #4]
    2742:	4618      	mov	r0, r3
    2744:	9900      	ldr	r1, [sp, #0]
    2746:	f7ff f8b3 	bl	18b0 <chThdEnqueueTimeoutS>
    274a:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
    274c:	9b03      	ldr	r3, [sp, #12]
    274e:	2b00      	cmp	r3, #0
    2750:	da03      	bge.n	275a <chIQGetTimeout+0x3a>
      chSysUnlock();
    2752:	f7ff fef5 	bl	2540 <chSysUnlock>
      return msg;
    2756:	9b03      	ldr	r3, [sp, #12]
    2758:	e020      	b.n	279c <chIQGetTimeout+0x7c>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    275a:	9801      	ldr	r0, [sp, #4]
    275c:	f7ff ff20 	bl	25a0 <chIQIsEmptyI>
    2760:	4603      	mov	r3, r0
    2762:	2b00      	cmp	r3, #0
    2764:	d1ec      	bne.n	2740 <chIQGetTimeout+0x20>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
    2766:	9b01      	ldr	r3, [sp, #4]
    2768:	689b      	ldr	r3, [r3, #8]
    276a:	1e5a      	subs	r2, r3, #1
    276c:	9b01      	ldr	r3, [sp, #4]
    276e:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
    2770:	9b01      	ldr	r3, [sp, #4]
    2772:	699b      	ldr	r3, [r3, #24]
    2774:	1c59      	adds	r1, r3, #1
    2776:	9a01      	ldr	r2, [sp, #4]
    2778:	6191      	str	r1, [r2, #24]
    277a:	781b      	ldrb	r3, [r3, #0]
    277c:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
    2780:	9b01      	ldr	r3, [sp, #4]
    2782:	699a      	ldr	r2, [r3, #24]
    2784:	9b01      	ldr	r3, [sp, #4]
    2786:	691b      	ldr	r3, [r3, #16]
    2788:	429a      	cmp	r2, r3
    278a:	d303      	bcc.n	2794 <chIQGetTimeout+0x74>
    iqp->q_rdptr = iqp->q_buffer;
    278c:	9b01      	ldr	r3, [sp, #4]
    278e:	68da      	ldr	r2, [r3, #12]
    2790:	9b01      	ldr	r3, [sp, #4]
    2792:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
    2794:	f7ff fed4 	bl	2540 <chSysUnlock>

  return (msg_t)b;
    2798:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    279c:	4618      	mov	r0, r3
    279e:	b005      	add	sp, #20
    27a0:	f85d fb04 	ldr.w	pc, [sp], #4
    27a4:	f3af 8000 	nop.w
    27a8:	f3af 8000 	nop.w
    27ac:	f3af 8000 	nop.w

000027b0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
    27b0:	b500      	push	{lr}
    27b2:	b087      	sub	sp, #28
    27b4:	9003      	str	r0, [sp, #12]
    27b6:	9102      	str	r1, [sp, #8]
    27b8:	9201      	str	r2, [sp, #4]
    27ba:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
    27bc:	9b03      	ldr	r3, [sp, #12]
    27be:	69db      	ldr	r3, [r3, #28]
    27c0:	9304      	str	r3, [sp, #16]
  size_t r = 0;
    27c2:	2300      	movs	r3, #0
    27c4:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
    27c6:	9b01      	ldr	r3, [sp, #4]
    27c8:	2b00      	cmp	r3, #0
    27ca:	d102      	bne.n	27d2 <chIQReadTimeout+0x22>
    27cc:	4825      	ldr	r0, [pc, #148]	; (2864 <chIQReadTimeout+0xb4>)
    27ce:	f7fe f847 	bl	860 <chSysHalt>

  chSysLock();
    27d2:	f7ff fead 	bl	2530 <chSysLock>
  while (true) {
    if (nfy != NULL) {
    27d6:	9b04      	ldr	r3, [sp, #16]
    27d8:	2b00      	cmp	r3, #0
    27da:	d003      	beq.n	27e4 <chIQReadTimeout+0x34>
      nfy(iqp);
    27dc:	9b04      	ldr	r3, [sp, #16]
    27de:	9803      	ldr	r0, [sp, #12]
    27e0:	4798      	blx	r3
    }

    while (chIQIsEmptyI(iqp)) {
    27e2:	e00c      	b.n	27fe <chIQReadTimeout+0x4e>
    27e4:	e00b      	b.n	27fe <chIQReadTimeout+0x4e>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
    27e6:	9b03      	ldr	r3, [sp, #12]
    27e8:	4618      	mov	r0, r3
    27ea:	9900      	ldr	r1, [sp, #0]
    27ec:	f7ff f860 	bl	18b0 <chThdEnqueueTimeoutS>
    27f0:	4603      	mov	r3, r0
    27f2:	2b00      	cmp	r3, #0
    27f4:	d003      	beq.n	27fe <chIQReadTimeout+0x4e>
        chSysUnlock();
    27f6:	f7ff fea3 	bl	2540 <chSysUnlock>
        return r;
    27fa:	9b05      	ldr	r3, [sp, #20]
    27fc:	e02e      	b.n	285c <chIQReadTimeout+0xac>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
    27fe:	9803      	ldr	r0, [sp, #12]
    2800:	f7ff fece 	bl	25a0 <chIQIsEmptyI>
    2804:	4603      	mov	r3, r0
    2806:	2b00      	cmp	r3, #0
    2808:	d1ed      	bne.n	27e6 <chIQReadTimeout+0x36>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
    280a:	9b03      	ldr	r3, [sp, #12]
    280c:	689b      	ldr	r3, [r3, #8]
    280e:	1e5a      	subs	r2, r3, #1
    2810:	9b03      	ldr	r3, [sp, #12]
    2812:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
    2814:	9b02      	ldr	r3, [sp, #8]
    2816:	1c5a      	adds	r2, r3, #1
    2818:	9202      	str	r2, [sp, #8]
    281a:	9a03      	ldr	r2, [sp, #12]
    281c:	6992      	ldr	r2, [r2, #24]
    281e:	1c50      	adds	r0, r2, #1
    2820:	9903      	ldr	r1, [sp, #12]
    2822:	6188      	str	r0, [r1, #24]
    2824:	7812      	ldrb	r2, [r2, #0]
    2826:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
    2828:	9b03      	ldr	r3, [sp, #12]
    282a:	699a      	ldr	r2, [r3, #24]
    282c:	9b03      	ldr	r3, [sp, #12]
    282e:	691b      	ldr	r3, [r3, #16]
    2830:	429a      	cmp	r2, r3
    2832:	d303      	bcc.n	283c <chIQReadTimeout+0x8c>
      iqp->q_rdptr = iqp->q_buffer;
    2834:	9b03      	ldr	r3, [sp, #12]
    2836:	68da      	ldr	r2, [r3, #12]
    2838:	9b03      	ldr	r3, [sp, #12]
    283a:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    283c:	f7ff fe80 	bl	2540 <chSysUnlock>

    r++;
    2840:	9b05      	ldr	r3, [sp, #20]
    2842:	3301      	adds	r3, #1
    2844:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
    2846:	9b01      	ldr	r3, [sp, #4]
    2848:	3b01      	subs	r3, #1
    284a:	9301      	str	r3, [sp, #4]
    284c:	9b01      	ldr	r3, [sp, #4]
    284e:	2b00      	cmp	r3, #0
    2850:	d101      	bne.n	2856 <chIQReadTimeout+0xa6>
      return r;
    2852:	9b05      	ldr	r3, [sp, #20]
    2854:	e002      	b.n	285c <chIQReadTimeout+0xac>
    }

    chSysLock();
    2856:	f7ff fe6b 	bl	2530 <chSysLock>
  }
    285a:	e7bc      	b.n	27d6 <chIQReadTimeout+0x26>
}
    285c:	4618      	mov	r0, r3
    285e:	b007      	add	sp, #28
    2860:	f85d fb04 	ldr.w	pc, [sp], #4
    2864:	00004870 	.word	0x00004870
    2868:	f3af 8000 	nop.w
    286c:	f3af 8000 	nop.w

00002870 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
    2870:	b500      	push	{lr}
    2872:	b085      	sub	sp, #20
    2874:	9003      	str	r0, [sp, #12]
    2876:	9102      	str	r1, [sp, #8]
    2878:	9201      	str	r2, [sp, #4]
    287a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
    287c:	9b03      	ldr	r3, [sp, #12]
    287e:	4618      	mov	r0, r3
    2880:	f7ff fe7e 	bl	2580 <chThdQueueObjectInit>
  oqp->q_counter = size;
    2884:	9b03      	ldr	r3, [sp, #12]
    2886:	9a01      	ldr	r2, [sp, #4]
    2888:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
    288a:	9b03      	ldr	r3, [sp, #12]
    288c:	9a02      	ldr	r2, [sp, #8]
    288e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
    2890:	9b03      	ldr	r3, [sp, #12]
    2892:	9a02      	ldr	r2, [sp, #8]
    2894:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
    2896:	9b03      	ldr	r3, [sp, #12]
    2898:	9a02      	ldr	r2, [sp, #8]
    289a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
    289c:	9a02      	ldr	r2, [sp, #8]
    289e:	9b01      	ldr	r3, [sp, #4]
    28a0:	441a      	add	r2, r3
    28a2:	9b03      	ldr	r3, [sp, #12]
    28a4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
    28a6:	9b03      	ldr	r3, [sp, #12]
    28a8:	9a00      	ldr	r2, [sp, #0]
    28aa:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
    28ac:	9b03      	ldr	r3, [sp, #12]
    28ae:	9a06      	ldr	r2, [sp, #24]
    28b0:	621a      	str	r2, [r3, #32]
}
    28b2:	b005      	add	sp, #20
    28b4:	f85d fb04 	ldr.w	pc, [sp], #4
    28b8:	f3af 8000 	nop.w
    28bc:	f3af 8000 	nop.w

000028c0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    28c0:	b500      	push	{lr}
    28c2:	b087      	sub	sp, #28
    28c4:	9003      	str	r0, [sp, #12]
    28c6:	460b      	mov	r3, r1
    28c8:	9201      	str	r2, [sp, #4]
    28ca:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
    28ce:	f7ff fe2f 	bl	2530 <chSysLock>
  while (chOQIsFullI(oqp)) {
    28d2:	e00c      	b.n	28ee <chOQPutTimeout+0x2e>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    28d4:	9b03      	ldr	r3, [sp, #12]
    28d6:	4618      	mov	r0, r3
    28d8:	9901      	ldr	r1, [sp, #4]
    28da:	f7fe ffe9 	bl	18b0 <chThdEnqueueTimeoutS>
    28de:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
    28e0:	9b05      	ldr	r3, [sp, #20]
    28e2:	2b00      	cmp	r3, #0
    28e4:	da03      	bge.n	28ee <chOQPutTimeout+0x2e>
      chSysUnlock();
    28e6:	f7ff fe2b 	bl	2540 <chSysUnlock>
      return msg;
    28ea:	9b05      	ldr	r3, [sp, #20]
    28ec:	e027      	b.n	293e <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    28ee:	9803      	ldr	r0, [sp, #12]
    28f0:	f7ff fea6 	bl	2640 <chOQIsFullI>
    28f4:	4603      	mov	r3, r0
    28f6:	2b00      	cmp	r3, #0
    28f8:	d1ec      	bne.n	28d4 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
    28fa:	9b03      	ldr	r3, [sp, #12]
    28fc:	689b      	ldr	r3, [r3, #8]
    28fe:	1e5a      	subs	r2, r3, #1
    2900:	9b03      	ldr	r3, [sp, #12]
    2902:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
    2904:	9b03      	ldr	r3, [sp, #12]
    2906:	695b      	ldr	r3, [r3, #20]
    2908:	1c59      	adds	r1, r3, #1
    290a:	9a03      	ldr	r2, [sp, #12]
    290c:	6151      	str	r1, [r2, #20]
    290e:	f89d 200b 	ldrb.w	r2, [sp, #11]
    2912:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
    2914:	9b03      	ldr	r3, [sp, #12]
    2916:	695a      	ldr	r2, [r3, #20]
    2918:	9b03      	ldr	r3, [sp, #12]
    291a:	691b      	ldr	r3, [r3, #16]
    291c:	429a      	cmp	r2, r3
    291e:	d303      	bcc.n	2928 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
    2920:	9b03      	ldr	r3, [sp, #12]
    2922:	68da      	ldr	r2, [r3, #12]
    2924:	9b03      	ldr	r3, [sp, #12]
    2926:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
    2928:	9b03      	ldr	r3, [sp, #12]
    292a:	69db      	ldr	r3, [r3, #28]
    292c:	2b00      	cmp	r3, #0
    292e:	d003      	beq.n	2938 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
    2930:	9b03      	ldr	r3, [sp, #12]
    2932:	69db      	ldr	r3, [r3, #28]
    2934:	9803      	ldr	r0, [sp, #12]
    2936:	4798      	blx	r3
  }
  chSysUnlock();
    2938:	f7ff fe02 	bl	2540 <chSysUnlock>

  return Q_OK;
    293c:	2300      	movs	r3, #0
}
    293e:	4618      	mov	r0, r3
    2940:	b007      	add	sp, #28
    2942:	f85d fb04 	ldr.w	pc, [sp], #4
    2946:	bf00      	nop
    2948:	f3af 8000 	nop.w
    294c:	f3af 8000 	nop.w

00002950 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
    2950:	b500      	push	{lr}
    2952:	b085      	sub	sp, #20
    2954:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();
    2956:	f7fe f88b 	bl	a70 <chDbgCheckClassI>

  if (chOQIsEmptyI(oqp)) {
    295a:	9801      	ldr	r0, [sp, #4]
    295c:	f7ff fe50 	bl	2600 <chOQIsEmptyI>
    2960:	4603      	mov	r3, r0
    2962:	2b00      	cmp	r3, #0
    2964:	d002      	beq.n	296c <chOQGetI+0x1c>
    return Q_EMPTY;
    2966:	f06f 0302 	mvn.w	r3, #2
    296a:	e01d      	b.n	29a8 <chOQGetI+0x58>
  }

  oqp->q_counter++;
    296c:	9b01      	ldr	r3, [sp, #4]
    296e:	689b      	ldr	r3, [r3, #8]
    2970:	1c5a      	adds	r2, r3, #1
    2972:	9b01      	ldr	r3, [sp, #4]
    2974:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
    2976:	9b01      	ldr	r3, [sp, #4]
    2978:	699b      	ldr	r3, [r3, #24]
    297a:	1c59      	adds	r1, r3, #1
    297c:	9a01      	ldr	r2, [sp, #4]
    297e:	6191      	str	r1, [r2, #24]
    2980:	781b      	ldrb	r3, [r3, #0]
    2982:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
    2986:	9b01      	ldr	r3, [sp, #4]
    2988:	699a      	ldr	r2, [r3, #24]
    298a:	9b01      	ldr	r3, [sp, #4]
    298c:	691b      	ldr	r3, [r3, #16]
    298e:	429a      	cmp	r2, r3
    2990:	d303      	bcc.n	299a <chOQGetI+0x4a>
    oqp->q_rdptr = oqp->q_buffer;
    2992:	9b01      	ldr	r3, [sp, #4]
    2994:	68da      	ldr	r2, [r3, #12]
    2996:	9b01      	ldr	r3, [sp, #4]
    2998:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
    299a:	9b01      	ldr	r3, [sp, #4]
    299c:	4618      	mov	r0, r3
    299e:	2100      	movs	r1, #0
    29a0:	f7fe ffa6 	bl	18f0 <chThdDequeueNextI>

  return (msg_t)b;
    29a4:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    29a8:	4618      	mov	r0, r3
    29aa:	b005      	add	sp, #20
    29ac:	f85d fb04 	ldr.w	pc, [sp], #4

000029b0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
    29b0:	b500      	push	{lr}
    29b2:	b087      	sub	sp, #28
    29b4:	9003      	str	r0, [sp, #12]
    29b6:	9102      	str	r1, [sp, #8]
    29b8:	9201      	str	r2, [sp, #4]
    29ba:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
    29bc:	9b03      	ldr	r3, [sp, #12]
    29be:	69db      	ldr	r3, [r3, #28]
    29c0:	9304      	str	r3, [sp, #16]
  size_t w = 0;
    29c2:	2300      	movs	r3, #0
    29c4:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
    29c6:	9b01      	ldr	r3, [sp, #4]
    29c8:	2b00      	cmp	r3, #0
    29ca:	d102      	bne.n	29d2 <chOQWriteTimeout+0x22>
    29cc:	4825      	ldr	r0, [pc, #148]	; (2a64 <chOQWriteTimeout+0xb4>)
    29ce:	f7fd ff47 	bl	860 <chSysHalt>

  chSysLock();
    29d2:	f7ff fdad 	bl	2530 <chSysLock>
  while (true) {
    while (chOQIsFullI(oqp)) {
    29d6:	e00b      	b.n	29f0 <chOQWriteTimeout+0x40>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
    29d8:	9b03      	ldr	r3, [sp, #12]
    29da:	4618      	mov	r0, r3
    29dc:	9900      	ldr	r1, [sp, #0]
    29de:	f7fe ff67 	bl	18b0 <chThdEnqueueTimeoutS>
    29e2:	4603      	mov	r3, r0
    29e4:	2b00      	cmp	r3, #0
    29e6:	d003      	beq.n	29f0 <chOQWriteTimeout+0x40>
        chSysUnlock();
    29e8:	f7ff fdaa 	bl	2540 <chSysUnlock>
        return w;
    29ec:	9b05      	ldr	r3, [sp, #20]
    29ee:	e035      	b.n	2a5c <chOQWriteTimeout+0xac>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
    29f0:	9803      	ldr	r0, [sp, #12]
    29f2:	f7ff fe25 	bl	2640 <chOQIsFullI>
    29f6:	4603      	mov	r3, r0
    29f8:	2b00      	cmp	r3, #0
    29fa:	d1ed      	bne.n	29d8 <chOQWriteTimeout+0x28>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
    29fc:	9b03      	ldr	r3, [sp, #12]
    29fe:	689b      	ldr	r3, [r3, #8]
    2a00:	1e5a      	subs	r2, r3, #1
    2a02:	9b03      	ldr	r3, [sp, #12]
    2a04:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
    2a06:	9b03      	ldr	r3, [sp, #12]
    2a08:	695b      	ldr	r3, [r3, #20]
    2a0a:	1c59      	adds	r1, r3, #1
    2a0c:	9a03      	ldr	r2, [sp, #12]
    2a0e:	6151      	str	r1, [r2, #20]
    2a10:	9a02      	ldr	r2, [sp, #8]
    2a12:	1c51      	adds	r1, r2, #1
    2a14:	9102      	str	r1, [sp, #8]
    2a16:	7812      	ldrb	r2, [r2, #0]
    2a18:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
    2a1a:	9b03      	ldr	r3, [sp, #12]
    2a1c:	695a      	ldr	r2, [r3, #20]
    2a1e:	9b03      	ldr	r3, [sp, #12]
    2a20:	691b      	ldr	r3, [r3, #16]
    2a22:	429a      	cmp	r2, r3
    2a24:	d303      	bcc.n	2a2e <chOQWriteTimeout+0x7e>
      oqp->q_wrptr = oqp->q_buffer;
    2a26:	9b03      	ldr	r3, [sp, #12]
    2a28:	68da      	ldr	r2, [r3, #12]
    2a2a:	9b03      	ldr	r3, [sp, #12]
    2a2c:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
    2a2e:	9b04      	ldr	r3, [sp, #16]
    2a30:	2b00      	cmp	r3, #0
    2a32:	d002      	beq.n	2a3a <chOQWriteTimeout+0x8a>
      nfy(oqp);
    2a34:	9b04      	ldr	r3, [sp, #16]
    2a36:	9803      	ldr	r0, [sp, #12]
    2a38:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    2a3a:	f7ff fd81 	bl	2540 <chSysUnlock>

    w++;
    2a3e:	9b05      	ldr	r3, [sp, #20]
    2a40:	3301      	adds	r3, #1
    2a42:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
    2a44:	9b01      	ldr	r3, [sp, #4]
    2a46:	3b01      	subs	r3, #1
    2a48:	9301      	str	r3, [sp, #4]
    2a4a:	9b01      	ldr	r3, [sp, #4]
    2a4c:	2b00      	cmp	r3, #0
    2a4e:	d101      	bne.n	2a54 <chOQWriteTimeout+0xa4>
      return w;
    2a50:	9b05      	ldr	r3, [sp, #20]
    2a52:	e003      	b.n	2a5c <chOQWriteTimeout+0xac>
    }
    chSysLock();
    2a54:	f7ff fd6c 	bl	2530 <chSysLock>
  }
    2a58:	bf00      	nop

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
    2a5a:	e7c9      	b.n	29f0 <chOQWriteTimeout+0x40>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
    2a5c:	4618      	mov	r0, r3
    2a5e:	b007      	add	sp, #28
    2a60:	f85d fb04 	ldr.w	pc, [sp], #4
    2a64:	00004880 	.word	0x00004880
    2a68:	f3af 8000 	nop.w
    2a6c:	f3af 8000 	nop.w

00002a70 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2a70:	b082      	sub	sp, #8
    2a72:	2320      	movs	r3, #32
    2a74:	9301      	str	r3, [sp, #4]
    2a76:	9b01      	ldr	r3, [sp, #4]
    2a78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2a7c:	b002      	add	sp, #8
    2a7e:	4770      	bx	lr

00002a80 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2a80:	b082      	sub	sp, #8
    2a82:	2300      	movs	r3, #0
    2a84:	9301      	str	r3, [sp, #4]
    2a86:	9b01      	ldr	r3, [sp, #4]
    2a88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2a8c:	b002      	add	sp, #8
    2a8e:	4770      	bx	lr

00002a90 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    2a90:	b508      	push	{r3, lr}

  port_lock();
    2a92:	f7ff ffed 	bl	2a70 <port_lock>
  _stats_start_measure_crit_thd();
    2a96:	f7ff f843 	bl	1b20 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2a9a:	f7fd ff49 	bl	930 <_dbg_check_lock>
}
    2a9e:	bd08      	pop	{r3, pc}

00002aa0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2aa0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2aa2:	f7fd ff5d 	bl	960 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2aa6:	f7ff f843 	bl	1b30 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    2aaa:	4b09      	ldr	r3, [pc, #36]	; (2ad0 <chSysUnlock+0x30>)
    2aac:	681a      	ldr	r2, [r3, #0]
    2aae:	4b08      	ldr	r3, [pc, #32]	; (2ad0 <chSysUnlock+0x30>)
    2ab0:	429a      	cmp	r2, r3
    2ab2:	d00a      	beq.n	2aca <chSysUnlock+0x2a>
    2ab4:	4b06      	ldr	r3, [pc, #24]	; (2ad0 <chSysUnlock+0x30>)
    2ab6:	699b      	ldr	r3, [r3, #24]
    2ab8:	689a      	ldr	r2, [r3, #8]
    2aba:	4b05      	ldr	r3, [pc, #20]	; (2ad0 <chSysUnlock+0x30>)
    2abc:	681b      	ldr	r3, [r3, #0]
    2abe:	689b      	ldr	r3, [r3, #8]
    2ac0:	429a      	cmp	r2, r3
    2ac2:	d202      	bcs.n	2aca <chSysUnlock+0x2a>
    2ac4:	4803      	ldr	r0, [pc, #12]	; (2ad4 <chSysUnlock+0x34>)
    2ac6:	f7fd fecb 	bl	860 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    2aca:	f7ff ffd9 	bl	2a80 <port_unlock>
}
    2ace:	bd08      	pop	{r3, pc}
    2ad0:	20000ac0 	.word	0x20000ac0
    2ad4:	000048a0 	.word	0x000048a0
    2ad8:	f3af 8000 	nop.w
    2adc:	f3af 8000 	nop.w

00002ae0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
    2ae0:	4b06      	ldr	r3, [pc, #24]	; (2afc <_core_init+0x1c>)
    2ae2:	3307      	adds	r3, #7
    2ae4:	f023 0307 	bic.w	r3, r3, #7
    2ae8:	461a      	mov	r2, r3
    2aea:	4b05      	ldr	r3, [pc, #20]	; (2b00 <_core_init+0x20>)
    2aec:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
    2aee:	4b05      	ldr	r3, [pc, #20]	; (2b04 <_core_init+0x24>)
    2af0:	f023 0307 	bic.w	r3, r3, #7
    2af4:	461a      	mov	r2, r3
    2af6:	4b04      	ldr	r3, [pc, #16]	; (2b08 <_core_init+0x28>)
    2af8:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
    2afa:	4770      	bx	lr
    2afc:	20001278 	.word	0x20001278
    2b00:	20001098 	.word	0x20001098
    2b04:	20020000 	.word	0x20020000
    2b08:	2000109c 	.word	0x2000109c
    2b0c:	f3af 8000 	nop.w

00002b10 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
    2b10:	b500      	push	{lr}
    2b12:	b085      	sub	sp, #20
    2b14:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
    2b16:	f7ff ffbb 	bl	2a90 <chSysLock>
  p = chCoreAllocI(size);
    2b1a:	9801      	ldr	r0, [sp, #4]
    2b1c:	f000 f808 	bl	2b30 <chCoreAllocI>
    2b20:	9003      	str	r0, [sp, #12]
  chSysUnlock();
    2b22:	f7ff ffbd 	bl	2aa0 <chSysUnlock>

  return p;
    2b26:	9b03      	ldr	r3, [sp, #12]
}
    2b28:	4618      	mov	r0, r3
    2b2a:	b005      	add	sp, #20
    2b2c:	f85d fb04 	ldr.w	pc, [sp], #4

00002b30 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
    2b30:	b500      	push	{lr}
    2b32:	b085      	sub	sp, #20
    2b34:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();
    2b36:	f7fd ff9b 	bl	a70 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
    2b3a:	9b01      	ldr	r3, [sp, #4]
    2b3c:	3307      	adds	r3, #7
    2b3e:	f023 0307 	bic.w	r3, r3, #7
    2b42:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
    2b44:	4b0c      	ldr	r3, [pc, #48]	; (2b78 <chCoreAllocI+0x48>)
    2b46:	681b      	ldr	r3, [r3, #0]
    2b48:	461a      	mov	r2, r3
    2b4a:	4b0c      	ldr	r3, [pc, #48]	; (2b7c <chCoreAllocI+0x4c>)
    2b4c:	681b      	ldr	r3, [r3, #0]
    2b4e:	1ad3      	subs	r3, r2, r3
    2b50:	461a      	mov	r2, r3
    2b52:	9b01      	ldr	r3, [sp, #4]
    2b54:	429a      	cmp	r2, r3
    2b56:	d201      	bcs.n	2b5c <chCoreAllocI+0x2c>
  /*lint -restore*/
    return NULL;
    2b58:	2300      	movs	r3, #0
    2b5a:	e009      	b.n	2b70 <chCoreAllocI+0x40>
  }
  p = nextmem;
    2b5c:	4b07      	ldr	r3, [pc, #28]	; (2b7c <chCoreAllocI+0x4c>)
    2b5e:	681b      	ldr	r3, [r3, #0]
    2b60:	9303      	str	r3, [sp, #12]
  nextmem += size;
    2b62:	4b06      	ldr	r3, [pc, #24]	; (2b7c <chCoreAllocI+0x4c>)
    2b64:	681a      	ldr	r2, [r3, #0]
    2b66:	9b01      	ldr	r3, [sp, #4]
    2b68:	441a      	add	r2, r3
    2b6a:	4b04      	ldr	r3, [pc, #16]	; (2b7c <chCoreAllocI+0x4c>)
    2b6c:	601a      	str	r2, [r3, #0]

  return p;
    2b6e:	9b03      	ldr	r3, [sp, #12]
}
    2b70:	4618      	mov	r0, r3
    2b72:	b005      	add	sp, #20
    2b74:	f85d fb04 	ldr.w	pc, [sp], #4
    2b78:	2000109c 	.word	0x2000109c
    2b7c:	20001098 	.word	0x20001098

00002b80 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
    2b80:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
    2b82:	4b06      	ldr	r3, [pc, #24]	; (2b9c <_heap_init+0x1c>)
    2b84:	4a06      	ldr	r2, [pc, #24]	; (2ba0 <_heap_init+0x20>)
    2b86:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
    2b88:	4b04      	ldr	r3, [pc, #16]	; (2b9c <_heap_init+0x1c>)
    2b8a:	2200      	movs	r2, #0
    2b8c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
    2b8e:	4b03      	ldr	r3, [pc, #12]	; (2b9c <_heap_init+0x1c>)
    2b90:	2200      	movs	r2, #0
    2b92:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
    2b94:	4803      	ldr	r0, [pc, #12]	; (2ba4 <_heap_init+0x24>)
    2b96:	f7ff fa53 	bl	2040 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
    2b9a:	bd08      	pop	{r3, pc}
    2b9c:	200010a0 	.word	0x200010a0
    2ba0:	00002b11 	.word	0x00002b11
    2ba4:	200010b0 	.word	0x200010b0
    2ba8:	f3af 8000 	nop.w
    2bac:	f3af 8000 	nop.w

00002bb0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
    2bb0:	b500      	push	{lr}
    2bb2:	b087      	sub	sp, #28
    2bb4:	9001      	str	r0, [sp, #4]
  union heap_header *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);
    2bb6:	9b01      	ldr	r3, [sp, #4]
    2bb8:	2b00      	cmp	r3, #0
    2bba:	d102      	bne.n	2bc2 <chHeapFree+0x12>
    2bbc:	483a      	ldr	r0, [pc, #232]	; (2ca8 <chHeapFree+0xf8>)
    2bbe:	f7fd fe4f 	bl	860 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
    2bc2:	9b01      	ldr	r3, [sp, #4]
    2bc4:	3b08      	subs	r3, #8
    2bc6:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = hp->h.u.heap;
    2bc8:	9b04      	ldr	r3, [sp, #16]
    2bca:	681b      	ldr	r3, [r3, #0]
    2bcc:	9303      	str	r3, [sp, #12]
  qp = &heapp->h_free;
    2bce:	9b03      	ldr	r3, [sp, #12]
    2bd0:	3308      	adds	r3, #8
    2bd2:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
    2bd4:	9b03      	ldr	r3, [sp, #12]
    2bd6:	3310      	adds	r3, #16
    2bd8:	4618      	mov	r0, r3
    2bda:	f7ff fa49 	bl	2070 <chMtxLock>
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");
    2bde:	9a04      	ldr	r2, [sp, #16]
    2be0:	9b05      	ldr	r3, [sp, #20]
    2be2:	429a      	cmp	r2, r3
    2be4:	d30a      	bcc.n	2bfc <chHeapFree+0x4c>
    2be6:	9b05      	ldr	r3, [sp, #20]
    2be8:	685b      	ldr	r3, [r3, #4]
    2bea:	3308      	adds	r3, #8
    2bec:	9a05      	ldr	r2, [sp, #20]
    2bee:	441a      	add	r2, r3
    2bf0:	9b04      	ldr	r3, [sp, #16]
    2bf2:	429a      	cmp	r2, r3
    2bf4:	d902      	bls.n	2bfc <chHeapFree+0x4c>
    2bf6:	482c      	ldr	r0, [pc, #176]	; (2ca8 <chHeapFree+0xf8>)
    2bf8:	f7fd fe32 	bl	860 <chSysHalt>

    if (((qp == &heapp->h_free) || (hp > qp)) &&
    2bfc:	9b03      	ldr	r3, [sp, #12]
    2bfe:	f103 0208 	add.w	r2, r3, #8
    2c02:	9b05      	ldr	r3, [sp, #20]
    2c04:	429a      	cmp	r2, r3
    2c06:	d003      	beq.n	2c10 <chHeapFree+0x60>
    2c08:	9a04      	ldr	r2, [sp, #16]
    2c0a:	9b05      	ldr	r3, [sp, #20]
    2c0c:	429a      	cmp	r2, r3
    2c0e:	d93e      	bls.n	2c8e <chHeapFree+0xde>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
    2c10:	9b05      	ldr	r3, [sp, #20]
    2c12:	681b      	ldr	r3, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
    2c14:	2b00      	cmp	r3, #0
    2c16:	d004      	beq.n	2c22 <chHeapFree+0x72>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
    2c18:	9b05      	ldr	r3, [sp, #20]
    2c1a:	681a      	ldr	r2, [r3, #0]
    2c1c:	9b04      	ldr	r3, [sp, #16]
    2c1e:	429a      	cmp	r2, r3
    2c20:	d935      	bls.n	2c8e <chHeapFree+0xde>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
    2c22:	9b05      	ldr	r3, [sp, #20]
    2c24:	681a      	ldr	r2, [r3, #0]
    2c26:	9b04      	ldr	r3, [sp, #16]
    2c28:	601a      	str	r2, [r3, #0]
      qp->h.u.next = hp;
    2c2a:	9b05      	ldr	r3, [sp, #20]
    2c2c:	9a04      	ldr	r2, [sp, #16]
    2c2e:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
    2c30:	9b04      	ldr	r3, [sp, #16]
    2c32:	685b      	ldr	r3, [r3, #4]
    2c34:	3308      	adds	r3, #8
    2c36:	9a04      	ldr	r2, [sp, #16]
    2c38:	441a      	add	r2, r3
    2c3a:	9b04      	ldr	r3, [sp, #16]
    2c3c:	681b      	ldr	r3, [r3, #0]
    2c3e:	429a      	cmp	r2, r3
    2c40:	d10e      	bne.n	2c60 <chHeapFree+0xb0>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
    2c42:	9b04      	ldr	r3, [sp, #16]
    2c44:	685a      	ldr	r2, [r3, #4]
    2c46:	9b04      	ldr	r3, [sp, #16]
    2c48:	681b      	ldr	r3, [r3, #0]
    2c4a:	685b      	ldr	r3, [r3, #4]
    2c4c:	4413      	add	r3, r2
    2c4e:	f103 0208 	add.w	r2, r3, #8
    2c52:	9b04      	ldr	r3, [sp, #16]
    2c54:	605a      	str	r2, [r3, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
    2c56:	9b04      	ldr	r3, [sp, #16]
    2c58:	681b      	ldr	r3, [r3, #0]
    2c5a:	681a      	ldr	r2, [r3, #0]
    2c5c:	9b04      	ldr	r3, [sp, #16]
    2c5e:	601a      	str	r2, [r3, #0]
      }
      if ((LIMIT(qp) == hp)) {
    2c60:	9b05      	ldr	r3, [sp, #20]
    2c62:	685b      	ldr	r3, [r3, #4]
    2c64:	3308      	adds	r3, #8
    2c66:	9a05      	ldr	r2, [sp, #20]
    2c68:	441a      	add	r2, r3
    2c6a:	9b04      	ldr	r3, [sp, #16]
    2c6c:	429a      	cmp	r2, r3
    2c6e:	d10d      	bne.n	2c8c <chHeapFree+0xdc>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
    2c70:	9b05      	ldr	r3, [sp, #20]
    2c72:	685a      	ldr	r2, [r3, #4]
    2c74:	9b04      	ldr	r3, [sp, #16]
    2c76:	685b      	ldr	r3, [r3, #4]
    2c78:	4413      	add	r3, r2
    2c7a:	f103 0208 	add.w	r2, r3, #8
    2c7e:	9b05      	ldr	r3, [sp, #20]
    2c80:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
    2c82:	9b04      	ldr	r3, [sp, #16]
    2c84:	681a      	ldr	r2, [r3, #0]
    2c86:	9b05      	ldr	r3, [sp, #20]
    2c88:	601a      	str	r2, [r3, #0]
      }
      break;
    2c8a:	e004      	b.n	2c96 <chHeapFree+0xe6>
    2c8c:	e003      	b.n	2c96 <chHeapFree+0xe6>
    }
    qp = qp->h.u.next;
    2c8e:	9b05      	ldr	r3, [sp, #20]
    2c90:	681b      	ldr	r3, [r3, #0]
    2c92:	9305      	str	r3, [sp, #20]
  }
    2c94:	e7a3      	b.n	2bde <chHeapFree+0x2e>
  H_UNLOCK(heapp);
    2c96:	9b03      	ldr	r3, [sp, #12]
    2c98:	3310      	adds	r3, #16
    2c9a:	4618      	mov	r0, r3
    2c9c:	f7ff fa78 	bl	2190 <chMtxUnlock>

  return;
    2ca0:	bf00      	nop
}
    2ca2:	b007      	add	sp, #28
    2ca4:	f85d fb04 	ldr.w	pc, [sp], #4
    2ca8:	000048b0 	.word	0x000048b0
    2cac:	f3af 8000 	nop.w

00002cb0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2cb0:	b082      	sub	sp, #8
    2cb2:	2320      	movs	r3, #32
    2cb4:	9301      	str	r3, [sp, #4]
    2cb6:	9b01      	ldr	r3, [sp, #4]
    2cb8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2cbc:	b002      	add	sp, #8
    2cbe:	4770      	bx	lr

00002cc0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2cc0:	b082      	sub	sp, #8
    2cc2:	2300      	movs	r3, #0
    2cc4:	9301      	str	r3, [sp, #4]
    2cc6:	9b01      	ldr	r3, [sp, #4]
    2cc8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2ccc:	b002      	add	sp, #8
    2cce:	4770      	bx	lr

00002cd0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    2cd0:	b508      	push	{r3, lr}

  port_lock();
    2cd2:	f7ff ffed 	bl	2cb0 <port_lock>
  _stats_start_measure_crit_thd();
    2cd6:	f7fe ff23 	bl	1b20 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2cda:	f7fd fe29 	bl	930 <_dbg_check_lock>
}
    2cde:	bd08      	pop	{r3, pc}

00002ce0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2ce0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2ce2:	f7fd fe3d 	bl	960 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2ce6:	f7fe ff23 	bl	1b30 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    2cea:	4b09      	ldr	r3, [pc, #36]	; (2d10 <chSysUnlock+0x30>)
    2cec:	681a      	ldr	r2, [r3, #0]
    2cee:	4b08      	ldr	r3, [pc, #32]	; (2d10 <chSysUnlock+0x30>)
    2cf0:	429a      	cmp	r2, r3
    2cf2:	d00a      	beq.n	2d0a <chSysUnlock+0x2a>
    2cf4:	4b06      	ldr	r3, [pc, #24]	; (2d10 <chSysUnlock+0x30>)
    2cf6:	699b      	ldr	r3, [r3, #24]
    2cf8:	689a      	ldr	r2, [r3, #8]
    2cfa:	4b05      	ldr	r3, [pc, #20]	; (2d10 <chSysUnlock+0x30>)
    2cfc:	681b      	ldr	r3, [r3, #0]
    2cfe:	689b      	ldr	r3, [r3, #8]
    2d00:	429a      	cmp	r2, r3
    2d02:	d202      	bcs.n	2d0a <chSysUnlock+0x2a>
    2d04:	4803      	ldr	r0, [pc, #12]	; (2d14 <chSysUnlock+0x34>)
    2d06:	f7fd fdab 	bl	860 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    2d0a:	f7ff ffd9 	bl	2cc0 <port_unlock>
}
    2d0e:	bd08      	pop	{r3, pc}
    2d10:	20000ac0 	.word	0x20000ac0
    2d14:	000048c0 	.word	0x000048c0
    2d18:	f3af 8000 	nop.w
    2d1c:	f3af 8000 	nop.w

00002d20 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    2d20:	b500      	push	{lr}
    2d22:	b085      	sub	sp, #20
    2d24:	9001      	str	r0, [sp, #4]
    2d26:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
    2d28:	9b00      	ldr	r3, [sp, #0]
    2d2a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
    2d2c:	f7fd fea0 	bl	a70 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
    2d30:	9b01      	ldr	r3, [sp, #4]
    2d32:	2b00      	cmp	r3, #0
    2d34:	d002      	beq.n	2d3c <chPoolFreeI+0x1c>
    2d36:	9b00      	ldr	r3, [sp, #0]
    2d38:	2b00      	cmp	r3, #0
    2d3a:	d102      	bne.n	2d42 <chPoolFreeI+0x22>
    2d3c:	4806      	ldr	r0, [pc, #24]	; (2d58 <chPoolFreeI+0x38>)
    2d3e:	f7fd fd8f 	bl	860 <chSysHalt>

  php->ph_next = mp->mp_next;
    2d42:	9b01      	ldr	r3, [sp, #4]
    2d44:	681a      	ldr	r2, [r3, #0]
    2d46:	9b03      	ldr	r3, [sp, #12]
    2d48:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
    2d4a:	9b01      	ldr	r3, [sp, #4]
    2d4c:	9a03      	ldr	r2, [sp, #12]
    2d4e:	601a      	str	r2, [r3, #0]
}
    2d50:	b005      	add	sp, #20
    2d52:	f85d fb04 	ldr.w	pc, [sp], #4
    2d56:	bf00      	nop
    2d58:	000048d0 	.word	0x000048d0
    2d5c:	f3af 8000 	nop.w

00002d60 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
    2d60:	b500      	push	{lr}
    2d62:	b083      	sub	sp, #12
    2d64:	9001      	str	r0, [sp, #4]
    2d66:	9100      	str	r1, [sp, #0]

  chSysLock();
    2d68:	f7ff ffb2 	bl	2cd0 <chSysLock>
  chPoolFreeI(mp, objp);
    2d6c:	9801      	ldr	r0, [sp, #4]
    2d6e:	9900      	ldr	r1, [sp, #0]
    2d70:	f7ff ffd6 	bl	2d20 <chPoolFreeI>
  chSysUnlock();
    2d74:	f7ff ffb4 	bl	2ce0 <chSysUnlock>
}
    2d78:	b003      	add	sp, #12
    2d7a:	f85d fb04 	ldr.w	pc, [sp], #4
    2d7e:	bf00      	nop

00002d80 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2d80:	b082      	sub	sp, #8
    2d82:	2320      	movs	r3, #32
    2d84:	9301      	str	r3, [sp, #4]
    2d86:	9b01      	ldr	r3, [sp, #4]
    2d88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2d8c:	b002      	add	sp, #8
    2d8e:	4770      	bx	lr

00002d90 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2d90:	b082      	sub	sp, #8
    2d92:	2300      	movs	r3, #0
    2d94:	9301      	str	r3, [sp, #4]
    2d96:	9b01      	ldr	r3, [sp, #4]
    2d98:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2d9c:	b002      	add	sp, #8
    2d9e:	4770      	bx	lr

00002da0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    2da0:	b508      	push	{r3, lr}

  port_lock();
    2da2:	f7ff ffed 	bl	2d80 <port_lock>
}
    2da6:	bd08      	pop	{r3, pc}
    2da8:	f3af 8000 	nop.w
    2dac:	f3af 8000 	nop.w

00002db0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    2db0:	b508      	push	{r3, lr}

  port_unlock();
    2db2:	f7ff ffed 	bl	2d90 <port_unlock>
}
    2db6:	bd08      	pop	{r3, pc}
    2db8:	f3af 8000 	nop.w
    2dbc:	f3af 8000 	nop.w

00002dc0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
    2dc0:	b510      	push	{r4, lr}
    2dc2:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    2dc4:	f3ef 8309 	mrs	r3, PSP
    2dc8:	461c      	mov	r4, r3
  return(result);
    2dca:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
    2dcc:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
    2dce:	9b01      	ldr	r3, [sp, #4]
    2dd0:	3320      	adds	r3, #32
    2dd2:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
    2dd4:	9b01      	ldr	r3, [sp, #4]
    2dd6:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    2dd8:	9b00      	ldr	r3, [sp, #0]
    2dda:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
    2dde:	f7ff ffe7 	bl	2db0 <port_unlock_from_isr>
}
    2de2:	b002      	add	sp, #8
    2de4:	bd10      	pop	{r4, pc}
    2de6:	bf00      	nop
    2de8:	f3af 8000 	nop.w
    2dec:	f3af 8000 	nop.w

00002df0 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
    2df0:	b510      	push	{r4, lr}
    2df2:	b082      	sub	sp, #8

  port_lock_from_isr();
    2df4:	f7ff ffd4 	bl	2da0 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
    2df8:	4b13      	ldr	r3, [pc, #76]	; (2e48 <_port_irq_epilogue+0x58>)
    2dfa:	685b      	ldr	r3, [r3, #4]
    2dfc:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    2e00:	2b00      	cmp	r3, #0
    2e02:	d01d      	beq.n	2e40 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    2e04:	f3ef 8309 	mrs	r3, PSP
    2e08:	461c      	mov	r4, r3
  return(result);
    2e0a:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
    2e0c:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
    2e0e:	9b01      	ldr	r3, [sp, #4]
    2e10:	3b20      	subs	r3, #32
    2e12:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
    2e14:	9b01      	ldr	r3, [sp, #4]
    2e16:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    2e1a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
    2e1c:	9b01      	ldr	r3, [sp, #4]
    2e1e:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    2e20:	9b00      	ldr	r3, [sp, #0]
    2e22:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
    2e26:	f7fe f9fb 	bl	1220 <chSchIsPreemptionRequired>
    2e2a:	4603      	mov	r3, r0
    2e2c:	2b00      	cmp	r3, #0
    2e2e:	d003      	beq.n	2e38 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    2e30:	9b01      	ldr	r3, [sp, #4]
    2e32:	4a06      	ldr	r2, [pc, #24]	; (2e4c <_port_irq_epilogue+0x5c>)
    2e34:	619a      	str	r2, [r3, #24]
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
    2e36:	e005      	b.n	2e44 <_port_irq_epilogue+0x54>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    2e38:	9b01      	ldr	r3, [sp, #4]
    2e3a:	4a05      	ldr	r2, [pc, #20]	; (2e50 <_port_irq_epilogue+0x60>)
    2e3c:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
    2e3e:	e001      	b.n	2e44 <_port_irq_epilogue+0x54>
  }
  port_unlock_from_isr();
    2e40:	f7ff ffb6 	bl	2db0 <port_unlock_from_isr>
}
    2e44:	b002      	add	sp, #8
    2e46:	bd10      	pop	{r4, pc}
    2e48:	e000ed00 	.word	0xe000ed00
    2e4c:	000002a9 	.word	0x000002a9
    2e50:	000002bc 	.word	0x000002bc
    2e54:	f3af 8000 	nop.w
    2e58:	f3af 8000 	nop.w
    2e5c:	f3af 8000 	nop.w

00002e60 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    2e60:	4770      	bx	lr
    2e62:	bf00      	nop
    2e64:	f3af 8000 	nop.w
    2e68:	f3af 8000 	nop.w
    2e6c:	f3af 8000 	nop.w

00002e70 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
    2e70:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    2e72:	f7ff fff5 	bl	2e60 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
    2e76:	f000 facb 	bl	3410 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    2e7a:	4806      	ldr	r0, [pc, #24]	; (2e94 <halInit+0x24>)
    2e7c:	f001 f8a8 	bl	3fd0 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
    2e80:	f000 f88e 	bl	2fa0 <adcInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    2e84:	f000 f9e4 	bl	3250 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    2e88:	f001 fba2 	bl	45d0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    2e8c:	f000 f838 	bl	2f00 <stInit>
#endif
}
    2e90:	bd08      	pop	{r3, pc}
    2e92:	bf00      	nop
    2e94:	00004a20 	.word	0x00004a20
    2e98:	f3af 8000 	nop.w
    2e9c:	f3af 8000 	nop.w

00002ea0 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
    2ea0:	b082      	sub	sp, #8
    2ea2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
    2ea4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2ea8:	9a01      	ldr	r2, [sp, #4]
    2eaa:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
    2eac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2eb0:	2200      	movs	r2, #0
    2eb2:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
    2eb4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2eb8:	2202      	movs	r2, #2
    2eba:	60da      	str	r2, [r3, #12]
}
    2ebc:	b002      	add	sp, #8
    2ebe:	4770      	bx	lr

00002ec0 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
    2ec0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2ec4:	2200      	movs	r2, #0
    2ec6:	60da      	str	r2, [r3, #12]
}
    2ec8:	4770      	bx	lr
    2eca:	bf00      	nop
    2ecc:	f3af 8000 	nop.w

00002ed0 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
    2ed0:	b082      	sub	sp, #8
    2ed2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
    2ed4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2ed8:	9a01      	ldr	r2, [sp, #4]
    2eda:	635a      	str	r2, [r3, #52]	; 0x34
}
    2edc:	b002      	add	sp, #8
    2ede:	4770      	bx	lr

00002ee0 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
    2ee0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2ee4:	68db      	ldr	r3, [r3, #12]
    2ee6:	f003 0302 	and.w	r3, r3, #2
    2eea:	2b00      	cmp	r3, #0
    2eec:	bf0c      	ite	eq
    2eee:	2300      	moveq	r3, #0
    2ef0:	2301      	movne	r3, #1
    2ef2:	b2db      	uxtb	r3, r3
}
    2ef4:	4618      	mov	r0, r3
    2ef6:	4770      	bx	lr
    2ef8:	f3af 8000 	nop.w
    2efc:	f3af 8000 	nop.w

00002f00 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
    2f00:	b508      	push	{r3, lr}

  st_lld_init();
    2f02:	f000 fe6d 	bl	3be0 <st_lld_init>
}
    2f06:	bd08      	pop	{r3, pc}
    2f08:	f3af 8000 	nop.w
    2f0c:	f3af 8000 	nop.w

00002f10 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
    2f10:	b500      	push	{lr}
    2f12:	b083      	sub	sp, #12
    2f14:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
    2f16:	f7ff ffe3 	bl	2ee0 <st_lld_is_alarm_active>
    2f1a:	4603      	mov	r3, r0
    2f1c:	2b00      	cmp	r3, #0
    2f1e:	d002      	beq.n	2f26 <stStartAlarm+0x16>
    2f20:	4804      	ldr	r0, [pc, #16]	; (2f34 <stStartAlarm+0x24>)
    2f22:	f7fd fc9d 	bl	860 <chSysHalt>

  st_lld_start_alarm(abstime);
    2f26:	9801      	ldr	r0, [sp, #4]
    2f28:	f7ff ffba 	bl	2ea0 <st_lld_start_alarm>
}
    2f2c:	b003      	add	sp, #12
    2f2e:	f85d fb04 	ldr.w	pc, [sp], #4
    2f32:	bf00      	nop
    2f34:	000048e0 	.word	0x000048e0
    2f38:	f3af 8000 	nop.w
    2f3c:	f3af 8000 	nop.w

00002f40 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
    2f40:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
    2f42:	f7ff ffbd 	bl	2ec0 <st_lld_stop_alarm>
}
    2f46:	bd08      	pop	{r3, pc}
    2f48:	f3af 8000 	nop.w
    2f4c:	f3af 8000 	nop.w

00002f50 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
    2f50:	b500      	push	{lr}
    2f52:	b083      	sub	sp, #12
    2f54:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
    2f56:	f7ff ffc3 	bl	2ee0 <st_lld_is_alarm_active>
    2f5a:	4603      	mov	r3, r0
    2f5c:	f083 0301 	eor.w	r3, r3, #1
    2f60:	b2db      	uxtb	r3, r3
    2f62:	2b00      	cmp	r3, #0
    2f64:	d002      	beq.n	2f6c <stSetAlarm+0x1c>
    2f66:	4804      	ldr	r0, [pc, #16]	; (2f78 <stSetAlarm+0x28>)
    2f68:	f7fd fc7a 	bl	860 <chSysHalt>

  st_lld_set_alarm(abstime);
    2f6c:	9801      	ldr	r0, [sp, #4]
    2f6e:	f7ff ffaf 	bl	2ed0 <st_lld_set_alarm>
}
    2f72:	b003      	add	sp, #12
    2f74:	f85d fb04 	ldr.w	pc, [sp], #4
    2f78:	000048f0 	.word	0x000048f0
    2f7c:	f3af 8000 	nop.w

00002f80 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
    2f80:	b500      	push	{lr}
    2f82:	b083      	sub	sp, #12
    2f84:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
    2f86:	9801      	ldr	r0, [sp, #4]
    2f88:	f7ff f85a 	bl	2040 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
    2f8c:	b003      	add	sp, #12
    2f8e:	f85d fb04 	ldr.w	pc, [sp], #4
    2f92:	bf00      	nop
    2f94:	f3af 8000 	nop.w
    2f98:	f3af 8000 	nop.w
    2f9c:	f3af 8000 	nop.w

00002fa0 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
    2fa0:	b508      	push	{r3, lr}

  adc_lld_init();
    2fa2:	f000 ff75 	bl	3e90 <adc_lld_init>
}
    2fa6:	bd08      	pop	{r3, pc}
    2fa8:	f3af 8000 	nop.w
    2fac:	f3af 8000 	nop.w

00002fb0 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
    2fb0:	b500      	push	{lr}
    2fb2:	b083      	sub	sp, #12
    2fb4:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
    2fb6:	9b01      	ldr	r3, [sp, #4]
    2fb8:	2201      	movs	r2, #1
    2fba:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
    2fbc:	9b01      	ldr	r3, [sp, #4]
    2fbe:	2200      	movs	r2, #0
    2fc0:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
    2fc2:	9b01      	ldr	r3, [sp, #4]
    2fc4:	2200      	movs	r2, #0
    2fc6:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
    2fc8:	9b01      	ldr	r3, [sp, #4]
    2fca:	2200      	movs	r2, #0
    2fcc:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
    2fce:	9b01      	ldr	r3, [sp, #4]
    2fd0:	2200      	movs	r2, #0
    2fd2:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
    2fd4:	9b01      	ldr	r3, [sp, #4]
    2fd6:	2200      	movs	r2, #0
    2fd8:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
    2fda:	9b01      	ldr	r3, [sp, #4]
    2fdc:	3318      	adds	r3, #24
    2fde:	4618      	mov	r0, r3
    2fe0:	f7ff ffce 	bl	2f80 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
    2fe4:	b003      	add	sp, #12
    2fe6:	f85d fb04 	ldr.w	pc, [sp], #4
    2fea:	bf00      	nop
    2fec:	f3af 8000 	nop.w

00002ff0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2ff0:	b082      	sub	sp, #8
    2ff2:	2320      	movs	r3, #32
    2ff4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    2ff6:	9b01      	ldr	r3, [sp, #4]
    2ff8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2ffc:	b002      	add	sp, #8
    2ffe:	4770      	bx	lr

00003000 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    3000:	b082      	sub	sp, #8
    3002:	2300      	movs	r3, #0
    3004:	9301      	str	r3, [sp, #4]
    3006:	9b01      	ldr	r3, [sp, #4]
    3008:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    300c:	b002      	add	sp, #8
    300e:	4770      	bx	lr

00003010 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    3010:	b508      	push	{r3, lr}

  port_lock();
    3012:	f7ff ffed 	bl	2ff0 <port_lock>
  _stats_start_measure_crit_thd();
    3016:	f7fe fd83 	bl	1b20 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    301a:	f7fd fc89 	bl	930 <_dbg_check_lock>
}
    301e:	bd08      	pop	{r3, pc}

00003020 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    3020:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    3022:	f7fd fc9d 	bl	960 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    3026:	f7fe fd83 	bl	1b30 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    302a:	4b09      	ldr	r3, [pc, #36]	; (3050 <chSysUnlock+0x30>)
    302c:	681a      	ldr	r2, [r3, #0]
    302e:	4b08      	ldr	r3, [pc, #32]	; (3050 <chSysUnlock+0x30>)
    3030:	429a      	cmp	r2, r3
    3032:	d00a      	beq.n	304a <chSysUnlock+0x2a>
    3034:	4b06      	ldr	r3, [pc, #24]	; (3050 <chSysUnlock+0x30>)
    3036:	699b      	ldr	r3, [r3, #24]
    3038:	689a      	ldr	r2, [r3, #8]
    303a:	4b05      	ldr	r3, [pc, #20]	; (3050 <chSysUnlock+0x30>)
    303c:	681b      	ldr	r3, [r3, #0]
    303e:	689b      	ldr	r3, [r3, #8]
    3040:	429a      	cmp	r2, r3
    3042:	d202      	bcs.n	304a <chSysUnlock+0x2a>
    3044:	4803      	ldr	r0, [pc, #12]	; (3054 <chSysUnlock+0x34>)
    3046:	f7fd fc0b 	bl	860 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    304a:	f7ff ffd9 	bl	3000 <port_unlock>
}
    304e:	bd08      	pop	{r3, pc}
    3050:	20000ac0 	.word	0x20000ac0
    3054:	00004930 	.word	0x00004930
    3058:	f3af 8000 	nop.w
    305c:	f3af 8000 	nop.w

00003060 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
    3060:	b082      	sub	sp, #8
    3062:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
    3064:	9b01      	ldr	r3, [sp, #4]
    3066:	9a01      	ldr	r2, [sp, #4]
    3068:	601a      	str	r2, [r3, #0]
}
    306a:	b002      	add	sp, #8
    306c:	4770      	bx	lr
    306e:	bf00      	nop

00003070 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
    3070:	b500      	push	{lr}
    3072:	b083      	sub	sp, #12
    3074:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    3076:	f7fd fcfb 	bl	a70 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
    307a:	9b01      	ldr	r3, [sp, #4]
    307c:	689b      	ldr	r3, [r3, #8]
    307e:	2b00      	cmp	r3, #0
    3080:	bf14      	ite	ne
    3082:	2300      	movne	r3, #0
    3084:	2301      	moveq	r3, #1
    3086:	b2db      	uxtb	r3, r3
}
    3088:	4618      	mov	r0, r3
    308a:	b003      	add	sp, #12
    308c:	f85d fb04 	ldr.w	pc, [sp], #4

00003090 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
    3090:	b508      	push	{r3, lr}

  chSysLock();
    3092:	f7ff ffbd 	bl	3010 <chSysLock>
}
    3096:	bd08      	pop	{r3, pc}
    3098:	f3af 8000 	nop.w
    309c:	f3af 8000 	nop.w

000030a0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
    30a0:	b508      	push	{r3, lr}

  chSysUnlock();
    30a2:	f7ff ffbd 	bl	3020 <chSysUnlock>
}
    30a6:	bd08      	pop	{r3, pc}
    30a8:	f3af 8000 	nop.w
    30ac:	f3af 8000 	nop.w

000030b0 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    30b0:	b500      	push	{lr}
    30b2:	b083      	sub	sp, #12
    30b4:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
    30b6:	9801      	ldr	r0, [sp, #4]
    30b8:	f7ff ffd2 	bl	3060 <chEvtObjectInit>
}
    30bc:	b003      	add	sp, #12
    30be:	f85d fb04 	ldr.w	pc, [sp], #4
    30c2:	bf00      	nop
    30c4:	f3af 8000 	nop.w
    30c8:	f3af 8000 	nop.w
    30cc:	f3af 8000 	nop.w

000030d0 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    30d0:	b500      	push	{lr}
    30d2:	b083      	sub	sp, #12
    30d4:	9001      	str	r0, [sp, #4]
    30d6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
    30d8:	9801      	ldr	r0, [sp, #4]
    30da:	9900      	ldr	r1, [sp, #0]
    30dc:	f7ff f8d0 	bl	2280 <chEvtBroadcastFlagsI>
}
    30e0:	b003      	add	sp, #12
    30e2:	f85d fb04 	ldr.w	pc, [sp], #4
    30e6:	bf00      	nop
    30e8:	f3af 8000 	nop.w
    30ec:	f3af 8000 	nop.w

000030f0 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    30f0:	b500      	push	{lr}
    30f2:	b085      	sub	sp, #20
    30f4:	9003      	str	r0, [sp, #12]
    30f6:	9102      	str	r1, [sp, #8]
    30f8:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    30fa:	9b03      	ldr	r3, [sp, #12]
    30fc:	3330      	adds	r3, #48	; 0x30
    30fe:	4618      	mov	r0, r3
    3100:	9902      	ldr	r1, [sp, #8]
    3102:	9a01      	ldr	r2, [sp, #4]
    3104:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3108:	f7ff fc52 	bl	29b0 <chOQWriteTimeout>
    310c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
    310e:	4618      	mov	r0, r3
    3110:	b005      	add	sp, #20
    3112:	f85d fb04 	ldr.w	pc, [sp], #4
    3116:	bf00      	nop
    3118:	f3af 8000 	nop.w
    311c:	f3af 8000 	nop.w

00003120 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    3120:	b500      	push	{lr}
    3122:	b085      	sub	sp, #20
    3124:	9003      	str	r0, [sp, #12]
    3126:	9102      	str	r1, [sp, #8]
    3128:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    312a:	9b03      	ldr	r3, [sp, #12]
    312c:	330c      	adds	r3, #12
    312e:	4618      	mov	r0, r3
    3130:	9902      	ldr	r1, [sp, #8]
    3132:	9a01      	ldr	r2, [sp, #4]
    3134:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3138:	f7ff fb3a 	bl	27b0 <chIQReadTimeout>
    313c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
    313e:	4618      	mov	r0, r3
    3140:	b005      	add	sp, #20
    3142:	f85d fb04 	ldr.w	pc, [sp], #4
    3146:	bf00      	nop
    3148:	f3af 8000 	nop.w
    314c:	f3af 8000 	nop.w

00003150 <put>:

static msg_t put(void *ip, uint8_t b) {
    3150:	b500      	push	{lr}
    3152:	b083      	sub	sp, #12
    3154:	9001      	str	r0, [sp, #4]
    3156:	460b      	mov	r3, r1
    3158:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    315c:	9b01      	ldr	r3, [sp, #4]
    315e:	f103 0230 	add.w	r2, r3, #48	; 0x30
    3162:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3166:	4610      	mov	r0, r2
    3168:	4619      	mov	r1, r3
    316a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    316e:	f7ff fba7 	bl	28c0 <chOQPutTimeout>
    3172:	4603      	mov	r3, r0
}
    3174:	4618      	mov	r0, r3
    3176:	b003      	add	sp, #12
    3178:	f85d fb04 	ldr.w	pc, [sp], #4
    317c:	f3af 8000 	nop.w

00003180 <get>:

static msg_t get(void *ip) {
    3180:	b500      	push	{lr}
    3182:	b083      	sub	sp, #12
    3184:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    3186:	9b01      	ldr	r3, [sp, #4]
    3188:	330c      	adds	r3, #12
    318a:	4618      	mov	r0, r3
    318c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3190:	f7ff fac6 	bl	2720 <chIQGetTimeout>
    3194:	4603      	mov	r3, r0
}
    3196:	4618      	mov	r0, r3
    3198:	b003      	add	sp, #12
    319a:	f85d fb04 	ldr.w	pc, [sp], #4
    319e:	bf00      	nop

000031a0 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    31a0:	b500      	push	{lr}
    31a2:	b085      	sub	sp, #20
    31a4:	9003      	str	r0, [sp, #12]
    31a6:	460b      	mov	r3, r1
    31a8:	9201      	str	r2, [sp, #4]
    31aa:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    31ae:	9b03      	ldr	r3, [sp, #12]
    31b0:	f103 0230 	add.w	r2, r3, #48	; 0x30
    31b4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    31b8:	4610      	mov	r0, r2
    31ba:	4619      	mov	r1, r3
    31bc:	9a01      	ldr	r2, [sp, #4]
    31be:	f7ff fb7f 	bl	28c0 <chOQPutTimeout>
    31c2:	4603      	mov	r3, r0
}
    31c4:	4618      	mov	r0, r3
    31c6:	b005      	add	sp, #20
    31c8:	f85d fb04 	ldr.w	pc, [sp], #4
    31cc:	f3af 8000 	nop.w

000031d0 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    31d0:	b500      	push	{lr}
    31d2:	b083      	sub	sp, #12
    31d4:	9001      	str	r0, [sp, #4]
    31d6:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    31d8:	9b01      	ldr	r3, [sp, #4]
    31da:	330c      	adds	r3, #12
    31dc:	4618      	mov	r0, r3
    31de:	9900      	ldr	r1, [sp, #0]
    31e0:	f7ff fa9e 	bl	2720 <chIQGetTimeout>
    31e4:	4603      	mov	r3, r0
}
    31e6:	4618      	mov	r0, r3
    31e8:	b003      	add	sp, #12
    31ea:	f85d fb04 	ldr.w	pc, [sp], #4
    31ee:	bf00      	nop

000031f0 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    31f0:	b500      	push	{lr}
    31f2:	b085      	sub	sp, #20
    31f4:	9003      	str	r0, [sp, #12]
    31f6:	9102      	str	r1, [sp, #8]
    31f8:	9201      	str	r2, [sp, #4]
    31fa:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    31fc:	9b03      	ldr	r3, [sp, #12]
    31fe:	3330      	adds	r3, #48	; 0x30
    3200:	4618      	mov	r0, r3
    3202:	9902      	ldr	r1, [sp, #8]
    3204:	9a01      	ldr	r2, [sp, #4]
    3206:	9b00      	ldr	r3, [sp, #0]
    3208:	f7ff fbd2 	bl	29b0 <chOQWriteTimeout>
    320c:	4603      	mov	r3, r0
}
    320e:	4618      	mov	r0, r3
    3210:	b005      	add	sp, #20
    3212:	f85d fb04 	ldr.w	pc, [sp], #4
    3216:	bf00      	nop
    3218:	f3af 8000 	nop.w
    321c:	f3af 8000 	nop.w

00003220 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    3220:	b500      	push	{lr}
    3222:	b085      	sub	sp, #20
    3224:	9003      	str	r0, [sp, #12]
    3226:	9102      	str	r1, [sp, #8]
    3228:	9201      	str	r2, [sp, #4]
    322a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    322c:	9b03      	ldr	r3, [sp, #12]
    322e:	330c      	adds	r3, #12
    3230:	4618      	mov	r0, r3
    3232:	9902      	ldr	r1, [sp, #8]
    3234:	9a01      	ldr	r2, [sp, #4]
    3236:	9b00      	ldr	r3, [sp, #0]
    3238:	f7ff faba 	bl	27b0 <chIQReadTimeout>
    323c:	4603      	mov	r3, r0
}
    323e:	4618      	mov	r0, r3
    3240:	b005      	add	sp, #20
    3242:	f85d fb04 	ldr.w	pc, [sp], #4
    3246:	bf00      	nop
    3248:	f3af 8000 	nop.w
    324c:	f3af 8000 	nop.w

00003250 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
    3250:	b508      	push	{r3, lr}

  sd_lld_init();
    3252:	f001 f975 	bl	4540 <sd_lld_init>
}
    3256:	bd08      	pop	{r3, pc}
    3258:	f3af 8000 	nop.w
    325c:	f3af 8000 	nop.w

00003260 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    3260:	b500      	push	{lr}
    3262:	b087      	sub	sp, #28
    3264:	9005      	str	r0, [sp, #20]
    3266:	9104      	str	r1, [sp, #16]
    3268:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
    326a:	9b05      	ldr	r3, [sp, #20]
    326c:	4a13      	ldr	r2, [pc, #76]	; (32bc <sdObjectInit+0x5c>)
    326e:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
    3270:	9b05      	ldr	r3, [sp, #20]
    3272:	3304      	adds	r3, #4
    3274:	4618      	mov	r0, r3
    3276:	f7ff ff1b 	bl	30b0 <osalEventObjectInit>
  sdp->state = SD_STOP;
    327a:	9b05      	ldr	r3, [sp, #20]
    327c:	2201      	movs	r2, #1
    327e:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    3280:	9b05      	ldr	r3, [sp, #20]
    3282:	f103 020c 	add.w	r2, r3, #12
    3286:	9b05      	ldr	r3, [sp, #20]
    3288:	3354      	adds	r3, #84	; 0x54
    328a:	9905      	ldr	r1, [sp, #20]
    328c:	9100      	str	r1, [sp, #0]
    328e:	4610      	mov	r0, r2
    3290:	4619      	mov	r1, r3
    3292:	2220      	movs	r2, #32
    3294:	9b04      	ldr	r3, [sp, #16]
    3296:	f7ff f9e3 	bl	2660 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    329a:	9b05      	ldr	r3, [sp, #20]
    329c:	f103 0230 	add.w	r2, r3, #48	; 0x30
    32a0:	9b05      	ldr	r3, [sp, #20]
    32a2:	3374      	adds	r3, #116	; 0x74
    32a4:	9905      	ldr	r1, [sp, #20]
    32a6:	9100      	str	r1, [sp, #0]
    32a8:	4610      	mov	r0, r2
    32aa:	4619      	mov	r1, r3
    32ac:	2220      	movs	r2, #32
    32ae:	9b03      	ldr	r3, [sp, #12]
    32b0:	f7ff fade 	bl	2870 <chOQObjectInit>
}
    32b4:	b007      	add	sp, #28
    32b6:	f85d fb04 	ldr.w	pc, [sp], #4
    32ba:	bf00      	nop
    32bc:	00004900 	.word	0x00004900

000032c0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    32c0:	b500      	push	{lr}
    32c2:	b083      	sub	sp, #12
    32c4:	9001      	str	r0, [sp, #4]
    32c6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);
    32c8:	9b01      	ldr	r3, [sp, #4]
    32ca:	2b00      	cmp	r3, #0
    32cc:	d102      	bne.n	32d4 <sdStart+0x14>
    32ce:	480e      	ldr	r0, [pc, #56]	; (3308 <sdStart+0x48>)
    32d0:	f7fd fac6 	bl	860 <chSysHalt>

  osalSysLock();
    32d4:	f7ff fedc 	bl	3090 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
    32d8:	9b01      	ldr	r3, [sp, #4]
    32da:	7a1b      	ldrb	r3, [r3, #8]
    32dc:	2b01      	cmp	r3, #1
    32de:	d006      	beq.n	32ee <sdStart+0x2e>
    32e0:	9b01      	ldr	r3, [sp, #4]
    32e2:	7a1b      	ldrb	r3, [r3, #8]
    32e4:	2b02      	cmp	r3, #2
    32e6:	d002      	beq.n	32ee <sdStart+0x2e>
    32e8:	4807      	ldr	r0, [pc, #28]	; (3308 <sdStart+0x48>)
    32ea:	f7fd fab9 	bl	860 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
    32ee:	9801      	ldr	r0, [sp, #4]
    32f0:	9900      	ldr	r1, [sp, #0]
    32f2:	f001 f93d 	bl	4570 <sd_lld_start>
  sdp->state = SD_READY;
    32f6:	9b01      	ldr	r3, [sp, #4]
    32f8:	2202      	movs	r2, #2
    32fa:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
    32fc:	f7ff fed0 	bl	30a0 <osalSysUnlock>
}
    3300:	b003      	add	sp, #12
    3302:	f85d fb04 	ldr.w	pc, [sp], #4
    3306:	bf00      	nop
    3308:	00004920 	.word	0x00004920
    330c:	f3af 8000 	nop.w

00003310 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    3310:	b500      	push	{lr}
    3312:	b083      	sub	sp, #12
    3314:	9001      	str	r0, [sp, #4]
    3316:	460b      	mov	r3, r1
    3318:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
    331c:	f7fd fba8 	bl	a70 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
    3320:	9b01      	ldr	r3, [sp, #4]
    3322:	2b00      	cmp	r3, #0
    3324:	d102      	bne.n	332c <sdIncomingDataI+0x1c>
    3326:	4813      	ldr	r0, [pc, #76]	; (3374 <sdIncomingDataI+0x64>)
    3328:	f7fd fa9a 	bl	860 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
    332c:	9b01      	ldr	r3, [sp, #4]
    332e:	330c      	adds	r3, #12
    3330:	4618      	mov	r0, r3
    3332:	f7ff fe9d 	bl	3070 <chIQIsEmptyI>
    3336:	4603      	mov	r3, r0
    3338:	2b00      	cmp	r3, #0
    333a:	d005      	beq.n	3348 <sdIncomingDataI+0x38>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    333c:	9b01      	ldr	r3, [sp, #4]
    333e:	3304      	adds	r3, #4
    3340:	4618      	mov	r0, r3
    3342:	2104      	movs	r1, #4
    3344:	f7ff fec4 	bl	30d0 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
    3348:	9b01      	ldr	r3, [sp, #4]
    334a:	f103 020c 	add.w	r2, r3, #12
    334e:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3352:	4610      	mov	r0, r2
    3354:	4619      	mov	r1, r3
    3356:	f7ff f9ab 	bl	26b0 <chIQPutI>
    335a:	4603      	mov	r3, r0
    335c:	2b00      	cmp	r3, #0
    335e:	da05      	bge.n	336c <sdIncomingDataI+0x5c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    3360:	9b01      	ldr	r3, [sp, #4]
    3362:	3304      	adds	r3, #4
    3364:	4618      	mov	r0, r3
    3366:	2180      	movs	r1, #128	; 0x80
    3368:	f7ff feb2 	bl	30d0 <osalEventBroadcastFlagsI>
}
    336c:	b003      	add	sp, #12
    336e:	f85d fb04 	ldr.w	pc, [sp], #4
    3372:	bf00      	nop
    3374:	00004940 	.word	0x00004940
    3378:	f3af 8000 	nop.w
    337c:	f3af 8000 	nop.w

00003380 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
    3380:	b082      	sub	sp, #8
    3382:	9001      	str	r0, [sp, #4]
    3384:	9100      	str	r1, [sp, #0]

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
    3386:	4911      	ldr	r1, [pc, #68]	; (33cc <nvicEnableVector+0x4c>)
    3388:	9b00      	ldr	r3, [sp, #0]
    338a:	b2db      	uxtb	r3, r3
    338c:	011b      	lsls	r3, r3, #4
    338e:	b2da      	uxtb	r2, r3
    3390:	9b01      	ldr	r3, [sp, #4]
    3392:	440b      	add	r3, r1
    3394:	f503 7340 	add.w	r3, r3, #768	; 0x300
    3398:	701a      	strb	r2, [r3, #0]
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
    339a:	4b0c      	ldr	r3, [pc, #48]	; (33cc <nvicEnableVector+0x4c>)
    339c:	9a01      	ldr	r2, [sp, #4]
    339e:	0952      	lsrs	r2, r2, #5
    33a0:	9901      	ldr	r1, [sp, #4]
    33a2:	f001 011f 	and.w	r1, r1, #31
    33a6:	2001      	movs	r0, #1
    33a8:	fa00 f101 	lsl.w	r1, r0, r1
    33ac:	3260      	adds	r2, #96	; 0x60
    33ae:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
    33b2:	4b06      	ldr	r3, [pc, #24]	; (33cc <nvicEnableVector+0x4c>)
    33b4:	9a01      	ldr	r2, [sp, #4]
    33b6:	0952      	lsrs	r2, r2, #5
    33b8:	9901      	ldr	r1, [sp, #4]
    33ba:	f001 011f 	and.w	r1, r1, #31
    33be:	2001      	movs	r0, #1
    33c0:	fa00 f101 	lsl.w	r1, r0, r1
    33c4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    33c8:	b002      	add	sp, #8
    33ca:	4770      	bx	lr
    33cc:	e000e100 	.word	0xe000e100

000033d0 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
    33d0:	4b0d      	ldr	r3, [pc, #52]	; (3408 <hal_lld_backup_domain_init+0x38>)
    33d2:	4a0d      	ldr	r2, [pc, #52]	; (3408 <hal_lld_backup_domain_init+0x38>)
    33d4:	6812      	ldr	r2, [r2, #0]
    33d6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    33da:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
    33dc:	4b0b      	ldr	r3, [pc, #44]	; (340c <hal_lld_backup_domain_init+0x3c>)
    33de:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    33e0:	f403 7340 	and.w	r3, r3, #768	; 0x300
    33e4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    33e8:	d006      	beq.n	33f8 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
    33ea:	4b08      	ldr	r3, [pc, #32]	; (340c <hal_lld_backup_domain_init+0x3c>)
    33ec:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    33f0:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
    33f2:	4b06      	ldr	r3, [pc, #24]	; (340c <hal_lld_backup_domain_init+0x3c>)
    33f4:	2200      	movs	r2, #0
    33f6:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
    33f8:	4b03      	ldr	r3, [pc, #12]	; (3408 <hal_lld_backup_domain_init+0x38>)
    33fa:	4a03      	ldr	r2, [pc, #12]	; (3408 <hal_lld_backup_domain_init+0x38>)
    33fc:	6852      	ldr	r2, [r2, #4]
    33fe:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    3402:	605a      	str	r2, [r3, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
    3404:	4770      	bx	lr
    3406:	bf00      	nop
    3408:	40007000 	.word	0x40007000
    340c:	40023800 	.word	0x40023800

00003410 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
    3410:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
    3412:	4b17      	ldr	r3, [pc, #92]	; (3470 <hal_lld_init+0x60>)
    3414:	691b      	ldr	r3, [r3, #16]
    3416:	4b16      	ldr	r3, [pc, #88]	; (3470 <hal_lld_init+0x60>)
    3418:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    341c:	611a      	str	r2, [r3, #16]
    341e:	4b14      	ldr	r3, [pc, #80]	; (3470 <hal_lld_init+0x60>)
    3420:	2200      	movs	r2, #0
    3422:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
    3424:	4b12      	ldr	r3, [pc, #72]	; (3470 <hal_lld_init+0x60>)
    3426:	695b      	ldr	r3, [r3, #20]
    3428:	4b11      	ldr	r3, [pc, #68]	; (3470 <hal_lld_init+0x60>)
    342a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    342e:	615a      	str	r2, [r3, #20]
    3430:	4b0f      	ldr	r3, [pc, #60]	; (3470 <hal_lld_init+0x60>)
    3432:	2200      	movs	r2, #0
    3434:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
    3436:	4b0e      	ldr	r3, [pc, #56]	; (3470 <hal_lld_init+0x60>)
    3438:	4a0d      	ldr	r2, [pc, #52]	; (3470 <hal_lld_init+0x60>)
    343a:	6a12      	ldr	r2, [r2, #32]
    343c:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
    3440:	621a      	str	r2, [r3, #32]
    3442:	4b0b      	ldr	r3, [pc, #44]	; (3470 <hal_lld_init+0x60>)
    3444:	2200      	movs	r2, #0
    3446:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
    3448:	4b09      	ldr	r3, [pc, #36]	; (3470 <hal_lld_init+0x60>)
    344a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    344c:	4b08      	ldr	r3, [pc, #32]	; (3470 <hal_lld_init+0x60>)
    344e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3452:	625a      	str	r2, [r3, #36]	; 0x24
    3454:	4b06      	ldr	r3, [pc, #24]	; (3470 <hal_lld_init+0x60>)
    3456:	2200      	movs	r2, #0
    3458:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
    345a:	4b05      	ldr	r3, [pc, #20]	; (3470 <hal_lld_init+0x60>)
    345c:	4a04      	ldr	r2, [pc, #16]	; (3470 <hal_lld_init+0x60>)
    345e:	6c12      	ldr	r2, [r2, #64]	; 0x40
    3460:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    3464:	641a      	str	r2, [r3, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
    3466:	f7ff ffb3 	bl	33d0 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
    346a:	f000 fb19 	bl	3aa0 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
    346e:	bd08      	pop	{r3, pc}
    3470:	40023800 	.word	0x40023800
    3474:	f3af 8000 	nop.w
    3478:	f3af 8000 	nop.w
    347c:	f3af 8000 	nop.w

00003480 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
    3480:	4b40      	ldr	r3, [pc, #256]	; (3584 <stm32_clock_init+0x104>)
    3482:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    3486:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
    3488:	4b3f      	ldr	r3, [pc, #252]	; (3588 <stm32_clock_init+0x108>)
    348a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    348e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
    3490:	4b3c      	ldr	r3, [pc, #240]	; (3584 <stm32_clock_init+0x104>)
    3492:	4a3c      	ldr	r2, [pc, #240]	; (3584 <stm32_clock_init+0x104>)
    3494:	6812      	ldr	r2, [r2, #0]
    3496:	f042 0201 	orr.w	r2, r2, #1
    349a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
    349c:	bf00      	nop
    349e:	4b39      	ldr	r3, [pc, #228]	; (3584 <stm32_clock_init+0x104>)
    34a0:	681b      	ldr	r3, [r3, #0]
    34a2:	f003 0302 	and.w	r3, r3, #2
    34a6:	2b00      	cmp	r3, #0
    34a8:	d0f9      	beq.n	349e <stm32_clock_init+0x1e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
    34aa:	4b36      	ldr	r3, [pc, #216]	; (3584 <stm32_clock_init+0x104>)
    34ac:	4a35      	ldr	r2, [pc, #212]	; (3584 <stm32_clock_init+0x104>)
    34ae:	6892      	ldr	r2, [r2, #8]
    34b0:	f022 0203 	bic.w	r2, r2, #3
    34b4:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
    34b6:	4b33      	ldr	r3, [pc, #204]	; (3584 <stm32_clock_init+0x104>)
    34b8:	4a32      	ldr	r2, [pc, #200]	; (3584 <stm32_clock_init+0x104>)
    34ba:	6892      	ldr	r2, [r2, #8]
    34bc:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
    34be:	bf00      	nop
    34c0:	4b30      	ldr	r3, [pc, #192]	; (3584 <stm32_clock_init+0x104>)
    34c2:	689b      	ldr	r3, [r3, #8]
    34c4:	f003 030c 	and.w	r3, r3, #12
    34c8:	2b00      	cmp	r3, #0
    34ca:	d1f9      	bne.n	34c0 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
    34cc:	4b2d      	ldr	r3, [pc, #180]	; (3584 <stm32_clock_init+0x104>)
    34ce:	4a2d      	ldr	r2, [pc, #180]	; (3584 <stm32_clock_init+0x104>)
    34d0:	6812      	ldr	r2, [r2, #0]
    34d2:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
    34d6:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
    34d8:	4b2a      	ldr	r3, [pc, #168]	; (3584 <stm32_clock_init+0x104>)
    34da:	2200      	movs	r2, #0
    34dc:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
    34de:	4b29      	ldr	r3, [pc, #164]	; (3584 <stm32_clock_init+0x104>)
    34e0:	4a28      	ldr	r2, [pc, #160]	; (3584 <stm32_clock_init+0x104>)
    34e2:	6812      	ldr	r2, [r2, #0]
    34e4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    34e8:	601a      	str	r2, [r3, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
    34ea:	bf00      	nop
    34ec:	4b25      	ldr	r3, [pc, #148]	; (3584 <stm32_clock_init+0x104>)
    34ee:	681b      	ldr	r3, [r3, #0]
    34f0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    34f4:	2b00      	cmp	r3, #0
    34f6:	d0f9      	beq.n	34ec <stm32_clock_init+0x6c>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
    34f8:	4b22      	ldr	r3, [pc, #136]	; (3584 <stm32_clock_init+0x104>)
    34fa:	4a22      	ldr	r2, [pc, #136]	; (3584 <stm32_clock_init+0x104>)
    34fc:	6f52      	ldr	r2, [r2, #116]	; 0x74
    34fe:	f042 0201 	orr.w	r2, r2, #1
    3502:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
    3504:	bf00      	nop
    3506:	4b1f      	ldr	r3, [pc, #124]	; (3584 <stm32_clock_init+0x104>)
    3508:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    350a:	f003 0302 	and.w	r3, r3, #2
    350e:	2b00      	cmp	r3, #0
    3510:	d0f9      	beq.n	3506 <stm32_clock_init+0x86>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
    3512:	4b1c      	ldr	r3, [pc, #112]	; (3584 <stm32_clock_init+0x104>)
    3514:	4a1d      	ldr	r2, [pc, #116]	; (358c <stm32_clock_init+0x10c>)
    3516:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
    3518:	4b1a      	ldr	r3, [pc, #104]	; (3584 <stm32_clock_init+0x104>)
    351a:	4a1a      	ldr	r2, [pc, #104]	; (3584 <stm32_clock_init+0x104>)
    351c:	6812      	ldr	r2, [r2, #0]
    351e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    3522:	601a      	str	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
    3524:	bf00      	nop
    3526:	4b18      	ldr	r3, [pc, #96]	; (3588 <stm32_clock_init+0x108>)
    3528:	685b      	ldr	r3, [r3, #4]
    352a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    352e:	2b00      	cmp	r3, #0
    3530:	d0f9      	beq.n	3526 <stm32_clock_init+0xa6>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
    3532:	bf00      	nop
    3534:	4b13      	ldr	r3, [pc, #76]	; (3584 <stm32_clock_init+0x104>)
    3536:	681b      	ldr	r3, [r3, #0]
    3538:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    353c:	2b00      	cmp	r3, #0
    353e:	d0f9      	beq.n	3534 <stm32_clock_init+0xb4>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
    3540:	4b10      	ldr	r3, [pc, #64]	; (3584 <stm32_clock_init+0x104>)
    3542:	4a13      	ldr	r2, [pc, #76]	; (3590 <stm32_clock_init+0x110>)
    3544:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
    3546:	4b13      	ldr	r3, [pc, #76]	; (3594 <stm32_clock_init+0x114>)
    3548:	f240 7205 	movw	r2, #1797	; 0x705
    354c:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
    354e:	4b0d      	ldr	r3, [pc, #52]	; (3584 <stm32_clock_init+0x104>)
    3550:	4a0c      	ldr	r2, [pc, #48]	; (3584 <stm32_clock_init+0x104>)
    3552:	6892      	ldr	r2, [r2, #8]
    3554:	f042 0202 	orr.w	r2, r2, #2
    3558:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
    355a:	bf00      	nop
    355c:	4b09      	ldr	r3, [pc, #36]	; (3584 <stm32_clock_init+0x104>)
    355e:	689b      	ldr	r3, [r3, #8]
    3560:	f003 030c 	and.w	r3, r3, #12
    3564:	2b08      	cmp	r3, #8
    3566:	d1f9      	bne.n	355c <stm32_clock_init+0xdc>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
    3568:	4b06      	ldr	r3, [pc, #24]	; (3584 <stm32_clock_init+0x104>)
    356a:	4a06      	ldr	r2, [pc, #24]	; (3584 <stm32_clock_init+0x104>)
    356c:	6c52      	ldr	r2, [r2, #68]	; 0x44
    356e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    3572:	645a      	str	r2, [r3, #68]	; 0x44
    3574:	4b03      	ldr	r3, [pc, #12]	; (3584 <stm32_clock_init+0x104>)
    3576:	4a03      	ldr	r2, [pc, #12]	; (3584 <stm32_clock_init+0x104>)
    3578:	6e52      	ldr	r2, [r2, #100]	; 0x64
    357a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    357e:	665a      	str	r2, [r3, #100]	; 0x64
}
    3580:	4770      	bx	lr
    3582:	bf00      	nop
    3584:	40023800 	.word	0x40023800
    3588:	40007000 	.word	0x40007000
    358c:	07405408 	.word	0x07405408
    3590:	38089400 	.word	0x38089400
    3594:	40023c00 	.word	0x40023c00
    3598:	f3af 8000 	nop.w
    359c:	f3af 8000 	nop.w

000035a0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
    35a0:	b500      	push	{lr}
    35a2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    35a4:	f7fe fa8c 	bl	1ac0 <_stats_increase_irq>
    35a8:	f7fd fa22 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
    35ac:	4b0c      	ldr	r3, [pc, #48]	; (35e0 <Vector6C+0x40>)
    35ae:	681b      	ldr	r3, [r3, #0]
    35b0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    35b4:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
    35b6:	4b0a      	ldr	r3, [pc, #40]	; (35e0 <Vector6C+0x40>)
    35b8:	9a01      	ldr	r2, [sp, #4]
    35ba:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[0].dma_func)
    35bc:	4b09      	ldr	r3, [pc, #36]	; (35e4 <Vector6C+0x44>)
    35be:	681b      	ldr	r3, [r3, #0]
    35c0:	2b00      	cmp	r3, #0
    35c2:	d006      	beq.n	35d2 <Vector6C+0x32>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
    35c4:	4b07      	ldr	r3, [pc, #28]	; (35e4 <Vector6C+0x44>)
    35c6:	681b      	ldr	r3, [r3, #0]
    35c8:	4a06      	ldr	r2, [pc, #24]	; (35e4 <Vector6C+0x44>)
    35ca:	6852      	ldr	r2, [r2, #4]
    35cc:	4610      	mov	r0, r2
    35ce:	9901      	ldr	r1, [sp, #4]
    35d0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    35d2:	f7fd fa2d 	bl	a30 <_dbg_check_leave_isr>
    35d6:	f7ff fc0b 	bl	2df0 <_port_irq_epilogue>
}
    35da:	b003      	add	sp, #12
    35dc:	f85d fb04 	ldr.w	pc, [sp], #4
    35e0:	40026000 	.word	0x40026000
    35e4:	200010c4 	.word	0x200010c4
    35e8:	f3af 8000 	nop.w
    35ec:	f3af 8000 	nop.w

000035f0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
    35f0:	b500      	push	{lr}
    35f2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    35f4:	f7fe fa64 	bl	1ac0 <_stats_increase_irq>
    35f8:	f7fd f9fa 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
    35fc:	4b0d      	ldr	r3, [pc, #52]	; (3634 <Vector70+0x44>)
    35fe:	681b      	ldr	r3, [r3, #0]
    3600:	099b      	lsrs	r3, r3, #6
    3602:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3606:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
    3608:	4b0a      	ldr	r3, [pc, #40]	; (3634 <Vector70+0x44>)
    360a:	9a01      	ldr	r2, [sp, #4]
    360c:	0192      	lsls	r2, r2, #6
    360e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[1].dma_func)
    3610:	4b09      	ldr	r3, [pc, #36]	; (3638 <Vector70+0x48>)
    3612:	689b      	ldr	r3, [r3, #8]
    3614:	2b00      	cmp	r3, #0
    3616:	d006      	beq.n	3626 <Vector70+0x36>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
    3618:	4b07      	ldr	r3, [pc, #28]	; (3638 <Vector70+0x48>)
    361a:	689b      	ldr	r3, [r3, #8]
    361c:	4a06      	ldr	r2, [pc, #24]	; (3638 <Vector70+0x48>)
    361e:	68d2      	ldr	r2, [r2, #12]
    3620:	4610      	mov	r0, r2
    3622:	9901      	ldr	r1, [sp, #4]
    3624:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3626:	f7fd fa03 	bl	a30 <_dbg_check_leave_isr>
    362a:	f7ff fbe1 	bl	2df0 <_port_irq_epilogue>
}
    362e:	b003      	add	sp, #12
    3630:	f85d fb04 	ldr.w	pc, [sp], #4
    3634:	40026000 	.word	0x40026000
    3638:	200010c4 	.word	0x200010c4
    363c:	f3af 8000 	nop.w

00003640 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
    3640:	b500      	push	{lr}
    3642:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3644:	f7fe fa3c 	bl	1ac0 <_stats_increase_irq>
    3648:	f7fd f9d2 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
    364c:	4b0d      	ldr	r3, [pc, #52]	; (3684 <Vector74+0x44>)
    364e:	681b      	ldr	r3, [r3, #0]
    3650:	0c1b      	lsrs	r3, r3, #16
    3652:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3656:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
    3658:	4b0a      	ldr	r3, [pc, #40]	; (3684 <Vector74+0x44>)
    365a:	9a01      	ldr	r2, [sp, #4]
    365c:	0412      	lsls	r2, r2, #16
    365e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[2].dma_func)
    3660:	4b09      	ldr	r3, [pc, #36]	; (3688 <Vector74+0x48>)
    3662:	691b      	ldr	r3, [r3, #16]
    3664:	2b00      	cmp	r3, #0
    3666:	d006      	beq.n	3676 <Vector74+0x36>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
    3668:	4b07      	ldr	r3, [pc, #28]	; (3688 <Vector74+0x48>)
    366a:	691b      	ldr	r3, [r3, #16]
    366c:	4a06      	ldr	r2, [pc, #24]	; (3688 <Vector74+0x48>)
    366e:	6952      	ldr	r2, [r2, #20]
    3670:	4610      	mov	r0, r2
    3672:	9901      	ldr	r1, [sp, #4]
    3674:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3676:	f7fd f9db 	bl	a30 <_dbg_check_leave_isr>
    367a:	f7ff fbb9 	bl	2df0 <_port_irq_epilogue>
}
    367e:	b003      	add	sp, #12
    3680:	f85d fb04 	ldr.w	pc, [sp], #4
    3684:	40026000 	.word	0x40026000
    3688:	200010c4 	.word	0x200010c4
    368c:	f3af 8000 	nop.w

00003690 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
    3690:	b500      	push	{lr}
    3692:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3694:	f7fe fa14 	bl	1ac0 <_stats_increase_irq>
    3698:	f7fd f9aa 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
    369c:	4b0d      	ldr	r3, [pc, #52]	; (36d4 <Vector78+0x44>)
    369e:	681b      	ldr	r3, [r3, #0]
    36a0:	0d9b      	lsrs	r3, r3, #22
    36a2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    36a6:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
    36a8:	4b0a      	ldr	r3, [pc, #40]	; (36d4 <Vector78+0x44>)
    36aa:	9a01      	ldr	r2, [sp, #4]
    36ac:	0592      	lsls	r2, r2, #22
    36ae:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[3].dma_func)
    36b0:	4b09      	ldr	r3, [pc, #36]	; (36d8 <Vector78+0x48>)
    36b2:	699b      	ldr	r3, [r3, #24]
    36b4:	2b00      	cmp	r3, #0
    36b6:	d006      	beq.n	36c6 <Vector78+0x36>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
    36b8:	4b07      	ldr	r3, [pc, #28]	; (36d8 <Vector78+0x48>)
    36ba:	699b      	ldr	r3, [r3, #24]
    36bc:	4a06      	ldr	r2, [pc, #24]	; (36d8 <Vector78+0x48>)
    36be:	69d2      	ldr	r2, [r2, #28]
    36c0:	4610      	mov	r0, r2
    36c2:	9901      	ldr	r1, [sp, #4]
    36c4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    36c6:	f7fd f9b3 	bl	a30 <_dbg_check_leave_isr>
    36ca:	f7ff fb91 	bl	2df0 <_port_irq_epilogue>
}
    36ce:	b003      	add	sp, #12
    36d0:	f85d fb04 	ldr.w	pc, [sp], #4
    36d4:	40026000 	.word	0x40026000
    36d8:	200010c4 	.word	0x200010c4
    36dc:	f3af 8000 	nop.w

000036e0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
    36e0:	b500      	push	{lr}
    36e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    36e4:	f7fe f9ec 	bl	1ac0 <_stats_increase_irq>
    36e8:	f7fd f982 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
    36ec:	4b0c      	ldr	r3, [pc, #48]	; (3720 <Vector7C+0x40>)
    36ee:	685b      	ldr	r3, [r3, #4]
    36f0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    36f4:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
    36f6:	4b0a      	ldr	r3, [pc, #40]	; (3720 <Vector7C+0x40>)
    36f8:	9a01      	ldr	r2, [sp, #4]
    36fa:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[4].dma_func)
    36fc:	4b09      	ldr	r3, [pc, #36]	; (3724 <Vector7C+0x44>)
    36fe:	6a1b      	ldr	r3, [r3, #32]
    3700:	2b00      	cmp	r3, #0
    3702:	d006      	beq.n	3712 <Vector7C+0x32>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
    3704:	4b07      	ldr	r3, [pc, #28]	; (3724 <Vector7C+0x44>)
    3706:	6a1b      	ldr	r3, [r3, #32]
    3708:	4a06      	ldr	r2, [pc, #24]	; (3724 <Vector7C+0x44>)
    370a:	6a52      	ldr	r2, [r2, #36]	; 0x24
    370c:	4610      	mov	r0, r2
    370e:	9901      	ldr	r1, [sp, #4]
    3710:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3712:	f7fd f98d 	bl	a30 <_dbg_check_leave_isr>
    3716:	f7ff fb6b 	bl	2df0 <_port_irq_epilogue>
}
    371a:	b003      	add	sp, #12
    371c:	f85d fb04 	ldr.w	pc, [sp], #4
    3720:	40026000 	.word	0x40026000
    3724:	200010c4 	.word	0x200010c4
    3728:	f3af 8000 	nop.w
    372c:	f3af 8000 	nop.w

00003730 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
    3730:	b500      	push	{lr}
    3732:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3734:	f7fe f9c4 	bl	1ac0 <_stats_increase_irq>
    3738:	f7fd f95a 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
    373c:	4b0d      	ldr	r3, [pc, #52]	; (3774 <Vector80+0x44>)
    373e:	685b      	ldr	r3, [r3, #4]
    3740:	099b      	lsrs	r3, r3, #6
    3742:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3746:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
    3748:	4b0a      	ldr	r3, [pc, #40]	; (3774 <Vector80+0x44>)
    374a:	9a01      	ldr	r2, [sp, #4]
    374c:	0192      	lsls	r2, r2, #6
    374e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[5].dma_func)
    3750:	4b09      	ldr	r3, [pc, #36]	; (3778 <Vector80+0x48>)
    3752:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3754:	2b00      	cmp	r3, #0
    3756:	d006      	beq.n	3766 <Vector80+0x36>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
    3758:	4b07      	ldr	r3, [pc, #28]	; (3778 <Vector80+0x48>)
    375a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    375c:	4a06      	ldr	r2, [pc, #24]	; (3778 <Vector80+0x48>)
    375e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    3760:	4610      	mov	r0, r2
    3762:	9901      	ldr	r1, [sp, #4]
    3764:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3766:	f7fd f963 	bl	a30 <_dbg_check_leave_isr>
    376a:	f7ff fb41 	bl	2df0 <_port_irq_epilogue>
}
    376e:	b003      	add	sp, #12
    3770:	f85d fb04 	ldr.w	pc, [sp], #4
    3774:	40026000 	.word	0x40026000
    3778:	200010c4 	.word	0x200010c4
    377c:	f3af 8000 	nop.w

00003780 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
    3780:	b500      	push	{lr}
    3782:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3784:	f7fe f99c 	bl	1ac0 <_stats_increase_irq>
    3788:	f7fd f932 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
    378c:	4b0d      	ldr	r3, [pc, #52]	; (37c4 <Vector84+0x44>)
    378e:	685b      	ldr	r3, [r3, #4]
    3790:	0c1b      	lsrs	r3, r3, #16
    3792:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3796:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
    3798:	4b0a      	ldr	r3, [pc, #40]	; (37c4 <Vector84+0x44>)
    379a:	9a01      	ldr	r2, [sp, #4]
    379c:	0412      	lsls	r2, r2, #16
    379e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[6].dma_func)
    37a0:	4b09      	ldr	r3, [pc, #36]	; (37c8 <Vector84+0x48>)
    37a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    37a4:	2b00      	cmp	r3, #0
    37a6:	d006      	beq.n	37b6 <Vector84+0x36>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
    37a8:	4b07      	ldr	r3, [pc, #28]	; (37c8 <Vector84+0x48>)
    37aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    37ac:	4a06      	ldr	r2, [pc, #24]	; (37c8 <Vector84+0x48>)
    37ae:	6b52      	ldr	r2, [r2, #52]	; 0x34
    37b0:	4610      	mov	r0, r2
    37b2:	9901      	ldr	r1, [sp, #4]
    37b4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    37b6:	f7fd f93b 	bl	a30 <_dbg_check_leave_isr>
    37ba:	f7ff fb19 	bl	2df0 <_port_irq_epilogue>
}
    37be:	b003      	add	sp, #12
    37c0:	f85d fb04 	ldr.w	pc, [sp], #4
    37c4:	40026000 	.word	0x40026000
    37c8:	200010c4 	.word	0x200010c4
    37cc:	f3af 8000 	nop.w

000037d0 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
    37d0:	b500      	push	{lr}
    37d2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    37d4:	f7fe f974 	bl	1ac0 <_stats_increase_irq>
    37d8:	f7fd f90a 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
    37dc:	4b0d      	ldr	r3, [pc, #52]	; (3814 <VectorFC+0x44>)
    37de:	685b      	ldr	r3, [r3, #4]
    37e0:	0d9b      	lsrs	r3, r3, #22
    37e2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    37e6:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
    37e8:	4b0a      	ldr	r3, [pc, #40]	; (3814 <VectorFC+0x44>)
    37ea:	9a01      	ldr	r2, [sp, #4]
    37ec:	0592      	lsls	r2, r2, #22
    37ee:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[7].dma_func)
    37f0:	4b09      	ldr	r3, [pc, #36]	; (3818 <VectorFC+0x48>)
    37f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    37f4:	2b00      	cmp	r3, #0
    37f6:	d006      	beq.n	3806 <VectorFC+0x36>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
    37f8:	4b07      	ldr	r3, [pc, #28]	; (3818 <VectorFC+0x48>)
    37fa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    37fc:	4a06      	ldr	r2, [pc, #24]	; (3818 <VectorFC+0x48>)
    37fe:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
    3800:	4610      	mov	r0, r2
    3802:	9901      	ldr	r1, [sp, #4]
    3804:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3806:	f7fd f913 	bl	a30 <_dbg_check_leave_isr>
    380a:	f7ff faf1 	bl	2df0 <_port_irq_epilogue>
}
    380e:	b003      	add	sp, #12
    3810:	f85d fb04 	ldr.w	pc, [sp], #4
    3814:	40026000 	.word	0x40026000
    3818:	200010c4 	.word	0x200010c4
    381c:	f3af 8000 	nop.w

00003820 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
    3820:	b500      	push	{lr}
    3822:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3824:	f7fe f94c 	bl	1ac0 <_stats_increase_irq>
    3828:	f7fd f8e2 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
    382c:	4b0c      	ldr	r3, [pc, #48]	; (3860 <Vector120+0x40>)
    382e:	681b      	ldr	r3, [r3, #0]
    3830:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3834:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
    3836:	4b0a      	ldr	r3, [pc, #40]	; (3860 <Vector120+0x40>)
    3838:	9a01      	ldr	r2, [sp, #4]
    383a:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[8].dma_func)
    383c:	4b09      	ldr	r3, [pc, #36]	; (3864 <Vector120+0x44>)
    383e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3840:	2b00      	cmp	r3, #0
    3842:	d006      	beq.n	3852 <Vector120+0x32>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
    3844:	4b07      	ldr	r3, [pc, #28]	; (3864 <Vector120+0x44>)
    3846:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3848:	4a06      	ldr	r2, [pc, #24]	; (3864 <Vector120+0x44>)
    384a:	6c52      	ldr	r2, [r2, #68]	; 0x44
    384c:	4610      	mov	r0, r2
    384e:	9901      	ldr	r1, [sp, #4]
    3850:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3852:	f7fd f8ed 	bl	a30 <_dbg_check_leave_isr>
    3856:	f7ff facb 	bl	2df0 <_port_irq_epilogue>
}
    385a:	b003      	add	sp, #12
    385c:	f85d fb04 	ldr.w	pc, [sp], #4
    3860:	40026400 	.word	0x40026400
    3864:	200010c4 	.word	0x200010c4
    3868:	f3af 8000 	nop.w
    386c:	f3af 8000 	nop.w

00003870 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
    3870:	b500      	push	{lr}
    3872:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3874:	f7fe f924 	bl	1ac0 <_stats_increase_irq>
    3878:	f7fd f8ba 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
    387c:	4b0d      	ldr	r3, [pc, #52]	; (38b4 <Vector124+0x44>)
    387e:	681b      	ldr	r3, [r3, #0]
    3880:	099b      	lsrs	r3, r3, #6
    3882:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3886:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
    3888:	4b0a      	ldr	r3, [pc, #40]	; (38b4 <Vector124+0x44>)
    388a:	9a01      	ldr	r2, [sp, #4]
    388c:	0192      	lsls	r2, r2, #6
    388e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[9].dma_func)
    3890:	4b09      	ldr	r3, [pc, #36]	; (38b8 <Vector124+0x48>)
    3892:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3894:	2b00      	cmp	r3, #0
    3896:	d006      	beq.n	38a6 <Vector124+0x36>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
    3898:	4b07      	ldr	r3, [pc, #28]	; (38b8 <Vector124+0x48>)
    389a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    389c:	4a06      	ldr	r2, [pc, #24]	; (38b8 <Vector124+0x48>)
    389e:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    38a0:	4610      	mov	r0, r2
    38a2:	9901      	ldr	r1, [sp, #4]
    38a4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    38a6:	f7fd f8c3 	bl	a30 <_dbg_check_leave_isr>
    38aa:	f7ff faa1 	bl	2df0 <_port_irq_epilogue>
}
    38ae:	b003      	add	sp, #12
    38b0:	f85d fb04 	ldr.w	pc, [sp], #4
    38b4:	40026400 	.word	0x40026400
    38b8:	200010c4 	.word	0x200010c4
    38bc:	f3af 8000 	nop.w

000038c0 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
    38c0:	b500      	push	{lr}
    38c2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    38c4:	f7fe f8fc 	bl	1ac0 <_stats_increase_irq>
    38c8:	f7fd f892 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
    38cc:	4b0d      	ldr	r3, [pc, #52]	; (3904 <Vector128+0x44>)
    38ce:	681b      	ldr	r3, [r3, #0]
    38d0:	0c1b      	lsrs	r3, r3, #16
    38d2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    38d6:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
    38d8:	4b0a      	ldr	r3, [pc, #40]	; (3904 <Vector128+0x44>)
    38da:	9a01      	ldr	r2, [sp, #4]
    38dc:	0412      	lsls	r2, r2, #16
    38de:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[10].dma_func)
    38e0:	4b09      	ldr	r3, [pc, #36]	; (3908 <Vector128+0x48>)
    38e2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    38e4:	2b00      	cmp	r3, #0
    38e6:	d006      	beq.n	38f6 <Vector128+0x36>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
    38e8:	4b07      	ldr	r3, [pc, #28]	; (3908 <Vector128+0x48>)
    38ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    38ec:	4a06      	ldr	r2, [pc, #24]	; (3908 <Vector128+0x48>)
    38ee:	6d52      	ldr	r2, [r2, #84]	; 0x54
    38f0:	4610      	mov	r0, r2
    38f2:	9901      	ldr	r1, [sp, #4]
    38f4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    38f6:	f7fd f89b 	bl	a30 <_dbg_check_leave_isr>
    38fa:	f7ff fa79 	bl	2df0 <_port_irq_epilogue>
}
    38fe:	b003      	add	sp, #12
    3900:	f85d fb04 	ldr.w	pc, [sp], #4
    3904:	40026400 	.word	0x40026400
    3908:	200010c4 	.word	0x200010c4
    390c:	f3af 8000 	nop.w

00003910 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
    3910:	b500      	push	{lr}
    3912:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3914:	f7fe f8d4 	bl	1ac0 <_stats_increase_irq>
    3918:	f7fd f86a 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
    391c:	4b0d      	ldr	r3, [pc, #52]	; (3954 <Vector12C+0x44>)
    391e:	681b      	ldr	r3, [r3, #0]
    3920:	0d9b      	lsrs	r3, r3, #22
    3922:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3926:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
    3928:	4b0a      	ldr	r3, [pc, #40]	; (3954 <Vector12C+0x44>)
    392a:	9a01      	ldr	r2, [sp, #4]
    392c:	0592      	lsls	r2, r2, #22
    392e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[11].dma_func)
    3930:	4b09      	ldr	r3, [pc, #36]	; (3958 <Vector12C+0x48>)
    3932:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    3934:	2b00      	cmp	r3, #0
    3936:	d006      	beq.n	3946 <Vector12C+0x36>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
    3938:	4b07      	ldr	r3, [pc, #28]	; (3958 <Vector12C+0x48>)
    393a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    393c:	4a06      	ldr	r2, [pc, #24]	; (3958 <Vector12C+0x48>)
    393e:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
    3940:	4610      	mov	r0, r2
    3942:	9901      	ldr	r1, [sp, #4]
    3944:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3946:	f7fd f873 	bl	a30 <_dbg_check_leave_isr>
    394a:	f7ff fa51 	bl	2df0 <_port_irq_epilogue>
}
    394e:	b003      	add	sp, #12
    3950:	f85d fb04 	ldr.w	pc, [sp], #4
    3954:	40026400 	.word	0x40026400
    3958:	200010c4 	.word	0x200010c4
    395c:	f3af 8000 	nop.w

00003960 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
    3960:	b500      	push	{lr}
    3962:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3964:	f7fe f8ac 	bl	1ac0 <_stats_increase_irq>
    3968:	f7fd f842 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
    396c:	4b0c      	ldr	r3, [pc, #48]	; (39a0 <Vector130+0x40>)
    396e:	685b      	ldr	r3, [r3, #4]
    3970:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3974:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
    3976:	4b0a      	ldr	r3, [pc, #40]	; (39a0 <Vector130+0x40>)
    3978:	9a01      	ldr	r2, [sp, #4]
    397a:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[12].dma_func)
    397c:	4b09      	ldr	r3, [pc, #36]	; (39a4 <Vector130+0x44>)
    397e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    3980:	2b00      	cmp	r3, #0
    3982:	d006      	beq.n	3992 <Vector130+0x32>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
    3984:	4b07      	ldr	r3, [pc, #28]	; (39a4 <Vector130+0x44>)
    3986:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    3988:	4a06      	ldr	r2, [pc, #24]	; (39a4 <Vector130+0x44>)
    398a:	6e52      	ldr	r2, [r2, #100]	; 0x64
    398c:	4610      	mov	r0, r2
    398e:	9901      	ldr	r1, [sp, #4]
    3990:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3992:	f7fd f84d 	bl	a30 <_dbg_check_leave_isr>
    3996:	f7ff fa2b 	bl	2df0 <_port_irq_epilogue>
}
    399a:	b003      	add	sp, #12
    399c:	f85d fb04 	ldr.w	pc, [sp], #4
    39a0:	40026400 	.word	0x40026400
    39a4:	200010c4 	.word	0x200010c4
    39a8:	f3af 8000 	nop.w
    39ac:	f3af 8000 	nop.w

000039b0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
    39b0:	b500      	push	{lr}
    39b2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    39b4:	f7fe f884 	bl	1ac0 <_stats_increase_irq>
    39b8:	f7fd f81a 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
    39bc:	4b0d      	ldr	r3, [pc, #52]	; (39f4 <Vector150+0x44>)
    39be:	685b      	ldr	r3, [r3, #4]
    39c0:	099b      	lsrs	r3, r3, #6
    39c2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    39c6:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
    39c8:	4b0a      	ldr	r3, [pc, #40]	; (39f4 <Vector150+0x44>)
    39ca:	9a01      	ldr	r2, [sp, #4]
    39cc:	0192      	lsls	r2, r2, #6
    39ce:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[13].dma_func)
    39d0:	4b09      	ldr	r3, [pc, #36]	; (39f8 <Vector150+0x48>)
    39d2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    39d4:	2b00      	cmp	r3, #0
    39d6:	d006      	beq.n	39e6 <Vector150+0x36>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
    39d8:	4b07      	ldr	r3, [pc, #28]	; (39f8 <Vector150+0x48>)
    39da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    39dc:	4a06      	ldr	r2, [pc, #24]	; (39f8 <Vector150+0x48>)
    39de:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    39e0:	4610      	mov	r0, r2
    39e2:	9901      	ldr	r1, [sp, #4]
    39e4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    39e6:	f7fd f823 	bl	a30 <_dbg_check_leave_isr>
    39ea:	f7ff fa01 	bl	2df0 <_port_irq_epilogue>
}
    39ee:	b003      	add	sp, #12
    39f0:	f85d fb04 	ldr.w	pc, [sp], #4
    39f4:	40026400 	.word	0x40026400
    39f8:	200010c4 	.word	0x200010c4
    39fc:	f3af 8000 	nop.w

00003a00 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
    3a00:	b500      	push	{lr}
    3a02:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3a04:	f7fe f85c 	bl	1ac0 <_stats_increase_irq>
    3a08:	f7fc fff2 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
    3a0c:	4b0d      	ldr	r3, [pc, #52]	; (3a44 <Vector154+0x44>)
    3a0e:	685b      	ldr	r3, [r3, #4]
    3a10:	0c1b      	lsrs	r3, r3, #16
    3a12:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3a16:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
    3a18:	4b0a      	ldr	r3, [pc, #40]	; (3a44 <Vector154+0x44>)
    3a1a:	9a01      	ldr	r2, [sp, #4]
    3a1c:	0412      	lsls	r2, r2, #16
    3a1e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[14].dma_func)
    3a20:	4b09      	ldr	r3, [pc, #36]	; (3a48 <Vector154+0x48>)
    3a22:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    3a24:	2b00      	cmp	r3, #0
    3a26:	d006      	beq.n	3a36 <Vector154+0x36>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
    3a28:	4b07      	ldr	r3, [pc, #28]	; (3a48 <Vector154+0x48>)
    3a2a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    3a2c:	4a06      	ldr	r2, [pc, #24]	; (3a48 <Vector154+0x48>)
    3a2e:	6f52      	ldr	r2, [r2, #116]	; 0x74
    3a30:	4610      	mov	r0, r2
    3a32:	9901      	ldr	r1, [sp, #4]
    3a34:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3a36:	f7fc fffb 	bl	a30 <_dbg_check_leave_isr>
    3a3a:	f7ff f9d9 	bl	2df0 <_port_irq_epilogue>
}
    3a3e:	b003      	add	sp, #12
    3a40:	f85d fb04 	ldr.w	pc, [sp], #4
    3a44:	40026400 	.word	0x40026400
    3a48:	200010c4 	.word	0x200010c4
    3a4c:	f3af 8000 	nop.w

00003a50 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
    3a50:	b500      	push	{lr}
    3a52:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3a54:	f7fe f834 	bl	1ac0 <_stats_increase_irq>
    3a58:	f7fc ffca 	bl	9f0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
    3a5c:	4b0d      	ldr	r3, [pc, #52]	; (3a94 <Vector158+0x44>)
    3a5e:	685b      	ldr	r3, [r3, #4]
    3a60:	0d9b      	lsrs	r3, r3, #22
    3a62:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3a66:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
    3a68:	4b0a      	ldr	r3, [pc, #40]	; (3a94 <Vector158+0x44>)
    3a6a:	9a01      	ldr	r2, [sp, #4]
    3a6c:	0592      	lsls	r2, r2, #22
    3a6e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[15].dma_func)
    3a70:	4b09      	ldr	r3, [pc, #36]	; (3a98 <Vector158+0x48>)
    3a72:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    3a74:	2b00      	cmp	r3, #0
    3a76:	d006      	beq.n	3a86 <Vector158+0x36>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
    3a78:	4b07      	ldr	r3, [pc, #28]	; (3a98 <Vector158+0x48>)
    3a7a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    3a7c:	4a06      	ldr	r2, [pc, #24]	; (3a98 <Vector158+0x48>)
    3a7e:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
    3a80:	4610      	mov	r0, r2
    3a82:	9901      	ldr	r1, [sp, #4]
    3a84:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3a86:	f7fc ffd3 	bl	a30 <_dbg_check_leave_isr>
    3a8a:	f7ff f9b1 	bl	2df0 <_port_irq_epilogue>
}
    3a8e:	b003      	add	sp, #12
    3a90:	f85d fb04 	ldr.w	pc, [sp], #4
    3a94:	40026400 	.word	0x40026400
    3a98:	200010c4 	.word	0x200010c4
    3a9c:	f3af 8000 	nop.w

00003aa0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
    3aa0:	b082      	sub	sp, #8
  unsigned i;

  dma_streams_mask = 0U;
    3aa2:	4b16      	ldr	r3, [pc, #88]	; (3afc <dmaInit+0x5c>)
    3aa4:	2200      	movs	r2, #0
    3aa6:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    3aa8:	2300      	movs	r3, #0
    3aaa:	9301      	str	r3, [sp, #4]
    3aac:	e011      	b.n	3ad2 <dmaInit+0x32>
    _stm32_dma_streams[i].stream->CR = 0U;
    3aae:	4914      	ldr	r1, [pc, #80]	; (3b00 <dmaInit+0x60>)
    3ab0:	9a01      	ldr	r2, [sp, #4]
    3ab2:	4613      	mov	r3, r2
    3ab4:	005b      	lsls	r3, r3, #1
    3ab6:	4413      	add	r3, r2
    3ab8:	009b      	lsls	r3, r3, #2
    3aba:	440b      	add	r3, r1
    3abc:	681b      	ldr	r3, [r3, #0]
    3abe:	2200      	movs	r2, #0
    3ac0:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
    3ac2:	4b10      	ldr	r3, [pc, #64]	; (3b04 <dmaInit+0x64>)
    3ac4:	9a01      	ldr	r2, [sp, #4]
    3ac6:	2100      	movs	r1, #0
    3ac8:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    3acc:	9b01      	ldr	r3, [sp, #4]
    3ace:	3301      	adds	r3, #1
    3ad0:	9301      	str	r3, [sp, #4]
    3ad2:	9b01      	ldr	r3, [sp, #4]
    3ad4:	2b0f      	cmp	r3, #15
    3ad6:	d9ea      	bls.n	3aae <dmaInit+0xe>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
    3ad8:	4b0b      	ldr	r3, [pc, #44]	; (3b08 <dmaInit+0x68>)
    3ada:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3ade:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
    3ae0:	4b09      	ldr	r3, [pc, #36]	; (3b08 <dmaInit+0x68>)
    3ae2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3ae6:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
    3ae8:	4b08      	ldr	r3, [pc, #32]	; (3b0c <dmaInit+0x6c>)
    3aea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3aee:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
    3af0:	4b06      	ldr	r3, [pc, #24]	; (3b0c <dmaInit+0x6c>)
    3af2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3af6:	60da      	str	r2, [r3, #12]
}
    3af8:	b002      	add	sp, #8
    3afa:	4770      	bx	lr
    3afc:	200010c0 	.word	0x200010c0
    3b00:	00004950 	.word	0x00004950
    3b04:	200010c4 	.word	0x200010c4
    3b08:	40026000 	.word	0x40026000
    3b0c:	40026400 	.word	0x40026400

00003b10 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    3b10:	b082      	sub	sp, #8
    3b12:	2320      	movs	r3, #32
    3b14:	9301      	str	r3, [sp, #4]
    3b16:	9b01      	ldr	r3, [sp, #4]
    3b18:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    3b1c:	b002      	add	sp, #8
    3b1e:	4770      	bx	lr

00003b20 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    3b20:	b082      	sub	sp, #8
    3b22:	2300      	movs	r3, #0
    3b24:	9301      	str	r3, [sp, #4]
    3b26:	9b01      	ldr	r3, [sp, #4]
    3b28:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    3b2c:	b002      	add	sp, #8
    3b2e:	4770      	bx	lr

00003b30 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    3b30:	b508      	push	{r3, lr}

  port_lock();
    3b32:	f7ff ffed 	bl	3b10 <port_lock>
}
    3b36:	bd08      	pop	{r3, pc}
    3b38:	f3af 8000 	nop.w
    3b3c:	f3af 8000 	nop.w

00003b40 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    3b40:	b508      	push	{r3, lr}

  port_unlock();
    3b42:	f7ff ffed 	bl	3b20 <port_unlock>
}
    3b46:	bd08      	pop	{r3, pc}
    3b48:	f3af 8000 	nop.w
    3b4c:	f3af 8000 	nop.w

00003b50 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    3b50:	b508      	push	{r3, lr}

  port_lock_from_isr();
    3b52:	f7ff ffed 	bl	3b30 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    3b56:	f7fd fff3 	bl	1b40 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    3b5a:	f7fc ff19 	bl	990 <_dbg_check_lock_from_isr>
}
    3b5e:	bd08      	pop	{r3, pc}

00003b60 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    3b60:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    3b62:	f7fc ff2d 	bl	9c0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    3b66:	f7fd fff3 	bl	1b50 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    3b6a:	f7ff ffe9 	bl	3b40 <port_unlock_from_isr>
}
    3b6e:	bd08      	pop	{r3, pc}

00003b70 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    3b70:	b508      	push	{r3, lr}

  chSysLockFromISR();
    3b72:	f7ff ffed 	bl	3b50 <chSysLockFromISR>
}
    3b76:	bd08      	pop	{r3, pc}
    3b78:	f3af 8000 	nop.w
    3b7c:	f3af 8000 	nop.w

00003b80 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    3b80:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    3b82:	f7ff ffed 	bl	3b60 <chSysUnlockFromISR>
}
    3b86:	bd08      	pop	{r3, pc}
    3b88:	f3af 8000 	nop.w
    3b8c:	f3af 8000 	nop.w

00003b90 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
    3b90:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
    3b92:	f7fc fe75 	bl	880 <chSysTimerHandlerI>
}
    3b96:	bd08      	pop	{r3, pc}
    3b98:	f3af 8000 	nop.w
    3b9c:	f3af 8000 	nop.w

00003ba0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
    3ba0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    3ba2:	f7fd ff8d 	bl	1ac0 <_stats_increase_irq>
    3ba6:	f7fc ff23 	bl	9f0 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    3baa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3bae:	691b      	ldr	r3, [r3, #16]
    3bb0:	f003 0302 	and.w	r3, r3, #2
    3bb4:	2b00      	cmp	r3, #0
    3bb6:	d009      	beq.n	3bcc <VectorB0+0x2c>
    STM32_ST_TIM->SR = 0U;
    3bb8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3bbc:	2200      	movs	r2, #0
    3bbe:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
    3bc0:	f7ff ffd6 	bl	3b70 <osalSysLockFromISR>
    osalOsTimerHandlerI();
    3bc4:	f7ff ffe4 	bl	3b90 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
    3bc8:	f7ff ffda 	bl	3b80 <osalSysUnlockFromISR>
  }

  OSAL_IRQ_EPILOGUE();
    3bcc:	f7fc ff30 	bl	a30 <_dbg_check_leave_isr>
    3bd0:	f7ff f90e 	bl	2df0 <_port_irq_epilogue>
}
    3bd4:	bd08      	pop	{r3, pc}
    3bd6:	bf00      	nop
    3bd8:	f3af 8000 	nop.w
    3bdc:	f3af 8000 	nop.w

00003be0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
    3be0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
    3be2:	4b19      	ldr	r3, [pc, #100]	; (3c48 <st_lld_init+0x68>)
    3be4:	4a18      	ldr	r2, [pc, #96]	; (3c48 <st_lld_init+0x68>)
    3be6:	6c12      	ldr	r2, [r2, #64]	; 0x40
    3be8:	f042 0201 	orr.w	r2, r2, #1
    3bec:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
    3bee:	4b17      	ldr	r3, [pc, #92]	; (3c4c <st_lld_init+0x6c>)
    3bf0:	4a16      	ldr	r2, [pc, #88]	; (3c4c <st_lld_init+0x6c>)
    3bf2:	6892      	ldr	r2, [r2, #8]
    3bf4:	f042 0201 	orr.w	r2, r2, #1
    3bf8:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
    3bfa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3bfe:	f242 02cf 	movw	r2, #8399	; 0x20cf
    3c02:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
    3c04:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3c08:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3c0c:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
    3c0e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3c12:	2200      	movs	r2, #0
    3c14:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
    3c16:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3c1a:	2200      	movs	r2, #0
    3c1c:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
    3c1e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3c22:	2200      	movs	r2, #0
    3c24:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
    3c26:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3c2a:	2200      	movs	r2, #0
    3c2c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
    3c2e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3c32:	2201      	movs	r2, #1
    3c34:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
    3c36:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3c3a:	2201      	movs	r2, #1
    3c3c:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
    3c3e:	201c      	movs	r0, #28
    3c40:	2108      	movs	r1, #8
    3c42:	f7ff fb9d 	bl	3380 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    3c46:	bd08      	pop	{r3, pc}
    3c48:	40023800 	.word	0x40023800
    3c4c:	e0042000 	.word	0xe0042000

00003c50 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    3c50:	b082      	sub	sp, #8
    3c52:	2320      	movs	r3, #32
    3c54:	9301      	str	r3, [sp, #4]
    3c56:	9b01      	ldr	r3, [sp, #4]
    3c58:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    3c5c:	b002      	add	sp, #8
    3c5e:	4770      	bx	lr

00003c60 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    3c60:	b082      	sub	sp, #8
    3c62:	2300      	movs	r3, #0
    3c64:	9301      	str	r3, [sp, #4]
    3c66:	9b01      	ldr	r3, [sp, #4]
    3c68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    3c6c:	b002      	add	sp, #8
    3c6e:	4770      	bx	lr

00003c70 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    3c70:	b508      	push	{r3, lr}

  port_lock();
    3c72:	f7ff ffed 	bl	3c50 <port_lock>
}
    3c76:	bd08      	pop	{r3, pc}
    3c78:	f3af 8000 	nop.w
    3c7c:	f3af 8000 	nop.w

00003c80 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    3c80:	b508      	push	{r3, lr}

  port_unlock();
    3c82:	f7ff ffed 	bl	3c60 <port_unlock>
}
    3c86:	bd08      	pop	{r3, pc}
    3c88:	f3af 8000 	nop.w
    3c8c:	f3af 8000 	nop.w

00003c90 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    3c90:	b508      	push	{r3, lr}

  port_lock_from_isr();
    3c92:	f7ff ffed 	bl	3c70 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    3c96:	f7fd ff53 	bl	1b40 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    3c9a:	f7fc fe79 	bl	990 <_dbg_check_lock_from_isr>
}
    3c9e:	bd08      	pop	{r3, pc}

00003ca0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    3ca0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    3ca2:	f7fc fe8d 	bl	9c0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    3ca6:	f7fd ff53 	bl	1b50 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    3caa:	f7ff ffe9 	bl	3c80 <port_unlock_from_isr>
}
    3cae:	bd08      	pop	{r3, pc}

00003cb0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    3cb0:	b508      	push	{r3, lr}

  chSysLockFromISR();
    3cb2:	f7ff ffed 	bl	3c90 <chSysLockFromISR>
}
    3cb6:	bd08      	pop	{r3, pc}
    3cb8:	f3af 8000 	nop.w
    3cbc:	f3af 8000 	nop.w

00003cc0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    3cc0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    3cc2:	f7ff ffed 	bl	3ca0 <chSysUnlockFromISR>
}
    3cc6:	bd08      	pop	{r3, pc}
    3cc8:	f3af 8000 	nop.w
    3ccc:	f3af 8000 	nop.w

00003cd0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    3cd0:	b500      	push	{lr}
    3cd2:	b083      	sub	sp, #12
    3cd4:	9001      	str	r0, [sp, #4]
    3cd6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
    3cd8:	9801      	ldr	r0, [sp, #4]
    3cda:	9900      	ldr	r1, [sp, #0]
    3cdc:	f7fd fdc0 	bl	1860 <chThdResumeI>
}
    3ce0:	b003      	add	sp, #12
    3ce2:	f85d fb04 	ldr.w	pc, [sp], #4
    3ce6:	bf00      	nop
    3ce8:	f3af 8000 	nop.w
    3cec:	f3af 8000 	nop.w

00003cf0 <Vector88>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
    3cf0:	b500      	push	{lr}
    3cf2:	b083      	sub	sp, #12
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();
    3cf4:	f7fd fee4 	bl	1ac0 <_stats_increase_irq>
    3cf8:	f7fc fe7a 	bl	9f0 <_dbg_check_enter_isr>

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
    3cfc:	4b58      	ldr	r3, [pc, #352]	; (3e60 <Vector88+0x170>)
    3cfe:	681b      	ldr	r3, [r3, #0]
    3d00:	9301      	str	r3, [sp, #4]
  ADC1->SR = 0;
    3d02:	4b57      	ldr	r3, [pc, #348]	; (3e60 <Vector88+0x170>)
    3d04:	2200      	movs	r2, #0
    3d06:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    3d08:	9b01      	ldr	r3, [sp, #4]
    3d0a:	f003 0320 	and.w	r3, r3, #32
    3d0e:	2b00      	cmp	r3, #0
    3d10:	d02d      	beq.n	3d6e <Vector88+0x7e>
    3d12:	4b54      	ldr	r3, [pc, #336]	; (3e64 <Vector88+0x174>)
    3d14:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3d16:	681b      	ldr	r3, [r3, #0]
    3d18:	685b      	ldr	r3, [r3, #4]
    3d1a:	2b00      	cmp	r3, #0
    3d1c:	d027      	beq.n	3d6e <Vector88+0x7e>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
    3d1e:	4b51      	ldr	r3, [pc, #324]	; (3e64 <Vector88+0x174>)
    3d20:	691b      	ldr	r3, [r3, #16]
    3d22:	2b00      	cmp	r3, #0
    3d24:	d023      	beq.n	3d6e <Vector88+0x7e>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    3d26:	484f      	ldr	r0, [pc, #316]	; (3e64 <Vector88+0x174>)
    3d28:	f000 f8fa 	bl	3f20 <adc_lld_stop_conversion>
    3d2c:	4b4d      	ldr	r3, [pc, #308]	; (3e64 <Vector88+0x174>)
    3d2e:	691b      	ldr	r3, [r3, #16]
    3d30:	689b      	ldr	r3, [r3, #8]
    3d32:	2b00      	cmp	r3, #0
    3d34:	d00f      	beq.n	3d56 <Vector88+0x66>
    3d36:	4b4b      	ldr	r3, [pc, #300]	; (3e64 <Vector88+0x174>)
    3d38:	2205      	movs	r2, #5
    3d3a:	701a      	strb	r2, [r3, #0]
    3d3c:	4b49      	ldr	r3, [pc, #292]	; (3e64 <Vector88+0x174>)
    3d3e:	691b      	ldr	r3, [r3, #16]
    3d40:	689b      	ldr	r3, [r3, #8]
    3d42:	4848      	ldr	r0, [pc, #288]	; (3e64 <Vector88+0x174>)
    3d44:	2101      	movs	r1, #1
    3d46:	4798      	blx	r3
    3d48:	4b46      	ldr	r3, [pc, #280]	; (3e64 <Vector88+0x174>)
    3d4a:	781b      	ldrb	r3, [r3, #0]
    3d4c:	2b05      	cmp	r3, #5
    3d4e:	d102      	bne.n	3d56 <Vector88+0x66>
    3d50:	4b44      	ldr	r3, [pc, #272]	; (3e64 <Vector88+0x174>)
    3d52:	2202      	movs	r2, #2
    3d54:	701a      	strb	r2, [r3, #0]
    3d56:	4b43      	ldr	r3, [pc, #268]	; (3e64 <Vector88+0x174>)
    3d58:	2200      	movs	r2, #0
    3d5a:	611a      	str	r2, [r3, #16]
    3d5c:	f7ff ffa8 	bl	3cb0 <osalSysLockFromISR>
    3d60:	4841      	ldr	r0, [pc, #260]	; (3e68 <Vector88+0x178>)
    3d62:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3d66:	f7ff ffb3 	bl	3cd0 <osalThreadResumeI>
    3d6a:	f7ff ffa9 	bl	3cc0 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC1 */

#if STM32_ADC_USE_ADC2
  sr = ADC2->SR;
    3d6e:	4b3f      	ldr	r3, [pc, #252]	; (3e6c <Vector88+0x17c>)
    3d70:	681b      	ldr	r3, [r3, #0]
    3d72:	9301      	str	r3, [sp, #4]
  ADC2->SR = 0;
    3d74:	4b3d      	ldr	r3, [pc, #244]	; (3e6c <Vector88+0x17c>)
    3d76:	2200      	movs	r2, #0
    3d78:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD2.dmastp) > 0)) {
    3d7a:	9b01      	ldr	r3, [sp, #4]
    3d7c:	f003 0320 	and.w	r3, r3, #32
    3d80:	2b00      	cmp	r3, #0
    3d82:	d02d      	beq.n	3de0 <Vector88+0xf0>
    3d84:	4b3a      	ldr	r3, [pc, #232]	; (3e70 <Vector88+0x180>)
    3d86:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3d88:	681b      	ldr	r3, [r3, #0]
    3d8a:	685b      	ldr	r3, [r3, #4]
    3d8c:	2b00      	cmp	r3, #0
    3d8e:	d027      	beq.n	3de0 <Vector88+0xf0>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD2.grpp != NULL)
    3d90:	4b37      	ldr	r3, [pc, #220]	; (3e70 <Vector88+0x180>)
    3d92:	691b      	ldr	r3, [r3, #16]
    3d94:	2b00      	cmp	r3, #0
    3d96:	d023      	beq.n	3de0 <Vector88+0xf0>
      _adc_isr_error_code(&ADCD2, ADC_ERR_OVERFLOW);
    3d98:	4835      	ldr	r0, [pc, #212]	; (3e70 <Vector88+0x180>)
    3d9a:	f000 f8c1 	bl	3f20 <adc_lld_stop_conversion>
    3d9e:	4b34      	ldr	r3, [pc, #208]	; (3e70 <Vector88+0x180>)
    3da0:	691b      	ldr	r3, [r3, #16]
    3da2:	689b      	ldr	r3, [r3, #8]
    3da4:	2b00      	cmp	r3, #0
    3da6:	d00f      	beq.n	3dc8 <Vector88+0xd8>
    3da8:	4b31      	ldr	r3, [pc, #196]	; (3e70 <Vector88+0x180>)
    3daa:	2205      	movs	r2, #5
    3dac:	701a      	strb	r2, [r3, #0]
    3dae:	4b30      	ldr	r3, [pc, #192]	; (3e70 <Vector88+0x180>)
    3db0:	691b      	ldr	r3, [r3, #16]
    3db2:	689b      	ldr	r3, [r3, #8]
    3db4:	482e      	ldr	r0, [pc, #184]	; (3e70 <Vector88+0x180>)
    3db6:	2101      	movs	r1, #1
    3db8:	4798      	blx	r3
    3dba:	4b2d      	ldr	r3, [pc, #180]	; (3e70 <Vector88+0x180>)
    3dbc:	781b      	ldrb	r3, [r3, #0]
    3dbe:	2b05      	cmp	r3, #5
    3dc0:	d102      	bne.n	3dc8 <Vector88+0xd8>
    3dc2:	4b2b      	ldr	r3, [pc, #172]	; (3e70 <Vector88+0x180>)
    3dc4:	2202      	movs	r2, #2
    3dc6:	701a      	strb	r2, [r3, #0]
    3dc8:	4b29      	ldr	r3, [pc, #164]	; (3e70 <Vector88+0x180>)
    3dca:	2200      	movs	r2, #0
    3dcc:	611a      	str	r2, [r3, #16]
    3dce:	f7ff ff6f 	bl	3cb0 <osalSysLockFromISR>
    3dd2:	4828      	ldr	r0, [pc, #160]	; (3e74 <Vector88+0x184>)
    3dd4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3dd8:	f7ff ff7a 	bl	3cd0 <osalThreadResumeI>
    3ddc:	f7ff ff70 	bl	3cc0 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC2 */

#if STM32_ADC_USE_ADC3
  sr = ADC3->SR;
    3de0:	4b25      	ldr	r3, [pc, #148]	; (3e78 <Vector88+0x188>)
    3de2:	681b      	ldr	r3, [r3, #0]
    3de4:	9301      	str	r3, [sp, #4]
  ADC3->SR = 0;
    3de6:	4b24      	ldr	r3, [pc, #144]	; (3e78 <Vector88+0x188>)
    3de8:	2200      	movs	r2, #0
    3dea:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD3.dmastp) > 0)) {
    3dec:	9b01      	ldr	r3, [sp, #4]
    3dee:	f003 0320 	and.w	r3, r3, #32
    3df2:	2b00      	cmp	r3, #0
    3df4:	d02d      	beq.n	3e52 <Vector88+0x162>
    3df6:	4b21      	ldr	r3, [pc, #132]	; (3e7c <Vector88+0x18c>)
    3df8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3dfa:	681b      	ldr	r3, [r3, #0]
    3dfc:	685b      	ldr	r3, [r3, #4]
    3dfe:	2b00      	cmp	r3, #0
    3e00:	d027      	beq.n	3e52 <Vector88+0x162>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD3.grpp != NULL)
    3e02:	4b1e      	ldr	r3, [pc, #120]	; (3e7c <Vector88+0x18c>)
    3e04:	691b      	ldr	r3, [r3, #16]
    3e06:	2b00      	cmp	r3, #0
    3e08:	d023      	beq.n	3e52 <Vector88+0x162>
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
    3e0a:	481c      	ldr	r0, [pc, #112]	; (3e7c <Vector88+0x18c>)
    3e0c:	f000 f888 	bl	3f20 <adc_lld_stop_conversion>
    3e10:	4b1a      	ldr	r3, [pc, #104]	; (3e7c <Vector88+0x18c>)
    3e12:	691b      	ldr	r3, [r3, #16]
    3e14:	689b      	ldr	r3, [r3, #8]
    3e16:	2b00      	cmp	r3, #0
    3e18:	d00f      	beq.n	3e3a <Vector88+0x14a>
    3e1a:	4b18      	ldr	r3, [pc, #96]	; (3e7c <Vector88+0x18c>)
    3e1c:	2205      	movs	r2, #5
    3e1e:	701a      	strb	r2, [r3, #0]
    3e20:	4b16      	ldr	r3, [pc, #88]	; (3e7c <Vector88+0x18c>)
    3e22:	691b      	ldr	r3, [r3, #16]
    3e24:	689b      	ldr	r3, [r3, #8]
    3e26:	4815      	ldr	r0, [pc, #84]	; (3e7c <Vector88+0x18c>)
    3e28:	2101      	movs	r1, #1
    3e2a:	4798      	blx	r3
    3e2c:	4b13      	ldr	r3, [pc, #76]	; (3e7c <Vector88+0x18c>)
    3e2e:	781b      	ldrb	r3, [r3, #0]
    3e30:	2b05      	cmp	r3, #5
    3e32:	d102      	bne.n	3e3a <Vector88+0x14a>
    3e34:	4b11      	ldr	r3, [pc, #68]	; (3e7c <Vector88+0x18c>)
    3e36:	2202      	movs	r2, #2
    3e38:	701a      	strb	r2, [r3, #0]
    3e3a:	4b10      	ldr	r3, [pc, #64]	; (3e7c <Vector88+0x18c>)
    3e3c:	2200      	movs	r2, #0
    3e3e:	611a      	str	r2, [r3, #16]
    3e40:	f7ff ff36 	bl	3cb0 <osalSysLockFromISR>
    3e44:	480e      	ldr	r0, [pc, #56]	; (3e80 <Vector88+0x190>)
    3e46:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3e4a:	f7ff ff41 	bl	3cd0 <osalThreadResumeI>
    3e4e:	f7ff ff37 	bl	3cc0 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
    3e52:	f7fc fded 	bl	a30 <_dbg_check_leave_isr>
    3e56:	f7fe ffcb 	bl	2df0 <_port_irq_epilogue>
}
    3e5a:	b003      	add	sp, #12
    3e5c:	f85d fb04 	ldr.w	pc, [sp], #4
    3e60:	40012000 	.word	0x40012000
    3e64:	20001144 	.word	0x20001144
    3e68:	20001158 	.word	0x20001158
    3e6c:	40012100 	.word	0x40012100
    3e70:	20001178 	.word	0x20001178
    3e74:	2000118c 	.word	0x2000118c
    3e78:	40012200 	.word	0x40012200
    3e7c:	200011ac 	.word	0x200011ac
    3e80:	200011c0 	.word	0x200011c0
    3e84:	f3af 8000 	nop.w
    3e88:	f3af 8000 	nop.w
    3e8c:	f3af 8000 	nop.w

00003e90 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
    3e90:	b508      	push	{r3, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
    3e92:	4814      	ldr	r0, [pc, #80]	; (3ee4 <adc_lld_init+0x54>)
    3e94:	f7ff f88c 	bl	2fb0 <adcObjectInit>
  ADCD1.adc = ADC1;
    3e98:	4b12      	ldr	r3, [pc, #72]	; (3ee4 <adc_lld_init+0x54>)
    3e9a:	4a13      	ldr	r2, [pc, #76]	; (3ee8 <adc_lld_init+0x58>)
    3e9c:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
    3e9e:	4b11      	ldr	r3, [pc, #68]	; (3ee4 <adc_lld_init+0x54>)
    3ea0:	4a12      	ldr	r2, [pc, #72]	; (3eec <adc_lld_init+0x5c>)
    3ea2:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
    3ea4:	4b0f      	ldr	r3, [pc, #60]	; (3ee4 <adc_lld_init+0x54>)
    3ea6:	4a12      	ldr	r2, [pc, #72]	; (3ef0 <adc_lld_init+0x60>)
    3ea8:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

#if STM32_ADC_USE_ADC2
  /* Driver initialization.*/
  adcObjectInit(&ADCD2);
    3eaa:	4812      	ldr	r0, [pc, #72]	; (3ef4 <adc_lld_init+0x64>)
    3eac:	f7ff f880 	bl	2fb0 <adcObjectInit>
  ADCD2.adc = ADC2;
    3eb0:	4b10      	ldr	r3, [pc, #64]	; (3ef4 <adc_lld_init+0x64>)
    3eb2:	4a11      	ldr	r2, [pc, #68]	; (3ef8 <adc_lld_init+0x68>)
    3eb4:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD2.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC2_DMA_STREAM);
    3eb6:	4b0f      	ldr	r3, [pc, #60]	; (3ef4 <adc_lld_init+0x64>)
    3eb8:	4a10      	ldr	r2, [pc, #64]	; (3efc <adc_lld_init+0x6c>)
    3eba:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD2.dmamode = STM32_DMA_CR_CHSEL(ADC2_DMA_CHANNEL) |
    3ebc:	4b0d      	ldr	r3, [pc, #52]	; (3ef4 <adc_lld_init+0x64>)
    3ebe:	4a10      	ldr	r2, [pc, #64]	; (3f00 <adc_lld_init+0x70>)
    3ec0:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

#if STM32_ADC_USE_ADC3
  /* Driver initialization.*/
  adcObjectInit(&ADCD3);
    3ec2:	4810      	ldr	r0, [pc, #64]	; (3f04 <adc_lld_init+0x74>)
    3ec4:	f7ff f874 	bl	2fb0 <adcObjectInit>
  ADCD3.adc = ADC3;
    3ec8:	4b0e      	ldr	r3, [pc, #56]	; (3f04 <adc_lld_init+0x74>)
    3eca:	4a0f      	ldr	r2, [pc, #60]	; (3f08 <adc_lld_init+0x78>)
    3ecc:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD3.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC3_DMA_STREAM);
    3ece:	4b0d      	ldr	r3, [pc, #52]	; (3f04 <adc_lld_init+0x74>)
    3ed0:	4a0e      	ldr	r2, [pc, #56]	; (3f0c <adc_lld_init+0x7c>)
    3ed2:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD3.dmamode = STM32_DMA_CR_CHSEL(ADC3_DMA_CHANNEL) |
    3ed4:	4b0b      	ldr	r3, [pc, #44]	; (3f04 <adc_lld_init+0x74>)
    3ed6:	4a0e      	ldr	r2, [pc, #56]	; (3f10 <adc_lld_init+0x80>)
    3ed8:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled because sharing.*/
  nvicEnableVector(STM32_ADC_NUMBER, STM32_ADC_IRQ_PRIORITY);
    3eda:	2012      	movs	r0, #18
    3edc:	2106      	movs	r1, #6
    3ede:	f7ff fa4f 	bl	3380 <nvicEnableVector>
}
    3ee2:	bd08      	pop	{r3, pc}
    3ee4:	20001144 	.word	0x20001144
    3ee8:	40012000 	.word	0x40012000
    3eec:	000049e0 	.word	0x000049e0
    3ef0:	00022c16 	.word	0x00022c16
    3ef4:	20001178 	.word	0x20001178
    3ef8:	40012100 	.word	0x40012100
    3efc:	000049c8 	.word	0x000049c8
    3f00:	02022c16 	.word	0x02022c16
    3f04:	200011ac 	.word	0x200011ac
    3f08:	40012200 	.word	0x40012200
    3f0c:	000049bc 	.word	0x000049bc
    3f10:	04022c16 	.word	0x04022c16
    3f14:	f3af 8000 	nop.w
    3f18:	f3af 8000 	nop.w
    3f1c:	f3af 8000 	nop.w

00003f20 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
    3f20:	b082      	sub	sp, #8
    3f22:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
    3f24:	9b01      	ldr	r3, [sp, #4]
    3f26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3f28:	681b      	ldr	r3, [r3, #0]
    3f2a:	9a01      	ldr	r2, [sp, #4]
    3f2c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    3f2e:	6812      	ldr	r2, [r2, #0]
    3f30:	6812      	ldr	r2, [r2, #0]
    3f32:	f022 021f 	bic.w	r2, r2, #31
    3f36:	601a      	str	r2, [r3, #0]
    3f38:	bf00      	nop
    3f3a:	9b01      	ldr	r3, [sp, #4]
    3f3c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3f3e:	681b      	ldr	r3, [r3, #0]
    3f40:	681b      	ldr	r3, [r3, #0]
    3f42:	f003 0301 	and.w	r3, r3, #1
    3f46:	2b00      	cmp	r3, #0
    3f48:	d1f7      	bne.n	3f3a <adc_lld_stop_conversion+0x1a>
    3f4a:	9b01      	ldr	r3, [sp, #4]
    3f4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3f4e:	685b      	ldr	r3, [r3, #4]
    3f50:	9a01      	ldr	r2, [sp, #4]
    3f52:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    3f54:	7a12      	ldrb	r2, [r2, #8]
    3f56:	213d      	movs	r1, #61	; 0x3d
    3f58:	fa01 f202 	lsl.w	r2, r1, r2
    3f5c:	601a      	str	r2, [r3, #0]
  adcp->adc->CR1 = 0;
    3f5e:	9b01      	ldr	r3, [sp, #4]
    3f60:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3f62:	2200      	movs	r2, #0
    3f64:	605a      	str	r2, [r3, #4]
  adcp->adc->CR2 = 0;
    3f66:	9b01      	ldr	r3, [sp, #4]
    3f68:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3f6a:	2200      	movs	r2, #0
    3f6c:	609a      	str	r2, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
    3f6e:	9b01      	ldr	r3, [sp, #4]
    3f70:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3f72:	2201      	movs	r2, #1
    3f74:	609a      	str	r2, [r3, #8]
}
    3f76:	b002      	add	sp, #8
    3f78:	4770      	bx	lr
    3f7a:	bf00      	nop
    3f7c:	f3af 8000 	nop.w

00003f80 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
    3f80:	b082      	sub	sp, #8
    3f82:	9001      	str	r0, [sp, #4]
    3f84:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
    3f86:	9b00      	ldr	r3, [sp, #0]
    3f88:	685a      	ldr	r2, [r3, #4]
    3f8a:	9b01      	ldr	r3, [sp, #4]
    3f8c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
    3f8e:	9b00      	ldr	r3, [sp, #0]
    3f90:	689a      	ldr	r2, [r3, #8]
    3f92:	9b01      	ldr	r3, [sp, #4]
    3f94:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
    3f96:	9b00      	ldr	r3, [sp, #0]
    3f98:	68da      	ldr	r2, [r3, #12]
    3f9a:	9b01      	ldr	r3, [sp, #4]
    3f9c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
    3f9e:	9b00      	ldr	r3, [sp, #0]
    3fa0:	691a      	ldr	r2, [r3, #16]
    3fa2:	9b01      	ldr	r3, [sp, #4]
    3fa4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
    3fa6:	9b00      	ldr	r3, [sp, #0]
    3fa8:	695a      	ldr	r2, [r3, #20]
    3faa:	9b01      	ldr	r3, [sp, #4]
    3fac:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
    3fae:	9b00      	ldr	r3, [sp, #0]
    3fb0:	699a      	ldr	r2, [r3, #24]
    3fb2:	9b01      	ldr	r3, [sp, #4]
    3fb4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
    3fb6:	9b00      	ldr	r3, [sp, #0]
    3fb8:	681a      	ldr	r2, [r3, #0]
    3fba:	9b01      	ldr	r3, [sp, #4]
    3fbc:	601a      	str	r2, [r3, #0]
}
    3fbe:	b002      	add	sp, #8
    3fc0:	4770      	bx	lr
    3fc2:	bf00      	nop
    3fc4:	f3af 8000 	nop.w
    3fc8:	f3af 8000 	nop.w
    3fcc:	f3af 8000 	nop.w

00003fd0 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    3fd0:	b500      	push	{lr}
    3fd2:	b083      	sub	sp, #12
    3fd4:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
    3fd6:	4a24      	ldr	r2, [pc, #144]	; (4068 <__ram2_size__+0x68>)
    3fd8:	4b23      	ldr	r3, [pc, #140]	; (4068 <__ram2_size__+0x68>)
    3fda:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    3fdc:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    3fe0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    3fe4:	6313      	str	r3, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
    3fe6:	4a20      	ldr	r2, [pc, #128]	; (4068 <__ram2_size__+0x68>)
    3fe8:	4b1f      	ldr	r3, [pc, #124]	; (4068 <__ram2_size__+0x68>)
    3fea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    3fec:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    3ff0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    3ff4:	6513      	str	r3, [r2, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
    3ff6:	9b01      	ldr	r3, [sp, #4]
    3ff8:	481c      	ldr	r0, [pc, #112]	; (406c <__ram2_size__+0x6c>)
    3ffa:	4619      	mov	r1, r3
    3ffc:	f7ff ffc0 	bl	3f80 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
    4000:	9b01      	ldr	r3, [sp, #4]
    4002:	331c      	adds	r3, #28
    4004:	481a      	ldr	r0, [pc, #104]	; (4070 <__ram2_size__+0x70>)
    4006:	4619      	mov	r1, r3
    4008:	f7ff ffba 	bl	3f80 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
    400c:	9b01      	ldr	r3, [sp, #4]
    400e:	3338      	adds	r3, #56	; 0x38
    4010:	4818      	ldr	r0, [pc, #96]	; (4074 <__ram2_size__+0x74>)
    4012:	4619      	mov	r1, r3
    4014:	f7ff ffb4 	bl	3f80 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
    4018:	9b01      	ldr	r3, [sp, #4]
    401a:	3354      	adds	r3, #84	; 0x54
    401c:	4816      	ldr	r0, [pc, #88]	; (4078 <__ram2_size__+0x78>)
    401e:	4619      	mov	r1, r3
    4020:	f7ff ffae 	bl	3f80 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
    4024:	9b01      	ldr	r3, [sp, #4]
    4026:	3370      	adds	r3, #112	; 0x70
    4028:	4814      	ldr	r0, [pc, #80]	; (407c <__ram2_size__+0x7c>)
    402a:	4619      	mov	r1, r3
    402c:	f7ff ffa8 	bl	3f80 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
    4030:	9b01      	ldr	r3, [sp, #4]
    4032:	338c      	adds	r3, #140	; 0x8c
    4034:	4812      	ldr	r0, [pc, #72]	; (4080 <__ram2_size__+0x80>)
    4036:	4619      	mov	r1, r3
    4038:	f7ff ffa2 	bl	3f80 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
    403c:	9b01      	ldr	r3, [sp, #4]
    403e:	33a8      	adds	r3, #168	; 0xa8
    4040:	4810      	ldr	r0, [pc, #64]	; (4084 <__ram2_size__+0x84>)
    4042:	4619      	mov	r1, r3
    4044:	f7ff ff9c 	bl	3f80 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
    4048:	9b01      	ldr	r3, [sp, #4]
    404a:	33c4      	adds	r3, #196	; 0xc4
    404c:	480e      	ldr	r0, [pc, #56]	; (4088 <__ram2_size__+0x88>)
    404e:	4619      	mov	r1, r3
    4050:	f7ff ff96 	bl	3f80 <initgpio>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
    4054:	9b01      	ldr	r3, [sp, #4]
    4056:	33e0      	adds	r3, #224	; 0xe0
    4058:	480c      	ldr	r0, [pc, #48]	; (408c <__ram2_size__+0x8c>)
    405a:	4619      	mov	r1, r3
    405c:	f7ff ff90 	bl	3f80 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
    4060:	b003      	add	sp, #12
    4062:	f85d fb04 	ldr.w	pc, [sp], #4
    4066:	bf00      	nop
    4068:	40023800 	.word	0x40023800
    406c:	40020000 	.word	0x40020000
    4070:	40020400 	.word	0x40020400
    4074:	40020800 	.word	0x40020800
    4078:	40020c00 	.word	0x40020c00
    407c:	40021000 	.word	0x40021000
    4080:	40021400 	.word	0x40021400
    4084:	40021800 	.word	0x40021800
    4088:	40021c00 	.word	0x40021c00
    408c:	40022000 	.word	0x40022000

00004090 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    4090:	b08e      	sub	sp, #56	; 0x38
    4092:	9003      	str	r0, [sp, #12]
    4094:	9102      	str	r1, [sp, #8]
    4096:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
    4098:	9b01      	ldr	r3, [sp, #4]
    409a:	f003 0303 	and.w	r3, r3, #3
    409e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
    40a0:	9b01      	ldr	r3, [sp, #4]
    40a2:	f003 0304 	and.w	r3, r3, #4
    40a6:	089b      	lsrs	r3, r3, #2
    40a8:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
    40aa:	9b01      	ldr	r3, [sp, #4]
    40ac:	f003 0318 	and.w	r3, r3, #24
    40b0:	08db      	lsrs	r3, r3, #3
    40b2:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
    40b4:	9b01      	ldr	r3, [sp, #4]
    40b6:	f003 0360 	and.w	r3, r3, #96	; 0x60
    40ba:	095b      	lsrs	r3, r3, #5
    40bc:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
    40be:	9b01      	ldr	r3, [sp, #4]
    40c0:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
    40c4:	09db      	lsrs	r3, r3, #7
    40c6:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
    40c8:	2300      	movs	r3, #0
    40ca:	9309      	str	r3, [sp, #36]	; 0x24
  while (TRUE) {
    if ((mask & 1) != 0) {
    40cc:	9b02      	ldr	r3, [sp, #8]
    40ce:	f003 0301 	and.w	r3, r3, #1
    40d2:	2b00      	cmp	r3, #0
    40d4:	d054      	beq.n	4180 <_pal_lld_setgroupmode+0xf0>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
    40d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    40d8:	f003 0307 	and.w	r3, r3, #7
    40dc:	009b      	lsls	r3, r3, #2
    40de:	9a08      	ldr	r2, [sp, #32]
    40e0:	fa02 f303 	lsl.w	r3, r2, r3
    40e4:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
    40e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    40e8:	f003 0307 	and.w	r3, r3, #7
    40ec:	009b      	lsls	r3, r3, #2
    40ee:	220f      	movs	r2, #15
    40f0:	fa02 f303 	lsl.w	r3, r2, r3
    40f4:	9306      	str	r3, [sp, #24]
      if (bit < 8)
    40f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    40f8:	2b07      	cmp	r3, #7
    40fa:	d809      	bhi.n	4110 <_pal_lld_setgroupmode+0x80>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
    40fc:	9b03      	ldr	r3, [sp, #12]
    40fe:	6a1a      	ldr	r2, [r3, #32]
    4100:	9b06      	ldr	r3, [sp, #24]
    4102:	43db      	mvns	r3, r3
    4104:	401a      	ands	r2, r3
    4106:	9b07      	ldr	r3, [sp, #28]
    4108:	431a      	orrs	r2, r3
    410a:	9b03      	ldr	r3, [sp, #12]
    410c:	621a      	str	r2, [r3, #32]
    410e:	e008      	b.n	4122 <_pal_lld_setgroupmode+0x92>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
    4110:	9b03      	ldr	r3, [sp, #12]
    4112:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    4114:	9b06      	ldr	r3, [sp, #24]
    4116:	43db      	mvns	r3, r3
    4118:	401a      	ands	r2, r3
    411a:	9b07      	ldr	r3, [sp, #28]
    411c:	431a      	orrs	r2, r3
    411e:	9b03      	ldr	r3, [sp, #12]
    4120:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
    4122:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4124:	2201      	movs	r2, #1
    4126:	fa02 f303 	lsl.w	r3, r2, r3
    412a:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
    412c:	9b03      	ldr	r3, [sp, #12]
    412e:	685a      	ldr	r2, [r3, #4]
    4130:	9b05      	ldr	r3, [sp, #20]
    4132:	43db      	mvns	r3, r3
    4134:	401a      	ands	r2, r3
    4136:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4138:	431a      	orrs	r2, r3
    413a:	9b03      	ldr	r3, [sp, #12]
    413c:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
    413e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4140:	005b      	lsls	r3, r3, #1
    4142:	2203      	movs	r2, #3
    4144:	fa02 f303 	lsl.w	r3, r2, r3
    4148:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
    414a:	9b03      	ldr	r3, [sp, #12]
    414c:	689a      	ldr	r2, [r3, #8]
    414e:	9b04      	ldr	r3, [sp, #16]
    4150:	43db      	mvns	r3, r3
    4152:	401a      	ands	r2, r3
    4154:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4156:	431a      	orrs	r2, r3
    4158:	9b03      	ldr	r3, [sp, #12]
    415a:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
    415c:	9b03      	ldr	r3, [sp, #12]
    415e:	68da      	ldr	r2, [r3, #12]
    4160:	9b04      	ldr	r3, [sp, #16]
    4162:	43db      	mvns	r3, r3
    4164:	401a      	ands	r2, r3
    4166:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4168:	431a      	orrs	r2, r3
    416a:	9b03      	ldr	r3, [sp, #12]
    416c:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
    416e:	9b03      	ldr	r3, [sp, #12]
    4170:	681a      	ldr	r2, [r3, #0]
    4172:	9b04      	ldr	r3, [sp, #16]
    4174:	43db      	mvns	r3, r3
    4176:	401a      	ands	r2, r3
    4178:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    417a:	431a      	orrs	r2, r3
    417c:	9b03      	ldr	r3, [sp, #12]
    417e:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
    4180:	9b02      	ldr	r3, [sp, #8]
    4182:	085b      	lsrs	r3, r3, #1
    4184:	9302      	str	r3, [sp, #8]
    if (!mask)
    4186:	9b02      	ldr	r3, [sp, #8]
    4188:	2b00      	cmp	r3, #0
    418a:	d100      	bne.n	418e <_pal_lld_setgroupmode+0xfe>
      return;
    418c:	e00f      	b.n	41ae <_pal_lld_setgroupmode+0x11e>
    otyper <<= 1;
    418e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4190:	005b      	lsls	r3, r3, #1
    4192:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
    4194:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4196:	009b      	lsls	r3, r3, #2
    4198:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
    419a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    419c:	009b      	lsls	r3, r3, #2
    419e:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
    41a0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    41a2:	009b      	lsls	r3, r3, #2
    41a4:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
    41a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    41a8:	3301      	adds	r3, #1
    41aa:	9309      	str	r3, [sp, #36]	; 0x24
  }
    41ac:	e78e      	b.n	40cc <_pal_lld_setgroupmode+0x3c>
}
    41ae:	b00e      	add	sp, #56	; 0x38
    41b0:	4770      	bx	lr
    41b2:	bf00      	nop
    41b4:	f3af 8000 	nop.w
    41b8:	f3af 8000 	nop.w
    41bc:	f3af 8000 	nop.w

000041c0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    41c0:	b082      	sub	sp, #8
    41c2:	2320      	movs	r3, #32
    41c4:	9301      	str	r3, [sp, #4]
    41c6:	9b01      	ldr	r3, [sp, #4]
    41c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    41cc:	b002      	add	sp, #8
    41ce:	4770      	bx	lr

000041d0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    41d0:	b082      	sub	sp, #8
    41d2:	2300      	movs	r3, #0
    41d4:	9301      	str	r3, [sp, #4]
    41d6:	9b01      	ldr	r3, [sp, #4]
    41d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    41dc:	b002      	add	sp, #8
    41de:	4770      	bx	lr

000041e0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    41e0:	b508      	push	{r3, lr}

  port_lock();
    41e2:	f7ff ffed 	bl	41c0 <port_lock>
}
    41e6:	bd08      	pop	{r3, pc}
    41e8:	f3af 8000 	nop.w
    41ec:	f3af 8000 	nop.w

000041f0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    41f0:	b508      	push	{r3, lr}

  port_unlock();
    41f2:	f7ff ffed 	bl	41d0 <port_unlock>
}
    41f6:	bd08      	pop	{r3, pc}
    41f8:	f3af 8000 	nop.w
    41fc:	f3af 8000 	nop.w

00004200 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    4200:	b508      	push	{r3, lr}

  port_lock_from_isr();
    4202:	f7ff ffed 	bl	41e0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    4206:	f7fd fc9b 	bl	1b40 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    420a:	f7fc fbc1 	bl	990 <_dbg_check_lock_from_isr>
}
    420e:	bd08      	pop	{r3, pc}

00004210 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    4210:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    4212:	f7fc fbd5 	bl	9c0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    4216:	f7fd fc9b 	bl	1b50 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    421a:	f7ff ffe9 	bl	41f0 <port_unlock_from_isr>
}
    421e:	bd08      	pop	{r3, pc}

00004220 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
    4220:	b500      	push	{lr}
    4222:	b083      	sub	sp, #12
    4224:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    4226:	f7fc fc23 	bl	a70 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    422a:	9b01      	ldr	r3, [sp, #4]
    422c:	695a      	ldr	r2, [r3, #20]
    422e:	9b01      	ldr	r3, [sp, #4]
    4230:	699b      	ldr	r3, [r3, #24]
    4232:	429a      	cmp	r2, r3
    4234:	d105      	bne.n	4242 <chOQIsEmptyI+0x22>
    4236:	9b01      	ldr	r3, [sp, #4]
    4238:	689b      	ldr	r3, [r3, #8]
    423a:	2b00      	cmp	r3, #0
    423c:	d001      	beq.n	4242 <chOQIsEmptyI+0x22>
    423e:	2301      	movs	r3, #1
    4240:	e000      	b.n	4244 <chOQIsEmptyI+0x24>
    4242:	2300      	movs	r3, #0
    4244:	f003 0301 	and.w	r3, r3, #1
    4248:	b2db      	uxtb	r3, r3
}
    424a:	4618      	mov	r0, r3
    424c:	b003      	add	sp, #12
    424e:	f85d fb04 	ldr.w	pc, [sp], #4
    4252:	bf00      	nop
    4254:	f3af 8000 	nop.w
    4258:	f3af 8000 	nop.w
    425c:	f3af 8000 	nop.w

00004260 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    4260:	b508      	push	{r3, lr}

  chSysLockFromISR();
    4262:	f7ff ffcd 	bl	4200 <chSysLockFromISR>
}
    4266:	bd08      	pop	{r3, pc}
    4268:	f3af 8000 	nop.w
    426c:	f3af 8000 	nop.w

00004270 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    4270:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    4272:	f7ff ffcd 	bl	4210 <chSysUnlockFromISR>
}
    4276:	bd08      	pop	{r3, pc}
    4278:	f3af 8000 	nop.w
    427c:	f3af 8000 	nop.w

00004280 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    4280:	b500      	push	{lr}
    4282:	b083      	sub	sp, #12
    4284:	9001      	str	r0, [sp, #4]
    4286:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
    4288:	9801      	ldr	r0, [sp, #4]
    428a:	9900      	ldr	r1, [sp, #0]
    428c:	f7fd fff8 	bl	2280 <chEvtBroadcastFlagsI>
}
    4290:	b003      	add	sp, #12
    4292:	f85d fb04 	ldr.w	pc, [sp], #4
    4296:	bf00      	nop
    4298:	f3af 8000 	nop.w
    429c:	f3af 8000 	nop.w

000042a0 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
    42a0:	b084      	sub	sp, #16
    42a2:	9001      	str	r0, [sp, #4]
    42a4:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
    42a6:	9b01      	ldr	r3, [sp, #4]
    42a8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    42ac:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
    42ae:	9b01      	ldr	r3, [sp, #4]
    42b0:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    42b4:	4b1d      	ldr	r3, [pc, #116]	; (432c <usart_init+0x8c>)
    42b6:	429a      	cmp	r2, r3
    42b8:	d005      	beq.n	42c6 <usart_init+0x26>
    42ba:	9b01      	ldr	r3, [sp, #4]
    42bc:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    42c0:	4b1b      	ldr	r3, [pc, #108]	; (4330 <usart_init+0x90>)
    42c2:	429a      	cmp	r2, r3
    42c4:	d107      	bne.n	42d6 <usart_init+0x36>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
    42c6:	9b00      	ldr	r3, [sp, #0]
    42c8:	681b      	ldr	r3, [r3, #0]
    42ca:	4a1a      	ldr	r2, [pc, #104]	; (4334 <usart_init+0x94>)
    42cc:	fbb2 f2f3 	udiv	r2, r2, r3
    42d0:	9b03      	ldr	r3, [sp, #12]
    42d2:	609a      	str	r2, [r3, #8]
    42d4:	e006      	b.n	42e4 <usart_init+0x44>
  else
    u->BRR = STM32_PCLK1 / config->speed;
    42d6:	9b00      	ldr	r3, [sp, #0]
    42d8:	681b      	ldr	r3, [r3, #0]
    42da:	4a17      	ldr	r2, [pc, #92]	; (4338 <usart_init+0x98>)
    42dc:	fbb2 f2f3 	udiv	r2, r2, r3
    42e0:	9b03      	ldr	r3, [sp, #12]
    42e2:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
    42e4:	9b00      	ldr	r3, [sp, #0]
    42e6:	88db      	ldrh	r3, [r3, #6]
    42e8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    42ec:	b29b      	uxth	r3, r3
    42ee:	461a      	mov	r2, r3
    42f0:	9b03      	ldr	r3, [sp, #12]
    42f2:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
    42f4:	9b00      	ldr	r3, [sp, #0]
    42f6:	891b      	ldrh	r3, [r3, #8]
    42f8:	f043 0301 	orr.w	r3, r3, #1
    42fc:	b29b      	uxth	r3, r3
    42fe:	461a      	mov	r2, r3
    4300:	9b03      	ldr	r3, [sp, #12]
    4302:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
    4304:	9b00      	ldr	r3, [sp, #0]
    4306:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
    4308:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
    430c:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
    4310:	b29b      	uxth	r3, r3
    4312:	461a      	mov	r2, r3
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
    4314:	9b03      	ldr	r3, [sp, #12]
    4316:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
    4318:	9b03      	ldr	r3, [sp, #12]
    431a:	2200      	movs	r2, #0
    431c:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
    431e:	9b03      	ldr	r3, [sp, #12]
    4320:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
    4322:	9b03      	ldr	r3, [sp, #12]
    4324:	685b      	ldr	r3, [r3, #4]
}
    4326:	b004      	add	sp, #16
    4328:	4770      	bx	lr
    432a:	bf00      	nop
    432c:	40011000 	.word	0x40011000
    4330:	40011400 	.word	0x40011400
    4334:	0501bd00 	.word	0x0501bd00
    4338:	0280de80 	.word	0x0280de80
    433c:	f3af 8000 	nop.w

00004340 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
    4340:	b500      	push	{lr}
    4342:	b085      	sub	sp, #20
    4344:	9001      	str	r0, [sp, #4]
    4346:	460b      	mov	r3, r1
    4348:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
    434c:	2300      	movs	r3, #0
    434e:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
    4350:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    4354:	f003 0308 	and.w	r3, r3, #8
    4358:	2b00      	cmp	r3, #0
    435a:	d003      	beq.n	4364 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
    435c:	9b03      	ldr	r3, [sp, #12]
    435e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    4362:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
    4364:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    4368:	f003 0301 	and.w	r3, r3, #1
    436c:	2b00      	cmp	r3, #0
    436e:	d003      	beq.n	4378 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
    4370:	9b03      	ldr	r3, [sp, #12]
    4372:	f043 0320 	orr.w	r3, r3, #32
    4376:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
    4378:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    437c:	f003 0302 	and.w	r3, r3, #2
    4380:	2b00      	cmp	r3, #0
    4382:	d003      	beq.n	438c <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
    4384:	9b03      	ldr	r3, [sp, #12]
    4386:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    438a:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
    438c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    4390:	f003 0304 	and.w	r3, r3, #4
    4394:	2b00      	cmp	r3, #0
    4396:	d003      	beq.n	43a0 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
    4398:	9b03      	ldr	r3, [sp, #12]
    439a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    439e:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
    43a0:	9b01      	ldr	r3, [sp, #4]
    43a2:	3304      	adds	r3, #4
    43a4:	4618      	mov	r0, r3
    43a6:	9903      	ldr	r1, [sp, #12]
    43a8:	f7ff ff6a 	bl	4280 <osalEventBroadcastFlagsI>
}
    43ac:	b005      	add	sp, #20
    43ae:	f85d fb04 	ldr.w	pc, [sp], #4
    43b2:	bf00      	nop
    43b4:	f3af 8000 	nop.w
    43b8:	f3af 8000 	nop.w
    43bc:	f3af 8000 	nop.w

000043c0 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
    43c0:	b500      	push	{lr}
    43c2:	b087      	sub	sp, #28
    43c4:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
    43c6:	9b01      	ldr	r3, [sp, #4]
    43c8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    43cc:	9304      	str	r3, [sp, #16]
  uint16_t cr1 = u->CR1;
    43ce:	9b04      	ldr	r3, [sp, #16]
    43d0:	68db      	ldr	r3, [r3, #12]
    43d2:	f8ad 300e 	strh.w	r3, [sp, #14]
  uint16_t sr = u->SR;
    43d6:	9b04      	ldr	r3, [sp, #16]
    43d8:	681b      	ldr	r3, [r3, #0]
    43da:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    43de:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    43e2:	f403 7380 	and.w	r3, r3, #256	; 0x100
    43e6:	2b00      	cmp	r3, #0
    43e8:	d00e      	beq.n	4408 <serve_interrupt+0x48>
    osalSysLockFromISR();
    43ea:	f7ff ff39 	bl	4260 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    43ee:	9b01      	ldr	r3, [sp, #4]
    43f0:	3304      	adds	r3, #4
    43f2:	4618      	mov	r0, r3
    43f4:	f44f 7100 	mov.w	r1, #512	; 0x200
    43f8:	f7ff ff42 	bl	4280 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
    43fc:	9b04      	ldr	r3, [sp, #16]
    43fe:	f46f 7280 	mvn.w	r2, #256	; 0x100
    4402:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
    4404:	f7ff ff34 	bl	4270 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  osalSysLockFromISR();
    4408:	f7ff ff2a 	bl	4260 <osalSysLockFromISR>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
    440c:	e01f      	b.n	444e <serve_interrupt+0x8e>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
    440e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    4412:	f003 030f 	and.w	r3, r3, #15
    4416:	2b00      	cmp	r3, #0
    4418:	d005      	beq.n	4426 <serve_interrupt+0x66>
      set_error(sdp, sr);
    441a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    441e:	9801      	ldr	r0, [sp, #4]
    4420:	4619      	mov	r1, r3
    4422:	f7ff ff8d 	bl	4340 <set_error>
    b = u->DR;
    4426:	9b04      	ldr	r3, [sp, #16]
    4428:	685b      	ldr	r3, [r3, #4]
    442a:	f88d 300d 	strb.w	r3, [sp, #13]
    if (sr & USART_SR_RXNE)
    442e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    4432:	f003 0320 	and.w	r3, r3, #32
    4436:	2b00      	cmp	r3, #0
    4438:	d005      	beq.n	4446 <serve_interrupt+0x86>
      sdIncomingDataI(sdp, b);
    443a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    443e:	9801      	ldr	r0, [sp, #4]
    4440:	4619      	mov	r1, r3
    4442:	f7fe ff65 	bl	3310 <sdIncomingDataI>
    sr = u->SR;
    4446:	9b04      	ldr	r3, [sp, #16]
    4448:	681b      	ldr	r3, [r3, #0]
    444a:	f8ad 3016 	strh.w	r3, [sp, #22]
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
    444e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    4452:	f003 032f 	and.w	r3, r3, #47	; 0x2f
    4456:	2b00      	cmp	r3, #0
    4458:	d1d9      	bne.n	440e <serve_interrupt+0x4e>
    b = u->DR;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
  }
  osalSysUnlockFromISR();
    445a:	f7ff ff09 	bl	4270 <osalSysUnlockFromISR>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    445e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    4462:	f003 0380 	and.w	r3, r3, #128	; 0x80
    4466:	2b00      	cmp	r3, #0
    4468:	d024      	beq.n	44b4 <serve_interrupt+0xf4>
    446a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    446e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    4472:	2b00      	cmp	r3, #0
    4474:	d01e      	beq.n	44b4 <serve_interrupt+0xf4>
    msg_t b;
    osalSysLockFromISR();
    4476:	f7ff fef3 	bl	4260 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
    447a:	9b01      	ldr	r3, [sp, #4]
    447c:	3330      	adds	r3, #48	; 0x30
    447e:	4618      	mov	r0, r3
    4480:	f7fe fa66 	bl	2950 <chOQGetI>
    4484:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
    4486:	9b02      	ldr	r3, [sp, #8]
    4488:	2b00      	cmp	r3, #0
    448a:	da0e      	bge.n	44aa <serve_interrupt+0xea>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    448c:	9b01      	ldr	r3, [sp, #4]
    448e:	3304      	adds	r3, #4
    4490:	4618      	mov	r0, r3
    4492:	2108      	movs	r1, #8
    4494:	f7ff fef4 	bl	4280 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    4498:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    449c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    44a0:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    44a4:	9b04      	ldr	r3, [sp, #16]
    44a6:	60da      	str	r2, [r3, #12]
    44a8:	e002      	b.n	44b0 <serve_interrupt+0xf0>
    }
    else
      u->DR = b;
    44aa:	9a02      	ldr	r2, [sp, #8]
    44ac:	9b04      	ldr	r3, [sp, #16]
    44ae:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
    44b0:	f7ff fede 	bl	4270 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    44b4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    44b8:	f003 0340 	and.w	r3, r3, #64	; 0x40
    44bc:	2b00      	cmp	r3, #0
    44be:	d01b      	beq.n	44f8 <serve_interrupt+0x138>
    osalSysLockFromISR();
    44c0:	f7ff fece 	bl	4260 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
    44c4:	9b01      	ldr	r3, [sp, #4]
    44c6:	3330      	adds	r3, #48	; 0x30
    44c8:	4618      	mov	r0, r3
    44ca:	f7ff fea9 	bl	4220 <chOQIsEmptyI>
    44ce:	4603      	mov	r3, r0
    44d0:	2b00      	cmp	r3, #0
    44d2:	d005      	beq.n	44e0 <serve_interrupt+0x120>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    44d4:	9b01      	ldr	r3, [sp, #4]
    44d6:	3304      	adds	r3, #4
    44d8:	4618      	mov	r0, r3
    44da:	2110      	movs	r1, #16
    44dc:	f7ff fed0 	bl	4280 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
    44e0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    44e4:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    44e8:	9b04      	ldr	r3, [sp, #16]
    44ea:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
    44ec:	9b04      	ldr	r3, [sp, #16]
    44ee:	f06f 0240 	mvn.w	r2, #64	; 0x40
    44f2:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
    44f4:	f7ff febc 	bl	4270 <osalSysUnlockFromISR>
  }
}
    44f8:	b007      	add	sp, #28
    44fa:	f85d fb04 	ldr.w	pc, [sp], #4
    44fe:	bf00      	nop

00004500 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
    4500:	b082      	sub	sp, #8
    4502:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
    4504:	4b03      	ldr	r3, [pc, #12]	; (4514 <notify1+0x14>)
    4506:	4a03      	ldr	r2, [pc, #12]	; (4514 <notify1+0x14>)
    4508:	68d2      	ldr	r2, [r2, #12]
    450a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    450e:	60da      	str	r2, [r3, #12]
}
    4510:	b002      	add	sp, #8
    4512:	4770      	bx	lr
    4514:	40011000 	.word	0x40011000
    4518:	f3af 8000 	nop.w
    451c:	f3af 8000 	nop.w

00004520 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
    4520:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    4522:	f7fd facd 	bl	1ac0 <_stats_increase_irq>
    4526:	f7fc fa63 	bl	9f0 <_dbg_check_enter_isr>

  serve_interrupt(&SD1);
    452a:	4804      	ldr	r0, [pc, #16]	; (453c <VectorD4+0x1c>)
    452c:	f7ff ff48 	bl	43c0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
    4530:	f7fc fa7e 	bl	a30 <_dbg_check_leave_isr>
    4534:	f7fe fc5c 	bl	2df0 <_port_irq_epilogue>
}
    4538:	bd08      	pop	{r3, pc}
    453a:	bf00      	nop
    453c:	200011e0 	.word	0x200011e0

00004540 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
    4540:	b508      	push	{r3, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
    4542:	4805      	ldr	r0, [pc, #20]	; (4558 <sd_lld_init+0x18>)
    4544:	2100      	movs	r1, #0
    4546:	4a05      	ldr	r2, [pc, #20]	; (455c <sd_lld_init+0x1c>)
    4548:	f7fe fe8a 	bl	3260 <sdObjectInit>
  SD1.usart = USART1;
    454c:	4b02      	ldr	r3, [pc, #8]	; (4558 <sd_lld_init+0x18>)
    454e:	4a04      	ldr	r2, [pc, #16]	; (4560 <sd_lld_init+0x20>)
    4550:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
    4554:	bd08      	pop	{r3, pc}
    4556:	bf00      	nop
    4558:	200011e0 	.word	0x200011e0
    455c:	00004501 	.word	0x00004501
    4560:	40011000 	.word	0x40011000
    4564:	f3af 8000 	nop.w
    4568:	f3af 8000 	nop.w
    456c:	f3af 8000 	nop.w

00004570 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
    4570:	b500      	push	{lr}
    4572:	b083      	sub	sp, #12
    4574:	9001      	str	r0, [sp, #4]
    4576:	9100      	str	r1, [sp, #0]

  if (config == NULL)
    4578:	9b00      	ldr	r3, [sp, #0]
    457a:	2b00      	cmp	r3, #0
    457c:	d101      	bne.n	4582 <sd_lld_start+0x12>
    config = &default_config;
    457e:	4b0d      	ldr	r3, [pc, #52]	; (45b4 <sd_lld_start+0x44>)
    4580:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
    4582:	9b01      	ldr	r3, [sp, #4]
    4584:	7a1b      	ldrb	r3, [r3, #8]
    4586:	2b01      	cmp	r3, #1
    4588:	d10d      	bne.n	45a6 <sd_lld_start+0x36>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
    458a:	9a01      	ldr	r2, [sp, #4]
    458c:	4b0a      	ldr	r3, [pc, #40]	; (45b8 <sd_lld_start+0x48>)
    458e:	429a      	cmp	r2, r3
    4590:	d109      	bne.n	45a6 <sd_lld_start+0x36>
      rccEnableUSART1(FALSE);
    4592:	4b0a      	ldr	r3, [pc, #40]	; (45bc <sd_lld_start+0x4c>)
    4594:	4a09      	ldr	r2, [pc, #36]	; (45bc <sd_lld_start+0x4c>)
    4596:	6c52      	ldr	r2, [r2, #68]	; 0x44
    4598:	f042 0210 	orr.w	r2, r2, #16
    459c:	645a      	str	r2, [r3, #68]	; 0x44
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    459e:	2025      	movs	r0, #37	; 0x25
    45a0:	210c      	movs	r1, #12
    45a2:	f7fe feed 	bl	3380 <nvicEnableVector>
      rccEnableUART8(FALSE);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
    45a6:	9801      	ldr	r0, [sp, #4]
    45a8:	9900      	ldr	r1, [sp, #0]
    45aa:	f7ff fe79 	bl	42a0 <usart_init>
}
    45ae:	b003      	add	sp, #12
    45b0:	f85d fb04 	ldr.w	pc, [sp], #4
    45b4:	00004a10 	.word	0x00004a10
    45b8:	200011e0 	.word	0x200011e0
    45bc:	40023800 	.word	0x40023800

000045c0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
    45c0:	b508      	push	{r3, lr}

  stm32_clock_init();
    45c2:	f7fe ff5d 	bl	3480 <stm32_clock_init>
}
    45c6:	bd08      	pop	{r3, pc}
    45c8:	f3af 8000 	nop.w
    45cc:	f3af 8000 	nop.w

000045d0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
    45d0:	4770      	bx	lr
    45d2:	bf00      	nop
    45d4:	f3af 8000 	nop.w
    45d8:	f3af 8000 	nop.w
    45dc:	f3af 8000 	nop.w
    45e0:	656c6469 	.word	0x656c6469
	...
    45f0:	31235653 	.word	0x31235653
    45f4:	00000000 	.word	0x00000000
    45f8:	32235653 	.word	0x32235653
    45fc:	00000000 	.word	0x00000000
    4600:	33235653 	.word	0x33235653
    4604:	00000000 	.word	0x00000000
    4608:	34235653 	.word	0x34235653
    460c:	00000000 	.word	0x00000000
    4610:	35235653 	.word	0x35235653
    4614:	00000000 	.word	0x00000000
    4618:	36235653 	.word	0x36235653
    461c:	00000000 	.word	0x00000000
    4620:	37235653 	.word	0x37235653
    4624:	00000000 	.word	0x00000000
    4628:	38235653 	.word	0x38235653
    462c:	00000000 	.word	0x00000000
    4630:	39235653 	.word	0x39235653
    4634:	00000000 	.word	0x00000000
    4638:	31235653 	.word	0x31235653
    463c:	00000030 	.word	0x00000030
    4640:	31235653 	.word	0x31235653
    4644:	00000031 	.word	0x00000031
	...
    4650:	63617473 	.word	0x63617473
    4654:	766f206b 	.word	0x766f206b
    4658:	6c667265 	.word	0x6c667265
    465c:	0000776f 	.word	0x0000776f

00004660 <__func__.6011>:
    4660:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

00004670 <__func__.6628>:
    4670:	54566863 65536f44 00004974 00000000     chVTDoSetI......

00004680 <__func__.6636>:
    4680:	54566863 65526f44 49746573 00000000     chVTDoResetI....

00004690 <__func__.6625>:
    4690:	63536863 61655268 00497964 00000000     chSchReadyI.....

000046a0 <__func__.6637>:
    46a0:	68546863 65724364 49657461 00000000     chThdCreateI....

000046b0 <__func__.5925>:
    46b0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000046c0 <__func__.6653>:
    46c0:	68546863 74655364 6f697250 79746972     chThdSetPriority
	...

000046e0 <__func__.6096>:
    46e0:	68546863 656c5364 00537065 00000000     chThdSleepS.....

000046f0 <__func__.6681>:
    46f0:	68546863 69784564 00005374 00000000     chThdExitS......

00004700 <__func__.6686>:
    4700:	68546863 69615764 00000074 00000000     chThdWait.......

00004710 <__func__.6703>:
    4710:	68546863 73655264 49656d75 00000000     chThdResumeI....

00004720 <__func__.6108>:
    4720:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
    4730:	00497478 00000000 00000000 00000000     xtI.............

00004740 <__func__.5925>:
    4740:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004750 <__func__.6625>:
    4750:	68546863 6c655264 65736165 00000000     chThdRelease....

00004760 <ch_debug>:
    4760:	6e69616d 18021600 08600404 1814100c     main......`.....
    4770:	2221201c 00000000 00000000 00000000     . !"............

00004780 <__func__.6621>:
    4780:	65536863 6a624f6d 49746365 0074696e     chSemObjectInit.

00004790 <__func__.6652>:
    4790:	65536863 6961576d 6d695474 74756f65     chSemWaitTimeout
    47a0:	00000053 00000000 00000000 00000000     S...............

000047b0 <__func__.6660>:
    47b0:	65536863 6769536d 496c616e 00000000     chSemSignalI....

000047c0 <__func__.6620>:
    47c0:	744d6863 6a624f78 49746365 0074696e     chMtxObjectInit.

000047d0 <__func__.5925>:
    47d0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000047e0 <__func__.6628>:
    47e0:	744d6863 636f4c78 0000536b 00000000     chMtxLockS......

000047f0 <__func__.6651>:
    47f0:	744d6863 6c6e5578 006b636f 00000000     chMtxUnlock.....

00004800 <__func__.6645>:
    4800:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
    4810:	49736761 00000000 00000000 00000000     agsI............

00004820 <__func__.6662>:
    4820:	76456863 67695374 496c616e 00000000     chEvtSignalI....

00004830 <__func__.6622>:
    4830:	424d6863 656a624f 6e497463 00007469     chMBObjectInit..

00004840 <__func__.5925>:
    4840:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004850 <__func__.6678>:
    4850:	424d6863 63746546 00005368 00000000     chMBFetchS......

00004860 <__func__.5925>:
    4860:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004870 <__func__.6648>:
    4870:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.

00004880 <__func__.6684>:
    4880:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

000048a0 <__func__.5925>:
    48a0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000048b0 <__func__.6644>:
    48b0:	65486863 72467061 00006565 00000000     chHeapFree......

000048c0 <__func__.5925>:
    48c0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000048d0 <__func__.6646>:
    48d0:	6f506863 72466c6f 00496565 00000000     chPoolFreeI.....

000048e0 <__func__.7143>:
    48e0:	74537473 41747261 6d72616c 00000000     stStartAlarm....

000048f0 <__func__.7150>:
    48f0:	65537473 616c4174 00006d72 00000000     stSetAlarm......

00004900 <vmt>:
    4900:	000030f1 00003121 00003151 00003181     .0..!1..Q1...1..
    4910:	000031a1 000031d1 000031f1 00003221     .1...1...1..!2..

00004920 <__func__.7188>:
    4920:	74536473 00747261 00000000 00000000     sdStart.........

00004930 <__func__.5925>:
    4930:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004940 <__func__.7197>:
    4940:	6e496473 696d6f63 6144676e 00496174     sdIncomingDataI.

00004950 <_stm32_dma_streams>:
    4950:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
    4960:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
    4970:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
    4980:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
    4990:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
    49a0:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
    49b0:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
    49c0:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
    49d0:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
    49e0:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
    49f0:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
    4a00:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

00004a10 <default_config>:
    4a10:	00002580 40000000 00000000 00000000     .%.....@........

00004a20 <pal_default_config>:
    4a20:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
    4a30:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
    4a40:	00000240 ffffffff 55514515 0000ffff     @........EQU....
    4a50:	04000000 00000040 02208001 00000000     ....@..... .....
    4a60:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
    4a70:	00060600 55000100 00000000 ffffffff     .......U........
    4a80:	00555055 00000fff 00000000 00000000     UPU.............
    4a90:	00000040 00000000 ffffffff 00000000     @...............
    4aa0:	0000ffff 00000000 00000000 00000000     ................
    4ab0:	00000000 ffffffff 00000000 0000ffff     ................
	...
    4ad0:	ffffffff 00000000 0000ffff 00000000     ................
	...
    4aec:	ffffffff 00000000 0000ffff 00000000     ................
	...
    4b08:	ffffffff 00000000 0000ffff 00000000     ................
    4b18:	00000000                                ....
