
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

000001c0 <Reset_Handler>:
     1c0:	b672      	cpsid	i
     1c2:	4821      	ldr	r0, [pc, #132]	; (248 <endfiniloop+0x4>)
     1c4:	f380 8809 	msr	PSP, r0
     1c8:	2002      	movs	r0, #2
     1ca:	f380 8814 	msr	CONTROL, r0
     1ce:	f3bf 8f6f 	isb	sy
     1d2:	f000 f875 	bl	2c0 <__core_init>
     1d6:	f003 fef3 	bl	3fc0 <__early_init>
     1da:	481c      	ldr	r0, [pc, #112]	; (24c <endfiniloop+0x8>)
     1dc:	491c      	ldr	r1, [pc, #112]	; (250 <endfiniloop+0xc>)
     1de:	4a1d      	ldr	r2, [pc, #116]	; (254 <endfiniloop+0x10>)

000001e0 <msloop>:
     1e0:	4291      	cmp	r1, r2
     1e2:	bf3c      	itt	cc
     1e4:	f841 0b04 	strcc.w	r0, [r1], #4
     1e8:	e7fa      	bcc.n	1e0 <msloop>
     1ea:	491b      	ldr	r1, [pc, #108]	; (258 <endfiniloop+0x14>)
     1ec:	4a16      	ldr	r2, [pc, #88]	; (248 <endfiniloop+0x4>)

000001ee <psloop>:
     1ee:	4291      	cmp	r1, r2
     1f0:	bf3c      	itt	cc
     1f2:	f841 0b04 	strcc.w	r0, [r1], #4
     1f6:	e7fa      	bcc.n	1ee <psloop>
     1f8:	4918      	ldr	r1, [pc, #96]	; (25c <endfiniloop+0x18>)
     1fa:	4a19      	ldr	r2, [pc, #100]	; (260 <endfiniloop+0x1c>)
     1fc:	4b19      	ldr	r3, [pc, #100]	; (264 <endfiniloop+0x20>)

000001fe <dloop>:
     1fe:	429a      	cmp	r2, r3
     200:	bf3e      	ittt	cc
     202:	f851 0b04 	ldrcc.w	r0, [r1], #4
     206:	f842 0b04 	strcc.w	r0, [r2], #4
     20a:	e7f8      	bcc.n	1fe <dloop>
     20c:	2000      	movs	r0, #0
     20e:	4916      	ldr	r1, [pc, #88]	; (268 <endfiniloop+0x24>)
     210:	4a16      	ldr	r2, [pc, #88]	; (26c <endfiniloop+0x28>)

00000212 <bloop>:
     212:	4291      	cmp	r1, r2
     214:	bf3c      	itt	cc
     216:	f841 0b04 	strcc.w	r0, [r1], #4
     21a:	e7fa      	bcc.n	212 <bloop>
     21c:	f000 f858 	bl	2d0 <__late_init>
     220:	4c13      	ldr	r4, [pc, #76]	; (270 <endfiniloop+0x2c>)
     222:	4d14      	ldr	r5, [pc, #80]	; (274 <endfiniloop+0x30>)

00000224 <initloop>:
     224:	42ac      	cmp	r4, r5
     226:	da03      	bge.n	230 <endinitloop>
     228:	f854 1b04 	ldr.w	r1, [r4], #4
     22c:	4788      	blx	r1
     22e:	e7f9      	b.n	224 <initloop>

00000230 <endinitloop>:
     230:	f003 fed6 	bl	3fe0 <main>
     234:	4c10      	ldr	r4, [pc, #64]	; (278 <endfiniloop+0x34>)
     236:	4d11      	ldr	r5, [pc, #68]	; (27c <endfiniloop+0x38>)

00000238 <finiloop>:
     238:	42ac      	cmp	r4, r5
     23a:	da03      	bge.n	244 <endfiniloop>
     23c:	f854 1b04 	ldr.w	r1, [r4], #4
     240:	4788      	blx	r1
     242:	e7f9      	b.n	238 <finiloop>

00000244 <endfiniloop>:
     244:	f000 b84c 	b.w	2e0 <__default_exit>
     248:	20000800 	.word	0x20000800
     24c:	55555555 	.word	0x55555555
     250:	20000000 	.word	0x20000000
     254:	20000400 	.word	0x20000400
     258:	20000400 	.word	0x20000400
     25c:	000049c0 	.word	0x000049c0
     260:	20000800 	.word	0x20000800
     264:	20000800 	.word	0x20000800
     268:	20000800 	.word	0x20000800
     26c:	20001740 	.word	0x20001740
     270:	000001c0 	.word	0x000001c0
     274:	000001c0 	.word	0x000001c0
     278:	000001c0 	.word	0x000001c0
     27c:	000001c0 	.word	0x000001c0

00000280 <_port_switch>:
     280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     284:	f8c1 d00c 	str.w	sp, [r1, #12]
     288:	f8d0 d00c 	ldr.w	sp, [r0, #12]
     28c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00000290 <_port_thread_start>:
     290:	f000 fa8e 	bl	7b0 <_dbg_check_unlock>
     294:	f001 fb24 	bl	18e0 <_stats_stop_measure_crit_thd>
     298:	2300      	movs	r3, #0
     29a:	f383 8811 	msr	BASEPRI, r3
     29e:	4628      	mov	r0, r5
     2a0:	47a0      	blx	r4
     2a2:	2000      	movs	r0, #0
     2a4:	f001 f964 	bl	1570 <chThdExit>

000002a8 <_port_switch_from_isr>:
     2a8:	f001 fb12 	bl	18d0 <_stats_start_measure_crit_thd>
     2ac:	f000 fa68 	bl	780 <_dbg_check_lock>
     2b0:	f000 ff4e 	bl	1150 <chSchDoReschedule>
     2b4:	f000 fa7c 	bl	7b0 <_dbg_check_unlock>
     2b8:	f001 fb12 	bl	18e0 <_stats_stop_measure_crit_thd>

000002bc <_port_exit_from_isr>:
     2bc:	df00      	svc	0
     2be:	e7fe      	b.n	2be <_port_exit_from_isr+0x2>

000002c0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
     2c0:	4770      	bx	lr
     2c2:	bf00      	nop
     2c4:	f3af 8000 	nop.w
     2c8:	f3af 8000 	nop.w
     2cc:	f3af 8000 	nop.w

000002d0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
     2d0:	4770      	bx	lr
     2d2:	bf00      	nop
     2d4:	f3af 8000 	nop.w
     2d8:	f3af 8000 	nop.w
     2dc:	f3af 8000 	nop.w

000002e0 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
     2e0:	e7fe      	b.n	2e0 <__default_exit>
     2e2:	bf00      	nop
     2e4:	f3af 8000 	nop.w
     2e8:	f3af 8000 	nop.w
     2ec:	f3af 8000 	nop.w

000002f0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
     2f0:	e7fe      	b.n	2f0 <_unhandled_exception>
     2f2:	bf00      	nop
     2f4:	f3af 8000 	nop.w
     2f8:	f3af 8000 	nop.w
     2fc:	f3af 8000 	nop.w

00000300 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
     300:	b084      	sub	sp, #16
     302:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
     304:	9b01      	ldr	r3, [sp, #4]
     306:	f003 0307 	and.w	r3, r3, #7
     30a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
     30c:	4b0a      	ldr	r3, [pc, #40]	; (338 <NVIC_SetPriorityGrouping+0x38>)
     30e:	68db      	ldr	r3, [r3, #12]
     310:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
     312:	9a02      	ldr	r2, [sp, #8]
     314:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
     318:	4013      	ands	r3, r2
     31a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
     31c:	9b03      	ldr	r3, [sp, #12]
     31e:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
     320:	9b02      	ldr	r3, [sp, #8]
     322:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
     324:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
     328:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     32c:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
     32e:	4b02      	ldr	r3, [pc, #8]	; (338 <NVIC_SetPriorityGrouping+0x38>)
     330:	9a02      	ldr	r2, [sp, #8]
     332:	60da      	str	r2, [r3, #12]
}
     334:	b004      	add	sp, #16
     336:	4770      	bx	lr
     338:	e000ed00 	.word	0xe000ed00
     33c:	f3af 8000 	nop.w

00000340 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
     340:	b082      	sub	sp, #8
     342:	4603      	mov	r3, r0
     344:	9100      	str	r1, [sp, #0]
     346:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
     34a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
     34e:	2b00      	cmp	r3, #0
     350:	da0c      	bge.n	36c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     352:	490c      	ldr	r1, [pc, #48]	; (384 <NVIC_SetPriority+0x44>)
     354:	f89d 3007 	ldrb.w	r3, [sp, #7]
     358:	f003 030f 	and.w	r3, r3, #15
     35c:	3b04      	subs	r3, #4
     35e:	9a00      	ldr	r2, [sp, #0]
     360:	b2d2      	uxtb	r2, r2
     362:	0112      	lsls	r2, r2, #4
     364:	b2d2      	uxtb	r2, r2
     366:	440b      	add	r3, r1
     368:	761a      	strb	r2, [r3, #24]
     36a:	e009      	b.n	380 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     36c:	4906      	ldr	r1, [pc, #24]	; (388 <NVIC_SetPriority+0x48>)
     36e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
     372:	9a00      	ldr	r2, [sp, #0]
     374:	b2d2      	uxtb	r2, r2
     376:	0112      	lsls	r2, r2, #4
     378:	b2d2      	uxtb	r2, r2
     37a:	440b      	add	r3, r1
     37c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
     380:	b002      	add	sp, #8
     382:	4770      	bx	lr
     384:	e000ed00 	.word	0xe000ed00
     388:	e000e100 	.word	0xe000e100
     38c:	f3af 8000 	nop.w

00000390 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
     390:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
     392:	4b0e      	ldr	r3, [pc, #56]	; (3cc <port_init+0x3c>)
     394:	2200      	movs	r2, #0
     396:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
     398:	2003      	movs	r0, #3
     39a:	f7ff ffb1 	bl	300 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
     39e:	4b0c      	ldr	r3, [pc, #48]	; (3d0 <port_init+0x40>)
     3a0:	4a0b      	ldr	r2, [pc, #44]	; (3d0 <port_init+0x40>)
     3a2:	68d2      	ldr	r2, [r2, #12]
     3a4:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
     3a8:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
     3aa:	4b0a      	ldr	r3, [pc, #40]	; (3d4 <port_init+0x44>)
     3ac:	4a09      	ldr	r2, [pc, #36]	; (3d4 <port_init+0x44>)
     3ae:	6812      	ldr	r2, [r2, #0]
     3b0:	f042 0201 	orr.w	r2, r2, #1
     3b4:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
     3b6:	f06f 0004 	mvn.w	r0, #4
     3ba:	2101      	movs	r1, #1
     3bc:	f7ff ffc0 	bl	340 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
     3c0:	f06f 0001 	mvn.w	r0, #1
     3c4:	2102      	movs	r1, #2
     3c6:	f7ff ffbb 	bl	340 <NVIC_SetPriority>
}
     3ca:	bd08      	pop	{r3, pc}
     3cc:	e000ed00 	.word	0xe000ed00
     3d0:	e000edf0 	.word	0xe000edf0
     3d4:	e0001000 	.word	0xe0001000
     3d8:	f3af 8000 	nop.w
     3dc:	f3af 8000 	nop.w

000003e0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     3e0:	b082      	sub	sp, #8
     3e2:	2320      	movs	r3, #32
     3e4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     3e6:	9b01      	ldr	r3, [sp, #4]
     3e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     3ec:	b002      	add	sp, #8
     3ee:	4770      	bx	lr

000003f0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     3f0:	b082      	sub	sp, #8
     3f2:	2300      	movs	r3, #0
     3f4:	9301      	str	r3, [sp, #4]
     3f6:	9b01      	ldr	r3, [sp, #4]
     3f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     3fc:	b002      	add	sp, #8
     3fe:	4770      	bx	lr

00000400 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     400:	b508      	push	{r3, lr}

  port_lock();
     402:	f7ff ffed 	bl	3e0 <port_lock>
}
     406:	bd08      	pop	{r3, pc}
     408:	f3af 8000 	nop.w
     40c:	f3af 8000 	nop.w

00000410 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     410:	b508      	push	{r3, lr}

  port_unlock();
     412:	f7ff ffed 	bl	3f0 <port_unlock>
}
     416:	bd08      	pop	{r3, pc}
     418:	f3af 8000 	nop.w
     41c:	f3af 8000 	nop.w

00000420 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
     420:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
     422:	4770      	bx	lr
     424:	f3af 8000 	nop.w
     428:	f3af 8000 	nop.w
     42c:	f3af 8000 	nop.w

00000430 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
     430:	b082      	sub	sp, #8
     432:	2300      	movs	r3, #0
     434:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     436:	9b01      	ldr	r3, [sp, #4]
     438:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
     43c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
     43e:	b002      	add	sp, #8
     440:	4770      	bx	lr
     442:	bf00      	nop
     444:	f3af 8000 	nop.w
     448:	f3af 8000 	nop.w
     44c:	f3af 8000 	nop.w

00000450 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
     450:	4770      	bx	lr
     452:	bf00      	nop
     454:	f3af 8000 	nop.w
     458:	f3af 8000 	nop.w
     45c:	f3af 8000 	nop.w

00000460 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     460:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     464:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     466:	4618      	mov	r0, r3
     468:	4770      	bx	lr
     46a:	bf00      	nop
     46c:	f3af 8000 	nop.w

00000470 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
     470:	b508      	push	{r3, lr}

  stStopAlarm();
     472:	f002 fa65 	bl	2940 <stStopAlarm>
}
     476:	bd08      	pop	{r3, pc}
     478:	f3af 8000 	nop.w
     47c:	f3af 8000 	nop.w

00000480 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
     480:	b500      	push	{lr}
     482:	b083      	sub	sp, #12
     484:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
     486:	9801      	ldr	r0, [sp, #4]
     488:	f002 fa62 	bl	2950 <stSetAlarm>
}
     48c:	b003      	add	sp, #12
     48e:	f85d fb04 	ldr.w	pc, [sp], #4
     492:	bf00      	nop
     494:	f3af 8000 	nop.w
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w

000004a0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     4a0:	b508      	push	{r3, lr}

  return stGetCounter();
     4a2:	f7ff ffdd 	bl	460 <st_lld_get_counter>
     4a6:	4603      	mov	r3, r0
}
     4a8:	4618      	mov	r0, r3
     4aa:	bd08      	pop	{r3, pc}
     4ac:	f3af 8000 	nop.w

000004b0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
     4b0:	b508      	push	{r3, lr}

  _dbg_check_enable();
     4b2:	f000 f94d 	bl	750 <_dbg_check_enable>
  port_enable();
     4b6:	f7ff ffbb 	bl	430 <port_enable>
}
     4ba:	bd08      	pop	{r3, pc}
     4bc:	f3af 8000 	nop.w

000004c0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
     4c0:	b508      	push	{r3, lr}

  port_lock_from_isr();
     4c2:	f7ff ff9d 	bl	400 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
     4c6:	f001 fa13 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
     4ca:	f000 f989 	bl	7e0 <_dbg_check_lock_from_isr>
}
     4ce:	bd08      	pop	{r3, pc}

000004d0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
     4d0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
     4d2:	f000 f99d 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
     4d6:	f001 fa13 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
     4da:	f7ff ff99 	bl	410 <port_unlock_from_isr>
}
     4de:	bd08      	pop	{r3, pc}

000004e0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     4e0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     4e2:	f7ff ffdd 	bl	4a0 <port_timer_get_time>
     4e6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     4e8:	4618      	mov	r0, r3
     4ea:	bd08      	pop	{r3, pc}
     4ec:	f3af 8000 	nop.w

000004f0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
     4f0:	b500      	push	{lr}
     4f2:	b085      	sub	sp, #20

  chDbgCheckClassI();
     4f4:	f000 f9e4 	bl	8c0 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
     4f8:	4b33      	ldr	r3, [pc, #204]	; (5c8 <chVTDoTickI+0xd8>)
     4fa:	69db      	ldr	r3, [r3, #28]
     4fc:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
     4fe:	f7ff ffef 	bl	4e0 <chVTGetSystemTimeX>
     502:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
     504:	e02a      	b.n	55c <chVTDoTickI+0x6c>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
     506:	4b30      	ldr	r3, [pc, #192]	; (5c8 <chVTDoTickI+0xd8>)
     508:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     50a:	9b03      	ldr	r3, [sp, #12]
     50c:	689b      	ldr	r3, [r3, #8]
     50e:	441a      	add	r2, r3
     510:	4b2d      	ldr	r3, [pc, #180]	; (5c8 <chVTDoTickI+0xd8>)
     512:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     514:	9b03      	ldr	r3, [sp, #12]
     516:	681b      	ldr	r3, [r3, #0]
     518:	4a2c      	ldr	r2, [pc, #176]	; (5cc <chVTDoTickI+0xdc>)
     51a:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
     51c:	9b03      	ldr	r3, [sp, #12]
     51e:	681a      	ldr	r2, [r3, #0]
     520:	4b29      	ldr	r3, [pc, #164]	; (5c8 <chVTDoTickI+0xd8>)
     522:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
     524:	9b03      	ldr	r3, [sp, #12]
     526:	68db      	ldr	r3, [r3, #12]
     528:	9300      	str	r3, [sp, #0]
    vtp->vt_func = NULL;
     52a:	9b03      	ldr	r3, [sp, #12]
     52c:	2200      	movs	r2, #0
     52e:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
     530:	4b25      	ldr	r3, [pc, #148]	; (5c8 <chVTDoTickI+0xd8>)
     532:	69da      	ldr	r2, [r3, #28]
     534:	4b25      	ldr	r3, [pc, #148]	; (5cc <chVTDoTickI+0xdc>)
     536:	429a      	cmp	r2, r3
     538:	d101      	bne.n	53e <chVTDoTickI+0x4e>
      port_timer_stop_alarm();
     53a:	f7ff ff99 	bl	470 <port_timer_stop_alarm>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
     53e:	f7ff ffc7 	bl	4d0 <chSysUnlockFromISR>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
     542:	9b03      	ldr	r3, [sp, #12]
     544:	691a      	ldr	r2, [r3, #16]
     546:	9b00      	ldr	r3, [sp, #0]
     548:	4610      	mov	r0, r2
     54a:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
     54c:	f7ff ffb8 	bl	4c0 <chSysLockFromISR>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
     550:	4b1d      	ldr	r3, [pc, #116]	; (5c8 <chVTDoTickI+0xd8>)
     552:	69db      	ldr	r3, [r3, #28]
     554:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
     556:	f7ff ffc3 	bl	4e0 <chVTGetSystemTimeX>
     55a:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
     55c:	9b03      	ldr	r3, [sp, #12]
     55e:	689a      	ldr	r2, [r3, #8]
     560:	4b19      	ldr	r3, [pc, #100]	; (5c8 <chVTDoTickI+0xd8>)
     562:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     564:	9902      	ldr	r1, [sp, #8]
     566:	1acb      	subs	r3, r1, r3
     568:	429a      	cmp	r2, r3
     56a:	d9cc      	bls.n	506 <chVTDoTickI+0x16>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
     56c:	4b16      	ldr	r3, [pc, #88]	; (5c8 <chVTDoTickI+0xd8>)
     56e:	69da      	ldr	r2, [r3, #28]
     570:	4b16      	ldr	r3, [pc, #88]	; (5cc <chVTDoTickI+0xdc>)
     572:	429a      	cmp	r2, r3
     574:	d100      	bne.n	578 <chVTDoTickI+0x88>
    return;
     576:	e023      	b.n	5c0 <chVTDoTickI+0xd0>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
     578:	4b13      	ldr	r3, [pc, #76]	; (5c8 <chVTDoTickI+0xd8>)
     57a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     57c:	9b03      	ldr	r3, [sp, #12]
     57e:	689b      	ldr	r3, [r3, #8]
     580:	441a      	add	r2, r3
     582:	9b02      	ldr	r3, [sp, #8]
     584:	1ad3      	subs	r3, r2, r3
     586:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
     588:	9b01      	ldr	r3, [sp, #4]
     58a:	2b01      	cmp	r3, #1
     58c:	d801      	bhi.n	592 <chVTDoTickI+0xa2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
     58e:	2302      	movs	r3, #2
     590:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
     592:	9a02      	ldr	r2, [sp, #8]
     594:	9b01      	ldr	r3, [sp, #4]
     596:	4413      	add	r3, r2
     598:	4618      	mov	r0, r3
     59a:	f7ff ff71 	bl	480 <port_timer_set_alarm>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
     59e:	f7ff ff9f 	bl	4e0 <chVTGetSystemTimeX>
     5a2:	4602      	mov	r2, r0
     5a4:	4b08      	ldr	r3, [pc, #32]	; (5c8 <chVTDoTickI+0xd8>)
     5a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     5a8:	1ad2      	subs	r2, r2, r3
     5aa:	9902      	ldr	r1, [sp, #8]
     5ac:	9b01      	ldr	r3, [sp, #4]
     5ae:	4419      	add	r1, r3
     5b0:	4b05      	ldr	r3, [pc, #20]	; (5c8 <chVTDoTickI+0xd8>)
     5b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     5b4:	1acb      	subs	r3, r1, r3
     5b6:	429a      	cmp	r2, r3
     5b8:	d902      	bls.n	5c0 <chVTDoTickI+0xd0>
     5ba:	4805      	ldr	r0, [pc, #20]	; (5d0 <chVTDoTickI+0xe0>)
     5bc:	f000 f878 	bl	6b0 <chSysHalt>
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     5c0:	b005      	add	sp, #20
     5c2:	f85d fb04 	ldr.w	pc, [sp], #4
     5c6:	bf00      	nop
     5c8:	20000800 	.word	0x20000800
     5cc:	2000081c 	.word	0x2000081c
     5d0:	00004520 	.word	0x00004520
     5d4:	f3af 8000 	nop.w
     5d8:	f3af 8000 	nop.w
     5dc:	f3af 8000 	nop.w

000005e0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
     5e0:	b082      	sub	sp, #8
     5e2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
     5e4:	4b02      	ldr	r3, [pc, #8]	; (5f0 <chRegSetThreadName+0x10>)
     5e6:	699b      	ldr	r3, [r3, #24]
     5e8:	9a01      	ldr	r2, [sp, #4]
     5ea:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
     5ec:	b002      	add	sp, #8
     5ee:	4770      	bx	lr
     5f0:	20000800 	.word	0x20000800
     5f4:	f3af 8000 	nop.w
     5f8:	f3af 8000 	nop.w
     5fc:	f3af 8000 	nop.w

00000600 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
     600:	b082      	sub	sp, #8
     602:	9001      	str	r0, [sp, #4]
     604:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
     606:	9b01      	ldr	r3, [sp, #4]
     608:	9a00      	ldr	r2, [sp, #0]
     60a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
     60c:	b002      	add	sp, #8
     60e:	4770      	bx	lr

00000610 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
     610:	b500      	push	{lr}
     612:	b083      	sub	sp, #12
     614:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
     616:	f7ff ff1b 	bl	450 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
  }
     61a:	e7fc      	b.n	616 <_idle_thread+0x6>
     61c:	f3af 8000 	nop.w

00000620 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
     620:	b500      	push	{lr}
     622:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
     624:	f7ff feb4 	bl	390 <port_init>
  _scheduler_init();
     628:	f000 fbc2 	bl	db0 <_scheduler_init>
  _vt_init();
     62c:	f000 f9f8 	bl	a20 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
     630:	f001 f88e 	bl	1750 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
     634:	f001 ff3c 	bl	24b0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
     638:	f001 ff8a 	bl	2550 <_heap_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  _stats_init();
     63c:	f001 f900 	bl	1840 <_stats_init>
#endif
#if CH_DBG_ENABLE_TRACE == TRUE
  _dbg_trace_init();
     640:	f000 f96e 	bl	920 <_dbg_trace_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
     644:	4812      	ldr	r0, [pc, #72]	; (690 <chSysInit+0x70>)
     646:	2140      	movs	r1, #64	; 0x40
     648:	f000 fe7a 	bl	1340 <_thread_init>
     64c:	4602      	mov	r2, r0
     64e:	4b11      	ldr	r3, [pc, #68]	; (694 <chSysInit+0x74>)
     650:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
     652:	4b10      	ldr	r3, [pc, #64]	; (694 <chSysInit+0x74>)
     654:	699b      	ldr	r3, [r3, #24]
     656:	2201      	movs	r2, #1
     658:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
     65c:	4b0d      	ldr	r3, [pc, #52]	; (694 <chSysInit+0x74>)
     65e:	699b      	ldr	r3, [r3, #24]
     660:	4a0d      	ldr	r2, [pc, #52]	; (698 <chSysInit+0x78>)
     662:	61da      	str	r2, [r3, #28]
#endif
  chSysEnable();
     664:	f7ff ff24 	bl	4b0 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
     668:	480c      	ldr	r0, [pc, #48]	; (69c <chSysInit+0x7c>)
     66a:	f7ff ffb9 	bl	5e0 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
     66e:	2300      	movs	r3, #0
     670:	9300      	str	r3, [sp, #0]
     672:	480b      	ldr	r0, [pc, #44]	; (6a0 <chSysInit+0x80>)
     674:	21f8      	movs	r1, #248	; 0xf8
     676:	2201      	movs	r2, #1
     678:	4b0a      	ldr	r3, [pc, #40]	; (6a4 <chSysInit+0x84>)
     67a:	f000 ff01 	bl	1480 <chThdCreateStatic>
     67e:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
     680:	9803      	ldr	r0, [sp, #12]
     682:	4909      	ldr	r1, [pc, #36]	; (6a8 <chSysInit+0x88>)
     684:	f7ff ffbc 	bl	600 <chRegSetThreadNameX>
  }
#endif
}
     688:	b005      	add	sp, #20
     68a:	f85d fb04 	ldr.w	pc, [sp], #4
     68e:	bf00      	nop
     690:	20000c40 	.word	0x20000c40
     694:	20000800 	.word	0x20000800
     698:	20000400 	.word	0x20000400
     69c:	000045f0 	.word	0x000045f0
     6a0:	20000ce0 	.word	0x20000ce0
     6a4:	00000611 	.word	0x00000611
     6a8:	000044a0 	.word	0x000044a0
     6ac:	f3af 8000 	nop.w

000006b0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
     6b0:	b500      	push	{lr}
     6b2:	b083      	sub	sp, #12
     6b4:	9001      	str	r0, [sp, #4]

  port_disable();
     6b6:	f7ff feb3 	bl	420 <port_disable>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
     6ba:	4b02      	ldr	r3, [pc, #8]	; (6c4 <chSysHalt+0x14>)
     6bc:	9a01      	ldr	r2, [sp, #4]
     6be:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
     6c0:	e7fe      	b.n	6c0 <chSysHalt+0x10>
     6c2:	bf00      	nop
     6c4:	20000800 	.word	0x20000800
     6c8:	f3af 8000 	nop.w
     6cc:	f3af 8000 	nop.w

000006d0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     6d0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
     6d2:	f000 f8f5 	bl	8c0 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
     6d6:	f7ff ff0b 	bl	4f0 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
     6da:	bd08      	pop	{r3, pc}
     6dc:	f3af 8000 	nop.w

000006e0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     6e0:	b082      	sub	sp, #8
     6e2:	2320      	movs	r3, #32
     6e4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     6e6:	9b01      	ldr	r3, [sp, #4]
     6e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     6ec:	b002      	add	sp, #8
     6ee:	4770      	bx	lr

000006f0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     6f0:	b082      	sub	sp, #8
     6f2:	2300      	movs	r3, #0
     6f4:	9301      	str	r3, [sp, #4]
     6f6:	9b01      	ldr	r3, [sp, #4]
     6f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     6fc:	b002      	add	sp, #8
     6fe:	4770      	bx	lr

00000700 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     700:	b508      	push	{r3, lr}

  port_lock();
     702:	f7ff ffed 	bl	6e0 <port_lock>
}
     706:	bd08      	pop	{r3, pc}
     708:	f3af 8000 	nop.w
     70c:	f3af 8000 	nop.w

00000710 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     710:	b508      	push	{r3, lr}

  port_unlock();
     712:	f7ff ffed 	bl	6f0 <port_unlock>
}
     716:	bd08      	pop	{r3, pc}
     718:	f3af 8000 	nop.w
     71c:	f3af 8000 	nop.w

00000720 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     720:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     724:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     726:	4618      	mov	r0, r3
     728:	4770      	bx	lr
     72a:	bf00      	nop
     72c:	f3af 8000 	nop.w

00000730 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     730:	b508      	push	{r3, lr}

  return stGetCounter();
     732:	f7ff fff5 	bl	720 <st_lld_get_counter>
     736:	4603      	mov	r3, r0
}
     738:	4618      	mov	r0, r3
     73a:	bd08      	pop	{r3, pc}
     73c:	f3af 8000 	nop.w

00000740 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     740:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     742:	f7ff fff5 	bl	730 <port_timer_get_time>
     746:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     748:	4618      	mov	r0, r3
     74a:	bd08      	pop	{r3, pc}
     74c:	f3af 8000 	nop.w

00000750 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
     750:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     752:	4b06      	ldr	r3, [pc, #24]	; (76c <_dbg_check_enable+0x1c>)
     754:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     756:	2b00      	cmp	r3, #0
     758:	d103      	bne.n	762 <_dbg_check_enable+0x12>
     75a:	4b04      	ldr	r3, [pc, #16]	; (76c <_dbg_check_enable+0x1c>)
     75c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     75e:	2b00      	cmp	r3, #0
     760:	d002      	beq.n	768 <_dbg_check_enable+0x18>
    chSysHalt("SV#3");
     762:	4803      	ldr	r0, [pc, #12]	; (770 <_dbg_check_enable+0x20>)
     764:	f7ff ffa4 	bl	6b0 <chSysHalt>
  }
}
     768:	bd08      	pop	{r3, pc}
     76a:	bf00      	nop
     76c:	20000800 	.word	0x20000800
     770:	000044c0 	.word	0x000044c0
     774:	f3af 8000 	nop.w
     778:	f3af 8000 	nop.w
     77c:	f3af 8000 	nop.w

00000780 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
     780:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     782:	4b07      	ldr	r3, [pc, #28]	; (7a0 <_dbg_check_lock+0x20>)
     784:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     786:	2b00      	cmp	r3, #0
     788:	d103      	bne.n	792 <_dbg_check_lock+0x12>
     78a:	4b05      	ldr	r3, [pc, #20]	; (7a0 <_dbg_check_lock+0x20>)
     78c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     78e:	2b00      	cmp	r3, #0
     790:	d002      	beq.n	798 <_dbg_check_lock+0x18>
    chSysHalt("SV#4");
     792:	4804      	ldr	r0, [pc, #16]	; (7a4 <_dbg_check_lock+0x24>)
     794:	f7ff ff8c 	bl	6b0 <chSysHalt>
  }
  _dbg_enter_lock();
     798:	4b01      	ldr	r3, [pc, #4]	; (7a0 <_dbg_check_lock+0x20>)
     79a:	2201      	movs	r2, #1
     79c:	635a      	str	r2, [r3, #52]	; 0x34
}
     79e:	bd08      	pop	{r3, pc}
     7a0:	20000800 	.word	0x20000800
     7a4:	000044c8 	.word	0x000044c8
     7a8:	f3af 8000 	nop.w
     7ac:	f3af 8000 	nop.w

000007b0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
     7b0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     7b2:	4b07      	ldr	r3, [pc, #28]	; (7d0 <_dbg_check_unlock+0x20>)
     7b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     7b6:	2b00      	cmp	r3, #0
     7b8:	d103      	bne.n	7c2 <_dbg_check_unlock+0x12>
     7ba:	4b05      	ldr	r3, [pc, #20]	; (7d0 <_dbg_check_unlock+0x20>)
     7bc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     7be:	2b00      	cmp	r3, #0
     7c0:	dc02      	bgt.n	7c8 <_dbg_check_unlock+0x18>
    chSysHalt("SV#5");
     7c2:	4804      	ldr	r0, [pc, #16]	; (7d4 <_dbg_check_unlock+0x24>)
     7c4:	f7ff ff74 	bl	6b0 <chSysHalt>
  }
  _dbg_leave_lock();
     7c8:	4b01      	ldr	r3, [pc, #4]	; (7d0 <_dbg_check_unlock+0x20>)
     7ca:	2200      	movs	r2, #0
     7cc:	635a      	str	r2, [r3, #52]	; 0x34
}
     7ce:	bd08      	pop	{r3, pc}
     7d0:	20000800 	.word	0x20000800
     7d4:	000044d0 	.word	0x000044d0
     7d8:	f3af 8000 	nop.w
     7dc:	f3af 8000 	nop.w

000007e0 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
     7e0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     7e2:	4b07      	ldr	r3, [pc, #28]	; (800 <_dbg_check_lock_from_isr+0x20>)
     7e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     7e6:	2b00      	cmp	r3, #0
     7e8:	dd03      	ble.n	7f2 <_dbg_check_lock_from_isr+0x12>
     7ea:	4b05      	ldr	r3, [pc, #20]	; (800 <_dbg_check_lock_from_isr+0x20>)
     7ec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     7ee:	2b00      	cmp	r3, #0
     7f0:	d002      	beq.n	7f8 <_dbg_check_lock_from_isr+0x18>
    chSysHalt("SV#6");
     7f2:	4804      	ldr	r0, [pc, #16]	; (804 <_dbg_check_lock_from_isr+0x24>)
     7f4:	f7ff ff5c 	bl	6b0 <chSysHalt>
  }
  _dbg_enter_lock();
     7f8:	4b01      	ldr	r3, [pc, #4]	; (800 <_dbg_check_lock_from_isr+0x20>)
     7fa:	2201      	movs	r2, #1
     7fc:	635a      	str	r2, [r3, #52]	; 0x34
}
     7fe:	bd08      	pop	{r3, pc}
     800:	20000800 	.word	0x20000800
     804:	000044d8 	.word	0x000044d8
     808:	f3af 8000 	nop.w
     80c:	f3af 8000 	nop.w

00000810 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
     810:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     812:	4b07      	ldr	r3, [pc, #28]	; (830 <_dbg_check_unlock_from_isr+0x20>)
     814:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     816:	2b00      	cmp	r3, #0
     818:	dd03      	ble.n	822 <_dbg_check_unlock_from_isr+0x12>
     81a:	4b05      	ldr	r3, [pc, #20]	; (830 <_dbg_check_unlock_from_isr+0x20>)
     81c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     81e:	2b00      	cmp	r3, #0
     820:	dc02      	bgt.n	828 <_dbg_check_unlock_from_isr+0x18>
    chSysHalt("SV#7");
     822:	4804      	ldr	r0, [pc, #16]	; (834 <_dbg_check_unlock_from_isr+0x24>)
     824:	f7ff ff44 	bl	6b0 <chSysHalt>
  }
  _dbg_leave_lock();
     828:	4b01      	ldr	r3, [pc, #4]	; (830 <_dbg_check_unlock_from_isr+0x20>)
     82a:	2200      	movs	r2, #0
     82c:	635a      	str	r2, [r3, #52]	; 0x34
}
     82e:	bd08      	pop	{r3, pc}
     830:	20000800 	.word	0x20000800
     834:	000044e0 	.word	0x000044e0
     838:	f3af 8000 	nop.w
     83c:	f3af 8000 	nop.w

00000840 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
     840:	b508      	push	{r3, lr}

  port_lock_from_isr();
     842:	f7ff ff5d 	bl	700 <port_lock_from_isr>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     846:	4b09      	ldr	r3, [pc, #36]	; (86c <_dbg_check_enter_isr+0x2c>)
     848:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     84a:	2b00      	cmp	r3, #0
     84c:	db03      	blt.n	856 <_dbg_check_enter_isr+0x16>
     84e:	4b07      	ldr	r3, [pc, #28]	; (86c <_dbg_check_enter_isr+0x2c>)
     850:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     852:	2b00      	cmp	r3, #0
     854:	d002      	beq.n	85c <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
     856:	4806      	ldr	r0, [pc, #24]	; (870 <_dbg_check_enter_isr+0x30>)
     858:	f7ff ff2a 	bl	6b0 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
     85c:	4b03      	ldr	r3, [pc, #12]	; (86c <_dbg_check_enter_isr+0x2c>)
     85e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     860:	1c5a      	adds	r2, r3, #1
     862:	4b02      	ldr	r3, [pc, #8]	; (86c <_dbg_check_enter_isr+0x2c>)
     864:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
     866:	f7ff ff53 	bl	710 <port_unlock_from_isr>
}
     86a:	bd08      	pop	{r3, pc}
     86c:	20000800 	.word	0x20000800
     870:	000044e8 	.word	0x000044e8
     874:	f3af 8000 	nop.w
     878:	f3af 8000 	nop.w
     87c:	f3af 8000 	nop.w

00000880 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
     880:	b508      	push	{r3, lr}

  port_lock_from_isr();
     882:	f7ff ff3d 	bl	700 <port_lock_from_isr>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     886:	4b09      	ldr	r3, [pc, #36]	; (8ac <_dbg_check_leave_isr+0x2c>)
     888:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     88a:	2b00      	cmp	r3, #0
     88c:	dd03      	ble.n	896 <_dbg_check_leave_isr+0x16>
     88e:	4b07      	ldr	r3, [pc, #28]	; (8ac <_dbg_check_leave_isr+0x2c>)
     890:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     892:	2b00      	cmp	r3, #0
     894:	d002      	beq.n	89c <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
     896:	4806      	ldr	r0, [pc, #24]	; (8b0 <_dbg_check_leave_isr+0x30>)
     898:	f7ff ff0a 	bl	6b0 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
     89c:	4b03      	ldr	r3, [pc, #12]	; (8ac <_dbg_check_leave_isr+0x2c>)
     89e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     8a0:	1e5a      	subs	r2, r3, #1
     8a2:	4b02      	ldr	r3, [pc, #8]	; (8ac <_dbg_check_leave_isr+0x2c>)
     8a4:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
     8a6:	f7ff ff33 	bl	710 <port_unlock_from_isr>
}
     8aa:	bd08      	pop	{r3, pc}
     8ac:	20000800 	.word	0x20000800
     8b0:	000044f0 	.word	0x000044f0
     8b4:	f3af 8000 	nop.w
     8b8:	f3af 8000 	nop.w
     8bc:	f3af 8000 	nop.w

000008c0 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
     8c0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     8c2:	4b06      	ldr	r3, [pc, #24]	; (8dc <chDbgCheckClassI+0x1c>)
     8c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     8c6:	2b00      	cmp	r3, #0
     8c8:	db03      	blt.n	8d2 <chDbgCheckClassI+0x12>
     8ca:	4b04      	ldr	r3, [pc, #16]	; (8dc <chDbgCheckClassI+0x1c>)
     8cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     8ce:	2b00      	cmp	r3, #0
     8d0:	dc02      	bgt.n	8d8 <chDbgCheckClassI+0x18>
    chSysHalt("SV#10");
     8d2:	4803      	ldr	r0, [pc, #12]	; (8e0 <chDbgCheckClassI+0x20>)
     8d4:	f7ff feec 	bl	6b0 <chSysHalt>
  }
}
     8d8:	bd08      	pop	{r3, pc}
     8da:	bf00      	nop
     8dc:	20000800 	.word	0x20000800
     8e0:	000044f8 	.word	0x000044f8
     8e4:	f3af 8000 	nop.w
     8e8:	f3af 8000 	nop.w
     8ec:	f3af 8000 	nop.w

000008f0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
     8f0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     8f2:	4b06      	ldr	r3, [pc, #24]	; (90c <chDbgCheckClassS+0x1c>)
     8f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     8f6:	2b00      	cmp	r3, #0
     8f8:	d103      	bne.n	902 <chDbgCheckClassS+0x12>
     8fa:	4b04      	ldr	r3, [pc, #16]	; (90c <chDbgCheckClassS+0x1c>)
     8fc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     8fe:	2b00      	cmp	r3, #0
     900:	dc02      	bgt.n	908 <chDbgCheckClassS+0x18>
    chSysHalt("SV#11");
     902:	4803      	ldr	r0, [pc, #12]	; (910 <chDbgCheckClassS+0x20>)
     904:	f7ff fed4 	bl	6b0 <chSysHalt>
  }
}
     908:	bd08      	pop	{r3, pc}
     90a:	bf00      	nop
     90c:	20000800 	.word	0x20000800
     910:	00004500 	.word	0x00004500
     914:	f3af 8000 	nop.w
     918:	f3af 8000 	nop.w
     91c:	f3af 8000 	nop.w

00000920 <_dbg_trace_init>:
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
     920:	4b03      	ldr	r3, [pc, #12]	; (930 <_dbg_trace_init+0x10>)
     922:	2240      	movs	r2, #64	; 0x40
     924:	639a      	str	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
     926:	4b02      	ldr	r3, [pc, #8]	; (930 <_dbg_trace_init+0x10>)
     928:	4a02      	ldr	r2, [pc, #8]	; (934 <_dbg_trace_init+0x14>)
     92a:	63da      	str	r2, [r3, #60]	; 0x3c
}
     92c:	4770      	bx	lr
     92e:	bf00      	nop
     930:	20000800 	.word	0x20000800
     934:	20000840 	.word	0x20000840
     938:	f3af 8000 	nop.w
     93c:	f3af 8000 	nop.w

00000940 <_dbg_trace>:
 *
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {
     940:	b510      	push	{r4, lr}
     942:	b082      	sub	sp, #8
     944:	9001      	str	r0, [sp, #4]

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
     946:	4b13      	ldr	r3, [pc, #76]	; (994 <_dbg_trace+0x54>)
     948:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
     94a:	f7ff fef9 	bl	740 <chVTGetSystemTimeX>
     94e:	4603      	mov	r3, r0
     950:	6023      	str	r3, [r4, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
     952:	4b10      	ldr	r3, [pc, #64]	; (994 <_dbg_trace+0x54>)
     954:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     956:	4a0f      	ldr	r2, [pc, #60]	; (994 <_dbg_trace+0x54>)
     958:	6992      	ldr	r2, [r2, #24]
     95a:	605a      	str	r2, [r3, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
     95c:	4b0d      	ldr	r3, [pc, #52]	; (994 <_dbg_trace+0x54>)
     95e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     960:	9a01      	ldr	r2, [sp, #4]
     962:	6a52      	ldr	r2, [r2, #36]	; 0x24
     964:	609a      	str	r2, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
     966:	4b0b      	ldr	r3, [pc, #44]	; (994 <_dbg_trace+0x54>)
     968:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     96a:	9a01      	ldr	r2, [sp, #4]
     96c:	f892 2020 	ldrb.w	r2, [r2, #32]
     970:	731a      	strb	r2, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
     972:	4b08      	ldr	r3, [pc, #32]	; (994 <_dbg_trace+0x54>)
     974:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     976:	f103 0210 	add.w	r2, r3, #16
     97a:	4b06      	ldr	r3, [pc, #24]	; (994 <_dbg_trace+0x54>)
     97c:	63da      	str	r2, [r3, #60]	; 0x3c
     97e:	4b05      	ldr	r3, [pc, #20]	; (994 <_dbg_trace+0x54>)
     980:	6bda      	ldr	r2, [r3, #60]	; 0x3c
     982:	4b05      	ldr	r3, [pc, #20]	; (998 <_dbg_trace+0x58>)
     984:	429a      	cmp	r2, r3
     986:	d302      	bcc.n	98e <_dbg_trace+0x4e>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
     988:	4b02      	ldr	r3, [pc, #8]	; (994 <_dbg_trace+0x54>)
     98a:	4a04      	ldr	r2, [pc, #16]	; (99c <_dbg_trace+0x5c>)
     98c:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
     98e:	b002      	add	sp, #8
     990:	bd10      	pop	{r4, pc}
     992:	bf00      	nop
     994:	20000800 	.word	0x20000800
     998:	20000c40 	.word	0x20000c40
     99c:	20000840 	.word	0x20000840

000009a0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     9a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     9a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     9a6:	4618      	mov	r0, r3
     9a8:	4770      	bx	lr
     9aa:	bf00      	nop
     9ac:	f3af 8000 	nop.w

000009b0 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
     9b0:	b500      	push	{lr}
     9b2:	b083      	sub	sp, #12
     9b4:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
     9b6:	9801      	ldr	r0, [sp, #4]
     9b8:	f001 ffaa 	bl	2910 <stStartAlarm>
}
     9bc:	b003      	add	sp, #12
     9be:	f85d fb04 	ldr.w	pc, [sp], #4
     9c2:	bf00      	nop
     9c4:	f3af 8000 	nop.w
     9c8:	f3af 8000 	nop.w
     9cc:	f3af 8000 	nop.w

000009d0 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
     9d0:	b508      	push	{r3, lr}

  stStopAlarm();
     9d2:	f001 ffb5 	bl	2940 <stStopAlarm>
}
     9d6:	bd08      	pop	{r3, pc}
     9d8:	f3af 8000 	nop.w
     9dc:	f3af 8000 	nop.w

000009e0 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
     9e0:	b500      	push	{lr}
     9e2:	b083      	sub	sp, #12
     9e4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
     9e6:	9801      	ldr	r0, [sp, #4]
     9e8:	f001 ffb2 	bl	2950 <stSetAlarm>
}
     9ec:	b003      	add	sp, #12
     9ee:	f85d fb04 	ldr.w	pc, [sp], #4
     9f2:	bf00      	nop
     9f4:	f3af 8000 	nop.w
     9f8:	f3af 8000 	nop.w
     9fc:	f3af 8000 	nop.w

00000a00 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     a00:	b508      	push	{r3, lr}

  return stGetCounter();
     a02:	f7ff ffcd 	bl	9a0 <st_lld_get_counter>
     a06:	4603      	mov	r3, r0
}
     a08:	4618      	mov	r0, r3
     a0a:	bd08      	pop	{r3, pc}
     a0c:	f3af 8000 	nop.w

00000a10 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     a10:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     a12:	f7ff fff5 	bl	a00 <port_timer_get_time>
     a16:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     a18:	4618      	mov	r0, r3
     a1a:	bd08      	pop	{r3, pc}
     a1c:	f3af 8000 	nop.w

00000a20 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
     a20:	4b06      	ldr	r3, [pc, #24]	; (a3c <_vt_init+0x1c>)
     a22:	4a07      	ldr	r2, [pc, #28]	; (a40 <_vt_init+0x20>)
     a24:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
     a26:	4b05      	ldr	r3, [pc, #20]	; (a3c <_vt_init+0x1c>)
     a28:	4a05      	ldr	r2, [pc, #20]	; (a40 <_vt_init+0x20>)
     a2a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
     a2c:	4b03      	ldr	r3, [pc, #12]	; (a3c <_vt_init+0x1c>)
     a2e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     a32:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
     a34:	4b01      	ldr	r3, [pc, #4]	; (a3c <_vt_init+0x1c>)
     a36:	2200      	movs	r2, #0
     a38:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     a3a:	4770      	bx	lr
     a3c:	20000800 	.word	0x20000800
     a40:	2000081c 	.word	0x2000081c
     a44:	f3af 8000 	nop.w
     a48:	f3af 8000 	nop.w
     a4c:	f3af 8000 	nop.w

00000a50 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
     a50:	b500      	push	{lr}
     a52:	b089      	sub	sp, #36	; 0x24
     a54:	9003      	str	r0, [sp, #12]
     a56:	9102      	str	r1, [sp, #8]
     a58:	9201      	str	r2, [sp, #4]
     a5a:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
     a5c:	f7ff ff30 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
     a60:	9b03      	ldr	r3, [sp, #12]
     a62:	2b00      	cmp	r3, #0
     a64:	d005      	beq.n	a72 <chVTDoSetI+0x22>
     a66:	9b01      	ldr	r3, [sp, #4]
     a68:	2b00      	cmp	r3, #0
     a6a:	d002      	beq.n	a72 <chVTDoSetI+0x22>
     a6c:	9b02      	ldr	r3, [sp, #8]
     a6e:	2b00      	cmp	r3, #0
     a70:	d102      	bne.n	a78 <chVTDoSetI+0x28>
     a72:	483a      	ldr	r0, [pc, #232]	; (b5c <chVTDoSetI+0x10c>)
     a74:	f7ff fe1c 	bl	6b0 <chSysHalt>

  vtp->vt_par = par;
     a78:	9b03      	ldr	r3, [sp, #12]
     a7a:	9a00      	ldr	r2, [sp, #0]
     a7c:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
     a7e:	9b03      	ldr	r3, [sp, #12]
     a80:	9a01      	ldr	r2, [sp, #4]
     a82:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
     a84:	f7ff ffc4 	bl	a10 <chVTGetSystemTimeX>
     a88:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
     a8a:	9b02      	ldr	r3, [sp, #8]
     a8c:	2b01      	cmp	r3, #1
     a8e:	d801      	bhi.n	a94 <chVTDoSetI+0x44>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
     a90:	2302      	movs	r3, #2
     a92:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
     a94:	4b32      	ldr	r3, [pc, #200]	; (b60 <chVTDoSetI+0x110>)
     a96:	69da      	ldr	r2, [r3, #28]
     a98:	4b32      	ldr	r3, [pc, #200]	; (b64 <chVTDoSetI+0x114>)
     a9a:	429a      	cmp	r2, r3
     a9c:	d119      	bne.n	ad2 <chVTDoSetI+0x82>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
     a9e:	4b30      	ldr	r3, [pc, #192]	; (b60 <chVTDoSetI+0x110>)
     aa0:	9a05      	ldr	r2, [sp, #20]
     aa2:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
     aa4:	4b2e      	ldr	r3, [pc, #184]	; (b60 <chVTDoSetI+0x110>)
     aa6:	9a03      	ldr	r2, [sp, #12]
     aa8:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
     aaa:	4b2d      	ldr	r3, [pc, #180]	; (b60 <chVTDoSetI+0x110>)
     aac:	9a03      	ldr	r2, [sp, #12]
     aae:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
     ab0:	9b03      	ldr	r3, [sp, #12]
     ab2:	4a2c      	ldr	r2, [pc, #176]	; (b64 <chVTDoSetI+0x114>)
     ab4:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
     ab6:	9b03      	ldr	r3, [sp, #12]
     ab8:	4a2a      	ldr	r2, [pc, #168]	; (b64 <chVTDoSetI+0x114>)
     aba:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
     abc:	9b03      	ldr	r3, [sp, #12]
     abe:	9a02      	ldr	r2, [sp, #8]
     ac0:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
     ac2:	4b27      	ldr	r3, [pc, #156]	; (b60 <chVTDoSetI+0x110>)
     ac4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     ac6:	9b02      	ldr	r3, [sp, #8]
     ac8:	4413      	add	r3, r2
     aca:	4618      	mov	r0, r3
     acc:	f7ff ff70 	bl	9b0 <port_timer_start_alarm>

      return;
     ad0:	e040      	b.n	b54 <chVTDoSetI+0x104>
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
     ad2:	9a05      	ldr	r2, [sp, #20]
     ad4:	9b02      	ldr	r3, [sp, #8]
     ad6:	441a      	add	r2, r3
     ad8:	4b21      	ldr	r3, [pc, #132]	; (b60 <chVTDoSetI+0x110>)
     ada:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     adc:	1ad3      	subs	r3, r2, r3
     ade:	9306      	str	r3, [sp, #24]
    if (delta < ch.vtlist.vt_next->vt_delta) {
     ae0:	4b1f      	ldr	r3, [pc, #124]	; (b60 <chVTDoSetI+0x110>)
     ae2:	69db      	ldr	r3, [r3, #28]
     ae4:	689a      	ldr	r2, [r3, #8]
     ae6:	9b06      	ldr	r3, [sp, #24]
     ae8:	429a      	cmp	r2, r3
     aea:	d906      	bls.n	afa <chVTDoSetI+0xaa>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
     aec:	4b1c      	ldr	r3, [pc, #112]	; (b60 <chVTDoSetI+0x110>)
     aee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     af0:	9b06      	ldr	r3, [sp, #24]
     af2:	4413      	add	r3, r2
     af4:	4618      	mov	r0, r3
     af6:	f7ff ff73 	bl	9e0 <port_timer_set_alarm>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
     afa:	4b19      	ldr	r3, [pc, #100]	; (b60 <chVTDoSetI+0x110>)
     afc:	69db      	ldr	r3, [r3, #28]
     afe:	9307      	str	r3, [sp, #28]
  while (p->vt_delta < delta) {
     b00:	e007      	b.n	b12 <chVTDoSetI+0xc2>
    delta -= p->vt_delta;
     b02:	9b07      	ldr	r3, [sp, #28]
     b04:	689b      	ldr	r3, [r3, #8]
     b06:	9a06      	ldr	r2, [sp, #24]
     b08:	1ad3      	subs	r3, r2, r3
     b0a:	9306      	str	r3, [sp, #24]
    p = p->vt_next;
     b0c:	9b07      	ldr	r3, [sp, #28]
     b0e:	681b      	ldr	r3, [r3, #0]
     b10:	9307      	str	r3, [sp, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
     b12:	9b07      	ldr	r3, [sp, #28]
     b14:	689a      	ldr	r2, [r3, #8]
     b16:	9b06      	ldr	r3, [sp, #24]
     b18:	429a      	cmp	r2, r3
     b1a:	d3f2      	bcc.n	b02 <chVTDoSetI+0xb2>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
     b1c:	9b03      	ldr	r3, [sp, #12]
     b1e:	9a07      	ldr	r2, [sp, #28]
     b20:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
     b22:	9b03      	ldr	r3, [sp, #12]
     b24:	681b      	ldr	r3, [r3, #0]
     b26:	685a      	ldr	r2, [r3, #4]
     b28:	9b03      	ldr	r3, [sp, #12]
     b2a:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
     b2c:	9b03      	ldr	r3, [sp, #12]
     b2e:	685b      	ldr	r3, [r3, #4]
     b30:	9a03      	ldr	r2, [sp, #12]
     b32:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
     b34:	9b07      	ldr	r3, [sp, #28]
     b36:	9a03      	ldr	r2, [sp, #12]
     b38:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
     b3a:	9b03      	ldr	r3, [sp, #12]
     b3c:	9a06      	ldr	r2, [sp, #24]
     b3e:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
     b40:	9b07      	ldr	r3, [sp, #28]
     b42:	689a      	ldr	r2, [r3, #8]
     b44:	9b06      	ldr	r3, [sp, #24]
     b46:	1ad2      	subs	r2, r2, r3
     b48:	9b07      	ldr	r3, [sp, #28]
     b4a:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
     b4c:	4b04      	ldr	r3, [pc, #16]	; (b60 <chVTDoSetI+0x110>)
     b4e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     b52:	625a      	str	r2, [r3, #36]	; 0x24
}
     b54:	b009      	add	sp, #36	; 0x24
     b56:	f85d fb04 	ldr.w	pc, [sp], #4
     b5a:	bf00      	nop
     b5c:	00004530 	.word	0x00004530
     b60:	20000800 	.word	0x20000800
     b64:	2000081c 	.word	0x2000081c
     b68:	f3af 8000 	nop.w
     b6c:	f3af 8000 	nop.w

00000b70 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
     b70:	b500      	push	{lr}
     b72:	b085      	sub	sp, #20
     b74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     b76:	f7ff fea3 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
     b7a:	9b01      	ldr	r3, [sp, #4]
     b7c:	2b00      	cmp	r3, #0
     b7e:	d102      	bne.n	b86 <chVTDoResetI+0x16>
     b80:	4836      	ldr	r0, [pc, #216]	; (c5c <chVTDoResetI+0xec>)
     b82:	f7ff fd95 	bl	6b0 <chSysHalt>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
     b86:	9b01      	ldr	r3, [sp, #4]
     b88:	68db      	ldr	r3, [r3, #12]
     b8a:	2b00      	cmp	r3, #0
     b8c:	d102      	bne.n	b94 <chVTDoResetI+0x24>
     b8e:	4833      	ldr	r0, [pc, #204]	; (c5c <chVTDoResetI+0xec>)
     b90:	f7ff fd8e 	bl	6b0 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
     b94:	4b32      	ldr	r3, [pc, #200]	; (c60 <chVTDoResetI+0xf0>)
     b96:	69da      	ldr	r2, [r3, #28]
     b98:	9b01      	ldr	r3, [sp, #4]
     b9a:	429a      	cmp	r2, r3
     b9c:	d01c      	beq.n	bd8 <chVTDoResetI+0x68>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
     b9e:	9b01      	ldr	r3, [sp, #4]
     ba0:	685b      	ldr	r3, [r3, #4]
     ba2:	9a01      	ldr	r2, [sp, #4]
     ba4:	6812      	ldr	r2, [r2, #0]
     ba6:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
     ba8:	9b01      	ldr	r3, [sp, #4]
     baa:	681b      	ldr	r3, [r3, #0]
     bac:	9a01      	ldr	r2, [sp, #4]
     bae:	6852      	ldr	r2, [r2, #4]
     bb0:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
     bb2:	9b01      	ldr	r3, [sp, #4]
     bb4:	2200      	movs	r2, #0
     bb6:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
     bb8:	9b01      	ldr	r3, [sp, #4]
     bba:	681a      	ldr	r2, [r3, #0]
     bbc:	4b29      	ldr	r3, [pc, #164]	; (c64 <chVTDoResetI+0xf4>)
     bbe:	429a      	cmp	r2, r3
     bc0:	d009      	beq.n	bd6 <chVTDoResetI+0x66>
      vtp->vt_next->vt_delta += vtp->vt_delta;
     bc2:	9b01      	ldr	r3, [sp, #4]
     bc4:	681b      	ldr	r3, [r3, #0]
     bc6:	9a01      	ldr	r2, [sp, #4]
     bc8:	6812      	ldr	r2, [r2, #0]
     bca:	6891      	ldr	r1, [r2, #8]
     bcc:	9a01      	ldr	r2, [sp, #4]
     bce:	6892      	ldr	r2, [r2, #8]
     bd0:	440a      	add	r2, r1
     bd2:	609a      	str	r2, [r3, #8]

    return;
     bd4:	e03e      	b.n	c54 <chVTDoResetI+0xe4>
     bd6:	e03d      	b.n	c54 <chVTDoResetI+0xe4>
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
     bd8:	9b01      	ldr	r3, [sp, #4]
     bda:	681a      	ldr	r2, [r3, #0]
     bdc:	4b20      	ldr	r3, [pc, #128]	; (c60 <chVTDoResetI+0xf0>)
     bde:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     be0:	4b1f      	ldr	r3, [pc, #124]	; (c60 <chVTDoResetI+0xf0>)
     be2:	69db      	ldr	r3, [r3, #28]
     be4:	4a1f      	ldr	r2, [pc, #124]	; (c64 <chVTDoResetI+0xf4>)
     be6:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
     be8:	9b01      	ldr	r3, [sp, #4]
     bea:	2200      	movs	r2, #0
     bec:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
     bee:	4b1c      	ldr	r3, [pc, #112]	; (c60 <chVTDoResetI+0xf0>)
     bf0:	69da      	ldr	r2, [r3, #28]
     bf2:	4b1c      	ldr	r3, [pc, #112]	; (c64 <chVTDoResetI+0xf4>)
     bf4:	429a      	cmp	r2, r3
     bf6:	d102      	bne.n	bfe <chVTDoResetI+0x8e>
    port_timer_stop_alarm();
     bf8:	f7ff feea 	bl	9d0 <port_timer_stop_alarm>

    return;
     bfc:	e02a      	b.n	c54 <chVTDoResetI+0xe4>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
     bfe:	4b18      	ldr	r3, [pc, #96]	; (c60 <chVTDoResetI+0xf0>)
     c00:	69db      	ldr	r3, [r3, #28]
     c02:	4a17      	ldr	r2, [pc, #92]	; (c60 <chVTDoResetI+0xf0>)
     c04:	69d2      	ldr	r2, [r2, #28]
     c06:	6891      	ldr	r1, [r2, #8]
     c08:	9a01      	ldr	r2, [sp, #4]
     c0a:	6892      	ldr	r2, [r2, #8]
     c0c:	440a      	add	r2, r1
     c0e:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
     c10:	f7ff fefe 	bl	a10 <chVTGetSystemTimeX>
     c14:	4602      	mov	r2, r0
     c16:	4b12      	ldr	r3, [pc, #72]	; (c60 <chVTDoResetI+0xf0>)
     c18:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     c1a:	1ad3      	subs	r3, r2, r3
     c1c:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
     c1e:	4b10      	ldr	r3, [pc, #64]	; (c60 <chVTDoResetI+0xf0>)
     c20:	69db      	ldr	r3, [r3, #28]
     c22:	689a      	ldr	r2, [r3, #8]
     c24:	9b02      	ldr	r3, [sp, #8]
     c26:	429a      	cmp	r2, r3
     c28:	d800      	bhi.n	c2c <chVTDoResetI+0xbc>
    return;
     c2a:	e013      	b.n	c54 <chVTDoResetI+0xe4>
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
     c2c:	4b0c      	ldr	r3, [pc, #48]	; (c60 <chVTDoResetI+0xf0>)
     c2e:	69db      	ldr	r3, [r3, #28]
     c30:	689a      	ldr	r2, [r3, #8]
     c32:	9b02      	ldr	r3, [sp, #8]
     c34:	1ad3      	subs	r3, r2, r3
     c36:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
     c38:	9b03      	ldr	r3, [sp, #12]
     c3a:	2b01      	cmp	r3, #1
     c3c:	d801      	bhi.n	c42 <chVTDoResetI+0xd2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
     c3e:	2302      	movs	r3, #2
     c40:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
     c42:	4b07      	ldr	r3, [pc, #28]	; (c60 <chVTDoResetI+0xf0>)
     c44:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     c46:	9b02      	ldr	r3, [sp, #8]
     c48:	441a      	add	r2, r3
     c4a:	9b03      	ldr	r3, [sp, #12]
     c4c:	4413      	add	r3, r2
     c4e:	4618      	mov	r0, r3
     c50:	f7ff fec6 	bl	9e0 <port_timer_set_alarm>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     c54:	b005      	add	sp, #20
     c56:	f85d fb04 	ldr.w	pc, [sp], #4
     c5a:	bf00      	nop
     c5c:	00004540 	.word	0x00004540
     c60:	20000800 	.word	0x20000800
     c64:	2000081c 	.word	0x2000081c
     c68:	f3af 8000 	nop.w
     c6c:	f3af 8000 	nop.w

00000c70 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     c70:	b082      	sub	sp, #8
     c72:	2320      	movs	r3, #32
     c74:	9301      	str	r3, [sp, #4]
     c76:	9b01      	ldr	r3, [sp, #4]
     c78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     c7c:	b002      	add	sp, #8
     c7e:	4770      	bx	lr

00000c80 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     c80:	b082      	sub	sp, #8
     c82:	2300      	movs	r3, #0
     c84:	9301      	str	r3, [sp, #4]
     c86:	9b01      	ldr	r3, [sp, #4]
     c88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     c8c:	b002      	add	sp, #8
     c8e:	4770      	bx	lr

00000c90 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     c90:	b508      	push	{r3, lr}

  port_lock();
     c92:	f7ff ffed 	bl	c70 <port_lock>
}
     c96:	bd08      	pop	{r3, pc}
     c98:	f3af 8000 	nop.w
     c9c:	f3af 8000 	nop.w

00000ca0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     ca0:	b508      	push	{r3, lr}

  port_unlock();
     ca2:	f7ff ffed 	bl	c80 <port_unlock>
}
     ca6:	bd08      	pop	{r3, pc}
     ca8:	f3af 8000 	nop.w
     cac:	f3af 8000 	nop.w

00000cb0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
     cb0:	b082      	sub	sp, #8
     cb2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
     cb4:	9b01      	ldr	r3, [sp, #4]
     cb6:	9a01      	ldr	r2, [sp, #4]
     cb8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
     cba:	9b01      	ldr	r3, [sp, #4]
     cbc:	9a01      	ldr	r2, [sp, #4]
     cbe:	605a      	str	r2, [r3, #4]
}
     cc0:	b002      	add	sp, #8
     cc2:	4770      	bx	lr
     cc4:	f3af 8000 	nop.w
     cc8:	f3af 8000 	nop.w
     ccc:	f3af 8000 	nop.w

00000cd0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
     cd0:	b084      	sub	sp, #16
     cd2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
     cd4:	9b01      	ldr	r3, [sp, #4]
     cd6:	681b      	ldr	r3, [r3, #0]
     cd8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
     cda:	9b03      	ldr	r3, [sp, #12]
     cdc:	681a      	ldr	r2, [r3, #0]
     cde:	9b01      	ldr	r3, [sp, #4]
     ce0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
     ce2:	9b01      	ldr	r3, [sp, #4]
     ce4:	681b      	ldr	r3, [r3, #0]
     ce6:	9a01      	ldr	r2, [sp, #4]
     ce8:	605a      	str	r2, [r3, #4]

  return tp;
     cea:	9b03      	ldr	r3, [sp, #12]
}
     cec:	4618      	mov	r0, r3
     cee:	b004      	add	sp, #16
     cf0:	4770      	bx	lr
     cf2:	bf00      	nop
     cf4:	f3af 8000 	nop.w
     cf8:	f3af 8000 	nop.w
     cfc:	f3af 8000 	nop.w

00000d00 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
     d00:	b082      	sub	sp, #8
     d02:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
     d04:	9b01      	ldr	r3, [sp, #4]
     d06:	685b      	ldr	r3, [r3, #4]
     d08:	9a01      	ldr	r2, [sp, #4]
     d0a:	6812      	ldr	r2, [r2, #0]
     d0c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
     d0e:	9b01      	ldr	r3, [sp, #4]
     d10:	681b      	ldr	r3, [r3, #0]
     d12:	9a01      	ldr	r2, [sp, #4]
     d14:	6852      	ldr	r2, [r2, #4]
     d16:	605a      	str	r2, [r3, #4]

  return tp;
     d18:	9b01      	ldr	r3, [sp, #4]
}
     d1a:	4618      	mov	r0, r3
     d1c:	b002      	add	sp, #8
     d1e:	4770      	bx	lr

00000d20 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
     d20:	b508      	push	{r3, lr}

  chDbgCheckClassI();
     d22:	f7ff fdcd 	bl	8c0 <chDbgCheckClassI>

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
     d26:	4b06      	ldr	r3, [pc, #24]	; (d40 <chSchIsRescRequiredI+0x20>)
     d28:	681b      	ldr	r3, [r3, #0]
     d2a:	689a      	ldr	r2, [r3, #8]
     d2c:	4b04      	ldr	r3, [pc, #16]	; (d40 <chSchIsRescRequiredI+0x20>)
     d2e:	699b      	ldr	r3, [r3, #24]
     d30:	689b      	ldr	r3, [r3, #8]
     d32:	429a      	cmp	r2, r3
     d34:	bf94      	ite	ls
     d36:	2300      	movls	r3, #0
     d38:	2301      	movhi	r3, #1
     d3a:	b2db      	uxtb	r3, r3
}
     d3c:	4618      	mov	r0, r3
     d3e:	bd08      	pop	{r3, pc}
     d40:	20000800 	.word	0x20000800
     d44:	f3af 8000 	nop.w
     d48:	f3af 8000 	nop.w
     d4c:	f3af 8000 	nop.w

00000d50 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
     d50:	b508      	push	{r3, lr}

  port_lock_from_isr();
     d52:	f7ff ff9d 	bl	c90 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
     d56:	f000 fdcb 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
     d5a:	f7ff fd41 	bl	7e0 <_dbg_check_lock_from_isr>
}
     d5e:	bd08      	pop	{r3, pc}

00000d60 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
     d60:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
     d62:	f7ff fd55 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
     d66:	f000 fdcb 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
     d6a:	f7ff ff99 	bl	ca0 <port_unlock_from_isr>
}
     d6e:	bd08      	pop	{r3, pc}

00000d70 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
     d70:	b500      	push	{lr}
     d72:	b083      	sub	sp, #12
     d74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     d76:	f7ff fda3 	bl	8c0 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
     d7a:	9b01      	ldr	r3, [sp, #4]
     d7c:	68db      	ldr	r3, [r3, #12]
     d7e:	2b00      	cmp	r3, #0
     d80:	bf0c      	ite	eq
     d82:	2300      	moveq	r3, #0
     d84:	2301      	movne	r3, #1
     d86:	b2db      	uxtb	r3, r3
}
     d88:	4618      	mov	r0, r3
     d8a:	b003      	add	sp, #12
     d8c:	f85d fb04 	ldr.w	pc, [sp], #4

00000d90 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
     d90:	b500      	push	{lr}
     d92:	b083      	sub	sp, #12
     d94:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     d96:	f7ff fd93 	bl	8c0 <chDbgCheckClassI>

  sp->s_cnt++;
     d9a:	9b01      	ldr	r3, [sp, #4]
     d9c:	689b      	ldr	r3, [r3, #8]
     d9e:	1c5a      	adds	r2, r3, #1
     da0:	9b01      	ldr	r3, [sp, #4]
     da2:	609a      	str	r2, [r3, #8]
}
     da4:	b003      	add	sp, #12
     da6:	f85d fb04 	ldr.w	pc, [sp], #4
     daa:	bf00      	nop
     dac:	f3af 8000 	nop.w

00000db0 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
     db0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
     db2:	4806      	ldr	r0, [pc, #24]	; (dcc <_scheduler_init+0x1c>)
     db4:	f7ff ff7c 	bl	cb0 <queue_init>
  ch.rlist.r_prio = NOPRIO;
     db8:	4b04      	ldr	r3, [pc, #16]	; (dcc <_scheduler_init+0x1c>)
     dba:	2200      	movs	r2, #0
     dbc:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
     dbe:	4b03      	ldr	r3, [pc, #12]	; (dcc <_scheduler_init+0x1c>)
     dc0:	4a02      	ldr	r2, [pc, #8]	; (dcc <_scheduler_init+0x1c>)
     dc2:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
     dc4:	4b01      	ldr	r3, [pc, #4]	; (dcc <_scheduler_init+0x1c>)
     dc6:	4a01      	ldr	r2, [pc, #4]	; (dcc <_scheduler_init+0x1c>)
     dc8:	615a      	str	r2, [r3, #20]
#endif
}
     dca:	bd08      	pop	{r3, pc}
     dcc:	20000800 	.word	0x20000800

00000dd0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     dd0:	b500      	push	{lr}
     dd2:	b085      	sub	sp, #20
     dd4:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
     dd6:	f7ff fd73 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
     dda:	9b01      	ldr	r3, [sp, #4]
     ddc:	2b00      	cmp	r3, #0
     dde:	d102      	bne.n	de6 <chSchReadyI+0x16>
     de0:	4818      	ldr	r0, [pc, #96]	; (e44 <chSchReadyI+0x74>)
     de2:	f7ff fc65 	bl	6b0 <chSysHalt>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
     de6:	9b01      	ldr	r3, [sp, #4]
     de8:	f893 3020 	ldrb.w	r3, [r3, #32]
     dec:	2b00      	cmp	r3, #0
     dee:	d004      	beq.n	dfa <chSchReadyI+0x2a>
     df0:	9b01      	ldr	r3, [sp, #4]
     df2:	f893 3020 	ldrb.w	r3, [r3, #32]
     df6:	2b0f      	cmp	r3, #15
     df8:	d102      	bne.n	e00 <chSchReadyI+0x30>
     dfa:	4812      	ldr	r0, [pc, #72]	; (e44 <chSchReadyI+0x74>)
     dfc:	f7ff fc58 	bl	6b0 <chSysHalt>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     e00:	9b01      	ldr	r3, [sp, #4]
     e02:	2200      	movs	r2, #0
     e04:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
     e08:	4b0f      	ldr	r3, [pc, #60]	; (e48 <chSchReadyI+0x78>)
     e0a:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
     e0c:	9b03      	ldr	r3, [sp, #12]
     e0e:	681b      	ldr	r3, [r3, #0]
     e10:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
     e12:	9b03      	ldr	r3, [sp, #12]
     e14:	689a      	ldr	r2, [r3, #8]
     e16:	9b01      	ldr	r3, [sp, #4]
     e18:	689b      	ldr	r3, [r3, #8]
     e1a:	429a      	cmp	r2, r3
     e1c:	d2f6      	bcs.n	e0c <chSchReadyI+0x3c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     e1e:	9b01      	ldr	r3, [sp, #4]
     e20:	9a03      	ldr	r2, [sp, #12]
     e22:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
     e24:	9b03      	ldr	r3, [sp, #12]
     e26:	685a      	ldr	r2, [r3, #4]
     e28:	9b01      	ldr	r3, [sp, #4]
     e2a:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
     e2c:	9b01      	ldr	r3, [sp, #4]
     e2e:	685b      	ldr	r3, [r3, #4]
     e30:	9a01      	ldr	r2, [sp, #4]
     e32:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
     e34:	9b03      	ldr	r3, [sp, #12]
     e36:	9a01      	ldr	r2, [sp, #4]
     e38:	605a      	str	r2, [r3, #4]

  return tp;
     e3a:	9b01      	ldr	r3, [sp, #4]
}
     e3c:	4618      	mov	r0, r3
     e3e:	b005      	add	sp, #20
     e40:	f85d fb04 	ldr.w	pc, [sp], #4
     e44:	00004550 	.word	0x00004550
     e48:	20000800 	.word	0x20000800
     e4c:	f3af 8000 	nop.w

00000e50 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
     e50:	b510      	push	{r4, lr}
     e52:	b084      	sub	sp, #16
     e54:	4603      	mov	r3, r0
     e56:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();
     e5a:	f7ff fd49 	bl	8f0 <chDbgCheckClassS>

  otp = currp;
     e5e:	4b19      	ldr	r3, [pc, #100]	; (ec4 <chSchGoSleepS+0x74>)
     e60:	699b      	ldr	r3, [r3, #24]
     e62:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
     e64:	9b03      	ldr	r3, [sp, #12]
     e66:	f89d 2007 	ldrb.w	r2, [sp, #7]
     e6a:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
     e6e:	4815      	ldr	r0, [pc, #84]	; (ec4 <chSchGoSleepS+0x74>)
     e70:	f7ff ff2e 	bl	cd0 <queue_fifo_remove>
     e74:	4602      	mov	r2, r0
     e76:	4b13      	ldr	r3, [pc, #76]	; (ec4 <chSchGoSleepS+0x74>)
     e78:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
     e7a:	4b12      	ldr	r3, [pc, #72]	; (ec4 <chSchGoSleepS+0x74>)
     e7c:	699b      	ldr	r3, [r3, #24]
     e7e:	2201      	movs	r2, #1
     e80:	f883 2020 	strb.w	r2, [r3, #32]
  chSysSwitch(currp, otp);
     e84:	9803      	ldr	r0, [sp, #12]
     e86:	f7ff fd5b 	bl	940 <_dbg_trace>
     e8a:	4b0e      	ldr	r3, [pc, #56]	; (ec4 <chSchGoSleepS+0x74>)
     e8c:	699b      	ldr	r3, [r3, #24]
     e8e:	4618      	mov	r0, r3
     e90:	9903      	ldr	r1, [sp, #12]
     e92:	f000 fcfd 	bl	1890 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
     e96:	f3ef 8309 	mrs	r3, PSP
     e9a:	461c      	mov	r4, r3
  return(result);
     e9c:	4623      	mov	r3, r4
     e9e:	9302      	str	r3, [sp, #8]
     ea0:	9b02      	ldr	r3, [sp, #8]
     ea2:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
     ea6:	9b03      	ldr	r3, [sp, #12]
     ea8:	69db      	ldr	r3, [r3, #28]
     eaa:	429a      	cmp	r2, r3
     eac:	d202      	bcs.n	eb4 <chSchGoSleepS+0x64>
     eae:	4806      	ldr	r0, [pc, #24]	; (ec8 <chSchGoSleepS+0x78>)
     eb0:	f7ff fbfe 	bl	6b0 <chSysHalt>
     eb4:	4b03      	ldr	r3, [pc, #12]	; (ec4 <chSchGoSleepS+0x74>)
     eb6:	699b      	ldr	r3, [r3, #24]
     eb8:	4618      	mov	r0, r3
     eba:	9903      	ldr	r1, [sp, #12]
     ebc:	f7ff f9e0 	bl	280 <_port_switch>
}
     ec0:	b004      	add	sp, #16
     ec2:	bd10      	pop	{r4, pc}
     ec4:	20000800 	.word	0x20000800
     ec8:	00004510 	.word	0x00004510
     ecc:	f3af 8000 	nop.w

00000ed0 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
     ed0:	b500      	push	{lr}
     ed2:	b085      	sub	sp, #20
     ed4:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
     ed6:	9b01      	ldr	r3, [sp, #4]
     ed8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
     eda:	f7ff ff39 	bl	d50 <chSysLockFromISR>
  switch (tp->p_state) {
     ede:	9b03      	ldr	r3, [sp, #12]
     ee0:	f893 3020 	ldrb.w	r3, [r3, #32]
     ee4:	2b07      	cmp	r3, #7
     ee6:	d824      	bhi.n	f32 <wakeup+0x62>
     ee8:	a201      	add	r2, pc, #4	; (adr r2, ef0 <wakeup+0x20>)
     eea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     eee:	bf00      	nop
     ef0:	00000f11 	.word	0x00000f11
     ef4:	00000f33 	.word	0x00000f33
     ef8:	00000f33 	.word	0x00000f33
     efc:	00000f17 	.word	0x00000f17
     f00:	00000f2b 	.word	0x00000f2b
     f04:	00000f21 	.word	0x00000f21
     f08:	00000f33 	.word	0x00000f33
     f0c:	00000f2b 	.word	0x00000f2b
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
     f10:	f7ff ff26 	bl	d60 <chSysUnlockFromISR>
    return;
     f14:	e017      	b.n	f46 <wakeup+0x76>
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
     f16:	9b03      	ldr	r3, [sp, #12]
     f18:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     f1a:	2200      	movs	r2, #0
     f1c:	601a      	str	r2, [r3, #0]
    break;
     f1e:	e009      	b.n	f34 <wakeup+0x64>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
     f20:	9b03      	ldr	r3, [sp, #12]
     f22:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     f24:	4618      	mov	r0, r3
     f26:	f7ff ff33 	bl	d90 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
     f2a:	9803      	ldr	r0, [sp, #12]
     f2c:	f7ff fee8 	bl	d00 <queue_dequeue>
    break;
     f30:	e000      	b.n	f34 <wakeup+0x64>
  default:
    /* Any other state, nothing to do.*/
    break;
     f32:	bf00      	nop
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
     f34:	9b03      	ldr	r3, [sp, #12]
     f36:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     f3a:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
     f3c:	9803      	ldr	r0, [sp, #12]
     f3e:	f7ff ff47 	bl	dd0 <chSchReadyI>
  chSysUnlockFromISR();
     f42:	f7ff ff0d 	bl	d60 <chSysUnlockFromISR>
}
     f46:	b005      	add	sp, #20
     f48:	f85d fb04 	ldr.w	pc, [sp], #4
     f4c:	f3af 8000 	nop.w

00000f50 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
     f50:	b500      	push	{lr}
     f52:	b089      	sub	sp, #36	; 0x24
     f54:	4603      	mov	r3, r0
     f56:	9100      	str	r1, [sp, #0]
     f58:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
     f5c:	f7ff fcc8 	bl	8f0 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
     f60:	9b00      	ldr	r3, [sp, #0]
     f62:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
     f66:	d019      	beq.n	f9c <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
     f68:	4b12      	ldr	r3, [pc, #72]	; (fb4 <chSchGoSleepTimeoutS+0x64>)
     f6a:	699b      	ldr	r3, [r3, #24]
     f6c:	aa03      	add	r2, sp, #12
     f6e:	4610      	mov	r0, r2
     f70:	9900      	ldr	r1, [sp, #0]
     f72:	4a11      	ldr	r2, [pc, #68]	; (fb8 <chSchGoSleepTimeoutS+0x68>)
     f74:	f7ff fd6c 	bl	a50 <chVTDoSetI>
    chSchGoSleepS(newstate);
     f78:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f7c:	4618      	mov	r0, r3
     f7e:	f7ff ff67 	bl	e50 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     f82:	ab03      	add	r3, sp, #12
     f84:	4618      	mov	r0, r3
     f86:	f7ff fef3 	bl	d70 <chVTIsArmedI>
     f8a:	4603      	mov	r3, r0
     f8c:	2b00      	cmp	r3, #0
     f8e:	d004      	beq.n	f9a <chSchGoSleepTimeoutS+0x4a>
      chVTDoResetI(&vt);
     f90:	ab03      	add	r3, sp, #12
     f92:	4618      	mov	r0, r3
     f94:	f7ff fdec 	bl	b70 <chVTDoResetI>
     f98:	e005      	b.n	fa6 <chSchGoSleepTimeoutS+0x56>
     f9a:	e004      	b.n	fa6 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
     f9c:	f89d 3007 	ldrb.w	r3, [sp, #7]
     fa0:	4618      	mov	r0, r3
     fa2:	f7ff ff55 	bl	e50 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
     fa6:	4b03      	ldr	r3, [pc, #12]	; (fb4 <chSchGoSleepTimeoutS+0x64>)
     fa8:	699b      	ldr	r3, [r3, #24]
     faa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     fac:	4618      	mov	r0, r3
     fae:	b009      	add	sp, #36	; 0x24
     fb0:	f85d fb04 	ldr.w	pc, [sp], #4
     fb4:	20000800 	.word	0x20000800
     fb8:	00000ed1 	.word	0x00000ed1
     fbc:	f3af 8000 	nop.w

00000fc0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     fc0:	b510      	push	{r4, lr}
     fc2:	b084      	sub	sp, #16
     fc4:	9001      	str	r0, [sp, #4]
     fc6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
     fc8:	f7ff fc92 	bl	8f0 <chDbgCheckClassS>

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
     fcc:	9b01      	ldr	r3, [sp, #4]
     fce:	9a00      	ldr	r2, [sp, #0]
     fd0:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
     fd2:	9b01      	ldr	r3, [sp, #4]
     fd4:	689a      	ldr	r2, [r3, #8]
     fd6:	4b19      	ldr	r3, [pc, #100]	; (103c <__ram5_size__+0x3c>)
     fd8:	699b      	ldr	r3, [r3, #24]
     fda:	689b      	ldr	r3, [r3, #8]
     fdc:	429a      	cmp	r2, r3
     fde:	d803      	bhi.n	fe8 <chSchWakeupS+0x28>
    (void) chSchReadyI(ntp);
     fe0:	9801      	ldr	r0, [sp, #4]
     fe2:	f7ff fef5 	bl	dd0 <chSchReadyI>
     fe6:	e026      	b.n	1036 <__ram5_size__+0x36>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
     fe8:	4b14      	ldr	r3, [pc, #80]	; (103c <__ram5_size__+0x3c>)
     fea:	699b      	ldr	r3, [r3, #24]
     fec:	4618      	mov	r0, r3
     fee:	f7ff feef 	bl	dd0 <chSchReadyI>
     ff2:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
     ff4:	4b11      	ldr	r3, [pc, #68]	; (103c <__ram5_size__+0x3c>)
     ff6:	9a01      	ldr	r2, [sp, #4]
     ff8:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
     ffa:	9b01      	ldr	r3, [sp, #4]
     ffc:	2201      	movs	r2, #1
     ffe:	f883 2020 	strb.w	r2, [r3, #32]
    chSysSwitch(ntp, otp);
    1002:	9803      	ldr	r0, [sp, #12]
    1004:	f7ff fc9c 	bl	940 <_dbg_trace>
    1008:	9801      	ldr	r0, [sp, #4]
    100a:	9903      	ldr	r1, [sp, #12]
    100c:	f000 fc40 	bl	1890 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    1010:	f3ef 8309 	mrs	r3, PSP
    1014:	461c      	mov	r4, r3
  return(result);
    1016:	4623      	mov	r3, r4
    1018:	9302      	str	r3, [sp, #8]
    101a:	9b02      	ldr	r3, [sp, #8]
    101c:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    1020:	9b03      	ldr	r3, [sp, #12]
    1022:	69db      	ldr	r3, [r3, #28]
    1024:	429a      	cmp	r2, r3
    1026:	d202      	bcs.n	102e <__ram5_size__+0x2e>
    1028:	4805      	ldr	r0, [pc, #20]	; (1040 <__ram5_size__+0x40>)
    102a:	f7ff fb41 	bl	6b0 <chSysHalt>
    102e:	9801      	ldr	r0, [sp, #4]
    1030:	9903      	ldr	r1, [sp, #12]
    1032:	f7ff f925 	bl	280 <_port_switch>
  }
}
    1036:	b004      	add	sp, #16
    1038:	bd10      	pop	{r4, pc}
    103a:	bf00      	nop
    103c:	20000800 	.word	0x20000800
    1040:	00004510 	.word	0x00004510
    1044:	f3af 8000 	nop.w
    1048:	f3af 8000 	nop.w
    104c:	f3af 8000 	nop.w

00001050 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
    1050:	b508      	push	{r3, lr}

  chDbgCheckClassS();
    1052:	f7ff fc4d 	bl	8f0 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
    1056:	f7ff fe63 	bl	d20 <chSchIsRescRequiredI>
    105a:	4603      	mov	r3, r0
    105c:	2b00      	cmp	r3, #0
    105e:	d001      	beq.n	1064 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
    1060:	f000 f81e 	bl	10a0 <chSchDoRescheduleAhead>
  }
}
    1064:	bd08      	pop	{r3, pc}
    1066:	bf00      	nop
    1068:	f3af 8000 	nop.w
    106c:	f3af 8000 	nop.w

00001070 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
    1070:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
    1072:	4b09      	ldr	r3, [pc, #36]	; (1098 <chSchIsPreemptionRequired+0x28>)
    1074:	681b      	ldr	r3, [r3, #0]
    1076:	689b      	ldr	r3, [r3, #8]
    1078:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
    107a:	4b07      	ldr	r3, [pc, #28]	; (1098 <chSchIsPreemptionRequired+0x28>)
    107c:	699b      	ldr	r3, [r3, #24]
    107e:	689b      	ldr	r3, [r3, #8]
    1080:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
    1082:	9a01      	ldr	r2, [sp, #4]
    1084:	9b00      	ldr	r3, [sp, #0]
    1086:	429a      	cmp	r2, r3
    1088:	bf94      	ite	ls
    108a:	2300      	movls	r3, #0
    108c:	2301      	movhi	r3, #1
    108e:	b2db      	uxtb	r3, r3
#endif
}
    1090:	4618      	mov	r0, r3
    1092:	b002      	add	sp, #8
    1094:	4770      	bx	lr
    1096:	bf00      	nop
    1098:	20000800 	.word	0x20000800
    109c:	f3af 8000 	nop.w

000010a0 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
    10a0:	b510      	push	{r4, lr}
    10a2:	b084      	sub	sp, #16
  thread_t *otp, *cp;

  otp = currp;
    10a4:	4b25      	ldr	r3, [pc, #148]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10a6:	699b      	ldr	r3, [r3, #24]
    10a8:	9302      	str	r3, [sp, #8]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
    10aa:	4824      	ldr	r0, [pc, #144]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10ac:	f7ff fe10 	bl	cd0 <queue_fifo_remove>
    10b0:	4602      	mov	r2, r0
    10b2:	4b22      	ldr	r3, [pc, #136]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10b4:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
    10b6:	4b21      	ldr	r3, [pc, #132]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10b8:	699b      	ldr	r3, [r3, #24]
    10ba:	2201      	movs	r2, #1
    10bc:	f883 2020 	strb.w	r2, [r3, #32]

  otp->p_state = CH_STATE_READY;
    10c0:	9b02      	ldr	r3, [sp, #8]
    10c2:	2200      	movs	r2, #0
    10c4:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
    10c8:	4b1c      	ldr	r3, [pc, #112]	; (113c <chSchDoRescheduleAhead+0x9c>)
    10ca:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
    10cc:	9b03      	ldr	r3, [sp, #12]
    10ce:	681b      	ldr	r3, [r3, #0]
    10d0:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio > otp->p_prio);
    10d2:	9b03      	ldr	r3, [sp, #12]
    10d4:	689a      	ldr	r2, [r3, #8]
    10d6:	9b02      	ldr	r3, [sp, #8]
    10d8:	689b      	ldr	r3, [r3, #8]
    10da:	429a      	cmp	r2, r3
    10dc:	d8f6      	bhi.n	10cc <chSchDoRescheduleAhead+0x2c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
    10de:	9b02      	ldr	r3, [sp, #8]
    10e0:	9a03      	ldr	r2, [sp, #12]
    10e2:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
    10e4:	9b03      	ldr	r3, [sp, #12]
    10e6:	685a      	ldr	r2, [r3, #4]
    10e8:	9b02      	ldr	r3, [sp, #8]
    10ea:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
    10ec:	9b02      	ldr	r3, [sp, #8]
    10ee:	685b      	ldr	r3, [r3, #4]
    10f0:	9a02      	ldr	r2, [sp, #8]
    10f2:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
    10f4:	9b03      	ldr	r3, [sp, #12]
    10f6:	9a02      	ldr	r2, [sp, #8]
    10f8:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
    10fa:	9802      	ldr	r0, [sp, #8]
    10fc:	f7ff fc20 	bl	940 <_dbg_trace>
    1100:	4b0e      	ldr	r3, [pc, #56]	; (113c <chSchDoRescheduleAhead+0x9c>)
    1102:	699b      	ldr	r3, [r3, #24]
    1104:	4618      	mov	r0, r3
    1106:	9902      	ldr	r1, [sp, #8]
    1108:	f000 fbc2 	bl	1890 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    110c:	f3ef 8309 	mrs	r3, PSP
    1110:	461c      	mov	r4, r3
  return(result);
    1112:	4623      	mov	r3, r4
    1114:	9301      	str	r3, [sp, #4]
    1116:	9b01      	ldr	r3, [sp, #4]
    1118:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    111c:	9b02      	ldr	r3, [sp, #8]
    111e:	69db      	ldr	r3, [r3, #28]
    1120:	429a      	cmp	r2, r3
    1122:	d202      	bcs.n	112a <chSchDoRescheduleAhead+0x8a>
    1124:	4806      	ldr	r0, [pc, #24]	; (1140 <chSchDoRescheduleAhead+0xa0>)
    1126:	f7ff fac3 	bl	6b0 <chSysHalt>
    112a:	4b04      	ldr	r3, [pc, #16]	; (113c <chSchDoRescheduleAhead+0x9c>)
    112c:	699b      	ldr	r3, [r3, #24]
    112e:	4618      	mov	r0, r3
    1130:	9902      	ldr	r1, [sp, #8]
    1132:	f7ff f8a5 	bl	280 <_port_switch>
}
    1136:	b004      	add	sp, #16
    1138:	bd10      	pop	{r4, pc}
    113a:	bf00      	nop
    113c:	20000800 	.word	0x20000800
    1140:	00004510 	.word	0x00004510
    1144:	f3af 8000 	nop.w
    1148:	f3af 8000 	nop.w
    114c:	f3af 8000 	nop.w

00001150 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    1150:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
    1152:	f7ff ffa5 	bl	10a0 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
    1156:	bd08      	pop	{r3, pc}
    1158:	f3af 8000 	nop.w
    115c:	f3af 8000 	nop.w

00001160 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1160:	b082      	sub	sp, #8
    1162:	2320      	movs	r3, #32
    1164:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    1166:	9b01      	ldr	r3, [sp, #4]
    1168:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    116c:	b002      	add	sp, #8
    116e:	4770      	bx	lr

00001170 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1170:	b082      	sub	sp, #8
    1172:	2300      	movs	r3, #0
    1174:	9301      	str	r3, [sp, #4]
    1176:	9b01      	ldr	r3, [sp, #4]
    1178:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    117c:	b002      	add	sp, #8
    117e:	4770      	bx	lr

00001180 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
    1180:	b082      	sub	sp, #8
    1182:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
    1184:	9b01      	ldr	r3, [sp, #4]
    1186:	9a01      	ldr	r2, [sp, #4]
    1188:	601a      	str	r2, [r3, #0]
}
    118a:	b002      	add	sp, #8
    118c:	4770      	bx	lr
    118e:	bf00      	nop

00001190 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
    1190:	b082      	sub	sp, #8
    1192:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
    1194:	9b01      	ldr	r3, [sp, #4]
    1196:	681a      	ldr	r2, [r3, #0]
    1198:	9b01      	ldr	r3, [sp, #4]
    119a:	429a      	cmp	r2, r3
    119c:	bf0c      	ite	eq
    119e:	2300      	moveq	r3, #0
    11a0:	2301      	movne	r3, #1
    11a2:	b2db      	uxtb	r3, r3
}
    11a4:	4618      	mov	r0, r3
    11a6:	b002      	add	sp, #8
    11a8:	4770      	bx	lr
    11aa:	bf00      	nop
    11ac:	f3af 8000 	nop.w

000011b0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    11b0:	b082      	sub	sp, #8
    11b2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    11b4:	9b01      	ldr	r3, [sp, #4]
    11b6:	9a01      	ldr	r2, [sp, #4]
    11b8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    11ba:	9b01      	ldr	r3, [sp, #4]
    11bc:	9a01      	ldr	r2, [sp, #4]
    11be:	605a      	str	r2, [r3, #4]
}
    11c0:	b002      	add	sp, #8
    11c2:	4770      	bx	lr
    11c4:	f3af 8000 	nop.w
    11c8:	f3af 8000 	nop.w
    11cc:	f3af 8000 	nop.w

000011d0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
    11d0:	b082      	sub	sp, #8
    11d2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
    11d4:	9b01      	ldr	r3, [sp, #4]
    11d6:	681a      	ldr	r2, [r3, #0]
    11d8:	9b01      	ldr	r3, [sp, #4]
    11da:	429a      	cmp	r2, r3
    11dc:	bf0c      	ite	eq
    11de:	2300      	moveq	r3, #0
    11e0:	2301      	movne	r3, #1
    11e2:	b2db      	uxtb	r3, r3
}
    11e4:	4618      	mov	r0, r3
    11e6:	b002      	add	sp, #8
    11e8:	4770      	bx	lr
    11ea:	bf00      	nop
    11ec:	f3af 8000 	nop.w

000011f0 <list_remove>:

  tp->p_next = tlp->p_next;
  tlp->p_next = tp;
}

static inline thread_t *list_remove(threads_list_t *tlp) {
    11f0:	b084      	sub	sp, #16
    11f2:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
    11f4:	9b01      	ldr	r3, [sp, #4]
    11f6:	681b      	ldr	r3, [r3, #0]
    11f8:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
    11fa:	9b03      	ldr	r3, [sp, #12]
    11fc:	681a      	ldr	r2, [r3, #0]
    11fe:	9b01      	ldr	r3, [sp, #4]
    1200:	601a      	str	r2, [r3, #0]

  return tp;
    1202:	9b03      	ldr	r3, [sp, #12]
}
    1204:	4618      	mov	r0, r3
    1206:	b004      	add	sp, #16
    1208:	4770      	bx	lr
    120a:	bf00      	nop
    120c:	f3af 8000 	nop.w

00001210 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
    1210:	b082      	sub	sp, #8
    1212:	9001      	str	r0, [sp, #4]
    1214:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
    1216:	9b01      	ldr	r3, [sp, #4]
    1218:	9a00      	ldr	r2, [sp, #0]
    121a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
    121c:	9b00      	ldr	r3, [sp, #0]
    121e:	685a      	ldr	r2, [r3, #4]
    1220:	9b01      	ldr	r3, [sp, #4]
    1222:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    1224:	9b01      	ldr	r3, [sp, #4]
    1226:	685b      	ldr	r3, [r3, #4]
    1228:	9a01      	ldr	r2, [sp, #4]
    122a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
    122c:	9b00      	ldr	r3, [sp, #0]
    122e:	9a01      	ldr	r2, [sp, #4]
    1230:	605a      	str	r2, [r3, #4]
}
    1232:	b002      	add	sp, #8
    1234:	4770      	bx	lr
    1236:	bf00      	nop
    1238:	f3af 8000 	nop.w
    123c:	f3af 8000 	nop.w

00001240 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
    1240:	b084      	sub	sp, #16
    1242:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
    1244:	9b01      	ldr	r3, [sp, #4]
    1246:	681b      	ldr	r3, [r3, #0]
    1248:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
    124a:	9b03      	ldr	r3, [sp, #12]
    124c:	681a      	ldr	r2, [r3, #0]
    124e:	9b01      	ldr	r3, [sp, #4]
    1250:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1252:	9b01      	ldr	r3, [sp, #4]
    1254:	681b      	ldr	r3, [r3, #0]
    1256:	9a01      	ldr	r2, [sp, #4]
    1258:	605a      	str	r2, [r3, #4]

  return tp;
    125a:	9b03      	ldr	r3, [sp, #12]
}
    125c:	4618      	mov	r0, r3
    125e:	b004      	add	sp, #16
    1260:	4770      	bx	lr
    1262:	bf00      	nop
    1264:	f3af 8000 	nop.w
    1268:	f3af 8000 	nop.w
    126c:	f3af 8000 	nop.w

00001270 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1270:	b508      	push	{r3, lr}

  port_lock();
    1272:	f7ff ff75 	bl	1160 <port_lock>
  _stats_start_measure_crit_thd();
    1276:	f000 fb2b 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    127a:	f7ff fa81 	bl	780 <_dbg_check_lock>
}
    127e:	bd08      	pop	{r3, pc}

00001280 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1280:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1282:	f7ff fa95 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1286:	f000 fb2b 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    128a:	4b09      	ldr	r3, [pc, #36]	; (12b0 <chSysUnlock+0x30>)
    128c:	681a      	ldr	r2, [r3, #0]
    128e:	4b08      	ldr	r3, [pc, #32]	; (12b0 <chSysUnlock+0x30>)
    1290:	429a      	cmp	r2, r3
    1292:	d00a      	beq.n	12aa <chSysUnlock+0x2a>
    1294:	4b06      	ldr	r3, [pc, #24]	; (12b0 <chSysUnlock+0x30>)
    1296:	699b      	ldr	r3, [r3, #24]
    1298:	689a      	ldr	r2, [r3, #8]
    129a:	4b05      	ldr	r3, [pc, #20]	; (12b0 <chSysUnlock+0x30>)
    129c:	681b      	ldr	r3, [r3, #0]
    129e:	689b      	ldr	r3, [r3, #8]
    12a0:	429a      	cmp	r2, r3
    12a2:	d202      	bcs.n	12aa <chSysUnlock+0x2a>
    12a4:	4803      	ldr	r0, [pc, #12]	; (12b4 <chSysUnlock+0x34>)
    12a6:	f7ff fa03 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    12aa:	f7ff ff61 	bl	1170 <port_unlock>
}
    12ae:	bd08      	pop	{r3, pc}
    12b0:	20000800 	.word	0x20000800
    12b4:	00004570 	.word	0x00004570
    12b8:	f3af 8000 	nop.w
    12bc:	f3af 8000 	nop.w

000012c0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
    12c0:	b500      	push	{lr}
    12c2:	b083      	sub	sp, #12
    12c4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
    12c6:	9b01      	ldr	r3, [sp, #4]
    12c8:	2b00      	cmp	r3, #0
    12ca:	d102      	bne.n	12d2 <chThdSleepS+0x12>
    12cc:	4804      	ldr	r0, [pc, #16]	; (12e0 <chThdSleepS+0x20>)
    12ce:	f7ff f9ef 	bl	6b0 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
    12d2:	2008      	movs	r0, #8
    12d4:	9901      	ldr	r1, [sp, #4]
    12d6:	f7ff fe3b 	bl	f50 <chSchGoSleepTimeoutS>
}
    12da:	b003      	add	sp, #12
    12dc:	f85d fb04 	ldr.w	pc, [sp], #4
    12e0:	000045a0 	.word	0x000045a0
    12e4:	f3af 8000 	nop.w
    12e8:	f3af 8000 	nop.w
    12ec:	f3af 8000 	nop.w

000012f0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    12f0:	b500      	push	{lr}
    12f2:	b085      	sub	sp, #20
    12f4:	9001      	str	r0, [sp, #4]
    12f6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
    12f8:	9801      	ldr	r0, [sp, #4]
    12fa:	f7ff ff69 	bl	11d0 <queue_notempty>
    12fe:	4603      	mov	r3, r0
    1300:	f083 0301 	eor.w	r3, r3, #1
    1304:	b2db      	uxtb	r3, r3
    1306:	2b00      	cmp	r3, #0
    1308:	d002      	beq.n	1310 <chThdDoDequeueNextI+0x20>
    130a:	480c      	ldr	r0, [pc, #48]	; (133c <chThdDoDequeueNextI+0x4c>)
    130c:	f7ff f9d0 	bl	6b0 <chSysHalt>

  tp = queue_fifo_remove(tqp);
    1310:	9801      	ldr	r0, [sp, #4]
    1312:	f7ff ff95 	bl	1240 <queue_fifo_remove>
    1316:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
    1318:	9b03      	ldr	r3, [sp, #12]
    131a:	f893 3020 	ldrb.w	r3, [r3, #32]
    131e:	2b04      	cmp	r3, #4
    1320:	d002      	beq.n	1328 <chThdDoDequeueNextI+0x38>
    1322:	4806      	ldr	r0, [pc, #24]	; (133c <chThdDoDequeueNextI+0x4c>)
    1324:	f7ff f9c4 	bl	6b0 <chSysHalt>

  tp->p_u.rdymsg = msg;
    1328:	9b03      	ldr	r3, [sp, #12]
    132a:	9a00      	ldr	r2, [sp, #0]
    132c:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
    132e:	9803      	ldr	r0, [sp, #12]
    1330:	f7ff fd4e 	bl	dd0 <chSchReadyI>
}
    1334:	b005      	add	sp, #20
    1336:	f85d fb04 	ldr.w	pc, [sp], #4
    133a:	bf00      	nop
    133c:	000045d0 	.word	0x000045d0

00001340 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
    1340:	b500      	push	{lr}
    1342:	b083      	sub	sp, #12
    1344:	9001      	str	r0, [sp, #4]
    1346:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
    1348:	9b01      	ldr	r3, [sp, #4]
    134a:	9a00      	ldr	r2, [sp, #0]
    134c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
    134e:	9b01      	ldr	r3, [sp, #4]
    1350:	2202      	movs	r2, #2
    1352:	f883 2020 	strb.w	r2, [r3, #32]
  tp->p_flags = CH_FLAG_MODE_STATIC;
    1356:	9b01      	ldr	r3, [sp, #4]
    1358:	2200      	movs	r2, #0
    135a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
    135e:	9b01      	ldr	r3, [sp, #4]
    1360:	9a00      	ldr	r2, [sp, #0]
    1362:	641a      	str	r2, [r3, #64]	; 0x40
  tp->p_mtxlist = NULL;
    1364:	9b01      	ldr	r3, [sp, #4]
    1366:	2200      	movs	r2, #0
    1368:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
    136a:	9b01      	ldr	r3, [sp, #4]
    136c:	2200      	movs	r2, #0
    136e:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
    1370:	9b01      	ldr	r3, [sp, #4]
    1372:	2201      	movs	r2, #1
    1374:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
    1378:	9b01      	ldr	r3, [sp, #4]
    137a:	2200      	movs	r2, #0
    137c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
    137e:	9b01      	ldr	r3, [sp, #4]
    1380:	4a15      	ldr	r2, [pc, #84]	; (13d8 <_thread_init+0x98>)
    1382:	611a      	str	r2, [r3, #16]
    1384:	4b14      	ldr	r3, [pc, #80]	; (13d8 <_thread_init+0x98>)
    1386:	695a      	ldr	r2, [r3, #20]
    1388:	9b01      	ldr	r3, [sp, #4]
    138a:	615a      	str	r2, [r3, #20]
    138c:	9b01      	ldr	r3, [sp, #4]
    138e:	695b      	ldr	r3, [r3, #20]
    1390:	9a01      	ldr	r2, [sp, #4]
    1392:	611a      	str	r2, [r3, #16]
    1394:	4b10      	ldr	r3, [pc, #64]	; (13d8 <_thread_init+0x98>)
    1396:	9a01      	ldr	r2, [sp, #4]
    1398:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
    139a:	9b01      	ldr	r3, [sp, #4]
    139c:	3328      	adds	r3, #40	; 0x28
    139e:	4618      	mov	r0, r3
    13a0:	f7ff feee 	bl	1180 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
    13a4:	9b01      	ldr	r3, [sp, #4]
    13a6:	332c      	adds	r3, #44	; 0x2c
    13a8:	4618      	mov	r0, r3
    13aa:	f7ff ff01 	bl	11b0 <queue_init>
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
    13ae:	9b01      	ldr	r3, [sp, #4]
    13b0:	f103 0260 	add.w	r2, r3, #96	; 0x60
    13b4:	9b01      	ldr	r3, [sp, #4]
    13b6:	61da      	str	r2, [r3, #28]
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->p_stats);
    13b8:	9b01      	ldr	r3, [sp, #4]
    13ba:	3348      	adds	r3, #72	; 0x48
    13bc:	4618      	mov	r0, r3
    13be:	f000 f9e7 	bl	1790 <chTMObjectInit>
  chTMStartMeasurementX(&tp->p_stats);
    13c2:	9b01      	ldr	r3, [sp, #4]
    13c4:	3348      	adds	r3, #72	; 0x48
    13c6:	4618      	mov	r0, r3
    13c8:	f000 f9fa 	bl	17c0 <chTMStartMeasurementX>
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
    13cc:	9b01      	ldr	r3, [sp, #4]
}
    13ce:	4618      	mov	r0, r3
    13d0:	b003      	add	sp, #12
    13d2:	f85d fb04 	ldr.w	pc, [sp], #4
    13d6:	bf00      	nop
    13d8:	20000800 	.word	0x20000800
    13dc:	f3af 8000 	nop.w

000013e0 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
    13e0:	b084      	sub	sp, #16
    13e2:	9003      	str	r0, [sp, #12]
    13e4:	9102      	str	r1, [sp, #8]
    13e6:	4613      	mov	r3, r2
    13e8:	f88d 3007 	strb.w	r3, [sp, #7]

  while (startp < endp) {
    13ec:	e005      	b.n	13fa <_thread_memfill+0x1a>
    *startp++ = v;
    13ee:	9b03      	ldr	r3, [sp, #12]
    13f0:	1c5a      	adds	r2, r3, #1
    13f2:	9203      	str	r2, [sp, #12]
    13f4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    13f8:	701a      	strb	r2, [r3, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    13fa:	9a03      	ldr	r2, [sp, #12]
    13fc:	9b02      	ldr	r3, [sp, #8]
    13fe:	429a      	cmp	r2, r3
    1400:	d3f5      	bcc.n	13ee <_thread_memfill+0xe>
    *startp++ = v;
  }
}
    1402:	b004      	add	sp, #16
    1404:	4770      	bx	lr
    1406:	bf00      	nop
    1408:	f3af 8000 	nop.w
    140c:	f3af 8000 	nop.w

00001410 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
    1410:	b500      	push	{lr}
    1412:	b087      	sub	sp, #28
    1414:	9003      	str	r0, [sp, #12]
    1416:	9102      	str	r1, [sp, #8]
    1418:	9201      	str	r2, [sp, #4]
    141a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
    141c:	9b03      	ldr	r3, [sp, #12]
    141e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
    1420:	f7ff fa4e 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
    1424:	9b03      	ldr	r3, [sp, #12]
    1426:	2b00      	cmp	r3, #0
    1428:	d008      	beq.n	143c <chThdCreateI+0x2c>
    142a:	9b02      	ldr	r3, [sp, #8]
    142c:	2be7      	cmp	r3, #231	; 0xe7
    142e:	d905      	bls.n	143c <chThdCreateI+0x2c>
    1430:	9b01      	ldr	r3, [sp, #4]
    1432:	2b7f      	cmp	r3, #127	; 0x7f
    1434:	d802      	bhi.n	143c <chThdCreateI+0x2c>
    1436:	9b00      	ldr	r3, [sp, #0]
    1438:	2b00      	cmp	r3, #0
    143a:	d102      	bne.n	1442 <chThdCreateI+0x32>
    143c:	480e      	ldr	r0, [pc, #56]	; (1478 <chThdCreateI+0x68>)
    143e:	f7ff f937 	bl	6b0 <chSysHalt>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    1442:	9b02      	ldr	r3, [sp, #8]
    1444:	3b24      	subs	r3, #36	; 0x24
    1446:	9a03      	ldr	r2, [sp, #12]
    1448:	441a      	add	r2, r3
    144a:	9b05      	ldr	r3, [sp, #20]
    144c:	60da      	str	r2, [r3, #12]
    144e:	9b05      	ldr	r3, [sp, #20]
    1450:	68db      	ldr	r3, [r3, #12]
    1452:	9a00      	ldr	r2, [sp, #0]
    1454:	601a      	str	r2, [r3, #0]
    1456:	9b05      	ldr	r3, [sp, #20]
    1458:	68db      	ldr	r3, [r3, #12]
    145a:	9a08      	ldr	r2, [sp, #32]
    145c:	605a      	str	r2, [r3, #4]
    145e:	9b05      	ldr	r3, [sp, #20]
    1460:	68db      	ldr	r3, [r3, #12]
    1462:	4a06      	ldr	r2, [pc, #24]	; (147c <chThdCreateI+0x6c>)
    1464:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
    1466:	9805      	ldr	r0, [sp, #20]
    1468:	9901      	ldr	r1, [sp, #4]
    146a:	f7ff ff69 	bl	1340 <_thread_init>
    146e:	4603      	mov	r3, r0
}
    1470:	4618      	mov	r0, r3
    1472:	b007      	add	sp, #28
    1474:	f85d fb04 	ldr.w	pc, [sp], #4
    1478:	00004560 	.word	0x00004560
    147c:	00000291 	.word	0x00000291

00001480 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
    1480:	b500      	push	{lr}
    1482:	b089      	sub	sp, #36	; 0x24
    1484:	9005      	str	r0, [sp, #20]
    1486:	9104      	str	r1, [sp, #16]
    1488:	9203      	str	r2, [sp, #12]
    148a:	9302      	str	r3, [sp, #8]
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
    148c:	9b05      	ldr	r3, [sp, #20]
    148e:	3360      	adds	r3, #96	; 0x60
    1490:	9805      	ldr	r0, [sp, #20]
    1492:	4619      	mov	r1, r3
    1494:	22ff      	movs	r2, #255	; 0xff
    1496:	f7ff ffa3 	bl	13e0 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
    149a:	9b05      	ldr	r3, [sp, #20]
    149c:	f103 0260 	add.w	r2, r3, #96	; 0x60
    14a0:	9905      	ldr	r1, [sp, #20]
    14a2:	9b04      	ldr	r3, [sp, #16]
    14a4:	440b      	add	r3, r1
    14a6:	4610      	mov	r0, r2
    14a8:	4619      	mov	r1, r3
    14aa:	2255      	movs	r2, #85	; 0x55
    14ac:	f7ff ff98 	bl	13e0 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
    14b0:	f7ff fede 	bl	1270 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
    14b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    14b6:	9300      	str	r3, [sp, #0]
    14b8:	9805      	ldr	r0, [sp, #20]
    14ba:	9904      	ldr	r1, [sp, #16]
    14bc:	9a03      	ldr	r2, [sp, #12]
    14be:	9b02      	ldr	r3, [sp, #8]
    14c0:	f7ff ffa6 	bl	1410 <chThdCreateI>
    14c4:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
    14c6:	9807      	ldr	r0, [sp, #28]
    14c8:	2100      	movs	r1, #0
    14ca:	f7ff fd79 	bl	fc0 <chSchWakeupS>
  chSysUnlock();
    14ce:	f7ff fed7 	bl	1280 <chSysUnlock>

  return tp;
    14d2:	9b07      	ldr	r3, [sp, #28]
}
    14d4:	4618      	mov	r0, r3
    14d6:	b009      	add	sp, #36	; 0x24
    14d8:	f85d fb04 	ldr.w	pc, [sp], #4
    14dc:	f3af 8000 	nop.w

000014e0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
    14e0:	b500      	push	{lr}
    14e2:	b085      	sub	sp, #20
    14e4:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
    14e6:	9b01      	ldr	r3, [sp, #4]
    14e8:	2b7f      	cmp	r3, #127	; 0x7f
    14ea:	d902      	bls.n	14f2 <chThdSetPriority+0x12>
    14ec:	4813      	ldr	r0, [pc, #76]	; (153c <chThdSetPriority+0x5c>)
    14ee:	f7ff f8df 	bl	6b0 <chSysHalt>

  chSysLock();
    14f2:	f7ff febd 	bl	1270 <chSysLock>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
    14f6:	4b12      	ldr	r3, [pc, #72]	; (1540 <chThdSetPriority+0x60>)
    14f8:	699b      	ldr	r3, [r3, #24]
    14fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    14fc:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
    14fe:	4b10      	ldr	r3, [pc, #64]	; (1540 <chThdSetPriority+0x60>)
    1500:	699b      	ldr	r3, [r3, #24]
    1502:	689a      	ldr	r2, [r3, #8]
    1504:	4b0e      	ldr	r3, [pc, #56]	; (1540 <chThdSetPriority+0x60>)
    1506:	699b      	ldr	r3, [r3, #24]
    1508:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    150a:	429a      	cmp	r2, r3
    150c:	d005      	beq.n	151a <chThdSetPriority+0x3a>
    150e:	4b0c      	ldr	r3, [pc, #48]	; (1540 <chThdSetPriority+0x60>)
    1510:	699b      	ldr	r3, [r3, #24]
    1512:	689a      	ldr	r2, [r3, #8]
    1514:	9b01      	ldr	r3, [sp, #4]
    1516:	429a      	cmp	r2, r3
    1518:	d203      	bcs.n	1522 <chThdSetPriority+0x42>
    currp->p_prio = newprio;
    151a:	4b09      	ldr	r3, [pc, #36]	; (1540 <chThdSetPriority+0x60>)
    151c:	699b      	ldr	r3, [r3, #24]
    151e:	9a01      	ldr	r2, [sp, #4]
    1520:	609a      	str	r2, [r3, #8]
  }
  currp->p_realprio = newprio;
    1522:	4b07      	ldr	r3, [pc, #28]	; (1540 <chThdSetPriority+0x60>)
    1524:	699b      	ldr	r3, [r3, #24]
    1526:	9a01      	ldr	r2, [sp, #4]
    1528:	641a      	str	r2, [r3, #64]	; 0x40
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
    152a:	f7ff fd91 	bl	1050 <chSchRescheduleS>
  chSysUnlock();
    152e:	f7ff fea7 	bl	1280 <chSysUnlock>

  return oldprio;
    1532:	9b03      	ldr	r3, [sp, #12]
}
    1534:	4618      	mov	r0, r3
    1536:	b005      	add	sp, #20
    1538:	f85d fb04 	ldr.w	pc, [sp], #4
    153c:	00004580 	.word	0x00004580
    1540:	20000800 	.word	0x20000800
    1544:	f3af 8000 	nop.w
    1548:	f3af 8000 	nop.w
    154c:	f3af 8000 	nop.w

00001550 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
    1550:	b500      	push	{lr}
    1552:	b083      	sub	sp, #12
    1554:	9001      	str	r0, [sp, #4]

  chSysLock();
    1556:	f7ff fe8b 	bl	1270 <chSysLock>
  chThdSleepS(time);
    155a:	9801      	ldr	r0, [sp, #4]
    155c:	f7ff feb0 	bl	12c0 <chThdSleepS>
  chSysUnlock();
    1560:	f7ff fe8e 	bl	1280 <chSysUnlock>
}
    1564:	b003      	add	sp, #12
    1566:	f85d fb04 	ldr.w	pc, [sp], #4
    156a:	bf00      	nop
    156c:	f3af 8000 	nop.w

00001570 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
    1570:	b500      	push	{lr}
    1572:	b083      	sub	sp, #12
    1574:	9001      	str	r0, [sp, #4]

  chSysLock();
    1576:	f7ff fe7b 	bl	1270 <chSysLock>
  chThdExitS(msg);
    157a:	9801      	ldr	r0, [sp, #4]
    157c:	f000 f808 	bl	1590 <chThdExitS>
  /* The thread never returns here.*/
}
    1580:	b003      	add	sp, #12
    1582:	f85d fb04 	ldr.w	pc, [sp], #4
    1586:	bf00      	nop
    1588:	f3af 8000 	nop.w
    158c:	f3af 8000 	nop.w

00001590 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
    1590:	b500      	push	{lr}
    1592:	b085      	sub	sp, #20
    1594:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
    1596:	4b19      	ldr	r3, [pc, #100]	; (15fc <chThdExitS+0x6c>)
    1598:	699b      	ldr	r3, [r3, #24]
    159a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
    159c:	9b03      	ldr	r3, [sp, #12]
    159e:	9a01      	ldr	r2, [sp, #4]
    15a0:	625a      	str	r2, [r3, #36]	; 0x24
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    15a2:	e008      	b.n	15b6 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->p_waiting));
    15a4:	9b03      	ldr	r3, [sp, #12]
    15a6:	3328      	adds	r3, #40	; 0x28
    15a8:	4618      	mov	r0, r3
    15aa:	f7ff fe21 	bl	11f0 <list_remove>
    15ae:	4603      	mov	r3, r0
    15b0:	4618      	mov	r0, r3
    15b2:	f7ff fc0d 	bl	dd0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    15b6:	9b03      	ldr	r3, [sp, #12]
    15b8:	3328      	adds	r3, #40	; 0x28
    15ba:	4618      	mov	r0, r3
    15bc:	f7ff fde8 	bl	1190 <list_notempty>
    15c0:	4603      	mov	r3, r0
    15c2:	2b00      	cmp	r3, #0
    15c4:	d1ee      	bne.n	15a4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    15c6:	9b03      	ldr	r3, [sp, #12]
    15c8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    15cc:	f003 0303 	and.w	r3, r3, #3
    15d0:	2b00      	cmp	r3, #0
    15d2:	d109      	bne.n	15e8 <chThdExitS+0x58>
    REG_REMOVE(tp);
    15d4:	9b03      	ldr	r3, [sp, #12]
    15d6:	695b      	ldr	r3, [r3, #20]
    15d8:	9a03      	ldr	r2, [sp, #12]
    15da:	6912      	ldr	r2, [r2, #16]
    15dc:	611a      	str	r2, [r3, #16]
    15de:	9b03      	ldr	r3, [sp, #12]
    15e0:	691b      	ldr	r3, [r3, #16]
    15e2:	9a03      	ldr	r2, [sp, #12]
    15e4:	6952      	ldr	r2, [r2, #20]
    15e6:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
    15e8:	200f      	movs	r0, #15
    15ea:	f7ff fc31 	bl	e50 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
    15ee:	4804      	ldr	r0, [pc, #16]	; (1600 <chThdExitS+0x70>)
    15f0:	f7ff f85e 	bl	6b0 <chSysHalt>
}
    15f4:	b005      	add	sp, #20
    15f6:	f85d fb04 	ldr.w	pc, [sp], #4
    15fa:	bf00      	nop
    15fc:	20000800 	.word	0x20000800
    1600:	000045b0 	.word	0x000045b0
    1604:	f3af 8000 	nop.w
    1608:	f3af 8000 	nop.w
    160c:	f3af 8000 	nop.w

00001610 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    1610:	b500      	push	{lr}
    1612:	b085      	sub	sp, #20
    1614:	9001      	str	r0, [sp, #4]
    1616:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
    1618:	9b01      	ldr	r3, [sp, #4]
    161a:	681b      	ldr	r3, [r3, #0]
    161c:	2b00      	cmp	r3, #0
    161e:	d013      	beq.n	1648 <chThdResumeI+0x38>
    thread_t *tp = *trp;
    1620:	9b01      	ldr	r3, [sp, #4]
    1622:	681b      	ldr	r3, [r3, #0]
    1624:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
    1626:	9b03      	ldr	r3, [sp, #12]
    1628:	f893 3020 	ldrb.w	r3, [r3, #32]
    162c:	2b03      	cmp	r3, #3
    162e:	d002      	beq.n	1636 <chThdResumeI+0x26>
    1630:	4807      	ldr	r0, [pc, #28]	; (1650 <chThdResumeI+0x40>)
    1632:	f7ff f83d 	bl	6b0 <chSysHalt>
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    1636:	9b01      	ldr	r3, [sp, #4]
    1638:	2200      	movs	r2, #0
    163a:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
    163c:	9b03      	ldr	r3, [sp, #12]
    163e:	9a00      	ldr	r2, [sp, #0]
    1640:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    1642:	9803      	ldr	r0, [sp, #12]
    1644:	f7ff fbc4 	bl	dd0 <chSchReadyI>
  }
}
    1648:	b005      	add	sp, #20
    164a:	f85d fb04 	ldr.w	pc, [sp], #4
    164e:	bf00      	nop
    1650:	000045c0 	.word	0x000045c0
    1654:	f3af 8000 	nop.w
    1658:	f3af 8000 	nop.w
    165c:	f3af 8000 	nop.w

00001660 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
    1660:	b500      	push	{lr}
    1662:	b083      	sub	sp, #12
    1664:	9001      	str	r0, [sp, #4]
    1666:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
    1668:	9b00      	ldr	r3, [sp, #0]
    166a:	2b00      	cmp	r3, #0
    166c:	d102      	bne.n	1674 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
    166e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1672:	e00a      	b.n	168a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
    1674:	4b07      	ldr	r3, [pc, #28]	; (1694 <chThdEnqueueTimeoutS+0x34>)
    1676:	699b      	ldr	r3, [r3, #24]
    1678:	4618      	mov	r0, r3
    167a:	9901      	ldr	r1, [sp, #4]
    167c:	f7ff fdc8 	bl	1210 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1680:	2004      	movs	r0, #4
    1682:	9900      	ldr	r1, [sp, #0]
    1684:	f7ff fc64 	bl	f50 <chSchGoSleepTimeoutS>
    1688:	4603      	mov	r3, r0
}
    168a:	4618      	mov	r0, r3
    168c:	b003      	add	sp, #12
    168e:	f85d fb04 	ldr.w	pc, [sp], #4
    1692:	bf00      	nop
    1694:	20000800 	.word	0x20000800
    1698:	f3af 8000 	nop.w
    169c:	f3af 8000 	nop.w

000016a0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    16a0:	b500      	push	{lr}
    16a2:	b083      	sub	sp, #12
    16a4:	9001      	str	r0, [sp, #4]
    16a6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
    16a8:	9801      	ldr	r0, [sp, #4]
    16aa:	f7ff fd91 	bl	11d0 <queue_notempty>
    16ae:	4603      	mov	r3, r0
    16b0:	2b00      	cmp	r3, #0
    16b2:	d003      	beq.n	16bc <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
    16b4:	9801      	ldr	r0, [sp, #4]
    16b6:	9900      	ldr	r1, [sp, #0]
    16b8:	f7ff fe1a 	bl	12f0 <chThdDoDequeueNextI>
  }
}
    16bc:	b003      	add	sp, #12
    16be:	f85d fb04 	ldr.w	pc, [sp], #4
    16c2:	bf00      	nop
    16c4:	f3af 8000 	nop.w
    16c8:	f3af 8000 	nop.w
    16cc:	f3af 8000 	nop.w

000016d0 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
    16d0:	4b01      	ldr	r3, [pc, #4]	; (16d8 <port_rt_get_counter_value+0x8>)
    16d2:	685b      	ldr	r3, [r3, #4]
}
    16d4:	4618      	mov	r0, r3
    16d6:	4770      	bx	lr
    16d8:	e0001000 	.word	0xe0001000
    16dc:	f3af 8000 	nop.w

000016e0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
    16e0:	b084      	sub	sp, #16
    16e2:	9003      	str	r0, [sp, #12]
    16e4:	9102      	str	r1, [sp, #8]
    16e6:	9201      	str	r2, [sp, #4]

  tmp->n++;
    16e8:	9b03      	ldr	r3, [sp, #12]
    16ea:	68db      	ldr	r3, [r3, #12]
    16ec:	1c5a      	adds	r2, r3, #1
    16ee:	9b03      	ldr	r3, [sp, #12]
    16f0:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
    16f2:	9b03      	ldr	r3, [sp, #12]
    16f4:	689b      	ldr	r3, [r3, #8]
    16f6:	9a02      	ldr	r2, [sp, #8]
    16f8:	1ad2      	subs	r2, r2, r3
    16fa:	9b01      	ldr	r3, [sp, #4]
    16fc:	1ad2      	subs	r2, r2, r3
    16fe:	9b03      	ldr	r3, [sp, #12]
    1700:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
    1702:	9b03      	ldr	r3, [sp, #12]
    1704:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
    1708:	9b03      	ldr	r3, [sp, #12]
    170a:	689b      	ldr	r3, [r3, #8]
    170c:	461a      	mov	r2, r3
    170e:	f04f 0300 	mov.w	r3, #0
    1712:	1812      	adds	r2, r2, r0
    1714:	eb43 0301 	adc.w	r3, r3, r1
    1718:	9903      	ldr	r1, [sp, #12]
    171a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
    171e:	9b03      	ldr	r3, [sp, #12]
    1720:	689a      	ldr	r2, [r3, #8]
    1722:	9b03      	ldr	r3, [sp, #12]
    1724:	685b      	ldr	r3, [r3, #4]
    1726:	429a      	cmp	r2, r3
    1728:	d904      	bls.n	1734 <tm_stop+0x54>
    tmp->worst = tmp->last;
    172a:	9b03      	ldr	r3, [sp, #12]
    172c:	689a      	ldr	r2, [r3, #8]
    172e:	9b03      	ldr	r3, [sp, #12]
    1730:	605a      	str	r2, [r3, #4]
    1732:	e009      	b.n	1748 <tm_stop+0x68>
  }
  else if (tmp->last < tmp->best) {
    1734:	9b03      	ldr	r3, [sp, #12]
    1736:	689a      	ldr	r2, [r3, #8]
    1738:	9b03      	ldr	r3, [sp, #12]
    173a:	681b      	ldr	r3, [r3, #0]
    173c:	429a      	cmp	r2, r3
    173e:	d203      	bcs.n	1748 <tm_stop+0x68>
    tmp->best = tmp->last;
    1740:	9b03      	ldr	r3, [sp, #12]
    1742:	689a      	ldr	r2, [r3, #8]
    1744:	9b03      	ldr	r3, [sp, #12]
    1746:	601a      	str	r2, [r3, #0]
  }
  /*lint -restore*/
}
    1748:	b004      	add	sp, #16
    174a:	4770      	bx	lr
    174c:	f3af 8000 	nop.w

00001750 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
    1750:	b500      	push	{lr}
    1752:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
    1754:	4b0b      	ldr	r3, [pc, #44]	; (1784 <_tm_init+0x34>)
    1756:	2200      	movs	r2, #0
    1758:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
  chTMObjectInit(&tm);
    175c:	466b      	mov	r3, sp
    175e:	4618      	mov	r0, r3
    1760:	f000 f816 	bl	1790 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
    1764:	466b      	mov	r3, sp
    1766:	4618      	mov	r0, r3
    1768:	f000 f82a 	bl	17c0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
    176c:	466b      	mov	r3, sp
    176e:	4618      	mov	r0, r3
    1770:	f000 f836 	bl	17e0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
    1774:	9a02      	ldr	r2, [sp, #8]
    1776:	4b03      	ldr	r3, [pc, #12]	; (1784 <_tm_init+0x34>)
    1778:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
}
    177c:	b007      	add	sp, #28
    177e:	f85d fb04 	ldr.w	pc, [sp], #4
    1782:	bf00      	nop
    1784:	20000800 	.word	0x20000800
    1788:	f3af 8000 	nop.w
    178c:	f3af 8000 	nop.w

00001790 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
    1790:	b082      	sub	sp, #8
    1792:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
    1794:	9b01      	ldr	r3, [sp, #4]
    1796:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    179a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
    179c:	9b01      	ldr	r3, [sp, #4]
    179e:	2200      	movs	r2, #0
    17a0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
    17a2:	9b01      	ldr	r3, [sp, #4]
    17a4:	2200      	movs	r2, #0
    17a6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
    17a8:	9b01      	ldr	r3, [sp, #4]
    17aa:	2200      	movs	r2, #0
    17ac:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
    17ae:	9901      	ldr	r1, [sp, #4]
    17b0:	f04f 0200 	mov.w	r2, #0
    17b4:	f04f 0300 	mov.w	r3, #0
    17b8:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
    17bc:	b002      	add	sp, #8
    17be:	4770      	bx	lr

000017c0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
    17c0:	b500      	push	{lr}
    17c2:	b083      	sub	sp, #12
    17c4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
    17c6:	f7ff ff83 	bl	16d0 <port_rt_get_counter_value>
    17ca:	4602      	mov	r2, r0
    17cc:	9b01      	ldr	r3, [sp, #4]
    17ce:	609a      	str	r2, [r3, #8]
}
    17d0:	b003      	add	sp, #12
    17d2:	f85d fb04 	ldr.w	pc, [sp], #4
    17d6:	bf00      	nop
    17d8:	f3af 8000 	nop.w
    17dc:	f3af 8000 	nop.w

000017e0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
    17e0:	b500      	push	{lr}
    17e2:	b083      	sub	sp, #12
    17e4:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
    17e6:	f7ff ff73 	bl	16d0 <port_rt_get_counter_value>
    17ea:	4602      	mov	r2, r0
    17ec:	4b05      	ldr	r3, [pc, #20]	; (1804 <chTMStopMeasurementX+0x24>)
    17ee:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
    17f2:	9801      	ldr	r0, [sp, #4]
    17f4:	4611      	mov	r1, r2
    17f6:	461a      	mov	r2, r3
    17f8:	f7ff ff72 	bl	16e0 <tm_stop>
}
    17fc:	b003      	add	sp, #12
    17fe:	f85d fb04 	ldr.w	pc, [sp], #4
    1802:	bf00      	nop
    1804:	20000800 	.word	0x20000800
    1808:	f3af 8000 	nop.w
    180c:	f3af 8000 	nop.w

00001810 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
    1810:	b500      	push	{lr}
    1812:	b083      	sub	sp, #12
    1814:	9001      	str	r0, [sp, #4]
    1816:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
    1818:	f7ff ff5a 	bl	16d0 <port_rt_get_counter_value>
    181c:	4602      	mov	r2, r0
    181e:	9b00      	ldr	r3, [sp, #0]
    1820:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
    1822:	9b00      	ldr	r3, [sp, #0]
    1824:	689b      	ldr	r3, [r3, #8]
    1826:	9801      	ldr	r0, [sp, #4]
    1828:	4619      	mov	r1, r3
    182a:	2200      	movs	r2, #0
    182c:	f7ff ff58 	bl	16e0 <tm_stop>
}
    1830:	b003      	add	sp, #12
    1832:	f85d fb04 	ldr.w	pc, [sp], #4
    1836:	bf00      	nop
    1838:	f3af 8000 	nop.w
    183c:	f3af 8000 	nop.w

00001840 <_stats_init>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
    1840:	b508      	push	{r3, lr}

  ch.kernel_stats.n_irq = (ucnt_t)0;
    1842:	4b07      	ldr	r3, [pc, #28]	; (1860 <_stats_init+0x20>)
    1844:	2200      	movs	r2, #0
    1846:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
    184a:	4b05      	ldr	r3, [pc, #20]	; (1860 <_stats_init+0x20>)
    184c:	2200      	movs	r2, #0
    184e:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
    1852:	4804      	ldr	r0, [pc, #16]	; (1864 <_stats_init+0x24>)
    1854:	f7ff ff9c 	bl	1790 <chTMObjectInit>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
    1858:	4803      	ldr	r0, [pc, #12]	; (1868 <_stats_init+0x28>)
    185a:	f7ff ff99 	bl	1790 <chTMObjectInit>
}
    185e:	bd08      	pop	{r3, pc}
    1860:	20000800 	.word	0x20000800
    1864:	20000cb0 	.word	0x20000cb0
    1868:	20000cc8 	.word	0x20000cc8
    186c:	f3af 8000 	nop.w

00001870 <_stats_increase_irq>:
/**
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {

  ch.kernel_stats.n_irq++;
    1870:	4b03      	ldr	r3, [pc, #12]	; (1880 <_stats_increase_irq+0x10>)
    1872:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
    1876:	1c5a      	adds	r2, r3, #1
    1878:	4b01      	ldr	r3, [pc, #4]	; (1880 <_stats_increase_irq+0x10>)
    187a:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
}
    187e:	4770      	bx	lr
    1880:	20000800 	.word	0x20000800
    1884:	f3af 8000 	nop.w
    1888:	f3af 8000 	nop.w
    188c:	f3af 8000 	nop.w

00001890 <_stats_ctxswc>:
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
    1890:	b500      	push	{lr}
    1892:	b083      	sub	sp, #12
    1894:	9001      	str	r0, [sp, #4]
    1896:	9100      	str	r1, [sp, #0]

  ch.kernel_stats.n_ctxswc++;
    1898:	4b09      	ldr	r3, [pc, #36]	; (18c0 <_stats_ctxswc+0x30>)
    189a:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
    189e:	1c5a      	adds	r2, r3, #1
    18a0:	4b07      	ldr	r3, [pc, #28]	; (18c0 <_stats_ctxswc+0x30>)
    18a2:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
    18a6:	9b00      	ldr	r3, [sp, #0]
    18a8:	f103 0248 	add.w	r2, r3, #72	; 0x48
    18ac:	9b01      	ldr	r3, [sp, #4]
    18ae:	3348      	adds	r3, #72	; 0x48
    18b0:	4610      	mov	r0, r2
    18b2:	4619      	mov	r1, r3
    18b4:	f7ff ffac 	bl	1810 <chTMChainMeasurementToX>
}
    18b8:	b003      	add	sp, #12
    18ba:	f85d fb04 	ldr.w	pc, [sp], #4
    18be:	bf00      	nop
    18c0:	20000800 	.word	0x20000800
    18c4:	f3af 8000 	nop.w
    18c8:	f3af 8000 	nop.w
    18cc:	f3af 8000 	nop.w

000018d0 <_stats_start_measure_crit_thd>:

/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {
    18d0:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
    18d2:	4802      	ldr	r0, [pc, #8]	; (18dc <_stats_start_measure_crit_thd+0xc>)
    18d4:	f7ff ff74 	bl	17c0 <chTMStartMeasurementX>
}
    18d8:	bd08      	pop	{r3, pc}
    18da:	bf00      	nop
    18dc:	20000cb0 	.word	0x20000cb0

000018e0 <_stats_stop_measure_crit_thd>:

/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {
    18e0:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
    18e2:	4802      	ldr	r0, [pc, #8]	; (18ec <_stats_stop_measure_crit_thd+0xc>)
    18e4:	f7ff ff7c 	bl	17e0 <chTMStopMeasurementX>
}
    18e8:	bd08      	pop	{r3, pc}
    18ea:	bf00      	nop
    18ec:	20000cb0 	.word	0x20000cb0

000018f0 <_stats_start_measure_crit_isr>:

/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {
    18f0:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
    18f2:	4802      	ldr	r0, [pc, #8]	; (18fc <_stats_start_measure_crit_isr+0xc>)
    18f4:	f7ff ff64 	bl	17c0 <chTMStartMeasurementX>
}
    18f8:	bd08      	pop	{r3, pc}
    18fa:	bf00      	nop
    18fc:	20000cc8 	.word	0x20000cc8

00001900 <_stats_stop_measure_crit_isr>:

/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {
    1900:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
    1902:	4802      	ldr	r0, [pc, #8]	; (190c <_stats_stop_measure_crit_isr+0xc>)
    1904:	f7ff ff6c 	bl	17e0 <chTMStopMeasurementX>
}
    1908:	bd08      	pop	{r3, pc}
    190a:	bf00      	nop
    190c:	20000cc8 	.word	0x20000cc8

00001910 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1910:	b082      	sub	sp, #8
    1912:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1914:	9b01      	ldr	r3, [sp, #4]
    1916:	9a01      	ldr	r2, [sp, #4]
    1918:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    191a:	9b01      	ldr	r3, [sp, #4]
    191c:	9a01      	ldr	r2, [sp, #4]
    191e:	605a      	str	r2, [r3, #4]
}
    1920:	b002      	add	sp, #8
    1922:	4770      	bx	lr
    1924:	f3af 8000 	nop.w
    1928:	f3af 8000 	nop.w
    192c:	f3af 8000 	nop.w

00001930 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
    1930:	b082      	sub	sp, #8
    1932:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
    1934:	9b01      	ldr	r3, [sp, #4]
    1936:	681a      	ldr	r2, [r3, #0]
    1938:	9b01      	ldr	r3, [sp, #4]
    193a:	429a      	cmp	r2, r3
    193c:	bf14      	ite	ne
    193e:	2300      	movne	r3, #0
    1940:	2301      	moveq	r3, #1
    1942:	b2db      	uxtb	r3, r3
}
    1944:	4618      	mov	r0, r3
    1946:	b002      	add	sp, #8
    1948:	4770      	bx	lr
    194a:	bf00      	nop
    194c:	f3af 8000 	nop.w

00001950 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
    1950:	b082      	sub	sp, #8
    1952:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
    1954:	9b01      	ldr	r3, [sp, #4]
    1956:	681a      	ldr	r2, [r3, #0]
    1958:	9b01      	ldr	r3, [sp, #4]
    195a:	429a      	cmp	r2, r3
    195c:	bf0c      	ite	eq
    195e:	2300      	moveq	r3, #0
    1960:	2301      	movne	r3, #1
    1962:	b2db      	uxtb	r3, r3
}
    1964:	4618      	mov	r0, r3
    1966:	b002      	add	sp, #8
    1968:	4770      	bx	lr
    196a:	bf00      	nop
    196c:	f3af 8000 	nop.w

00001970 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
    1970:	b082      	sub	sp, #8
    1972:	9001      	str	r0, [sp, #4]
    1974:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
    1976:	9b01      	ldr	r3, [sp, #4]
    1978:	9a00      	ldr	r2, [sp, #0]
    197a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
    197c:	9b00      	ldr	r3, [sp, #0]
    197e:	685a      	ldr	r2, [r3, #4]
    1980:	9b01      	ldr	r3, [sp, #4]
    1982:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    1984:	9b01      	ldr	r3, [sp, #4]
    1986:	685b      	ldr	r3, [r3, #4]
    1988:	9a01      	ldr	r2, [sp, #4]
    198a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
    198c:	9b00      	ldr	r3, [sp, #0]
    198e:	9a01      	ldr	r2, [sp, #4]
    1990:	605a      	str	r2, [r3, #4]
}
    1992:	b002      	add	sp, #8
    1994:	4770      	bx	lr
    1996:	bf00      	nop
    1998:	f3af 8000 	nop.w
    199c:	f3af 8000 	nop.w

000019a0 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
    19a0:	b084      	sub	sp, #16
    19a2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
    19a4:	9b01      	ldr	r3, [sp, #4]
    19a6:	681b      	ldr	r3, [r3, #0]
    19a8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
    19aa:	9b03      	ldr	r3, [sp, #12]
    19ac:	681a      	ldr	r2, [r3, #0]
    19ae:	9b01      	ldr	r3, [sp, #4]
    19b0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    19b2:	9b01      	ldr	r3, [sp, #4]
    19b4:	681b      	ldr	r3, [r3, #0]
    19b6:	9a01      	ldr	r2, [sp, #4]
    19b8:	605a      	str	r2, [r3, #4]

  return tp;
    19ba:	9b03      	ldr	r3, [sp, #12]
}
    19bc:	4618      	mov	r0, r3
    19be:	b004      	add	sp, #16
    19c0:	4770      	bx	lr
    19c2:	bf00      	nop
    19c4:	f3af 8000 	nop.w
    19c8:	f3af 8000 	nop.w
    19cc:	f3af 8000 	nop.w

000019d0 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
    19d0:	b500      	push	{lr}
    19d2:	b083      	sub	sp, #12
    19d4:	9001      	str	r0, [sp, #4]
    19d6:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
    19d8:	9b01      	ldr	r3, [sp, #4]
    19da:	2b00      	cmp	r3, #0
    19dc:	d002      	beq.n	19e4 <chSemObjectInit+0x14>
    19de:	9b00      	ldr	r3, [sp, #0]
    19e0:	2b00      	cmp	r3, #0
    19e2:	da02      	bge.n	19ea <chSemObjectInit+0x1a>
    19e4:	4806      	ldr	r0, [pc, #24]	; (1a00 <chSemObjectInit+0x30>)
    19e6:	f7fe fe63 	bl	6b0 <chSysHalt>

  queue_init(&sp->s_queue);
    19ea:	9b01      	ldr	r3, [sp, #4]
    19ec:	4618      	mov	r0, r3
    19ee:	f7ff ff8f 	bl	1910 <queue_init>
  sp->s_cnt = n;
    19f2:	9b01      	ldr	r3, [sp, #4]
    19f4:	9a00      	ldr	r2, [sp, #0]
    19f6:	609a      	str	r2, [r3, #8]
}
    19f8:	b003      	add	sp, #12
    19fa:	f85d fb04 	ldr.w	pc, [sp], #4
    19fe:	bf00      	nop
    1a00:	00004610 	.word	0x00004610
    1a04:	f3af 8000 	nop.w
    1a08:	f3af 8000 	nop.w
    1a0c:	f3af 8000 	nop.w

00001a10 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
    1a10:	b500      	push	{lr}
    1a12:	b083      	sub	sp, #12
    1a14:	9001      	str	r0, [sp, #4]
    1a16:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
    1a18:	f7fe ff6a 	bl	8f0 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
    1a1c:	9b01      	ldr	r3, [sp, #4]
    1a1e:	2b00      	cmp	r3, #0
    1a20:	d102      	bne.n	1a28 <chSemWaitTimeoutS+0x18>
    1a22:	4826      	ldr	r0, [pc, #152]	; (1abc <chSemWaitTimeoutS+0xac>)
    1a24:	f7fe fe44 	bl	6b0 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
    1a28:	9b01      	ldr	r3, [sp, #4]
    1a2a:	689b      	ldr	r3, [r3, #8]
    1a2c:	2b00      	cmp	r3, #0
    1a2e:	db09      	blt.n	1a44 <chSemWaitTimeoutS+0x34>
    1a30:	9b01      	ldr	r3, [sp, #4]
    1a32:	4618      	mov	r0, r3
    1a34:	f7ff ff7c 	bl	1930 <queue_isempty>
    1a38:	4603      	mov	r3, r0
    1a3a:	f083 0301 	eor.w	r3, r3, #1
    1a3e:	b2db      	uxtb	r3, r3
    1a40:	2b00      	cmp	r3, #0
    1a42:	d010      	beq.n	1a66 <chSemWaitTimeoutS+0x56>
    1a44:	9b01      	ldr	r3, [sp, #4]
    1a46:	689b      	ldr	r3, [r3, #8]
    1a48:	2b00      	cmp	r3, #0
    1a4a:	da09      	bge.n	1a60 <chSemWaitTimeoutS+0x50>
    1a4c:	9b01      	ldr	r3, [sp, #4]
    1a4e:	4618      	mov	r0, r3
    1a50:	f7ff ff7e 	bl	1950 <queue_notempty>
    1a54:	4603      	mov	r3, r0
    1a56:	f083 0301 	eor.w	r3, r3, #1
    1a5a:	b2db      	uxtb	r3, r3
    1a5c:	2b00      	cmp	r3, #0
    1a5e:	d002      	beq.n	1a66 <chSemWaitTimeoutS+0x56>
    1a60:	4816      	ldr	r0, [pc, #88]	; (1abc <chSemWaitTimeoutS+0xac>)
    1a62:	f7fe fe25 	bl	6b0 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    1a66:	9b01      	ldr	r3, [sp, #4]
    1a68:	689b      	ldr	r3, [r3, #8]
    1a6a:	1e5a      	subs	r2, r3, #1
    1a6c:	9b01      	ldr	r3, [sp, #4]
    1a6e:	609a      	str	r2, [r3, #8]
    1a70:	9b01      	ldr	r3, [sp, #4]
    1a72:	689b      	ldr	r3, [r3, #8]
    1a74:	2b00      	cmp	r3, #0
    1a76:	da1b      	bge.n	1ab0 <chSemWaitTimeoutS+0xa0>
    if (TIME_IMMEDIATE == time) {
    1a78:	9b00      	ldr	r3, [sp, #0]
    1a7a:	2b00      	cmp	r3, #0
    1a7c:	d107      	bne.n	1a8e <chSemWaitTimeoutS+0x7e>
      sp->s_cnt++;
    1a7e:	9b01      	ldr	r3, [sp, #4]
    1a80:	689b      	ldr	r3, [r3, #8]
    1a82:	1c5a      	adds	r2, r3, #1
    1a84:	9b01      	ldr	r3, [sp, #4]
    1a86:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
    1a88:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1a8c:	e011      	b.n	1ab2 <chSemWaitTimeoutS+0xa2>
    }
    currp->p_u.wtsemp = sp;
    1a8e:	4b0c      	ldr	r3, [pc, #48]	; (1ac0 <chSemWaitTimeoutS+0xb0>)
    1a90:	699b      	ldr	r3, [r3, #24]
    1a92:	9a01      	ldr	r2, [sp, #4]
    1a94:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->s_queue);
    1a96:	4b0a      	ldr	r3, [pc, #40]	; (1ac0 <chSemWaitTimeoutS+0xb0>)
    1a98:	699a      	ldr	r2, [r3, #24]
    1a9a:	9b01      	ldr	r3, [sp, #4]
    1a9c:	4610      	mov	r0, r2
    1a9e:	4619      	mov	r1, r3
    1aa0:	f7ff ff66 	bl	1970 <queue_insert>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
    1aa4:	2005      	movs	r0, #5
    1aa6:	9900      	ldr	r1, [sp, #0]
    1aa8:	f7ff fa52 	bl	f50 <chSchGoSleepTimeoutS>
    1aac:	4603      	mov	r3, r0
    1aae:	e000      	b.n	1ab2 <chSemWaitTimeoutS+0xa2>
  }

  return MSG_OK;
    1ab0:	2300      	movs	r3, #0
}
    1ab2:	4618      	mov	r0, r3
    1ab4:	b003      	add	sp, #12
    1ab6:	f85d fb04 	ldr.w	pc, [sp], #4
    1aba:	bf00      	nop
    1abc:	00004620 	.word	0x00004620
    1ac0:	20000800 	.word	0x20000800
    1ac4:	f3af 8000 	nop.w
    1ac8:	f3af 8000 	nop.w
    1acc:	f3af 8000 	nop.w

00001ad0 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    1ad0:	b500      	push	{lr}
    1ad2:	b085      	sub	sp, #20
    1ad4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1ad6:	f7fe fef3 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(sp != NULL);
    1ada:	9b01      	ldr	r3, [sp, #4]
    1adc:	2b00      	cmp	r3, #0
    1ade:	d102      	bne.n	1ae6 <chSemSignalI+0x16>
    1ae0:	481c      	ldr	r0, [pc, #112]	; (1b54 <chSemSignalI+0x84>)
    1ae2:	f7fe fde5 	bl	6b0 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
    1ae6:	9b01      	ldr	r3, [sp, #4]
    1ae8:	689b      	ldr	r3, [r3, #8]
    1aea:	2b00      	cmp	r3, #0
    1aec:	db09      	blt.n	1b02 <chSemSignalI+0x32>
    1aee:	9b01      	ldr	r3, [sp, #4]
    1af0:	4618      	mov	r0, r3
    1af2:	f7ff ff1d 	bl	1930 <queue_isempty>
    1af6:	4603      	mov	r3, r0
    1af8:	f083 0301 	eor.w	r3, r3, #1
    1afc:	b2db      	uxtb	r3, r3
    1afe:	2b00      	cmp	r3, #0
    1b00:	d010      	beq.n	1b24 <chSemSignalI+0x54>
    1b02:	9b01      	ldr	r3, [sp, #4]
    1b04:	689b      	ldr	r3, [r3, #8]
    1b06:	2b00      	cmp	r3, #0
    1b08:	da09      	bge.n	1b1e <chSemSignalI+0x4e>
    1b0a:	9b01      	ldr	r3, [sp, #4]
    1b0c:	4618      	mov	r0, r3
    1b0e:	f7ff ff1f 	bl	1950 <queue_notempty>
    1b12:	4603      	mov	r3, r0
    1b14:	f083 0301 	eor.w	r3, r3, #1
    1b18:	b2db      	uxtb	r3, r3
    1b1a:	2b00      	cmp	r3, #0
    1b1c:	d002      	beq.n	1b24 <chSemSignalI+0x54>
    1b1e:	480d      	ldr	r0, [pc, #52]	; (1b54 <chSemSignalI+0x84>)
    1b20:	f7fe fdc6 	bl	6b0 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
    1b24:	9b01      	ldr	r3, [sp, #4]
    1b26:	689b      	ldr	r3, [r3, #8]
    1b28:	1c5a      	adds	r2, r3, #1
    1b2a:	9b01      	ldr	r3, [sp, #4]
    1b2c:	609a      	str	r2, [r3, #8]
    1b2e:	9b01      	ldr	r3, [sp, #4]
    1b30:	689b      	ldr	r3, [r3, #8]
    1b32:	2b00      	cmp	r3, #0
    1b34:	dc0a      	bgt.n	1b4c <chSemSignalI+0x7c>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    1b36:	9b01      	ldr	r3, [sp, #4]
    1b38:	4618      	mov	r0, r3
    1b3a:	f7ff ff31 	bl	19a0 <queue_fifo_remove>
    1b3e:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
    1b40:	9b03      	ldr	r3, [sp, #12]
    1b42:	2200      	movs	r2, #0
    1b44:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    1b46:	9803      	ldr	r0, [sp, #12]
    1b48:	f7ff f942 	bl	dd0 <chSchReadyI>
  }
}
    1b4c:	b005      	add	sp, #20
    1b4e:	f85d fb04 	ldr.w	pc, [sp], #4
    1b52:	bf00      	nop
    1b54:	00004640 	.word	0x00004640
    1b58:	f3af 8000 	nop.w
    1b5c:	f3af 8000 	nop.w

00001b60 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1b60:	b082      	sub	sp, #8
    1b62:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1b64:	9b01      	ldr	r3, [sp, #4]
    1b66:	9a01      	ldr	r2, [sp, #4]
    1b68:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    1b6a:	9b01      	ldr	r3, [sp, #4]
    1b6c:	9a01      	ldr	r2, [sp, #4]
    1b6e:	605a      	str	r2, [r3, #4]
}
    1b70:	b002      	add	sp, #8
    1b72:	4770      	bx	lr
    1b74:	f3af 8000 	nop.w
    1b78:	f3af 8000 	nop.w
    1b7c:	f3af 8000 	nop.w

00001b80 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
    1b80:	b500      	push	{lr}
    1b82:	b083      	sub	sp, #12
    1b84:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
    1b86:	9b01      	ldr	r3, [sp, #4]
    1b88:	2b00      	cmp	r3, #0
    1b8a:	d102      	bne.n	1b92 <chMtxObjectInit+0x12>
    1b8c:	4806      	ldr	r0, [pc, #24]	; (1ba8 <chMtxObjectInit+0x28>)
    1b8e:	f7fe fd8f 	bl	6b0 <chSysHalt>

  queue_init(&mp->m_queue);
    1b92:	9b01      	ldr	r3, [sp, #4]
    1b94:	4618      	mov	r0, r3
    1b96:	f7ff ffe3 	bl	1b60 <queue_init>
  mp->m_owner = NULL;
    1b9a:	9b01      	ldr	r3, [sp, #4]
    1b9c:	2200      	movs	r2, #0
    1b9e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
    1ba0:	b003      	add	sp, #12
    1ba2:	f85d fb04 	ldr.w	pc, [sp], #4
    1ba6:	bf00      	nop
    1ba8:	00004650 	.word	0x00004650
    1bac:	f3af 8000 	nop.w

00001bb0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    1bb0:	b500      	push	{lr}
    1bb2:	b085      	sub	sp, #20
    1bb4:	9001      	str	r0, [sp, #4]
    1bb6:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
    1bb8:	f7fe fe82 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
    1bbc:	9b01      	ldr	r3, [sp, #4]
    1bbe:	2b00      	cmp	r3, #0
    1bc0:	d102      	bne.n	1bc8 <chEvtBroadcastFlagsI+0x18>
    1bc2:	4814      	ldr	r0, [pc, #80]	; (1c14 <chEvtBroadcastFlagsI+0x64>)
    1bc4:	f7fe fd74 	bl	6b0 <chSysHalt>

  elp = esp->es_next;
    1bc8:	9b01      	ldr	r3, [sp, #4]
    1bca:	681b      	ldr	r3, [r3, #0]
    1bcc:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    1bce:	e01a      	b.n	1c06 <chEvtBroadcastFlagsI+0x56>
  /*lint -restore*/
    elp->el_flags |= flags;
    1bd0:	9b03      	ldr	r3, [sp, #12]
    1bd2:	68da      	ldr	r2, [r3, #12]
    1bd4:	9b00      	ldr	r3, [sp, #0]
    1bd6:	431a      	orrs	r2, r3
    1bd8:	9b03      	ldr	r3, [sp, #12]
    1bda:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    1bdc:	9b00      	ldr	r3, [sp, #0]
    1bde:	2b00      	cmp	r3, #0
    1be0:	d006      	beq.n	1bf0 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
    1be2:	9b03      	ldr	r3, [sp, #12]
    1be4:	68da      	ldr	r2, [r3, #12]
    1be6:	9b03      	ldr	r3, [sp, #12]
    1be8:	691b      	ldr	r3, [r3, #16]
    1bea:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    1bec:	2b00      	cmp	r3, #0
    1bee:	d007      	beq.n	1c00 <chEvtBroadcastFlagsI+0x50>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    1bf0:	9b03      	ldr	r3, [sp, #12]
    1bf2:	685a      	ldr	r2, [r3, #4]
    1bf4:	9b03      	ldr	r3, [sp, #12]
    1bf6:	689b      	ldr	r3, [r3, #8]
    1bf8:	4610      	mov	r0, r2
    1bfa:	4619      	mov	r1, r3
    1bfc:	f000 f810 	bl	1c20 <chEvtSignalI>
    }
    elp = elp->el_next;
    1c00:	9b03      	ldr	r3, [sp, #12]
    1c02:	681b      	ldr	r3, [r3, #0]
    1c04:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    1c06:	9a03      	ldr	r2, [sp, #12]
    1c08:	9b01      	ldr	r3, [sp, #4]
    1c0a:	429a      	cmp	r2, r3
    1c0c:	d1e0      	bne.n	1bd0 <chEvtBroadcastFlagsI+0x20>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
    1c0e:	b005      	add	sp, #20
    1c10:	f85d fb04 	ldr.w	pc, [sp], #4
    1c14:	00004660 	.word	0x00004660
    1c18:	f3af 8000 	nop.w
    1c1c:	f3af 8000 	nop.w

00001c20 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
    1c20:	b500      	push	{lr}
    1c22:	b083      	sub	sp, #12
    1c24:	9001      	str	r0, [sp, #4]
    1c26:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
    1c28:	f7fe fe4a 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
    1c2c:	9b01      	ldr	r3, [sp, #4]
    1c2e:	2b00      	cmp	r3, #0
    1c30:	d102      	bne.n	1c38 <chEvtSignalI+0x18>
    1c32:	4816      	ldr	r0, [pc, #88]	; (1c8c <chEvtSignalI+0x6c>)
    1c34:	f7fe fd3c 	bl	6b0 <chSysHalt>

  tp->p_epending |= events;
    1c38:	9b01      	ldr	r3, [sp, #4]
    1c3a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1c3c:	9b00      	ldr	r3, [sp, #0]
    1c3e:	431a      	orrs	r2, r3
    1c40:	9b01      	ldr	r3, [sp, #4]
    1c42:	639a      	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    1c44:	9b01      	ldr	r3, [sp, #4]
    1c46:	f893 3020 	ldrb.w	r3, [r3, #32]
    1c4a:	2b0a      	cmp	r3, #10
    1c4c:	d106      	bne.n	1c5c <chEvtSignalI+0x3c>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    1c4e:	9b01      	ldr	r3, [sp, #4]
    1c50:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1c52:	9b01      	ldr	r3, [sp, #4]
    1c54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1c56:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    1c58:	2b00      	cmp	r3, #0
    1c5a:	d10d      	bne.n	1c78 <chEvtSignalI+0x58>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
    1c5c:	9b01      	ldr	r3, [sp, #4]
    1c5e:	f893 3020 	ldrb.w	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    1c62:	2b0b      	cmp	r3, #11
    1c64:	d10e      	bne.n	1c84 <chEvtSignalI+0x64>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    1c66:	9b01      	ldr	r3, [sp, #4]
    1c68:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1c6a:	9b01      	ldr	r3, [sp, #4]
    1c6c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1c6e:	401a      	ands	r2, r3
    1c70:	9b01      	ldr	r3, [sp, #4]
    1c72:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
    1c74:	429a      	cmp	r2, r3
    1c76:	d105      	bne.n	1c84 <chEvtSignalI+0x64>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
    1c78:	9b01      	ldr	r3, [sp, #4]
    1c7a:	2200      	movs	r2, #0
    1c7c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    1c7e:	9801      	ldr	r0, [sp, #4]
    1c80:	f7ff f8a6 	bl	dd0 <chSchReadyI>
  }
}
    1c84:	b003      	add	sp, #12
    1c86:	f85d fb04 	ldr.w	pc, [sp], #4
    1c8a:	bf00      	nop
    1c8c:	00004680 	.word	0x00004680

00001c90 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1c90:	b082      	sub	sp, #8
    1c92:	2320      	movs	r3, #32
    1c94:	9301      	str	r3, [sp, #4]
    1c96:	9b01      	ldr	r3, [sp, #4]
    1c98:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1c9c:	b002      	add	sp, #8
    1c9e:	4770      	bx	lr

00001ca0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1ca0:	b082      	sub	sp, #8
    1ca2:	2300      	movs	r3, #0
    1ca4:	9301      	str	r3, [sp, #4]
    1ca6:	9b01      	ldr	r3, [sp, #4]
    1ca8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1cac:	b002      	add	sp, #8
    1cae:	4770      	bx	lr

00001cb0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1cb0:	b508      	push	{r3, lr}

  port_lock();
    1cb2:	f7ff ffed 	bl	1c90 <port_lock>
  _stats_start_measure_crit_thd();
    1cb6:	f7ff fe0b 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1cba:	f7fe fd61 	bl	780 <_dbg_check_lock>
}
    1cbe:	bd08      	pop	{r3, pc}

00001cc0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1cc0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1cc2:	f7fe fd75 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1cc6:	f7ff fe0b 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    1cca:	4b09      	ldr	r3, [pc, #36]	; (1cf0 <chSysUnlock+0x30>)
    1ccc:	681a      	ldr	r2, [r3, #0]
    1cce:	4b08      	ldr	r3, [pc, #32]	; (1cf0 <chSysUnlock+0x30>)
    1cd0:	429a      	cmp	r2, r3
    1cd2:	d00a      	beq.n	1cea <chSysUnlock+0x2a>
    1cd4:	4b06      	ldr	r3, [pc, #24]	; (1cf0 <chSysUnlock+0x30>)
    1cd6:	699b      	ldr	r3, [r3, #24]
    1cd8:	689a      	ldr	r2, [r3, #8]
    1cda:	4b05      	ldr	r3, [pc, #20]	; (1cf0 <chSysUnlock+0x30>)
    1cdc:	681b      	ldr	r3, [r3, #0]
    1cde:	689b      	ldr	r3, [r3, #8]
    1ce0:	429a      	cmp	r2, r3
    1ce2:	d202      	bcs.n	1cea <chSysUnlock+0x2a>
    1ce4:	4803      	ldr	r0, [pc, #12]	; (1cf4 <chSysUnlock+0x34>)
    1ce6:	f7fe fce3 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    1cea:	f7ff ffd9 	bl	1ca0 <port_unlock>
}
    1cee:	bd08      	pop	{r3, pc}
    1cf0:	20000800 	.word	0x20000800
    1cf4:	000046a0 	.word	0x000046a0
    1cf8:	f3af 8000 	nop.w
    1cfc:	f3af 8000 	nop.w

00001d00 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
    1d00:	b500      	push	{lr}
    1d02:	b085      	sub	sp, #20
    1d04:	9003      	str	r0, [sp, #12]
    1d06:	9102      	str	r1, [sp, #8]
    1d08:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
    1d0a:	9b03      	ldr	r3, [sp, #12]
    1d0c:	2b00      	cmp	r3, #0
    1d0e:	d005      	beq.n	1d1c <chMBObjectInit+0x1c>
    1d10:	9b02      	ldr	r3, [sp, #8]
    1d12:	2b00      	cmp	r3, #0
    1d14:	d002      	beq.n	1d1c <chMBObjectInit+0x1c>
    1d16:	9b01      	ldr	r3, [sp, #4]
    1d18:	2b00      	cmp	r3, #0
    1d1a:	dc02      	bgt.n	1d22 <chMBObjectInit+0x22>
    1d1c:	4810      	ldr	r0, [pc, #64]	; (1d60 <chMBObjectInit+0x60>)
    1d1e:	f7fe fcc7 	bl	6b0 <chSysHalt>

  mbp->mb_buffer = buf;
    1d22:	9b03      	ldr	r3, [sp, #12]
    1d24:	9a02      	ldr	r2, [sp, #8]
    1d26:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
    1d28:	9b03      	ldr	r3, [sp, #12]
    1d2a:	9a02      	ldr	r2, [sp, #8]
    1d2c:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
    1d2e:	9b03      	ldr	r3, [sp, #12]
    1d30:	9a02      	ldr	r2, [sp, #8]
    1d32:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
    1d34:	9b01      	ldr	r3, [sp, #4]
    1d36:	009b      	lsls	r3, r3, #2
    1d38:	9a02      	ldr	r2, [sp, #8]
    1d3a:	441a      	add	r2, r3
    1d3c:	9b03      	ldr	r3, [sp, #12]
    1d3e:	605a      	str	r2, [r3, #4]
  chSemObjectInit(&mbp->mb_emptysem, n);
    1d40:	9b03      	ldr	r3, [sp, #12]
    1d42:	331c      	adds	r3, #28
    1d44:	4618      	mov	r0, r3
    1d46:	9901      	ldr	r1, [sp, #4]
    1d48:	f7ff fe42 	bl	19d0 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
    1d4c:	9b03      	ldr	r3, [sp, #12]
    1d4e:	3310      	adds	r3, #16
    1d50:	4618      	mov	r0, r3
    1d52:	2100      	movs	r1, #0
    1d54:	f7ff fe3c 	bl	19d0 <chSemObjectInit>
}
    1d58:	b005      	add	sp, #20
    1d5a:	f85d fb04 	ldr.w	pc, [sp], #4
    1d5e:	bf00      	nop
    1d60:	00004690 	.word	0x00004690
    1d64:	f3af 8000 	nop.w
    1d68:	f3af 8000 	nop.w
    1d6c:	f3af 8000 	nop.w

00001d70 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    1d70:	b500      	push	{lr}
    1d72:	b087      	sub	sp, #28
    1d74:	9003      	str	r0, [sp, #12]
    1d76:	9102      	str	r1, [sp, #8]
    1d78:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
    1d7a:	f7ff ff99 	bl	1cb0 <chSysLock>
  rdymsg = chMBPostS(mbp, msg, timeout);
    1d7e:	9803      	ldr	r0, [sp, #12]
    1d80:	9902      	ldr	r1, [sp, #8]
    1d82:	9a01      	ldr	r2, [sp, #4]
    1d84:	f000 f80c 	bl	1da0 <chMBPostS>
    1d88:	9005      	str	r0, [sp, #20]
  chSysUnlock();
    1d8a:	f7ff ff99 	bl	1cc0 <chSysUnlock>

  return rdymsg;
    1d8e:	9b05      	ldr	r3, [sp, #20]
}
    1d90:	4618      	mov	r0, r3
    1d92:	b007      	add	sp, #28
    1d94:	f85d fb04 	ldr.w	pc, [sp], #4
    1d98:	f3af 8000 	nop.w
    1d9c:	f3af 8000 	nop.w

00001da0 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    1da0:	b500      	push	{lr}
    1da2:	b087      	sub	sp, #28
    1da4:	9003      	str	r0, [sp, #12]
    1da6:	9102      	str	r1, [sp, #8]
    1da8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
    1daa:	f7fe fda1 	bl	8f0 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);
    1dae:	9b03      	ldr	r3, [sp, #12]
    1db0:	2b00      	cmp	r3, #0
    1db2:	d102      	bne.n	1dba <chMBPostS+0x1a>
    1db4:	4814      	ldr	r0, [pc, #80]	; (1e08 <chMBPostS+0x68>)
    1db6:	f7fe fc7b 	bl	6b0 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
    1dba:	9b03      	ldr	r3, [sp, #12]
    1dbc:	331c      	adds	r3, #28
    1dbe:	4618      	mov	r0, r3
    1dc0:	9901      	ldr	r1, [sp, #4]
    1dc2:	f7ff fe25 	bl	1a10 <chSemWaitTimeoutS>
    1dc6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
    1dc8:	9b05      	ldr	r3, [sp, #20]
    1dca:	2b00      	cmp	r3, #0
    1dcc:	d117      	bne.n	1dfe <chMBPostS+0x5e>
    *mbp->mb_wrptr++ = msg;
    1dce:	9b03      	ldr	r3, [sp, #12]
    1dd0:	689b      	ldr	r3, [r3, #8]
    1dd2:	1d19      	adds	r1, r3, #4
    1dd4:	9a03      	ldr	r2, [sp, #12]
    1dd6:	6091      	str	r1, [r2, #8]
    1dd8:	9a02      	ldr	r2, [sp, #8]
    1dda:	601a      	str	r2, [r3, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
    1ddc:	9b03      	ldr	r3, [sp, #12]
    1dde:	689a      	ldr	r2, [r3, #8]
    1de0:	9b03      	ldr	r3, [sp, #12]
    1de2:	685b      	ldr	r3, [r3, #4]
    1de4:	429a      	cmp	r2, r3
    1de6:	d303      	bcc.n	1df0 <chMBPostS+0x50>
      mbp->mb_wrptr = mbp->mb_buffer;
    1de8:	9b03      	ldr	r3, [sp, #12]
    1dea:	681a      	ldr	r2, [r3, #0]
    1dec:	9b03      	ldr	r3, [sp, #12]
    1dee:	609a      	str	r2, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
    1df0:	9b03      	ldr	r3, [sp, #12]
    1df2:	3310      	adds	r3, #16
    1df4:	4618      	mov	r0, r3
    1df6:	f7ff fe6b 	bl	1ad0 <chSemSignalI>
    chSchRescheduleS();
    1dfa:	f7ff f929 	bl	1050 <chSchRescheduleS>
  }

  return rdymsg;
    1dfe:	9b05      	ldr	r3, [sp, #20]
}
    1e00:	4618      	mov	r0, r3
    1e02:	b007      	add	sp, #28
    1e04:	f85d fb04 	ldr.w	pc, [sp], #4
    1e08:	000046b0 	.word	0x000046b0
    1e0c:	f3af 8000 	nop.w

00001e10 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    1e10:	b500      	push	{lr}
    1e12:	b087      	sub	sp, #28
    1e14:	9003      	str	r0, [sp, #12]
    1e16:	9102      	str	r1, [sp, #8]
    1e18:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
    1e1a:	f7ff ff49 	bl	1cb0 <chSysLock>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    1e1e:	9803      	ldr	r0, [sp, #12]
    1e20:	9902      	ldr	r1, [sp, #8]
    1e22:	9a01      	ldr	r2, [sp, #4]
    1e24:	f000 f80c 	bl	1e40 <chMBFetchS>
    1e28:	9005      	str	r0, [sp, #20]
  chSysUnlock();
    1e2a:	f7ff ff49 	bl	1cc0 <chSysUnlock>

  return rdymsg;
    1e2e:	9b05      	ldr	r3, [sp, #20]
}
    1e30:	4618      	mov	r0, r3
    1e32:	b007      	add	sp, #28
    1e34:	f85d fb04 	ldr.w	pc, [sp], #4
    1e38:	f3af 8000 	nop.w
    1e3c:	f3af 8000 	nop.w

00001e40 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    1e40:	b500      	push	{lr}
    1e42:	b087      	sub	sp, #28
    1e44:	9003      	str	r0, [sp, #12]
    1e46:	9102      	str	r1, [sp, #8]
    1e48:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
    1e4a:	f7fe fd51 	bl	8f0 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
    1e4e:	9b03      	ldr	r3, [sp, #12]
    1e50:	2b00      	cmp	r3, #0
    1e52:	d002      	beq.n	1e5a <chMBFetchS+0x1a>
    1e54:	9b02      	ldr	r3, [sp, #8]
    1e56:	2b00      	cmp	r3, #0
    1e58:	d102      	bne.n	1e60 <chMBFetchS+0x20>
    1e5a:	4815      	ldr	r0, [pc, #84]	; (1eb0 <chMBFetchS+0x70>)
    1e5c:	f7fe fc28 	bl	6b0 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
    1e60:	9b03      	ldr	r3, [sp, #12]
    1e62:	3310      	adds	r3, #16
    1e64:	4618      	mov	r0, r3
    1e66:	9901      	ldr	r1, [sp, #4]
    1e68:	f7ff fdd2 	bl	1a10 <chSemWaitTimeoutS>
    1e6c:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
    1e6e:	9b05      	ldr	r3, [sp, #20]
    1e70:	2b00      	cmp	r3, #0
    1e72:	d118      	bne.n	1ea6 <chMBFetchS+0x66>
    *msgp = *mbp->mb_rdptr++;
    1e74:	9b03      	ldr	r3, [sp, #12]
    1e76:	68db      	ldr	r3, [r3, #12]
    1e78:	1d19      	adds	r1, r3, #4
    1e7a:	9a03      	ldr	r2, [sp, #12]
    1e7c:	60d1      	str	r1, [r2, #12]
    1e7e:	681a      	ldr	r2, [r3, #0]
    1e80:	9b02      	ldr	r3, [sp, #8]
    1e82:	601a      	str	r2, [r3, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
    1e84:	9b03      	ldr	r3, [sp, #12]
    1e86:	68da      	ldr	r2, [r3, #12]
    1e88:	9b03      	ldr	r3, [sp, #12]
    1e8a:	685b      	ldr	r3, [r3, #4]
    1e8c:	429a      	cmp	r2, r3
    1e8e:	d303      	bcc.n	1e98 <chMBFetchS+0x58>
      mbp->mb_rdptr = mbp->mb_buffer;
    1e90:	9b03      	ldr	r3, [sp, #12]
    1e92:	681a      	ldr	r2, [r3, #0]
    1e94:	9b03      	ldr	r3, [sp, #12]
    1e96:	60da      	str	r2, [r3, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
    1e98:	9b03      	ldr	r3, [sp, #12]
    1e9a:	331c      	adds	r3, #28
    1e9c:	4618      	mov	r0, r3
    1e9e:	f7ff fe17 	bl	1ad0 <chSemSignalI>
    chSchRescheduleS();
    1ea2:	f7ff f8d5 	bl	1050 <chSchRescheduleS>
  }

  return rdymsg;
    1ea6:	9b05      	ldr	r3, [sp, #20]
}
    1ea8:	4618      	mov	r0, r3
    1eaa:	b007      	add	sp, #28
    1eac:	f85d fb04 	ldr.w	pc, [sp], #4
    1eb0:	000046c0 	.word	0x000046c0
    1eb4:	f3af 8000 	nop.w
    1eb8:	f3af 8000 	nop.w
    1ebc:	f3af 8000 	nop.w

00001ec0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1ec0:	b082      	sub	sp, #8
    1ec2:	2320      	movs	r3, #32
    1ec4:	9301      	str	r3, [sp, #4]
    1ec6:	9b01      	ldr	r3, [sp, #4]
    1ec8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1ecc:	b002      	add	sp, #8
    1ece:	4770      	bx	lr

00001ed0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1ed0:	b082      	sub	sp, #8
    1ed2:	2300      	movs	r3, #0
    1ed4:	9301      	str	r3, [sp, #4]
    1ed6:	9b01      	ldr	r3, [sp, #4]
    1ed8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1edc:	b002      	add	sp, #8
    1ede:	4770      	bx	lr

00001ee0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1ee0:	b082      	sub	sp, #8
    1ee2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1ee4:	9b01      	ldr	r3, [sp, #4]
    1ee6:	9a01      	ldr	r2, [sp, #4]
    1ee8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    1eea:	9b01      	ldr	r3, [sp, #4]
    1eec:	9a01      	ldr	r2, [sp, #4]
    1eee:	605a      	str	r2, [r3, #4]
}
    1ef0:	b002      	add	sp, #8
    1ef2:	4770      	bx	lr
    1ef4:	f3af 8000 	nop.w
    1ef8:	f3af 8000 	nop.w
    1efc:	f3af 8000 	nop.w

00001f00 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1f00:	b508      	push	{r3, lr}

  port_lock();
    1f02:	f7ff ffdd 	bl	1ec0 <port_lock>
  _stats_start_measure_crit_thd();
    1f06:	f7ff fce3 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1f0a:	f7fe fc39 	bl	780 <_dbg_check_lock>
}
    1f0e:	bd08      	pop	{r3, pc}

00001f10 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1f10:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1f12:	f7fe fc4d 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1f16:	f7ff fce3 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    1f1a:	4b09      	ldr	r3, [pc, #36]	; (1f40 <chSysUnlock+0x30>)
    1f1c:	681a      	ldr	r2, [r3, #0]
    1f1e:	4b08      	ldr	r3, [pc, #32]	; (1f40 <chSysUnlock+0x30>)
    1f20:	429a      	cmp	r2, r3
    1f22:	d00a      	beq.n	1f3a <chSysUnlock+0x2a>
    1f24:	4b06      	ldr	r3, [pc, #24]	; (1f40 <chSysUnlock+0x30>)
    1f26:	699b      	ldr	r3, [r3, #24]
    1f28:	689a      	ldr	r2, [r3, #8]
    1f2a:	4b05      	ldr	r3, [pc, #20]	; (1f40 <chSysUnlock+0x30>)
    1f2c:	681b      	ldr	r3, [r3, #0]
    1f2e:	689b      	ldr	r3, [r3, #8]
    1f30:	429a      	cmp	r2, r3
    1f32:	d202      	bcs.n	1f3a <chSysUnlock+0x2a>
    1f34:	4803      	ldr	r0, [pc, #12]	; (1f44 <chSysUnlock+0x34>)
    1f36:	f7fe fbbb 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    1f3a:	f7ff ffc9 	bl	1ed0 <port_unlock>
}
    1f3e:	bd08      	pop	{r3, pc}
    1f40:	20000800 	.word	0x20000800
    1f44:	000046d0 	.word	0x000046d0
    1f48:	f3af 8000 	nop.w
    1f4c:	f3af 8000 	nop.w

00001f50 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
    1f50:	b500      	push	{lr}
    1f52:	b083      	sub	sp, #12
    1f54:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
    1f56:	9801      	ldr	r0, [sp, #4]
    1f58:	f7ff ffc2 	bl	1ee0 <queue_init>
}
    1f5c:	b003      	add	sp, #12
    1f5e:	f85d fb04 	ldr.w	pc, [sp], #4
    1f62:	bf00      	nop
    1f64:	f3af 8000 	nop.w
    1f68:	f3af 8000 	nop.w
    1f6c:	f3af 8000 	nop.w

00001f70 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
    1f70:	b500      	push	{lr}
    1f72:	b083      	sub	sp, #12
    1f74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1f76:	f7fe fca3 	bl	8c0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
    1f7a:	9b01      	ldr	r3, [sp, #4]
    1f7c:	689b      	ldr	r3, [r3, #8]
    1f7e:	2b00      	cmp	r3, #0
    1f80:	bf14      	ite	ne
    1f82:	2300      	movne	r3, #0
    1f84:	2301      	moveq	r3, #1
    1f86:	b2db      	uxtb	r3, r3
}
    1f88:	4618      	mov	r0, r3
    1f8a:	b003      	add	sp, #12
    1f8c:	f85d fb04 	ldr.w	pc, [sp], #4

00001f90 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
    1f90:	b500      	push	{lr}
    1f92:	b083      	sub	sp, #12
    1f94:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1f96:	f7fe fc93 	bl	8c0 <chDbgCheckClassI>

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
    1f9a:	9b01      	ldr	r3, [sp, #4]
    1f9c:	695a      	ldr	r2, [r3, #20]
    1f9e:	9b01      	ldr	r3, [sp, #4]
    1fa0:	699b      	ldr	r3, [r3, #24]
    1fa2:	429a      	cmp	r2, r3
    1fa4:	d105      	bne.n	1fb2 <chIQIsFullI+0x22>
    1fa6:	9b01      	ldr	r3, [sp, #4]
    1fa8:	689b      	ldr	r3, [r3, #8]
    1faa:	2b00      	cmp	r3, #0
    1fac:	d001      	beq.n	1fb2 <chIQIsFullI+0x22>
    1fae:	2301      	movs	r3, #1
    1fb0:	e000      	b.n	1fb4 <chIQIsFullI+0x24>
    1fb2:	2300      	movs	r3, #0
    1fb4:	f003 0301 	and.w	r3, r3, #1
    1fb8:	b2db      	uxtb	r3, r3
}
    1fba:	4618      	mov	r0, r3
    1fbc:	b003      	add	sp, #12
    1fbe:	f85d fb04 	ldr.w	pc, [sp], #4
    1fc2:	bf00      	nop
    1fc4:	f3af 8000 	nop.w
    1fc8:	f3af 8000 	nop.w
    1fcc:	f3af 8000 	nop.w

00001fd0 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
    1fd0:	b500      	push	{lr}
    1fd2:	b083      	sub	sp, #12
    1fd4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1fd6:	f7fe fc73 	bl	8c0 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    1fda:	9b01      	ldr	r3, [sp, #4]
    1fdc:	695a      	ldr	r2, [r3, #20]
    1fde:	9b01      	ldr	r3, [sp, #4]
    1fe0:	699b      	ldr	r3, [r3, #24]
    1fe2:	429a      	cmp	r2, r3
    1fe4:	d105      	bne.n	1ff2 <chOQIsEmptyI+0x22>
    1fe6:	9b01      	ldr	r3, [sp, #4]
    1fe8:	689b      	ldr	r3, [r3, #8]
    1fea:	2b00      	cmp	r3, #0
    1fec:	d001      	beq.n	1ff2 <chOQIsEmptyI+0x22>
    1fee:	2301      	movs	r3, #1
    1ff0:	e000      	b.n	1ff4 <chOQIsEmptyI+0x24>
    1ff2:	2300      	movs	r3, #0
    1ff4:	f003 0301 	and.w	r3, r3, #1
    1ff8:	b2db      	uxtb	r3, r3
}
    1ffa:	4618      	mov	r0, r3
    1ffc:	b003      	add	sp, #12
    1ffe:	f85d fb04 	ldr.w	pc, [sp], #4
    2002:	bf00      	nop
    2004:	f3af 8000 	nop.w
    2008:	f3af 8000 	nop.w
    200c:	f3af 8000 	nop.w

00002010 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
    2010:	b500      	push	{lr}
    2012:	b083      	sub	sp, #12
    2014:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    2016:	f7fe fc53 	bl	8c0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
    201a:	9b01      	ldr	r3, [sp, #4]
    201c:	689b      	ldr	r3, [r3, #8]
    201e:	2b00      	cmp	r3, #0
    2020:	bf14      	ite	ne
    2022:	2300      	movne	r3, #0
    2024:	2301      	moveq	r3, #1
    2026:	b2db      	uxtb	r3, r3
}
    2028:	4618      	mov	r0, r3
    202a:	b003      	add	sp, #12
    202c:	f85d fb04 	ldr.w	pc, [sp], #4

00002030 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
    2030:	b500      	push	{lr}
    2032:	b085      	sub	sp, #20
    2034:	9003      	str	r0, [sp, #12]
    2036:	9102      	str	r1, [sp, #8]
    2038:	9201      	str	r2, [sp, #4]
    203a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
    203c:	9b03      	ldr	r3, [sp, #12]
    203e:	4618      	mov	r0, r3
    2040:	f7ff ff86 	bl	1f50 <chThdQueueObjectInit>
  iqp->q_counter = 0;
    2044:	9b03      	ldr	r3, [sp, #12]
    2046:	2200      	movs	r2, #0
    2048:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
    204a:	9b03      	ldr	r3, [sp, #12]
    204c:	9a02      	ldr	r2, [sp, #8]
    204e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
    2050:	9b03      	ldr	r3, [sp, #12]
    2052:	9a02      	ldr	r2, [sp, #8]
    2054:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
    2056:	9b03      	ldr	r3, [sp, #12]
    2058:	9a02      	ldr	r2, [sp, #8]
    205a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
    205c:	9a02      	ldr	r2, [sp, #8]
    205e:	9b01      	ldr	r3, [sp, #4]
    2060:	441a      	add	r2, r3
    2062:	9b03      	ldr	r3, [sp, #12]
    2064:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
    2066:	9b03      	ldr	r3, [sp, #12]
    2068:	9a00      	ldr	r2, [sp, #0]
    206a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
    206c:	9b03      	ldr	r3, [sp, #12]
    206e:	9a06      	ldr	r2, [sp, #24]
    2070:	621a      	str	r2, [r3, #32]
}
    2072:	b005      	add	sp, #20
    2074:	f85d fb04 	ldr.w	pc, [sp], #4
    2078:	f3af 8000 	nop.w
    207c:	f3af 8000 	nop.w

00002080 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
    2080:	b500      	push	{lr}
    2082:	b083      	sub	sp, #12
    2084:	9001      	str	r0, [sp, #4]
    2086:	460b      	mov	r3, r1
    2088:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();
    208c:	f7fe fc18 	bl	8c0 <chDbgCheckClassI>

  if (chIQIsFullI(iqp)) {
    2090:	9801      	ldr	r0, [sp, #4]
    2092:	f7ff ff7d 	bl	1f90 <chIQIsFullI>
    2096:	4603      	mov	r3, r0
    2098:	2b00      	cmp	r3, #0
    209a:	d002      	beq.n	20a2 <chIQPutI+0x22>
    return Q_FULL;
    209c:	f06f 0303 	mvn.w	r3, #3
    20a0:	e01c      	b.n	20dc <chIQPutI+0x5c>
  }

  iqp->q_counter++;
    20a2:	9b01      	ldr	r3, [sp, #4]
    20a4:	689b      	ldr	r3, [r3, #8]
    20a6:	1c5a      	adds	r2, r3, #1
    20a8:	9b01      	ldr	r3, [sp, #4]
    20aa:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
    20ac:	9b01      	ldr	r3, [sp, #4]
    20ae:	695b      	ldr	r3, [r3, #20]
    20b0:	1c59      	adds	r1, r3, #1
    20b2:	9a01      	ldr	r2, [sp, #4]
    20b4:	6151      	str	r1, [r2, #20]
    20b6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    20ba:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
    20bc:	9b01      	ldr	r3, [sp, #4]
    20be:	695a      	ldr	r2, [r3, #20]
    20c0:	9b01      	ldr	r3, [sp, #4]
    20c2:	691b      	ldr	r3, [r3, #16]
    20c4:	429a      	cmp	r2, r3
    20c6:	d303      	bcc.n	20d0 <chIQPutI+0x50>
    iqp->q_wrptr = iqp->q_buffer;
    20c8:	9b01      	ldr	r3, [sp, #4]
    20ca:	68da      	ldr	r2, [r3, #12]
    20cc:	9b01      	ldr	r3, [sp, #4]
    20ce:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
    20d0:	9b01      	ldr	r3, [sp, #4]
    20d2:	4618      	mov	r0, r3
    20d4:	2100      	movs	r1, #0
    20d6:	f7ff fae3 	bl	16a0 <chThdDequeueNextI>

  return Q_OK;
    20da:	2300      	movs	r3, #0
}
    20dc:	4618      	mov	r0, r3
    20de:	b003      	add	sp, #12
    20e0:	f85d fb04 	ldr.w	pc, [sp], #4
    20e4:	f3af 8000 	nop.w
    20e8:	f3af 8000 	nop.w
    20ec:	f3af 8000 	nop.w

000020f0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
    20f0:	b500      	push	{lr}
    20f2:	b085      	sub	sp, #20
    20f4:	9001      	str	r0, [sp, #4]
    20f6:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
    20f8:	f7ff ff02 	bl	1f00 <chSysLock>
  if (iqp->q_notify != NULL) {
    20fc:	9b01      	ldr	r3, [sp, #4]
    20fe:	69db      	ldr	r3, [r3, #28]
    2100:	2b00      	cmp	r3, #0
    2102:	d004      	beq.n	210e <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
    2104:	9b01      	ldr	r3, [sp, #4]
    2106:	69db      	ldr	r3, [r3, #28]
    2108:	9801      	ldr	r0, [sp, #4]
    210a:	4798      	blx	r3
  }

  while (chIQIsEmptyI(iqp)) {
    210c:	e00d      	b.n	212a <chIQGetTimeout+0x3a>
    210e:	e00c      	b.n	212a <chIQGetTimeout+0x3a>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
    2110:	9b01      	ldr	r3, [sp, #4]
    2112:	4618      	mov	r0, r3
    2114:	9900      	ldr	r1, [sp, #0]
    2116:	f7ff faa3 	bl	1660 <chThdEnqueueTimeoutS>
    211a:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
    211c:	9b03      	ldr	r3, [sp, #12]
    211e:	2b00      	cmp	r3, #0
    2120:	da03      	bge.n	212a <chIQGetTimeout+0x3a>
      chSysUnlock();
    2122:	f7ff fef5 	bl	1f10 <chSysUnlock>
      return msg;
    2126:	9b03      	ldr	r3, [sp, #12]
    2128:	e020      	b.n	216c <chIQGetTimeout+0x7c>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    212a:	9801      	ldr	r0, [sp, #4]
    212c:	f7ff ff20 	bl	1f70 <chIQIsEmptyI>
    2130:	4603      	mov	r3, r0
    2132:	2b00      	cmp	r3, #0
    2134:	d1ec      	bne.n	2110 <chIQGetTimeout+0x20>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
    2136:	9b01      	ldr	r3, [sp, #4]
    2138:	689b      	ldr	r3, [r3, #8]
    213a:	1e5a      	subs	r2, r3, #1
    213c:	9b01      	ldr	r3, [sp, #4]
    213e:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
    2140:	9b01      	ldr	r3, [sp, #4]
    2142:	699b      	ldr	r3, [r3, #24]
    2144:	1c59      	adds	r1, r3, #1
    2146:	9a01      	ldr	r2, [sp, #4]
    2148:	6191      	str	r1, [r2, #24]
    214a:	781b      	ldrb	r3, [r3, #0]
    214c:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
    2150:	9b01      	ldr	r3, [sp, #4]
    2152:	699a      	ldr	r2, [r3, #24]
    2154:	9b01      	ldr	r3, [sp, #4]
    2156:	691b      	ldr	r3, [r3, #16]
    2158:	429a      	cmp	r2, r3
    215a:	d303      	bcc.n	2164 <chIQGetTimeout+0x74>
    iqp->q_rdptr = iqp->q_buffer;
    215c:	9b01      	ldr	r3, [sp, #4]
    215e:	68da      	ldr	r2, [r3, #12]
    2160:	9b01      	ldr	r3, [sp, #4]
    2162:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
    2164:	f7ff fed4 	bl	1f10 <chSysUnlock>

  return (msg_t)b;
    2168:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    216c:	4618      	mov	r0, r3
    216e:	b005      	add	sp, #20
    2170:	f85d fb04 	ldr.w	pc, [sp], #4
    2174:	f3af 8000 	nop.w
    2178:	f3af 8000 	nop.w
    217c:	f3af 8000 	nop.w

00002180 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
    2180:	b500      	push	{lr}
    2182:	b087      	sub	sp, #28
    2184:	9003      	str	r0, [sp, #12]
    2186:	9102      	str	r1, [sp, #8]
    2188:	9201      	str	r2, [sp, #4]
    218a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
    218c:	9b03      	ldr	r3, [sp, #12]
    218e:	69db      	ldr	r3, [r3, #28]
    2190:	9304      	str	r3, [sp, #16]
  size_t r = 0;
    2192:	2300      	movs	r3, #0
    2194:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
    2196:	9b01      	ldr	r3, [sp, #4]
    2198:	2b00      	cmp	r3, #0
    219a:	d102      	bne.n	21a2 <chIQReadTimeout+0x22>
    219c:	4825      	ldr	r0, [pc, #148]	; (2234 <chIQReadTimeout+0xb4>)
    219e:	f7fe fa87 	bl	6b0 <chSysHalt>

  chSysLock();
    21a2:	f7ff fead 	bl	1f00 <chSysLock>
  while (true) {
    if (nfy != NULL) {
    21a6:	9b04      	ldr	r3, [sp, #16]
    21a8:	2b00      	cmp	r3, #0
    21aa:	d003      	beq.n	21b4 <chIQReadTimeout+0x34>
      nfy(iqp);
    21ac:	9b04      	ldr	r3, [sp, #16]
    21ae:	9803      	ldr	r0, [sp, #12]
    21b0:	4798      	blx	r3
    }

    while (chIQIsEmptyI(iqp)) {
    21b2:	e00c      	b.n	21ce <chIQReadTimeout+0x4e>
    21b4:	e00b      	b.n	21ce <chIQReadTimeout+0x4e>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
    21b6:	9b03      	ldr	r3, [sp, #12]
    21b8:	4618      	mov	r0, r3
    21ba:	9900      	ldr	r1, [sp, #0]
    21bc:	f7ff fa50 	bl	1660 <chThdEnqueueTimeoutS>
    21c0:	4603      	mov	r3, r0
    21c2:	2b00      	cmp	r3, #0
    21c4:	d003      	beq.n	21ce <chIQReadTimeout+0x4e>
        chSysUnlock();
    21c6:	f7ff fea3 	bl	1f10 <chSysUnlock>
        return r;
    21ca:	9b05      	ldr	r3, [sp, #20]
    21cc:	e02e      	b.n	222c <chIQReadTimeout+0xac>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
    21ce:	9803      	ldr	r0, [sp, #12]
    21d0:	f7ff fece 	bl	1f70 <chIQIsEmptyI>
    21d4:	4603      	mov	r3, r0
    21d6:	2b00      	cmp	r3, #0
    21d8:	d1ed      	bne.n	21b6 <chIQReadTimeout+0x36>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
    21da:	9b03      	ldr	r3, [sp, #12]
    21dc:	689b      	ldr	r3, [r3, #8]
    21de:	1e5a      	subs	r2, r3, #1
    21e0:	9b03      	ldr	r3, [sp, #12]
    21e2:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
    21e4:	9b02      	ldr	r3, [sp, #8]
    21e6:	1c5a      	adds	r2, r3, #1
    21e8:	9202      	str	r2, [sp, #8]
    21ea:	9a03      	ldr	r2, [sp, #12]
    21ec:	6992      	ldr	r2, [r2, #24]
    21ee:	1c50      	adds	r0, r2, #1
    21f0:	9903      	ldr	r1, [sp, #12]
    21f2:	6188      	str	r0, [r1, #24]
    21f4:	7812      	ldrb	r2, [r2, #0]
    21f6:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
    21f8:	9b03      	ldr	r3, [sp, #12]
    21fa:	699a      	ldr	r2, [r3, #24]
    21fc:	9b03      	ldr	r3, [sp, #12]
    21fe:	691b      	ldr	r3, [r3, #16]
    2200:	429a      	cmp	r2, r3
    2202:	d303      	bcc.n	220c <chIQReadTimeout+0x8c>
      iqp->q_rdptr = iqp->q_buffer;
    2204:	9b03      	ldr	r3, [sp, #12]
    2206:	68da      	ldr	r2, [r3, #12]
    2208:	9b03      	ldr	r3, [sp, #12]
    220a:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    220c:	f7ff fe80 	bl	1f10 <chSysUnlock>

    r++;
    2210:	9b05      	ldr	r3, [sp, #20]
    2212:	3301      	adds	r3, #1
    2214:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
    2216:	9b01      	ldr	r3, [sp, #4]
    2218:	3b01      	subs	r3, #1
    221a:	9301      	str	r3, [sp, #4]
    221c:	9b01      	ldr	r3, [sp, #4]
    221e:	2b00      	cmp	r3, #0
    2220:	d101      	bne.n	2226 <chIQReadTimeout+0xa6>
      return r;
    2222:	9b05      	ldr	r3, [sp, #20]
    2224:	e002      	b.n	222c <chIQReadTimeout+0xac>
    }

    chSysLock();
    2226:	f7ff fe6b 	bl	1f00 <chSysLock>
  }
    222a:	e7bc      	b.n	21a6 <chIQReadTimeout+0x26>
}
    222c:	4618      	mov	r0, r3
    222e:	b007      	add	sp, #28
    2230:	f85d fb04 	ldr.w	pc, [sp], #4
    2234:	000046e0 	.word	0x000046e0
    2238:	f3af 8000 	nop.w
    223c:	f3af 8000 	nop.w

00002240 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
    2240:	b500      	push	{lr}
    2242:	b085      	sub	sp, #20
    2244:	9003      	str	r0, [sp, #12]
    2246:	9102      	str	r1, [sp, #8]
    2248:	9201      	str	r2, [sp, #4]
    224a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
    224c:	9b03      	ldr	r3, [sp, #12]
    224e:	4618      	mov	r0, r3
    2250:	f7ff fe7e 	bl	1f50 <chThdQueueObjectInit>
  oqp->q_counter = size;
    2254:	9b03      	ldr	r3, [sp, #12]
    2256:	9a01      	ldr	r2, [sp, #4]
    2258:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
    225a:	9b03      	ldr	r3, [sp, #12]
    225c:	9a02      	ldr	r2, [sp, #8]
    225e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
    2260:	9b03      	ldr	r3, [sp, #12]
    2262:	9a02      	ldr	r2, [sp, #8]
    2264:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
    2266:	9b03      	ldr	r3, [sp, #12]
    2268:	9a02      	ldr	r2, [sp, #8]
    226a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
    226c:	9a02      	ldr	r2, [sp, #8]
    226e:	9b01      	ldr	r3, [sp, #4]
    2270:	441a      	add	r2, r3
    2272:	9b03      	ldr	r3, [sp, #12]
    2274:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
    2276:	9b03      	ldr	r3, [sp, #12]
    2278:	9a00      	ldr	r2, [sp, #0]
    227a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
    227c:	9b03      	ldr	r3, [sp, #12]
    227e:	9a06      	ldr	r2, [sp, #24]
    2280:	621a      	str	r2, [r3, #32]
}
    2282:	b005      	add	sp, #20
    2284:	f85d fb04 	ldr.w	pc, [sp], #4
    2288:	f3af 8000 	nop.w
    228c:	f3af 8000 	nop.w

00002290 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    2290:	b500      	push	{lr}
    2292:	b087      	sub	sp, #28
    2294:	9003      	str	r0, [sp, #12]
    2296:	460b      	mov	r3, r1
    2298:	9201      	str	r2, [sp, #4]
    229a:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
    229e:	f7ff fe2f 	bl	1f00 <chSysLock>
  while (chOQIsFullI(oqp)) {
    22a2:	e00c      	b.n	22be <chOQPutTimeout+0x2e>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    22a4:	9b03      	ldr	r3, [sp, #12]
    22a6:	4618      	mov	r0, r3
    22a8:	9901      	ldr	r1, [sp, #4]
    22aa:	f7ff f9d9 	bl	1660 <chThdEnqueueTimeoutS>
    22ae:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
    22b0:	9b05      	ldr	r3, [sp, #20]
    22b2:	2b00      	cmp	r3, #0
    22b4:	da03      	bge.n	22be <chOQPutTimeout+0x2e>
      chSysUnlock();
    22b6:	f7ff fe2b 	bl	1f10 <chSysUnlock>
      return msg;
    22ba:	9b05      	ldr	r3, [sp, #20]
    22bc:	e027      	b.n	230e <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    22be:	9803      	ldr	r0, [sp, #12]
    22c0:	f7ff fea6 	bl	2010 <chOQIsFullI>
    22c4:	4603      	mov	r3, r0
    22c6:	2b00      	cmp	r3, #0
    22c8:	d1ec      	bne.n	22a4 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
    22ca:	9b03      	ldr	r3, [sp, #12]
    22cc:	689b      	ldr	r3, [r3, #8]
    22ce:	1e5a      	subs	r2, r3, #1
    22d0:	9b03      	ldr	r3, [sp, #12]
    22d2:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
    22d4:	9b03      	ldr	r3, [sp, #12]
    22d6:	695b      	ldr	r3, [r3, #20]
    22d8:	1c59      	adds	r1, r3, #1
    22da:	9a03      	ldr	r2, [sp, #12]
    22dc:	6151      	str	r1, [r2, #20]
    22de:	f89d 200b 	ldrb.w	r2, [sp, #11]
    22e2:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
    22e4:	9b03      	ldr	r3, [sp, #12]
    22e6:	695a      	ldr	r2, [r3, #20]
    22e8:	9b03      	ldr	r3, [sp, #12]
    22ea:	691b      	ldr	r3, [r3, #16]
    22ec:	429a      	cmp	r2, r3
    22ee:	d303      	bcc.n	22f8 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
    22f0:	9b03      	ldr	r3, [sp, #12]
    22f2:	68da      	ldr	r2, [r3, #12]
    22f4:	9b03      	ldr	r3, [sp, #12]
    22f6:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
    22f8:	9b03      	ldr	r3, [sp, #12]
    22fa:	69db      	ldr	r3, [r3, #28]
    22fc:	2b00      	cmp	r3, #0
    22fe:	d003      	beq.n	2308 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
    2300:	9b03      	ldr	r3, [sp, #12]
    2302:	69db      	ldr	r3, [r3, #28]
    2304:	9803      	ldr	r0, [sp, #12]
    2306:	4798      	blx	r3
  }
  chSysUnlock();
    2308:	f7ff fe02 	bl	1f10 <chSysUnlock>

  return Q_OK;
    230c:	2300      	movs	r3, #0
}
    230e:	4618      	mov	r0, r3
    2310:	b007      	add	sp, #28
    2312:	f85d fb04 	ldr.w	pc, [sp], #4
    2316:	bf00      	nop
    2318:	f3af 8000 	nop.w
    231c:	f3af 8000 	nop.w

00002320 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
    2320:	b500      	push	{lr}
    2322:	b085      	sub	sp, #20
    2324:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();
    2326:	f7fe facb 	bl	8c0 <chDbgCheckClassI>

  if (chOQIsEmptyI(oqp)) {
    232a:	9801      	ldr	r0, [sp, #4]
    232c:	f7ff fe50 	bl	1fd0 <chOQIsEmptyI>
    2330:	4603      	mov	r3, r0
    2332:	2b00      	cmp	r3, #0
    2334:	d002      	beq.n	233c <chOQGetI+0x1c>
    return Q_EMPTY;
    2336:	f06f 0302 	mvn.w	r3, #2
    233a:	e01d      	b.n	2378 <chOQGetI+0x58>
  }

  oqp->q_counter++;
    233c:	9b01      	ldr	r3, [sp, #4]
    233e:	689b      	ldr	r3, [r3, #8]
    2340:	1c5a      	adds	r2, r3, #1
    2342:	9b01      	ldr	r3, [sp, #4]
    2344:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
    2346:	9b01      	ldr	r3, [sp, #4]
    2348:	699b      	ldr	r3, [r3, #24]
    234a:	1c59      	adds	r1, r3, #1
    234c:	9a01      	ldr	r2, [sp, #4]
    234e:	6191      	str	r1, [r2, #24]
    2350:	781b      	ldrb	r3, [r3, #0]
    2352:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
    2356:	9b01      	ldr	r3, [sp, #4]
    2358:	699a      	ldr	r2, [r3, #24]
    235a:	9b01      	ldr	r3, [sp, #4]
    235c:	691b      	ldr	r3, [r3, #16]
    235e:	429a      	cmp	r2, r3
    2360:	d303      	bcc.n	236a <chOQGetI+0x4a>
    oqp->q_rdptr = oqp->q_buffer;
    2362:	9b01      	ldr	r3, [sp, #4]
    2364:	68da      	ldr	r2, [r3, #12]
    2366:	9b01      	ldr	r3, [sp, #4]
    2368:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
    236a:	9b01      	ldr	r3, [sp, #4]
    236c:	4618      	mov	r0, r3
    236e:	2100      	movs	r1, #0
    2370:	f7ff f996 	bl	16a0 <chThdDequeueNextI>

  return (msg_t)b;
    2374:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    2378:	4618      	mov	r0, r3
    237a:	b005      	add	sp, #20
    237c:	f85d fb04 	ldr.w	pc, [sp], #4

00002380 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
    2380:	b500      	push	{lr}
    2382:	b087      	sub	sp, #28
    2384:	9003      	str	r0, [sp, #12]
    2386:	9102      	str	r1, [sp, #8]
    2388:	9201      	str	r2, [sp, #4]
    238a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
    238c:	9b03      	ldr	r3, [sp, #12]
    238e:	69db      	ldr	r3, [r3, #28]
    2390:	9304      	str	r3, [sp, #16]
  size_t w = 0;
    2392:	2300      	movs	r3, #0
    2394:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
    2396:	9b01      	ldr	r3, [sp, #4]
    2398:	2b00      	cmp	r3, #0
    239a:	d102      	bne.n	23a2 <chOQWriteTimeout+0x22>
    239c:	4825      	ldr	r0, [pc, #148]	; (2434 <chOQWriteTimeout+0xb4>)
    239e:	f7fe f987 	bl	6b0 <chSysHalt>

  chSysLock();
    23a2:	f7ff fdad 	bl	1f00 <chSysLock>
  while (true) {
    while (chOQIsFullI(oqp)) {
    23a6:	e00b      	b.n	23c0 <chOQWriteTimeout+0x40>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
    23a8:	9b03      	ldr	r3, [sp, #12]
    23aa:	4618      	mov	r0, r3
    23ac:	9900      	ldr	r1, [sp, #0]
    23ae:	f7ff f957 	bl	1660 <chThdEnqueueTimeoutS>
    23b2:	4603      	mov	r3, r0
    23b4:	2b00      	cmp	r3, #0
    23b6:	d003      	beq.n	23c0 <chOQWriteTimeout+0x40>
        chSysUnlock();
    23b8:	f7ff fdaa 	bl	1f10 <chSysUnlock>
        return w;
    23bc:	9b05      	ldr	r3, [sp, #20]
    23be:	e035      	b.n	242c <chOQWriteTimeout+0xac>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
    23c0:	9803      	ldr	r0, [sp, #12]
    23c2:	f7ff fe25 	bl	2010 <chOQIsFullI>
    23c6:	4603      	mov	r3, r0
    23c8:	2b00      	cmp	r3, #0
    23ca:	d1ed      	bne.n	23a8 <chOQWriteTimeout+0x28>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
    23cc:	9b03      	ldr	r3, [sp, #12]
    23ce:	689b      	ldr	r3, [r3, #8]
    23d0:	1e5a      	subs	r2, r3, #1
    23d2:	9b03      	ldr	r3, [sp, #12]
    23d4:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
    23d6:	9b03      	ldr	r3, [sp, #12]
    23d8:	695b      	ldr	r3, [r3, #20]
    23da:	1c59      	adds	r1, r3, #1
    23dc:	9a03      	ldr	r2, [sp, #12]
    23de:	6151      	str	r1, [r2, #20]
    23e0:	9a02      	ldr	r2, [sp, #8]
    23e2:	1c51      	adds	r1, r2, #1
    23e4:	9102      	str	r1, [sp, #8]
    23e6:	7812      	ldrb	r2, [r2, #0]
    23e8:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
    23ea:	9b03      	ldr	r3, [sp, #12]
    23ec:	695a      	ldr	r2, [r3, #20]
    23ee:	9b03      	ldr	r3, [sp, #12]
    23f0:	691b      	ldr	r3, [r3, #16]
    23f2:	429a      	cmp	r2, r3
    23f4:	d303      	bcc.n	23fe <chOQWriteTimeout+0x7e>
      oqp->q_wrptr = oqp->q_buffer;
    23f6:	9b03      	ldr	r3, [sp, #12]
    23f8:	68da      	ldr	r2, [r3, #12]
    23fa:	9b03      	ldr	r3, [sp, #12]
    23fc:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
    23fe:	9b04      	ldr	r3, [sp, #16]
    2400:	2b00      	cmp	r3, #0
    2402:	d002      	beq.n	240a <chOQWriteTimeout+0x8a>
      nfy(oqp);
    2404:	9b04      	ldr	r3, [sp, #16]
    2406:	9803      	ldr	r0, [sp, #12]
    2408:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    240a:	f7ff fd81 	bl	1f10 <chSysUnlock>

    w++;
    240e:	9b05      	ldr	r3, [sp, #20]
    2410:	3301      	adds	r3, #1
    2412:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
    2414:	9b01      	ldr	r3, [sp, #4]
    2416:	3b01      	subs	r3, #1
    2418:	9301      	str	r3, [sp, #4]
    241a:	9b01      	ldr	r3, [sp, #4]
    241c:	2b00      	cmp	r3, #0
    241e:	d101      	bne.n	2424 <chOQWriteTimeout+0xa4>
      return w;
    2420:	9b05      	ldr	r3, [sp, #20]
    2422:	e003      	b.n	242c <chOQWriteTimeout+0xac>
    }
    chSysLock();
    2424:	f7ff fd6c 	bl	1f00 <chSysLock>
  }
    2428:	bf00      	nop

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
    242a:	e7c9      	b.n	23c0 <chOQWriteTimeout+0x40>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
    242c:	4618      	mov	r0, r3
    242e:	b007      	add	sp, #28
    2430:	f85d fb04 	ldr.w	pc, [sp], #4
    2434:	000046f0 	.word	0x000046f0
    2438:	f3af 8000 	nop.w
    243c:	f3af 8000 	nop.w

00002440 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2440:	b082      	sub	sp, #8
    2442:	2320      	movs	r3, #32
    2444:	9301      	str	r3, [sp, #4]
    2446:	9b01      	ldr	r3, [sp, #4]
    2448:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    244c:	b002      	add	sp, #8
    244e:	4770      	bx	lr

00002450 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2450:	b082      	sub	sp, #8
    2452:	2300      	movs	r3, #0
    2454:	9301      	str	r3, [sp, #4]
    2456:	9b01      	ldr	r3, [sp, #4]
    2458:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    245c:	b002      	add	sp, #8
    245e:	4770      	bx	lr

00002460 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    2460:	b508      	push	{r3, lr}

  port_lock();
    2462:	f7ff ffed 	bl	2440 <port_lock>
  _stats_start_measure_crit_thd();
    2466:	f7ff fa33 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    246a:	f7fe f989 	bl	780 <_dbg_check_lock>
}
    246e:	bd08      	pop	{r3, pc}

00002470 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2470:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2472:	f7fe f99d 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2476:	f7ff fa33 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    247a:	4b09      	ldr	r3, [pc, #36]	; (24a0 <chSysUnlock+0x30>)
    247c:	681a      	ldr	r2, [r3, #0]
    247e:	4b08      	ldr	r3, [pc, #32]	; (24a0 <chSysUnlock+0x30>)
    2480:	429a      	cmp	r2, r3
    2482:	d00a      	beq.n	249a <chSysUnlock+0x2a>
    2484:	4b06      	ldr	r3, [pc, #24]	; (24a0 <chSysUnlock+0x30>)
    2486:	699b      	ldr	r3, [r3, #24]
    2488:	689a      	ldr	r2, [r3, #8]
    248a:	4b05      	ldr	r3, [pc, #20]	; (24a0 <chSysUnlock+0x30>)
    248c:	681b      	ldr	r3, [r3, #0]
    248e:	689b      	ldr	r3, [r3, #8]
    2490:	429a      	cmp	r2, r3
    2492:	d202      	bcs.n	249a <chSysUnlock+0x2a>
    2494:	4803      	ldr	r0, [pc, #12]	; (24a4 <chSysUnlock+0x34>)
    2496:	f7fe f90b 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    249a:	f7ff ffd9 	bl	2450 <port_unlock>
}
    249e:	bd08      	pop	{r3, pc}
    24a0:	20000800 	.word	0x20000800
    24a4:	00004710 	.word	0x00004710
    24a8:	f3af 8000 	nop.w
    24ac:	f3af 8000 	nop.w

000024b0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
    24b0:	4b06      	ldr	r3, [pc, #24]	; (24cc <_core_init+0x1c>)
    24b2:	3307      	adds	r3, #7
    24b4:	f023 0307 	bic.w	r3, r3, #7
    24b8:	461a      	mov	r2, r3
    24ba:	4b05      	ldr	r3, [pc, #20]	; (24d0 <_core_init+0x20>)
    24bc:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
    24be:	4b05      	ldr	r3, [pc, #20]	; (24d4 <_core_init+0x24>)
    24c0:	f023 0307 	bic.w	r3, r3, #7
    24c4:	461a      	mov	r2, r3
    24c6:	4b04      	ldr	r3, [pc, #16]	; (24d8 <_core_init+0x28>)
    24c8:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
    24ca:	4770      	bx	lr
    24cc:	20001740 	.word	0x20001740
    24d0:	20000dd8 	.word	0x20000dd8
    24d4:	20020000 	.word	0x20020000
    24d8:	20000ddc 	.word	0x20000ddc
    24dc:	f3af 8000 	nop.w

000024e0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
    24e0:	b500      	push	{lr}
    24e2:	b085      	sub	sp, #20
    24e4:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
    24e6:	f7ff ffbb 	bl	2460 <chSysLock>
  p = chCoreAllocI(size);
    24ea:	9801      	ldr	r0, [sp, #4]
    24ec:	f000 f808 	bl	2500 <chCoreAllocI>
    24f0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
    24f2:	f7ff ffbd 	bl	2470 <chSysUnlock>

  return p;
    24f6:	9b03      	ldr	r3, [sp, #12]
}
    24f8:	4618      	mov	r0, r3
    24fa:	b005      	add	sp, #20
    24fc:	f85d fb04 	ldr.w	pc, [sp], #4

00002500 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
    2500:	b500      	push	{lr}
    2502:	b085      	sub	sp, #20
    2504:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();
    2506:	f7fe f9db 	bl	8c0 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
    250a:	9b01      	ldr	r3, [sp, #4]
    250c:	3307      	adds	r3, #7
    250e:	f023 0307 	bic.w	r3, r3, #7
    2512:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
    2514:	4b0c      	ldr	r3, [pc, #48]	; (2548 <chCoreAllocI+0x48>)
    2516:	681b      	ldr	r3, [r3, #0]
    2518:	461a      	mov	r2, r3
    251a:	4b0c      	ldr	r3, [pc, #48]	; (254c <chCoreAllocI+0x4c>)
    251c:	681b      	ldr	r3, [r3, #0]
    251e:	1ad3      	subs	r3, r2, r3
    2520:	461a      	mov	r2, r3
    2522:	9b01      	ldr	r3, [sp, #4]
    2524:	429a      	cmp	r2, r3
    2526:	d201      	bcs.n	252c <chCoreAllocI+0x2c>
  /*lint -restore*/
    return NULL;
    2528:	2300      	movs	r3, #0
    252a:	e009      	b.n	2540 <chCoreAllocI+0x40>
  }
  p = nextmem;
    252c:	4b07      	ldr	r3, [pc, #28]	; (254c <chCoreAllocI+0x4c>)
    252e:	681b      	ldr	r3, [r3, #0]
    2530:	9303      	str	r3, [sp, #12]
  nextmem += size;
    2532:	4b06      	ldr	r3, [pc, #24]	; (254c <chCoreAllocI+0x4c>)
    2534:	681a      	ldr	r2, [r3, #0]
    2536:	9b01      	ldr	r3, [sp, #4]
    2538:	441a      	add	r2, r3
    253a:	4b04      	ldr	r3, [pc, #16]	; (254c <chCoreAllocI+0x4c>)
    253c:	601a      	str	r2, [r3, #0]

  return p;
    253e:	9b03      	ldr	r3, [sp, #12]
}
    2540:	4618      	mov	r0, r3
    2542:	b005      	add	sp, #20
    2544:	f85d fb04 	ldr.w	pc, [sp], #4
    2548:	20000ddc 	.word	0x20000ddc
    254c:	20000dd8 	.word	0x20000dd8

00002550 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
    2550:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
    2552:	4b06      	ldr	r3, [pc, #24]	; (256c <_heap_init+0x1c>)
    2554:	4a06      	ldr	r2, [pc, #24]	; (2570 <_heap_init+0x20>)
    2556:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
    2558:	4b04      	ldr	r3, [pc, #16]	; (256c <_heap_init+0x1c>)
    255a:	2200      	movs	r2, #0
    255c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
    255e:	4b03      	ldr	r3, [pc, #12]	; (256c <_heap_init+0x1c>)
    2560:	2200      	movs	r2, #0
    2562:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
    2564:	4803      	ldr	r0, [pc, #12]	; (2574 <_heap_init+0x24>)
    2566:	f7ff fb0b 	bl	1b80 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
    256a:	bd08      	pop	{r3, pc}
    256c:	20000de0 	.word	0x20000de0
    2570:	000024e1 	.word	0x000024e1
    2574:	20000df0 	.word	0x20000df0
    2578:	f3af 8000 	nop.w
    257c:	f3af 8000 	nop.w

00002580 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2580:	b082      	sub	sp, #8
    2582:	2320      	movs	r3, #32
    2584:	9301      	str	r3, [sp, #4]
    2586:	9b01      	ldr	r3, [sp, #4]
    2588:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    258c:	b002      	add	sp, #8
    258e:	4770      	bx	lr

00002590 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2590:	b082      	sub	sp, #8
    2592:	2300      	movs	r3, #0
    2594:	9301      	str	r3, [sp, #4]
    2596:	9b01      	ldr	r3, [sp, #4]
    2598:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    259c:	b002      	add	sp, #8
    259e:	4770      	bx	lr

000025a0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    25a0:	b508      	push	{r3, lr}

  port_lock();
    25a2:	f7ff ffed 	bl	2580 <port_lock>
  _stats_start_measure_crit_thd();
    25a6:	f7ff f993 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    25aa:	f7fe f8e9 	bl	780 <_dbg_check_lock>
}
    25ae:	bd08      	pop	{r3, pc}

000025b0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    25b0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    25b2:	f7fe f8fd 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    25b6:	f7ff f993 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    25ba:	4b09      	ldr	r3, [pc, #36]	; (25e0 <chSysUnlock+0x30>)
    25bc:	681a      	ldr	r2, [r3, #0]
    25be:	4b08      	ldr	r3, [pc, #32]	; (25e0 <chSysUnlock+0x30>)
    25c0:	429a      	cmp	r2, r3
    25c2:	d00a      	beq.n	25da <chSysUnlock+0x2a>
    25c4:	4b06      	ldr	r3, [pc, #24]	; (25e0 <chSysUnlock+0x30>)
    25c6:	699b      	ldr	r3, [r3, #24]
    25c8:	689a      	ldr	r2, [r3, #8]
    25ca:	4b05      	ldr	r3, [pc, #20]	; (25e0 <chSysUnlock+0x30>)
    25cc:	681b      	ldr	r3, [r3, #0]
    25ce:	689b      	ldr	r3, [r3, #8]
    25d0:	429a      	cmp	r2, r3
    25d2:	d202      	bcs.n	25da <chSysUnlock+0x2a>
    25d4:	4803      	ldr	r0, [pc, #12]	; (25e4 <chSysUnlock+0x34>)
    25d6:	f7fe f86b 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    25da:	f7ff ffd9 	bl	2590 <port_unlock>
}
    25de:	bd08      	pop	{r3, pc}
    25e0:	20000800 	.word	0x20000800
    25e4:	00004760 	.word	0x00004760
    25e8:	f3af 8000 	nop.w
    25ec:	f3af 8000 	nop.w

000025f0 <chPoolAdd>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
    25f0:	b500      	push	{lr}
    25f2:	b083      	sub	sp, #12
    25f4:	9001      	str	r0, [sp, #4]
    25f6:	9100      	str	r1, [sp, #0]

  chPoolFree(mp, objp);
    25f8:	9801      	ldr	r0, [sp, #4]
    25fa:	9900      	ldr	r1, [sp, #0]
    25fc:	f000 f8b0 	bl	2760 <chPoolFree>
}
    2600:	b003      	add	sp, #12
    2602:	f85d fb04 	ldr.w	pc, [sp], #4
    2606:	bf00      	nop
    2608:	f3af 8000 	nop.w
    260c:	f3af 8000 	nop.w

00002610 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
    2610:	b500      	push	{lr}
    2612:	b085      	sub	sp, #20
    2614:	9003      	str	r0, [sp, #12]
    2616:	9102      	str	r1, [sp, #8]
    2618:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
    261a:	9b03      	ldr	r3, [sp, #12]
    261c:	2b00      	cmp	r3, #0
    261e:	d002      	beq.n	2626 <chPoolObjectInit+0x16>
    2620:	9b02      	ldr	r3, [sp, #8]
    2622:	2b03      	cmp	r3, #3
    2624:	d802      	bhi.n	262c <chPoolObjectInit+0x1c>
    2626:	4807      	ldr	r0, [pc, #28]	; (2644 <chPoolObjectInit+0x34>)
    2628:	f7fe f842 	bl	6b0 <chSysHalt>

  mp->mp_next = NULL;
    262c:	9b03      	ldr	r3, [sp, #12]
    262e:	2200      	movs	r2, #0
    2630:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
    2632:	9b03      	ldr	r3, [sp, #12]
    2634:	9a02      	ldr	r2, [sp, #8]
    2636:	605a      	str	r2, [r3, #4]
  mp->mp_provider = provider;
    2638:	9b03      	ldr	r3, [sp, #12]
    263a:	9a01      	ldr	r2, [sp, #4]
    263c:	609a      	str	r2, [r3, #8]
}
    263e:	b005      	add	sp, #20
    2640:	f85d fb04 	ldr.w	pc, [sp], #4
    2644:	00004720 	.word	0x00004720
    2648:	f3af 8000 	nop.w
    264c:	f3af 8000 	nop.w

00002650 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
    2650:	b500      	push	{lr}
    2652:	b085      	sub	sp, #20
    2654:	9003      	str	r0, [sp, #12]
    2656:	9102      	str	r1, [sp, #8]
    2658:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0U));
    265a:	9b03      	ldr	r3, [sp, #12]
    265c:	2b00      	cmp	r3, #0
    265e:	d002      	beq.n	2666 <chPoolLoadArray+0x16>
    2660:	9b01      	ldr	r3, [sp, #4]
    2662:	2b00      	cmp	r3, #0
    2664:	d103      	bne.n	266e <chPoolLoadArray+0x1e>
    2666:	480b      	ldr	r0, [pc, #44]	; (2694 <chPoolLoadArray+0x44>)
    2668:	f7fe f822 	bl	6b0 <chSysHalt>

  while (n != 0U) {
    266c:	e00c      	b.n	2688 <chPoolLoadArray+0x38>
    266e:	e00b      	b.n	2688 <chPoolLoadArray+0x38>
    chPoolAdd(mp, p);
    2670:	9803      	ldr	r0, [sp, #12]
    2672:	9902      	ldr	r1, [sp, #8]
    2674:	f7ff ffbc 	bl	25f0 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    2678:	9b03      	ldr	r3, [sp, #12]
    267a:	685b      	ldr	r3, [r3, #4]
    267c:	9a02      	ldr	r2, [sp, #8]
    267e:	4413      	add	r3, r2
    2680:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
    2682:	9b01      	ldr	r3, [sp, #4]
    2684:	3b01      	subs	r3, #1
    2686:	9301      	str	r3, [sp, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    2688:	9b01      	ldr	r3, [sp, #4]
    268a:	2b00      	cmp	r3, #0
    268c:	d1f0      	bne.n	2670 <chPoolLoadArray+0x20>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    /*lint -restore*/
    n--;
  }
}
    268e:	b005      	add	sp, #20
    2690:	f85d fb04 	ldr.w	pc, [sp], #4
    2694:	00004740 	.word	0x00004740
    2698:	f3af 8000 	nop.w
    269c:	f3af 8000 	nop.w

000026a0 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
    26a0:	b500      	push	{lr}
    26a2:	b085      	sub	sp, #20
    26a4:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
    26a6:	f7fe f90b 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
    26aa:	9b01      	ldr	r3, [sp, #4]
    26ac:	2b00      	cmp	r3, #0
    26ae:	d102      	bne.n	26b6 <chPoolAllocI+0x16>
    26b0:	480f      	ldr	r0, [pc, #60]	; (26f0 <chPoolAllocI+0x50>)
    26b2:	f7fd fffd 	bl	6b0 <chSysHalt>

  objp = mp->mp_next;
    26b6:	9b01      	ldr	r3, [sp, #4]
    26b8:	681b      	ldr	r3, [r3, #0]
    26ba:	9303      	str	r3, [sp, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    26bc:	9b03      	ldr	r3, [sp, #12]
    26be:	2b00      	cmp	r3, #0
    26c0:	d005      	beq.n	26ce <chPoolAllocI+0x2e>
    mp->mp_next = mp->mp_next->ph_next;
    26c2:	9b01      	ldr	r3, [sp, #4]
    26c4:	681b      	ldr	r3, [r3, #0]
    26c6:	681a      	ldr	r2, [r3, #0]
    26c8:	9b01      	ldr	r3, [sp, #4]
    26ca:	601a      	str	r2, [r3, #0]
    26cc:	e00a      	b.n	26e4 <chPoolAllocI+0x44>
  }
  else if (mp->mp_provider != NULL) {
    26ce:	9b01      	ldr	r3, [sp, #4]
    26d0:	689b      	ldr	r3, [r3, #8]
    26d2:	2b00      	cmp	r3, #0
    26d4:	d006      	beq.n	26e4 <chPoolAllocI+0x44>
    objp = mp->mp_provider(mp->mp_object_size);
    26d6:	9b01      	ldr	r3, [sp, #4]
    26d8:	689b      	ldr	r3, [r3, #8]
    26da:	9a01      	ldr	r2, [sp, #4]
    26dc:	6852      	ldr	r2, [r2, #4]
    26de:	4610      	mov	r0, r2
    26e0:	4798      	blx	r3
    26e2:	9003      	str	r0, [sp, #12]
  }
  /*lint -restore*/

  return objp;
    26e4:	9b03      	ldr	r3, [sp, #12]
}
    26e6:	4618      	mov	r0, r3
    26e8:	b005      	add	sp, #20
    26ea:	f85d fb04 	ldr.w	pc, [sp], #4
    26ee:	bf00      	nop
    26f0:	00004750 	.word	0x00004750
    26f4:	f3af 8000 	nop.w
    26f8:	f3af 8000 	nop.w
    26fc:	f3af 8000 	nop.w

00002700 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
    2700:	b500      	push	{lr}
    2702:	b085      	sub	sp, #20
    2704:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
    2706:	f7ff ff4b 	bl	25a0 <chSysLock>
  objp = chPoolAllocI(mp);
    270a:	9801      	ldr	r0, [sp, #4]
    270c:	f7ff ffc8 	bl	26a0 <chPoolAllocI>
    2710:	9003      	str	r0, [sp, #12]
  chSysUnlock();
    2712:	f7ff ff4d 	bl	25b0 <chSysUnlock>

  return objp;
    2716:	9b03      	ldr	r3, [sp, #12]
}
    2718:	4618      	mov	r0, r3
    271a:	b005      	add	sp, #20
    271c:	f85d fb04 	ldr.w	pc, [sp], #4

00002720 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    2720:	b500      	push	{lr}
    2722:	b085      	sub	sp, #20
    2724:	9001      	str	r0, [sp, #4]
    2726:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
    2728:	9b00      	ldr	r3, [sp, #0]
    272a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
    272c:	f7fe f8c8 	bl	8c0 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
    2730:	9b01      	ldr	r3, [sp, #4]
    2732:	2b00      	cmp	r3, #0
    2734:	d002      	beq.n	273c <chPoolFreeI+0x1c>
    2736:	9b00      	ldr	r3, [sp, #0]
    2738:	2b00      	cmp	r3, #0
    273a:	d102      	bne.n	2742 <chPoolFreeI+0x22>
    273c:	4806      	ldr	r0, [pc, #24]	; (2758 <chPoolFreeI+0x38>)
    273e:	f7fd ffb7 	bl	6b0 <chSysHalt>

  php->ph_next = mp->mp_next;
    2742:	9b01      	ldr	r3, [sp, #4]
    2744:	681a      	ldr	r2, [r3, #0]
    2746:	9b03      	ldr	r3, [sp, #12]
    2748:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
    274a:	9b01      	ldr	r3, [sp, #4]
    274c:	9a03      	ldr	r2, [sp, #12]
    274e:	601a      	str	r2, [r3, #0]
}
    2750:	b005      	add	sp, #20
    2752:	f85d fb04 	ldr.w	pc, [sp], #4
    2756:	bf00      	nop
    2758:	00004770 	.word	0x00004770
    275c:	f3af 8000 	nop.w

00002760 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
    2760:	b500      	push	{lr}
    2762:	b083      	sub	sp, #12
    2764:	9001      	str	r0, [sp, #4]
    2766:	9100      	str	r1, [sp, #0]

  chSysLock();
    2768:	f7ff ff1a 	bl	25a0 <chSysLock>
  chPoolFreeI(mp, objp);
    276c:	9801      	ldr	r0, [sp, #4]
    276e:	9900      	ldr	r1, [sp, #0]
    2770:	f7ff ffd6 	bl	2720 <chPoolFreeI>
  chSysUnlock();
    2774:	f7ff ff1c 	bl	25b0 <chSysUnlock>
}
    2778:	b003      	add	sp, #12
    277a:	f85d fb04 	ldr.w	pc, [sp], #4
    277e:	bf00      	nop

00002780 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2780:	b082      	sub	sp, #8
    2782:	2320      	movs	r3, #32
    2784:	9301      	str	r3, [sp, #4]
    2786:	9b01      	ldr	r3, [sp, #4]
    2788:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    278c:	b002      	add	sp, #8
    278e:	4770      	bx	lr

00002790 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2790:	b082      	sub	sp, #8
    2792:	2300      	movs	r3, #0
    2794:	9301      	str	r3, [sp, #4]
    2796:	9b01      	ldr	r3, [sp, #4]
    2798:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    279c:	b002      	add	sp, #8
    279e:	4770      	bx	lr

000027a0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    27a0:	b508      	push	{r3, lr}

  port_lock();
    27a2:	f7ff ffed 	bl	2780 <port_lock>
}
    27a6:	bd08      	pop	{r3, pc}
    27a8:	f3af 8000 	nop.w
    27ac:	f3af 8000 	nop.w

000027b0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    27b0:	b508      	push	{r3, lr}

  port_unlock();
    27b2:	f7ff ffed 	bl	2790 <port_unlock>
}
    27b6:	bd08      	pop	{r3, pc}
    27b8:	f3af 8000 	nop.w
    27bc:	f3af 8000 	nop.w

000027c0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
    27c0:	b510      	push	{r4, lr}
    27c2:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    27c4:	f3ef 8309 	mrs	r3, PSP
    27c8:	461c      	mov	r4, r3
  return(result);
    27ca:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
    27cc:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
    27ce:	9b01      	ldr	r3, [sp, #4]
    27d0:	3320      	adds	r3, #32
    27d2:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
    27d4:	9b01      	ldr	r3, [sp, #4]
    27d6:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    27d8:	9b00      	ldr	r3, [sp, #0]
    27da:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
    27de:	f7ff ffe7 	bl	27b0 <port_unlock_from_isr>
}
    27e2:	b002      	add	sp, #8
    27e4:	bd10      	pop	{r4, pc}
    27e6:	bf00      	nop
    27e8:	f3af 8000 	nop.w
    27ec:	f3af 8000 	nop.w

000027f0 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
    27f0:	b510      	push	{r4, lr}
    27f2:	b082      	sub	sp, #8

  port_lock_from_isr();
    27f4:	f7ff ffd4 	bl	27a0 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
    27f8:	4b13      	ldr	r3, [pc, #76]	; (2848 <_port_irq_epilogue+0x58>)
    27fa:	685b      	ldr	r3, [r3, #4]
    27fc:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    2800:	2b00      	cmp	r3, #0
    2802:	d01d      	beq.n	2840 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    2804:	f3ef 8309 	mrs	r3, PSP
    2808:	461c      	mov	r4, r3
  return(result);
    280a:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
    280c:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
    280e:	9b01      	ldr	r3, [sp, #4]
    2810:	3b20      	subs	r3, #32
    2812:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
    2814:	9b01      	ldr	r3, [sp, #4]
    2816:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    281a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
    281c:	9b01      	ldr	r3, [sp, #4]
    281e:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    2820:	9b00      	ldr	r3, [sp, #0]
    2822:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
    2826:	f7fe fc23 	bl	1070 <chSchIsPreemptionRequired>
    282a:	4603      	mov	r3, r0
    282c:	2b00      	cmp	r3, #0
    282e:	d003      	beq.n	2838 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    2830:	9b01      	ldr	r3, [sp, #4]
    2832:	4a06      	ldr	r2, [pc, #24]	; (284c <_port_irq_epilogue+0x5c>)
    2834:	619a      	str	r2, [r3, #24]
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
    2836:	e005      	b.n	2844 <_port_irq_epilogue+0x54>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    2838:	9b01      	ldr	r3, [sp, #4]
    283a:	4a05      	ldr	r2, [pc, #20]	; (2850 <_port_irq_epilogue+0x60>)
    283c:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
    283e:	e001      	b.n	2844 <_port_irq_epilogue+0x54>
  }
  port_unlock_from_isr();
    2840:	f7ff ffb6 	bl	27b0 <port_unlock_from_isr>
}
    2844:	b002      	add	sp, #8
    2846:	bd10      	pop	{r4, pc}
    2848:	e000ed00 	.word	0xe000ed00
    284c:	000002a9 	.word	0x000002a9
    2850:	000002bc 	.word	0x000002bc
    2854:	f3af 8000 	nop.w
    2858:	f3af 8000 	nop.w
    285c:	f3af 8000 	nop.w

00002860 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    2860:	4770      	bx	lr
    2862:	bf00      	nop
    2864:	f3af 8000 	nop.w
    2868:	f3af 8000 	nop.w
    286c:	f3af 8000 	nop.w

00002870 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
    2870:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    2872:	f7ff fff5 	bl	2860 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
    2876:	f000 facb 	bl	2e10 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    287a:	4806      	ldr	r0, [pc, #24]	; (2894 <halInit+0x24>)
    287c:	f001 f8a8 	bl	39d0 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
    2880:	f000 f88e 	bl	29a0 <adcInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    2884:	f000 f9e4 	bl	2c50 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    2888:	f001 fba2 	bl	3fd0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    288c:	f000 f838 	bl	2900 <stInit>
#endif
}
    2890:	bd08      	pop	{r3, pc}
    2892:	bf00      	nop
    2894:	000048c0 	.word	0x000048c0
    2898:	f3af 8000 	nop.w
    289c:	f3af 8000 	nop.w

000028a0 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
    28a0:	b082      	sub	sp, #8
    28a2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
    28a4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    28a8:	9a01      	ldr	r2, [sp, #4]
    28aa:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
    28ac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    28b0:	2200      	movs	r2, #0
    28b2:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
    28b4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    28b8:	2202      	movs	r2, #2
    28ba:	60da      	str	r2, [r3, #12]
}
    28bc:	b002      	add	sp, #8
    28be:	4770      	bx	lr

000028c0 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
    28c0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    28c4:	2200      	movs	r2, #0
    28c6:	60da      	str	r2, [r3, #12]
}
    28c8:	4770      	bx	lr
    28ca:	bf00      	nop
    28cc:	f3af 8000 	nop.w

000028d0 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
    28d0:	b082      	sub	sp, #8
    28d2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
    28d4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    28d8:	9a01      	ldr	r2, [sp, #4]
    28da:	635a      	str	r2, [r3, #52]	; 0x34
}
    28dc:	b002      	add	sp, #8
    28de:	4770      	bx	lr

000028e0 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
    28e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    28e4:	68db      	ldr	r3, [r3, #12]
    28e6:	f003 0302 	and.w	r3, r3, #2
    28ea:	2b00      	cmp	r3, #0
    28ec:	bf0c      	ite	eq
    28ee:	2300      	moveq	r3, #0
    28f0:	2301      	movne	r3, #1
    28f2:	b2db      	uxtb	r3, r3
}
    28f4:	4618      	mov	r0, r3
    28f6:	4770      	bx	lr
    28f8:	f3af 8000 	nop.w
    28fc:	f3af 8000 	nop.w

00002900 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
    2900:	b508      	push	{r3, lr}

  st_lld_init();
    2902:	f000 fe6d 	bl	35e0 <st_lld_init>
}
    2906:	bd08      	pop	{r3, pc}
    2908:	f3af 8000 	nop.w
    290c:	f3af 8000 	nop.w

00002910 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
    2910:	b500      	push	{lr}
    2912:	b083      	sub	sp, #12
    2914:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
    2916:	f7ff ffe3 	bl	28e0 <st_lld_is_alarm_active>
    291a:	4603      	mov	r3, r0
    291c:	2b00      	cmp	r3, #0
    291e:	d002      	beq.n	2926 <stStartAlarm+0x16>
    2920:	4804      	ldr	r0, [pc, #16]	; (2934 <stStartAlarm+0x24>)
    2922:	f7fd fec5 	bl	6b0 <chSysHalt>

  st_lld_start_alarm(abstime);
    2926:	9801      	ldr	r0, [sp, #4]
    2928:	f7ff ffba 	bl	28a0 <st_lld_start_alarm>
}
    292c:	b003      	add	sp, #12
    292e:	f85d fb04 	ldr.w	pc, [sp], #4
    2932:	bf00      	nop
    2934:	00004780 	.word	0x00004780
    2938:	f3af 8000 	nop.w
    293c:	f3af 8000 	nop.w

00002940 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
    2940:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
    2942:	f7ff ffbd 	bl	28c0 <st_lld_stop_alarm>
}
    2946:	bd08      	pop	{r3, pc}
    2948:	f3af 8000 	nop.w
    294c:	f3af 8000 	nop.w

00002950 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
    2950:	b500      	push	{lr}
    2952:	b083      	sub	sp, #12
    2954:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
    2956:	f7ff ffc3 	bl	28e0 <st_lld_is_alarm_active>
    295a:	4603      	mov	r3, r0
    295c:	f083 0301 	eor.w	r3, r3, #1
    2960:	b2db      	uxtb	r3, r3
    2962:	2b00      	cmp	r3, #0
    2964:	d002      	beq.n	296c <stSetAlarm+0x1c>
    2966:	4804      	ldr	r0, [pc, #16]	; (2978 <stSetAlarm+0x28>)
    2968:	f7fd fea2 	bl	6b0 <chSysHalt>

  st_lld_set_alarm(abstime);
    296c:	9801      	ldr	r0, [sp, #4]
    296e:	f7ff ffaf 	bl	28d0 <st_lld_set_alarm>
}
    2972:	b003      	add	sp, #12
    2974:	f85d fb04 	ldr.w	pc, [sp], #4
    2978:	00004790 	.word	0x00004790
    297c:	f3af 8000 	nop.w

00002980 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
    2980:	b500      	push	{lr}
    2982:	b083      	sub	sp, #12
    2984:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
    2986:	9801      	ldr	r0, [sp, #4]
    2988:	f7ff f8fa 	bl	1b80 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
    298c:	b003      	add	sp, #12
    298e:	f85d fb04 	ldr.w	pc, [sp], #4
    2992:	bf00      	nop
    2994:	f3af 8000 	nop.w
    2998:	f3af 8000 	nop.w
    299c:	f3af 8000 	nop.w

000029a0 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
    29a0:	b508      	push	{r3, lr}

  adc_lld_init();
    29a2:	f000 ff75 	bl	3890 <adc_lld_init>
}
    29a6:	bd08      	pop	{r3, pc}
    29a8:	f3af 8000 	nop.w
    29ac:	f3af 8000 	nop.w

000029b0 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
    29b0:	b500      	push	{lr}
    29b2:	b083      	sub	sp, #12
    29b4:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
    29b6:	9b01      	ldr	r3, [sp, #4]
    29b8:	2201      	movs	r2, #1
    29ba:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
    29bc:	9b01      	ldr	r3, [sp, #4]
    29be:	2200      	movs	r2, #0
    29c0:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
    29c2:	9b01      	ldr	r3, [sp, #4]
    29c4:	2200      	movs	r2, #0
    29c6:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
    29c8:	9b01      	ldr	r3, [sp, #4]
    29ca:	2200      	movs	r2, #0
    29cc:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
    29ce:	9b01      	ldr	r3, [sp, #4]
    29d0:	2200      	movs	r2, #0
    29d2:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
    29d4:	9b01      	ldr	r3, [sp, #4]
    29d6:	2200      	movs	r2, #0
    29d8:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
    29da:	9b01      	ldr	r3, [sp, #4]
    29dc:	3318      	adds	r3, #24
    29de:	4618      	mov	r0, r3
    29e0:	f7ff ffce 	bl	2980 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
    29e4:	b003      	add	sp, #12
    29e6:	f85d fb04 	ldr.w	pc, [sp], #4
    29ea:	bf00      	nop
    29ec:	f3af 8000 	nop.w

000029f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    29f0:	b082      	sub	sp, #8
    29f2:	2320      	movs	r3, #32
    29f4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    29f6:	9b01      	ldr	r3, [sp, #4]
    29f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    29fc:	b002      	add	sp, #8
    29fe:	4770      	bx	lr

00002a00 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2a00:	b082      	sub	sp, #8
    2a02:	2300      	movs	r3, #0
    2a04:	9301      	str	r3, [sp, #4]
    2a06:	9b01      	ldr	r3, [sp, #4]
    2a08:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2a0c:	b002      	add	sp, #8
    2a0e:	4770      	bx	lr

00002a10 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    2a10:	b508      	push	{r3, lr}

  port_lock();
    2a12:	f7ff ffed 	bl	29f0 <port_lock>
  _stats_start_measure_crit_thd();
    2a16:	f7fe ff5b 	bl	18d0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2a1a:	f7fd feb1 	bl	780 <_dbg_check_lock>
}
    2a1e:	bd08      	pop	{r3, pc}

00002a20 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2a20:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2a22:	f7fd fec5 	bl	7b0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2a26:	f7fe ff5b 	bl	18e0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    2a2a:	4b09      	ldr	r3, [pc, #36]	; (2a50 <chSysUnlock+0x30>)
    2a2c:	681a      	ldr	r2, [r3, #0]
    2a2e:	4b08      	ldr	r3, [pc, #32]	; (2a50 <chSysUnlock+0x30>)
    2a30:	429a      	cmp	r2, r3
    2a32:	d00a      	beq.n	2a4a <chSysUnlock+0x2a>
    2a34:	4b06      	ldr	r3, [pc, #24]	; (2a50 <chSysUnlock+0x30>)
    2a36:	699b      	ldr	r3, [r3, #24]
    2a38:	689a      	ldr	r2, [r3, #8]
    2a3a:	4b05      	ldr	r3, [pc, #20]	; (2a50 <chSysUnlock+0x30>)
    2a3c:	681b      	ldr	r3, [r3, #0]
    2a3e:	689b      	ldr	r3, [r3, #8]
    2a40:	429a      	cmp	r2, r3
    2a42:	d202      	bcs.n	2a4a <chSysUnlock+0x2a>
    2a44:	4803      	ldr	r0, [pc, #12]	; (2a54 <chSysUnlock+0x34>)
    2a46:	f7fd fe33 	bl	6b0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    2a4a:	f7ff ffd9 	bl	2a00 <port_unlock>
}
    2a4e:	bd08      	pop	{r3, pc}
    2a50:	20000800 	.word	0x20000800
    2a54:	000047d0 	.word	0x000047d0
    2a58:	f3af 8000 	nop.w
    2a5c:	f3af 8000 	nop.w

00002a60 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
    2a60:	b082      	sub	sp, #8
    2a62:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
    2a64:	9b01      	ldr	r3, [sp, #4]
    2a66:	9a01      	ldr	r2, [sp, #4]
    2a68:	601a      	str	r2, [r3, #0]
}
    2a6a:	b002      	add	sp, #8
    2a6c:	4770      	bx	lr
    2a6e:	bf00      	nop

00002a70 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
    2a70:	b500      	push	{lr}
    2a72:	b083      	sub	sp, #12
    2a74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    2a76:	f7fd ff23 	bl	8c0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
    2a7a:	9b01      	ldr	r3, [sp, #4]
    2a7c:	689b      	ldr	r3, [r3, #8]
    2a7e:	2b00      	cmp	r3, #0
    2a80:	bf14      	ite	ne
    2a82:	2300      	movne	r3, #0
    2a84:	2301      	moveq	r3, #1
    2a86:	b2db      	uxtb	r3, r3
}
    2a88:	4618      	mov	r0, r3
    2a8a:	b003      	add	sp, #12
    2a8c:	f85d fb04 	ldr.w	pc, [sp], #4

00002a90 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
    2a90:	b508      	push	{r3, lr}

  chSysLock();
    2a92:	f7ff ffbd 	bl	2a10 <chSysLock>
}
    2a96:	bd08      	pop	{r3, pc}
    2a98:	f3af 8000 	nop.w
    2a9c:	f3af 8000 	nop.w

00002aa0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
    2aa0:	b508      	push	{r3, lr}

  chSysUnlock();
    2aa2:	f7ff ffbd 	bl	2a20 <chSysUnlock>
}
    2aa6:	bd08      	pop	{r3, pc}
    2aa8:	f3af 8000 	nop.w
    2aac:	f3af 8000 	nop.w

00002ab0 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    2ab0:	b500      	push	{lr}
    2ab2:	b083      	sub	sp, #12
    2ab4:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
    2ab6:	9801      	ldr	r0, [sp, #4]
    2ab8:	f7ff ffd2 	bl	2a60 <chEvtObjectInit>
}
    2abc:	b003      	add	sp, #12
    2abe:	f85d fb04 	ldr.w	pc, [sp], #4
    2ac2:	bf00      	nop
    2ac4:	f3af 8000 	nop.w
    2ac8:	f3af 8000 	nop.w
    2acc:	f3af 8000 	nop.w

00002ad0 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    2ad0:	b500      	push	{lr}
    2ad2:	b083      	sub	sp, #12
    2ad4:	9001      	str	r0, [sp, #4]
    2ad6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
    2ad8:	9801      	ldr	r0, [sp, #4]
    2ada:	9900      	ldr	r1, [sp, #0]
    2adc:	f7ff f868 	bl	1bb0 <chEvtBroadcastFlagsI>
}
    2ae0:	b003      	add	sp, #12
    2ae2:	f85d fb04 	ldr.w	pc, [sp], #4
    2ae6:	bf00      	nop
    2ae8:	f3af 8000 	nop.w
    2aec:	f3af 8000 	nop.w

00002af0 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    2af0:	b500      	push	{lr}
    2af2:	b085      	sub	sp, #20
    2af4:	9003      	str	r0, [sp, #12]
    2af6:	9102      	str	r1, [sp, #8]
    2af8:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    2afa:	9b03      	ldr	r3, [sp, #12]
    2afc:	3330      	adds	r3, #48	; 0x30
    2afe:	4618      	mov	r0, r3
    2b00:	9902      	ldr	r1, [sp, #8]
    2b02:	9a01      	ldr	r2, [sp, #4]
    2b04:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2b08:	f7ff fc3a 	bl	2380 <chOQWriteTimeout>
    2b0c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
    2b0e:	4618      	mov	r0, r3
    2b10:	b005      	add	sp, #20
    2b12:	f85d fb04 	ldr.w	pc, [sp], #4
    2b16:	bf00      	nop
    2b18:	f3af 8000 	nop.w
    2b1c:	f3af 8000 	nop.w

00002b20 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    2b20:	b500      	push	{lr}
    2b22:	b085      	sub	sp, #20
    2b24:	9003      	str	r0, [sp, #12]
    2b26:	9102      	str	r1, [sp, #8]
    2b28:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    2b2a:	9b03      	ldr	r3, [sp, #12]
    2b2c:	330c      	adds	r3, #12
    2b2e:	4618      	mov	r0, r3
    2b30:	9902      	ldr	r1, [sp, #8]
    2b32:	9a01      	ldr	r2, [sp, #4]
    2b34:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2b38:	f7ff fb22 	bl	2180 <chIQReadTimeout>
    2b3c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
    2b3e:	4618      	mov	r0, r3
    2b40:	b005      	add	sp, #20
    2b42:	f85d fb04 	ldr.w	pc, [sp], #4
    2b46:	bf00      	nop
    2b48:	f3af 8000 	nop.w
    2b4c:	f3af 8000 	nop.w

00002b50 <put>:

static msg_t put(void *ip, uint8_t b) {
    2b50:	b500      	push	{lr}
    2b52:	b083      	sub	sp, #12
    2b54:	9001      	str	r0, [sp, #4]
    2b56:	460b      	mov	r3, r1
    2b58:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    2b5c:	9b01      	ldr	r3, [sp, #4]
    2b5e:	f103 0230 	add.w	r2, r3, #48	; 0x30
    2b62:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2b66:	4610      	mov	r0, r2
    2b68:	4619      	mov	r1, r3
    2b6a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2b6e:	f7ff fb8f 	bl	2290 <chOQPutTimeout>
    2b72:	4603      	mov	r3, r0
}
    2b74:	4618      	mov	r0, r3
    2b76:	b003      	add	sp, #12
    2b78:	f85d fb04 	ldr.w	pc, [sp], #4
    2b7c:	f3af 8000 	nop.w

00002b80 <get>:

static msg_t get(void *ip) {
    2b80:	b500      	push	{lr}
    2b82:	b083      	sub	sp, #12
    2b84:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    2b86:	9b01      	ldr	r3, [sp, #4]
    2b88:	330c      	adds	r3, #12
    2b8a:	4618      	mov	r0, r3
    2b8c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2b90:	f7ff faae 	bl	20f0 <chIQGetTimeout>
    2b94:	4603      	mov	r3, r0
}
    2b96:	4618      	mov	r0, r3
    2b98:	b003      	add	sp, #12
    2b9a:	f85d fb04 	ldr.w	pc, [sp], #4
    2b9e:	bf00      	nop

00002ba0 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    2ba0:	b500      	push	{lr}
    2ba2:	b085      	sub	sp, #20
    2ba4:	9003      	str	r0, [sp, #12]
    2ba6:	460b      	mov	r3, r1
    2ba8:	9201      	str	r2, [sp, #4]
    2baa:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    2bae:	9b03      	ldr	r3, [sp, #12]
    2bb0:	f103 0230 	add.w	r2, r3, #48	; 0x30
    2bb4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    2bb8:	4610      	mov	r0, r2
    2bba:	4619      	mov	r1, r3
    2bbc:	9a01      	ldr	r2, [sp, #4]
    2bbe:	f7ff fb67 	bl	2290 <chOQPutTimeout>
    2bc2:	4603      	mov	r3, r0
}
    2bc4:	4618      	mov	r0, r3
    2bc6:	b005      	add	sp, #20
    2bc8:	f85d fb04 	ldr.w	pc, [sp], #4
    2bcc:	f3af 8000 	nop.w

00002bd0 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    2bd0:	b500      	push	{lr}
    2bd2:	b083      	sub	sp, #12
    2bd4:	9001      	str	r0, [sp, #4]
    2bd6:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    2bd8:	9b01      	ldr	r3, [sp, #4]
    2bda:	330c      	adds	r3, #12
    2bdc:	4618      	mov	r0, r3
    2bde:	9900      	ldr	r1, [sp, #0]
    2be0:	f7ff fa86 	bl	20f0 <chIQGetTimeout>
    2be4:	4603      	mov	r3, r0
}
    2be6:	4618      	mov	r0, r3
    2be8:	b003      	add	sp, #12
    2bea:	f85d fb04 	ldr.w	pc, [sp], #4
    2bee:	bf00      	nop

00002bf0 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    2bf0:	b500      	push	{lr}
    2bf2:	b085      	sub	sp, #20
    2bf4:	9003      	str	r0, [sp, #12]
    2bf6:	9102      	str	r1, [sp, #8]
    2bf8:	9201      	str	r2, [sp, #4]
    2bfa:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    2bfc:	9b03      	ldr	r3, [sp, #12]
    2bfe:	3330      	adds	r3, #48	; 0x30
    2c00:	4618      	mov	r0, r3
    2c02:	9902      	ldr	r1, [sp, #8]
    2c04:	9a01      	ldr	r2, [sp, #4]
    2c06:	9b00      	ldr	r3, [sp, #0]
    2c08:	f7ff fbba 	bl	2380 <chOQWriteTimeout>
    2c0c:	4603      	mov	r3, r0
}
    2c0e:	4618      	mov	r0, r3
    2c10:	b005      	add	sp, #20
    2c12:	f85d fb04 	ldr.w	pc, [sp], #4
    2c16:	bf00      	nop
    2c18:	f3af 8000 	nop.w
    2c1c:	f3af 8000 	nop.w

00002c20 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    2c20:	b500      	push	{lr}
    2c22:	b085      	sub	sp, #20
    2c24:	9003      	str	r0, [sp, #12]
    2c26:	9102      	str	r1, [sp, #8]
    2c28:	9201      	str	r2, [sp, #4]
    2c2a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    2c2c:	9b03      	ldr	r3, [sp, #12]
    2c2e:	330c      	adds	r3, #12
    2c30:	4618      	mov	r0, r3
    2c32:	9902      	ldr	r1, [sp, #8]
    2c34:	9a01      	ldr	r2, [sp, #4]
    2c36:	9b00      	ldr	r3, [sp, #0]
    2c38:	f7ff faa2 	bl	2180 <chIQReadTimeout>
    2c3c:	4603      	mov	r3, r0
}
    2c3e:	4618      	mov	r0, r3
    2c40:	b005      	add	sp, #20
    2c42:	f85d fb04 	ldr.w	pc, [sp], #4
    2c46:	bf00      	nop
    2c48:	f3af 8000 	nop.w
    2c4c:	f3af 8000 	nop.w

00002c50 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
    2c50:	b508      	push	{r3, lr}

  sd_lld_init();
    2c52:	f001 f975 	bl	3f40 <sd_lld_init>
}
    2c56:	bd08      	pop	{r3, pc}
    2c58:	f3af 8000 	nop.w
    2c5c:	f3af 8000 	nop.w

00002c60 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    2c60:	b500      	push	{lr}
    2c62:	b087      	sub	sp, #28
    2c64:	9005      	str	r0, [sp, #20]
    2c66:	9104      	str	r1, [sp, #16]
    2c68:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
    2c6a:	9b05      	ldr	r3, [sp, #20]
    2c6c:	4a13      	ldr	r2, [pc, #76]	; (2cbc <sdObjectInit+0x5c>)
    2c6e:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
    2c70:	9b05      	ldr	r3, [sp, #20]
    2c72:	3304      	adds	r3, #4
    2c74:	4618      	mov	r0, r3
    2c76:	f7ff ff1b 	bl	2ab0 <osalEventObjectInit>
  sdp->state = SD_STOP;
    2c7a:	9b05      	ldr	r3, [sp, #20]
    2c7c:	2201      	movs	r2, #1
    2c7e:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    2c80:	9b05      	ldr	r3, [sp, #20]
    2c82:	f103 020c 	add.w	r2, r3, #12
    2c86:	9b05      	ldr	r3, [sp, #20]
    2c88:	3354      	adds	r3, #84	; 0x54
    2c8a:	9905      	ldr	r1, [sp, #20]
    2c8c:	9100      	str	r1, [sp, #0]
    2c8e:	4610      	mov	r0, r2
    2c90:	4619      	mov	r1, r3
    2c92:	2240      	movs	r2, #64	; 0x40
    2c94:	9b04      	ldr	r3, [sp, #16]
    2c96:	f7ff f9cb 	bl	2030 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    2c9a:	9b05      	ldr	r3, [sp, #20]
    2c9c:	f103 0230 	add.w	r2, r3, #48	; 0x30
    2ca0:	9b05      	ldr	r3, [sp, #20]
    2ca2:	3394      	adds	r3, #148	; 0x94
    2ca4:	9905      	ldr	r1, [sp, #20]
    2ca6:	9100      	str	r1, [sp, #0]
    2ca8:	4610      	mov	r0, r2
    2caa:	4619      	mov	r1, r3
    2cac:	2240      	movs	r2, #64	; 0x40
    2cae:	9b03      	ldr	r3, [sp, #12]
    2cb0:	f7ff fac6 	bl	2240 <chOQObjectInit>
}
    2cb4:	b007      	add	sp, #28
    2cb6:	f85d fb04 	ldr.w	pc, [sp], #4
    2cba:	bf00      	nop
    2cbc:	000047a0 	.word	0x000047a0

00002cc0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    2cc0:	b500      	push	{lr}
    2cc2:	b083      	sub	sp, #12
    2cc4:	9001      	str	r0, [sp, #4]
    2cc6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);
    2cc8:	9b01      	ldr	r3, [sp, #4]
    2cca:	2b00      	cmp	r3, #0
    2ccc:	d102      	bne.n	2cd4 <sdStart+0x14>
    2cce:	480e      	ldr	r0, [pc, #56]	; (2d08 <sdStart+0x48>)
    2cd0:	f7fd fcee 	bl	6b0 <chSysHalt>

  osalSysLock();
    2cd4:	f7ff fedc 	bl	2a90 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
    2cd8:	9b01      	ldr	r3, [sp, #4]
    2cda:	7a1b      	ldrb	r3, [r3, #8]
    2cdc:	2b01      	cmp	r3, #1
    2cde:	d006      	beq.n	2cee <sdStart+0x2e>
    2ce0:	9b01      	ldr	r3, [sp, #4]
    2ce2:	7a1b      	ldrb	r3, [r3, #8]
    2ce4:	2b02      	cmp	r3, #2
    2ce6:	d002      	beq.n	2cee <sdStart+0x2e>
    2ce8:	4807      	ldr	r0, [pc, #28]	; (2d08 <sdStart+0x48>)
    2cea:	f7fd fce1 	bl	6b0 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
    2cee:	9801      	ldr	r0, [sp, #4]
    2cf0:	9900      	ldr	r1, [sp, #0]
    2cf2:	f001 f93d 	bl	3f70 <sd_lld_start>
  sdp->state = SD_READY;
    2cf6:	9b01      	ldr	r3, [sp, #4]
    2cf8:	2202      	movs	r2, #2
    2cfa:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
    2cfc:	f7ff fed0 	bl	2aa0 <osalSysUnlock>
}
    2d00:	b003      	add	sp, #12
    2d02:	f85d fb04 	ldr.w	pc, [sp], #4
    2d06:	bf00      	nop
    2d08:	000047c0 	.word	0x000047c0
    2d0c:	f3af 8000 	nop.w

00002d10 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    2d10:	b500      	push	{lr}
    2d12:	b083      	sub	sp, #12
    2d14:	9001      	str	r0, [sp, #4]
    2d16:	460b      	mov	r3, r1
    2d18:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
    2d1c:	f7fd fdd0 	bl	8c0 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
    2d20:	9b01      	ldr	r3, [sp, #4]
    2d22:	2b00      	cmp	r3, #0
    2d24:	d102      	bne.n	2d2c <sdIncomingDataI+0x1c>
    2d26:	4813      	ldr	r0, [pc, #76]	; (2d74 <sdIncomingDataI+0x64>)
    2d28:	f7fd fcc2 	bl	6b0 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
    2d2c:	9b01      	ldr	r3, [sp, #4]
    2d2e:	330c      	adds	r3, #12
    2d30:	4618      	mov	r0, r3
    2d32:	f7ff fe9d 	bl	2a70 <chIQIsEmptyI>
    2d36:	4603      	mov	r3, r0
    2d38:	2b00      	cmp	r3, #0
    2d3a:	d005      	beq.n	2d48 <sdIncomingDataI+0x38>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    2d3c:	9b01      	ldr	r3, [sp, #4]
    2d3e:	3304      	adds	r3, #4
    2d40:	4618      	mov	r0, r3
    2d42:	2104      	movs	r1, #4
    2d44:	f7ff fec4 	bl	2ad0 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
    2d48:	9b01      	ldr	r3, [sp, #4]
    2d4a:	f103 020c 	add.w	r2, r3, #12
    2d4e:	f89d 3003 	ldrb.w	r3, [sp, #3]
    2d52:	4610      	mov	r0, r2
    2d54:	4619      	mov	r1, r3
    2d56:	f7ff f993 	bl	2080 <chIQPutI>
    2d5a:	4603      	mov	r3, r0
    2d5c:	2b00      	cmp	r3, #0
    2d5e:	da05      	bge.n	2d6c <sdIncomingDataI+0x5c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    2d60:	9b01      	ldr	r3, [sp, #4]
    2d62:	3304      	adds	r3, #4
    2d64:	4618      	mov	r0, r3
    2d66:	2180      	movs	r1, #128	; 0x80
    2d68:	f7ff feb2 	bl	2ad0 <osalEventBroadcastFlagsI>
}
    2d6c:	b003      	add	sp, #12
    2d6e:	f85d fb04 	ldr.w	pc, [sp], #4
    2d72:	bf00      	nop
    2d74:	000047e0 	.word	0x000047e0
    2d78:	f3af 8000 	nop.w
    2d7c:	f3af 8000 	nop.w

00002d80 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
    2d80:	b082      	sub	sp, #8
    2d82:	9001      	str	r0, [sp, #4]
    2d84:	9100      	str	r1, [sp, #0]

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
    2d86:	4911      	ldr	r1, [pc, #68]	; (2dcc <nvicEnableVector+0x4c>)
    2d88:	9b00      	ldr	r3, [sp, #0]
    2d8a:	b2db      	uxtb	r3, r3
    2d8c:	011b      	lsls	r3, r3, #4
    2d8e:	b2da      	uxtb	r2, r3
    2d90:	9b01      	ldr	r3, [sp, #4]
    2d92:	440b      	add	r3, r1
    2d94:	f503 7340 	add.w	r3, r3, #768	; 0x300
    2d98:	701a      	strb	r2, [r3, #0]
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
    2d9a:	4b0c      	ldr	r3, [pc, #48]	; (2dcc <nvicEnableVector+0x4c>)
    2d9c:	9a01      	ldr	r2, [sp, #4]
    2d9e:	0952      	lsrs	r2, r2, #5
    2da0:	9901      	ldr	r1, [sp, #4]
    2da2:	f001 011f 	and.w	r1, r1, #31
    2da6:	2001      	movs	r0, #1
    2da8:	fa00 f101 	lsl.w	r1, r0, r1
    2dac:	3260      	adds	r2, #96	; 0x60
    2dae:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
    2db2:	4b06      	ldr	r3, [pc, #24]	; (2dcc <nvicEnableVector+0x4c>)
    2db4:	9a01      	ldr	r2, [sp, #4]
    2db6:	0952      	lsrs	r2, r2, #5
    2db8:	9901      	ldr	r1, [sp, #4]
    2dba:	f001 011f 	and.w	r1, r1, #31
    2dbe:	2001      	movs	r0, #1
    2dc0:	fa00 f101 	lsl.w	r1, r0, r1
    2dc4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    2dc8:	b002      	add	sp, #8
    2dca:	4770      	bx	lr
    2dcc:	e000e100 	.word	0xe000e100

00002dd0 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
    2dd0:	4b0d      	ldr	r3, [pc, #52]	; (2e08 <hal_lld_backup_domain_init+0x38>)
    2dd2:	4a0d      	ldr	r2, [pc, #52]	; (2e08 <hal_lld_backup_domain_init+0x38>)
    2dd4:	6812      	ldr	r2, [r2, #0]
    2dd6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    2dda:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
    2ddc:	4b0b      	ldr	r3, [pc, #44]	; (2e0c <hal_lld_backup_domain_init+0x3c>)
    2dde:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    2de0:	f403 7340 	and.w	r3, r3, #768	; 0x300
    2de4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    2de8:	d006      	beq.n	2df8 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
    2dea:	4b08      	ldr	r3, [pc, #32]	; (2e0c <hal_lld_backup_domain_init+0x3c>)
    2dec:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    2df0:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
    2df2:	4b06      	ldr	r3, [pc, #24]	; (2e0c <hal_lld_backup_domain_init+0x3c>)
    2df4:	2200      	movs	r2, #0
    2df6:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
    2df8:	4b03      	ldr	r3, [pc, #12]	; (2e08 <hal_lld_backup_domain_init+0x38>)
    2dfa:	4a03      	ldr	r2, [pc, #12]	; (2e08 <hal_lld_backup_domain_init+0x38>)
    2dfc:	6852      	ldr	r2, [r2, #4]
    2dfe:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    2e02:	605a      	str	r2, [r3, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
    2e04:	4770      	bx	lr
    2e06:	bf00      	nop
    2e08:	40007000 	.word	0x40007000
    2e0c:	40023800 	.word	0x40023800

00002e10 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
    2e10:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
    2e12:	4b17      	ldr	r3, [pc, #92]	; (2e70 <hal_lld_init+0x60>)
    2e14:	691b      	ldr	r3, [r3, #16]
    2e16:	4b16      	ldr	r3, [pc, #88]	; (2e70 <hal_lld_init+0x60>)
    2e18:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2e1c:	611a      	str	r2, [r3, #16]
    2e1e:	4b14      	ldr	r3, [pc, #80]	; (2e70 <hal_lld_init+0x60>)
    2e20:	2200      	movs	r2, #0
    2e22:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
    2e24:	4b12      	ldr	r3, [pc, #72]	; (2e70 <hal_lld_init+0x60>)
    2e26:	695b      	ldr	r3, [r3, #20]
    2e28:	4b11      	ldr	r3, [pc, #68]	; (2e70 <hal_lld_init+0x60>)
    2e2a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2e2e:	615a      	str	r2, [r3, #20]
    2e30:	4b0f      	ldr	r3, [pc, #60]	; (2e70 <hal_lld_init+0x60>)
    2e32:	2200      	movs	r2, #0
    2e34:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
    2e36:	4b0e      	ldr	r3, [pc, #56]	; (2e70 <hal_lld_init+0x60>)
    2e38:	4a0d      	ldr	r2, [pc, #52]	; (2e70 <hal_lld_init+0x60>)
    2e3a:	6a12      	ldr	r2, [r2, #32]
    2e3c:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
    2e40:	621a      	str	r2, [r3, #32]
    2e42:	4b0b      	ldr	r3, [pc, #44]	; (2e70 <hal_lld_init+0x60>)
    2e44:	2200      	movs	r2, #0
    2e46:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
    2e48:	4b09      	ldr	r3, [pc, #36]	; (2e70 <hal_lld_init+0x60>)
    2e4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2e4c:	4b08      	ldr	r3, [pc, #32]	; (2e70 <hal_lld_init+0x60>)
    2e4e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2e52:	625a      	str	r2, [r3, #36]	; 0x24
    2e54:	4b06      	ldr	r3, [pc, #24]	; (2e70 <hal_lld_init+0x60>)
    2e56:	2200      	movs	r2, #0
    2e58:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
    2e5a:	4b05      	ldr	r3, [pc, #20]	; (2e70 <hal_lld_init+0x60>)
    2e5c:	4a04      	ldr	r2, [pc, #16]	; (2e70 <hal_lld_init+0x60>)
    2e5e:	6c12      	ldr	r2, [r2, #64]	; 0x40
    2e60:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    2e64:	641a      	str	r2, [r3, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
    2e66:	f7ff ffb3 	bl	2dd0 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
    2e6a:	f000 fb19 	bl	34a0 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
    2e6e:	bd08      	pop	{r3, pc}
    2e70:	40023800 	.word	0x40023800
    2e74:	f3af 8000 	nop.w
    2e78:	f3af 8000 	nop.w
    2e7c:	f3af 8000 	nop.w

00002e80 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
    2e80:	4b40      	ldr	r3, [pc, #256]	; (2f84 <stm32_clock_init+0x104>)
    2e82:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    2e86:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
    2e88:	4b3f      	ldr	r3, [pc, #252]	; (2f88 <stm32_clock_init+0x108>)
    2e8a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    2e8e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
    2e90:	4b3c      	ldr	r3, [pc, #240]	; (2f84 <stm32_clock_init+0x104>)
    2e92:	4a3c      	ldr	r2, [pc, #240]	; (2f84 <stm32_clock_init+0x104>)
    2e94:	6812      	ldr	r2, [r2, #0]
    2e96:	f042 0201 	orr.w	r2, r2, #1
    2e9a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
    2e9c:	bf00      	nop
    2e9e:	4b39      	ldr	r3, [pc, #228]	; (2f84 <stm32_clock_init+0x104>)
    2ea0:	681b      	ldr	r3, [r3, #0]
    2ea2:	f003 0302 	and.w	r3, r3, #2
    2ea6:	2b00      	cmp	r3, #0
    2ea8:	d0f9      	beq.n	2e9e <stm32_clock_init+0x1e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
    2eaa:	4b36      	ldr	r3, [pc, #216]	; (2f84 <stm32_clock_init+0x104>)
    2eac:	4a35      	ldr	r2, [pc, #212]	; (2f84 <stm32_clock_init+0x104>)
    2eae:	6892      	ldr	r2, [r2, #8]
    2eb0:	f022 0203 	bic.w	r2, r2, #3
    2eb4:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
    2eb6:	4b33      	ldr	r3, [pc, #204]	; (2f84 <stm32_clock_init+0x104>)
    2eb8:	4a32      	ldr	r2, [pc, #200]	; (2f84 <stm32_clock_init+0x104>)
    2eba:	6892      	ldr	r2, [r2, #8]
    2ebc:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
    2ebe:	bf00      	nop
    2ec0:	4b30      	ldr	r3, [pc, #192]	; (2f84 <stm32_clock_init+0x104>)
    2ec2:	689b      	ldr	r3, [r3, #8]
    2ec4:	f003 030c 	and.w	r3, r3, #12
    2ec8:	2b00      	cmp	r3, #0
    2eca:	d1f9      	bne.n	2ec0 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
    2ecc:	4b2d      	ldr	r3, [pc, #180]	; (2f84 <stm32_clock_init+0x104>)
    2ece:	4a2d      	ldr	r2, [pc, #180]	; (2f84 <stm32_clock_init+0x104>)
    2ed0:	6812      	ldr	r2, [r2, #0]
    2ed2:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
    2ed6:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
    2ed8:	4b2a      	ldr	r3, [pc, #168]	; (2f84 <stm32_clock_init+0x104>)
    2eda:	2200      	movs	r2, #0
    2edc:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
    2ede:	4b29      	ldr	r3, [pc, #164]	; (2f84 <stm32_clock_init+0x104>)
    2ee0:	4a28      	ldr	r2, [pc, #160]	; (2f84 <stm32_clock_init+0x104>)
    2ee2:	6812      	ldr	r2, [r2, #0]
    2ee4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    2ee8:	601a      	str	r2, [r3, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
    2eea:	bf00      	nop
    2eec:	4b25      	ldr	r3, [pc, #148]	; (2f84 <stm32_clock_init+0x104>)
    2eee:	681b      	ldr	r3, [r3, #0]
    2ef0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    2ef4:	2b00      	cmp	r3, #0
    2ef6:	d0f9      	beq.n	2eec <stm32_clock_init+0x6c>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
    2ef8:	4b22      	ldr	r3, [pc, #136]	; (2f84 <stm32_clock_init+0x104>)
    2efa:	4a22      	ldr	r2, [pc, #136]	; (2f84 <stm32_clock_init+0x104>)
    2efc:	6f52      	ldr	r2, [r2, #116]	; 0x74
    2efe:	f042 0201 	orr.w	r2, r2, #1
    2f02:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
    2f04:	bf00      	nop
    2f06:	4b1f      	ldr	r3, [pc, #124]	; (2f84 <stm32_clock_init+0x104>)
    2f08:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    2f0a:	f003 0302 	and.w	r3, r3, #2
    2f0e:	2b00      	cmp	r3, #0
    2f10:	d0f9      	beq.n	2f06 <stm32_clock_init+0x86>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
    2f12:	4b1c      	ldr	r3, [pc, #112]	; (2f84 <stm32_clock_init+0x104>)
    2f14:	4a1d      	ldr	r2, [pc, #116]	; (2f8c <stm32_clock_init+0x10c>)
    2f16:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
    2f18:	4b1a      	ldr	r3, [pc, #104]	; (2f84 <stm32_clock_init+0x104>)
    2f1a:	4a1a      	ldr	r2, [pc, #104]	; (2f84 <stm32_clock_init+0x104>)
    2f1c:	6812      	ldr	r2, [r2, #0]
    2f1e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    2f22:	601a      	str	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
    2f24:	bf00      	nop
    2f26:	4b18      	ldr	r3, [pc, #96]	; (2f88 <stm32_clock_init+0x108>)
    2f28:	685b      	ldr	r3, [r3, #4]
    2f2a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    2f2e:	2b00      	cmp	r3, #0
    2f30:	d0f9      	beq.n	2f26 <stm32_clock_init+0xa6>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
    2f32:	bf00      	nop
    2f34:	4b13      	ldr	r3, [pc, #76]	; (2f84 <stm32_clock_init+0x104>)
    2f36:	681b      	ldr	r3, [r3, #0]
    2f38:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    2f3c:	2b00      	cmp	r3, #0
    2f3e:	d0f9      	beq.n	2f34 <stm32_clock_init+0xb4>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
    2f40:	4b10      	ldr	r3, [pc, #64]	; (2f84 <stm32_clock_init+0x104>)
    2f42:	4a13      	ldr	r2, [pc, #76]	; (2f90 <stm32_clock_init+0x110>)
    2f44:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
    2f46:	4b13      	ldr	r3, [pc, #76]	; (2f94 <stm32_clock_init+0x114>)
    2f48:	f240 7205 	movw	r2, #1797	; 0x705
    2f4c:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
    2f4e:	4b0d      	ldr	r3, [pc, #52]	; (2f84 <stm32_clock_init+0x104>)
    2f50:	4a0c      	ldr	r2, [pc, #48]	; (2f84 <stm32_clock_init+0x104>)
    2f52:	6892      	ldr	r2, [r2, #8]
    2f54:	f042 0202 	orr.w	r2, r2, #2
    2f58:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
    2f5a:	bf00      	nop
    2f5c:	4b09      	ldr	r3, [pc, #36]	; (2f84 <stm32_clock_init+0x104>)
    2f5e:	689b      	ldr	r3, [r3, #8]
    2f60:	f003 030c 	and.w	r3, r3, #12
    2f64:	2b08      	cmp	r3, #8
    2f66:	d1f9      	bne.n	2f5c <stm32_clock_init+0xdc>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
    2f68:	4b06      	ldr	r3, [pc, #24]	; (2f84 <stm32_clock_init+0x104>)
    2f6a:	4a06      	ldr	r2, [pc, #24]	; (2f84 <stm32_clock_init+0x104>)
    2f6c:	6c52      	ldr	r2, [r2, #68]	; 0x44
    2f6e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    2f72:	645a      	str	r2, [r3, #68]	; 0x44
    2f74:	4b03      	ldr	r3, [pc, #12]	; (2f84 <stm32_clock_init+0x104>)
    2f76:	4a03      	ldr	r2, [pc, #12]	; (2f84 <stm32_clock_init+0x104>)
    2f78:	6e52      	ldr	r2, [r2, #100]	; 0x64
    2f7a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    2f7e:	665a      	str	r2, [r3, #100]	; 0x64
}
    2f80:	4770      	bx	lr
    2f82:	bf00      	nop
    2f84:	40023800 	.word	0x40023800
    2f88:	40007000 	.word	0x40007000
    2f8c:	07405408 	.word	0x07405408
    2f90:	38089400 	.word	0x38089400
    2f94:	40023c00 	.word	0x40023c00
    2f98:	f3af 8000 	nop.w
    2f9c:	f3af 8000 	nop.w

00002fa0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
    2fa0:	b500      	push	{lr}
    2fa2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2fa4:	f7fe fc64 	bl	1870 <_stats_increase_irq>
    2fa8:	f7fd fc4a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
    2fac:	4b0c      	ldr	r3, [pc, #48]	; (2fe0 <Vector6C+0x40>)
    2fae:	681b      	ldr	r3, [r3, #0]
    2fb0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    2fb4:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
    2fb6:	4b0a      	ldr	r3, [pc, #40]	; (2fe0 <Vector6C+0x40>)
    2fb8:	9a01      	ldr	r2, [sp, #4]
    2fba:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[0].dma_func)
    2fbc:	4b09      	ldr	r3, [pc, #36]	; (2fe4 <Vector6C+0x44>)
    2fbe:	681b      	ldr	r3, [r3, #0]
    2fc0:	2b00      	cmp	r3, #0
    2fc2:	d006      	beq.n	2fd2 <Vector6C+0x32>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
    2fc4:	4b07      	ldr	r3, [pc, #28]	; (2fe4 <Vector6C+0x44>)
    2fc6:	681b      	ldr	r3, [r3, #0]
    2fc8:	4a06      	ldr	r2, [pc, #24]	; (2fe4 <Vector6C+0x44>)
    2fca:	6852      	ldr	r2, [r2, #4]
    2fcc:	4610      	mov	r0, r2
    2fce:	9901      	ldr	r1, [sp, #4]
    2fd0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    2fd2:	f7fd fc55 	bl	880 <_dbg_check_leave_isr>
    2fd6:	f7ff fc0b 	bl	27f0 <_port_irq_epilogue>
}
    2fda:	b003      	add	sp, #12
    2fdc:	f85d fb04 	ldr.w	pc, [sp], #4
    2fe0:	40026000 	.word	0x40026000
    2fe4:	20000e04 	.word	0x20000e04
    2fe8:	f3af 8000 	nop.w
    2fec:	f3af 8000 	nop.w

00002ff0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
    2ff0:	b500      	push	{lr}
    2ff2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    2ff4:	f7fe fc3c 	bl	1870 <_stats_increase_irq>
    2ff8:	f7fd fc22 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
    2ffc:	4b0d      	ldr	r3, [pc, #52]	; (3034 <Vector70+0x44>)
    2ffe:	681b      	ldr	r3, [r3, #0]
    3000:	099b      	lsrs	r3, r3, #6
    3002:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3006:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
    3008:	4b0a      	ldr	r3, [pc, #40]	; (3034 <Vector70+0x44>)
    300a:	9a01      	ldr	r2, [sp, #4]
    300c:	0192      	lsls	r2, r2, #6
    300e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[1].dma_func)
    3010:	4b09      	ldr	r3, [pc, #36]	; (3038 <Vector70+0x48>)
    3012:	689b      	ldr	r3, [r3, #8]
    3014:	2b00      	cmp	r3, #0
    3016:	d006      	beq.n	3026 <Vector70+0x36>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
    3018:	4b07      	ldr	r3, [pc, #28]	; (3038 <Vector70+0x48>)
    301a:	689b      	ldr	r3, [r3, #8]
    301c:	4a06      	ldr	r2, [pc, #24]	; (3038 <Vector70+0x48>)
    301e:	68d2      	ldr	r2, [r2, #12]
    3020:	4610      	mov	r0, r2
    3022:	9901      	ldr	r1, [sp, #4]
    3024:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3026:	f7fd fc2b 	bl	880 <_dbg_check_leave_isr>
    302a:	f7ff fbe1 	bl	27f0 <_port_irq_epilogue>
}
    302e:	b003      	add	sp, #12
    3030:	f85d fb04 	ldr.w	pc, [sp], #4
    3034:	40026000 	.word	0x40026000
    3038:	20000e04 	.word	0x20000e04
    303c:	f3af 8000 	nop.w

00003040 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
    3040:	b500      	push	{lr}
    3042:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3044:	f7fe fc14 	bl	1870 <_stats_increase_irq>
    3048:	f7fd fbfa 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
    304c:	4b0d      	ldr	r3, [pc, #52]	; (3084 <Vector74+0x44>)
    304e:	681b      	ldr	r3, [r3, #0]
    3050:	0c1b      	lsrs	r3, r3, #16
    3052:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3056:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
    3058:	4b0a      	ldr	r3, [pc, #40]	; (3084 <Vector74+0x44>)
    305a:	9a01      	ldr	r2, [sp, #4]
    305c:	0412      	lsls	r2, r2, #16
    305e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[2].dma_func)
    3060:	4b09      	ldr	r3, [pc, #36]	; (3088 <Vector74+0x48>)
    3062:	691b      	ldr	r3, [r3, #16]
    3064:	2b00      	cmp	r3, #0
    3066:	d006      	beq.n	3076 <Vector74+0x36>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
    3068:	4b07      	ldr	r3, [pc, #28]	; (3088 <Vector74+0x48>)
    306a:	691b      	ldr	r3, [r3, #16]
    306c:	4a06      	ldr	r2, [pc, #24]	; (3088 <Vector74+0x48>)
    306e:	6952      	ldr	r2, [r2, #20]
    3070:	4610      	mov	r0, r2
    3072:	9901      	ldr	r1, [sp, #4]
    3074:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3076:	f7fd fc03 	bl	880 <_dbg_check_leave_isr>
    307a:	f7ff fbb9 	bl	27f0 <_port_irq_epilogue>
}
    307e:	b003      	add	sp, #12
    3080:	f85d fb04 	ldr.w	pc, [sp], #4
    3084:	40026000 	.word	0x40026000
    3088:	20000e04 	.word	0x20000e04
    308c:	f3af 8000 	nop.w

00003090 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
    3090:	b500      	push	{lr}
    3092:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3094:	f7fe fbec 	bl	1870 <_stats_increase_irq>
    3098:	f7fd fbd2 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
    309c:	4b0d      	ldr	r3, [pc, #52]	; (30d4 <Vector78+0x44>)
    309e:	681b      	ldr	r3, [r3, #0]
    30a0:	0d9b      	lsrs	r3, r3, #22
    30a2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    30a6:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
    30a8:	4b0a      	ldr	r3, [pc, #40]	; (30d4 <Vector78+0x44>)
    30aa:	9a01      	ldr	r2, [sp, #4]
    30ac:	0592      	lsls	r2, r2, #22
    30ae:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[3].dma_func)
    30b0:	4b09      	ldr	r3, [pc, #36]	; (30d8 <Vector78+0x48>)
    30b2:	699b      	ldr	r3, [r3, #24]
    30b4:	2b00      	cmp	r3, #0
    30b6:	d006      	beq.n	30c6 <Vector78+0x36>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
    30b8:	4b07      	ldr	r3, [pc, #28]	; (30d8 <Vector78+0x48>)
    30ba:	699b      	ldr	r3, [r3, #24]
    30bc:	4a06      	ldr	r2, [pc, #24]	; (30d8 <Vector78+0x48>)
    30be:	69d2      	ldr	r2, [r2, #28]
    30c0:	4610      	mov	r0, r2
    30c2:	9901      	ldr	r1, [sp, #4]
    30c4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    30c6:	f7fd fbdb 	bl	880 <_dbg_check_leave_isr>
    30ca:	f7ff fb91 	bl	27f0 <_port_irq_epilogue>
}
    30ce:	b003      	add	sp, #12
    30d0:	f85d fb04 	ldr.w	pc, [sp], #4
    30d4:	40026000 	.word	0x40026000
    30d8:	20000e04 	.word	0x20000e04
    30dc:	f3af 8000 	nop.w

000030e0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
    30e0:	b500      	push	{lr}
    30e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    30e4:	f7fe fbc4 	bl	1870 <_stats_increase_irq>
    30e8:	f7fd fbaa 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
    30ec:	4b0c      	ldr	r3, [pc, #48]	; (3120 <Vector7C+0x40>)
    30ee:	685b      	ldr	r3, [r3, #4]
    30f0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    30f4:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
    30f6:	4b0a      	ldr	r3, [pc, #40]	; (3120 <Vector7C+0x40>)
    30f8:	9a01      	ldr	r2, [sp, #4]
    30fa:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[4].dma_func)
    30fc:	4b09      	ldr	r3, [pc, #36]	; (3124 <Vector7C+0x44>)
    30fe:	6a1b      	ldr	r3, [r3, #32]
    3100:	2b00      	cmp	r3, #0
    3102:	d006      	beq.n	3112 <Vector7C+0x32>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
    3104:	4b07      	ldr	r3, [pc, #28]	; (3124 <Vector7C+0x44>)
    3106:	6a1b      	ldr	r3, [r3, #32]
    3108:	4a06      	ldr	r2, [pc, #24]	; (3124 <Vector7C+0x44>)
    310a:	6a52      	ldr	r2, [r2, #36]	; 0x24
    310c:	4610      	mov	r0, r2
    310e:	9901      	ldr	r1, [sp, #4]
    3110:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3112:	f7fd fbb5 	bl	880 <_dbg_check_leave_isr>
    3116:	f7ff fb6b 	bl	27f0 <_port_irq_epilogue>
}
    311a:	b003      	add	sp, #12
    311c:	f85d fb04 	ldr.w	pc, [sp], #4
    3120:	40026000 	.word	0x40026000
    3124:	20000e04 	.word	0x20000e04
    3128:	f3af 8000 	nop.w
    312c:	f3af 8000 	nop.w

00003130 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
    3130:	b500      	push	{lr}
    3132:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3134:	f7fe fb9c 	bl	1870 <_stats_increase_irq>
    3138:	f7fd fb82 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
    313c:	4b0d      	ldr	r3, [pc, #52]	; (3174 <Vector80+0x44>)
    313e:	685b      	ldr	r3, [r3, #4]
    3140:	099b      	lsrs	r3, r3, #6
    3142:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3146:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
    3148:	4b0a      	ldr	r3, [pc, #40]	; (3174 <Vector80+0x44>)
    314a:	9a01      	ldr	r2, [sp, #4]
    314c:	0192      	lsls	r2, r2, #6
    314e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[5].dma_func)
    3150:	4b09      	ldr	r3, [pc, #36]	; (3178 <Vector80+0x48>)
    3152:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3154:	2b00      	cmp	r3, #0
    3156:	d006      	beq.n	3166 <Vector80+0x36>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
    3158:	4b07      	ldr	r3, [pc, #28]	; (3178 <Vector80+0x48>)
    315a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    315c:	4a06      	ldr	r2, [pc, #24]	; (3178 <Vector80+0x48>)
    315e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    3160:	4610      	mov	r0, r2
    3162:	9901      	ldr	r1, [sp, #4]
    3164:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3166:	f7fd fb8b 	bl	880 <_dbg_check_leave_isr>
    316a:	f7ff fb41 	bl	27f0 <_port_irq_epilogue>
}
    316e:	b003      	add	sp, #12
    3170:	f85d fb04 	ldr.w	pc, [sp], #4
    3174:	40026000 	.word	0x40026000
    3178:	20000e04 	.word	0x20000e04
    317c:	f3af 8000 	nop.w

00003180 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
    3180:	b500      	push	{lr}
    3182:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3184:	f7fe fb74 	bl	1870 <_stats_increase_irq>
    3188:	f7fd fb5a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
    318c:	4b0d      	ldr	r3, [pc, #52]	; (31c4 <Vector84+0x44>)
    318e:	685b      	ldr	r3, [r3, #4]
    3190:	0c1b      	lsrs	r3, r3, #16
    3192:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3196:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
    3198:	4b0a      	ldr	r3, [pc, #40]	; (31c4 <Vector84+0x44>)
    319a:	9a01      	ldr	r2, [sp, #4]
    319c:	0412      	lsls	r2, r2, #16
    319e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[6].dma_func)
    31a0:	4b09      	ldr	r3, [pc, #36]	; (31c8 <Vector84+0x48>)
    31a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    31a4:	2b00      	cmp	r3, #0
    31a6:	d006      	beq.n	31b6 <Vector84+0x36>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
    31a8:	4b07      	ldr	r3, [pc, #28]	; (31c8 <Vector84+0x48>)
    31aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    31ac:	4a06      	ldr	r2, [pc, #24]	; (31c8 <Vector84+0x48>)
    31ae:	6b52      	ldr	r2, [r2, #52]	; 0x34
    31b0:	4610      	mov	r0, r2
    31b2:	9901      	ldr	r1, [sp, #4]
    31b4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    31b6:	f7fd fb63 	bl	880 <_dbg_check_leave_isr>
    31ba:	f7ff fb19 	bl	27f0 <_port_irq_epilogue>
}
    31be:	b003      	add	sp, #12
    31c0:	f85d fb04 	ldr.w	pc, [sp], #4
    31c4:	40026000 	.word	0x40026000
    31c8:	20000e04 	.word	0x20000e04
    31cc:	f3af 8000 	nop.w

000031d0 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
    31d0:	b500      	push	{lr}
    31d2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    31d4:	f7fe fb4c 	bl	1870 <_stats_increase_irq>
    31d8:	f7fd fb32 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
    31dc:	4b0d      	ldr	r3, [pc, #52]	; (3214 <VectorFC+0x44>)
    31de:	685b      	ldr	r3, [r3, #4]
    31e0:	0d9b      	lsrs	r3, r3, #22
    31e2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    31e6:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
    31e8:	4b0a      	ldr	r3, [pc, #40]	; (3214 <VectorFC+0x44>)
    31ea:	9a01      	ldr	r2, [sp, #4]
    31ec:	0592      	lsls	r2, r2, #22
    31ee:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[7].dma_func)
    31f0:	4b09      	ldr	r3, [pc, #36]	; (3218 <VectorFC+0x48>)
    31f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    31f4:	2b00      	cmp	r3, #0
    31f6:	d006      	beq.n	3206 <VectorFC+0x36>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
    31f8:	4b07      	ldr	r3, [pc, #28]	; (3218 <VectorFC+0x48>)
    31fa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    31fc:	4a06      	ldr	r2, [pc, #24]	; (3218 <VectorFC+0x48>)
    31fe:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
    3200:	4610      	mov	r0, r2
    3202:	9901      	ldr	r1, [sp, #4]
    3204:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3206:	f7fd fb3b 	bl	880 <_dbg_check_leave_isr>
    320a:	f7ff faf1 	bl	27f0 <_port_irq_epilogue>
}
    320e:	b003      	add	sp, #12
    3210:	f85d fb04 	ldr.w	pc, [sp], #4
    3214:	40026000 	.word	0x40026000
    3218:	20000e04 	.word	0x20000e04
    321c:	f3af 8000 	nop.w

00003220 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
    3220:	b500      	push	{lr}
    3222:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3224:	f7fe fb24 	bl	1870 <_stats_increase_irq>
    3228:	f7fd fb0a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
    322c:	4b0c      	ldr	r3, [pc, #48]	; (3260 <Vector120+0x40>)
    322e:	681b      	ldr	r3, [r3, #0]
    3230:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3234:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
    3236:	4b0a      	ldr	r3, [pc, #40]	; (3260 <Vector120+0x40>)
    3238:	9a01      	ldr	r2, [sp, #4]
    323a:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[8].dma_func)
    323c:	4b09      	ldr	r3, [pc, #36]	; (3264 <Vector120+0x44>)
    323e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3240:	2b00      	cmp	r3, #0
    3242:	d006      	beq.n	3252 <Vector120+0x32>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
    3244:	4b07      	ldr	r3, [pc, #28]	; (3264 <Vector120+0x44>)
    3246:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3248:	4a06      	ldr	r2, [pc, #24]	; (3264 <Vector120+0x44>)
    324a:	6c52      	ldr	r2, [r2, #68]	; 0x44
    324c:	4610      	mov	r0, r2
    324e:	9901      	ldr	r1, [sp, #4]
    3250:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3252:	f7fd fb15 	bl	880 <_dbg_check_leave_isr>
    3256:	f7ff facb 	bl	27f0 <_port_irq_epilogue>
}
    325a:	b003      	add	sp, #12
    325c:	f85d fb04 	ldr.w	pc, [sp], #4
    3260:	40026400 	.word	0x40026400
    3264:	20000e04 	.word	0x20000e04
    3268:	f3af 8000 	nop.w
    326c:	f3af 8000 	nop.w

00003270 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
    3270:	b500      	push	{lr}
    3272:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3274:	f7fe fafc 	bl	1870 <_stats_increase_irq>
    3278:	f7fd fae2 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
    327c:	4b0d      	ldr	r3, [pc, #52]	; (32b4 <Vector124+0x44>)
    327e:	681b      	ldr	r3, [r3, #0]
    3280:	099b      	lsrs	r3, r3, #6
    3282:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3286:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
    3288:	4b0a      	ldr	r3, [pc, #40]	; (32b4 <Vector124+0x44>)
    328a:	9a01      	ldr	r2, [sp, #4]
    328c:	0192      	lsls	r2, r2, #6
    328e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[9].dma_func)
    3290:	4b09      	ldr	r3, [pc, #36]	; (32b8 <Vector124+0x48>)
    3292:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3294:	2b00      	cmp	r3, #0
    3296:	d006      	beq.n	32a6 <Vector124+0x36>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
    3298:	4b07      	ldr	r3, [pc, #28]	; (32b8 <Vector124+0x48>)
    329a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    329c:	4a06      	ldr	r2, [pc, #24]	; (32b8 <Vector124+0x48>)
    329e:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    32a0:	4610      	mov	r0, r2
    32a2:	9901      	ldr	r1, [sp, #4]
    32a4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    32a6:	f7fd faeb 	bl	880 <_dbg_check_leave_isr>
    32aa:	f7ff faa1 	bl	27f0 <_port_irq_epilogue>
}
    32ae:	b003      	add	sp, #12
    32b0:	f85d fb04 	ldr.w	pc, [sp], #4
    32b4:	40026400 	.word	0x40026400
    32b8:	20000e04 	.word	0x20000e04
    32bc:	f3af 8000 	nop.w

000032c0 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
    32c0:	b500      	push	{lr}
    32c2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    32c4:	f7fe fad4 	bl	1870 <_stats_increase_irq>
    32c8:	f7fd faba 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
    32cc:	4b0d      	ldr	r3, [pc, #52]	; (3304 <Vector128+0x44>)
    32ce:	681b      	ldr	r3, [r3, #0]
    32d0:	0c1b      	lsrs	r3, r3, #16
    32d2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    32d6:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
    32d8:	4b0a      	ldr	r3, [pc, #40]	; (3304 <Vector128+0x44>)
    32da:	9a01      	ldr	r2, [sp, #4]
    32dc:	0412      	lsls	r2, r2, #16
    32de:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[10].dma_func)
    32e0:	4b09      	ldr	r3, [pc, #36]	; (3308 <Vector128+0x48>)
    32e2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    32e4:	2b00      	cmp	r3, #0
    32e6:	d006      	beq.n	32f6 <Vector128+0x36>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
    32e8:	4b07      	ldr	r3, [pc, #28]	; (3308 <Vector128+0x48>)
    32ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    32ec:	4a06      	ldr	r2, [pc, #24]	; (3308 <Vector128+0x48>)
    32ee:	6d52      	ldr	r2, [r2, #84]	; 0x54
    32f0:	4610      	mov	r0, r2
    32f2:	9901      	ldr	r1, [sp, #4]
    32f4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    32f6:	f7fd fac3 	bl	880 <_dbg_check_leave_isr>
    32fa:	f7ff fa79 	bl	27f0 <_port_irq_epilogue>
}
    32fe:	b003      	add	sp, #12
    3300:	f85d fb04 	ldr.w	pc, [sp], #4
    3304:	40026400 	.word	0x40026400
    3308:	20000e04 	.word	0x20000e04
    330c:	f3af 8000 	nop.w

00003310 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
    3310:	b500      	push	{lr}
    3312:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3314:	f7fe faac 	bl	1870 <_stats_increase_irq>
    3318:	f7fd fa92 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
    331c:	4b0d      	ldr	r3, [pc, #52]	; (3354 <Vector12C+0x44>)
    331e:	681b      	ldr	r3, [r3, #0]
    3320:	0d9b      	lsrs	r3, r3, #22
    3322:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3326:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
    3328:	4b0a      	ldr	r3, [pc, #40]	; (3354 <Vector12C+0x44>)
    332a:	9a01      	ldr	r2, [sp, #4]
    332c:	0592      	lsls	r2, r2, #22
    332e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[11].dma_func)
    3330:	4b09      	ldr	r3, [pc, #36]	; (3358 <Vector12C+0x48>)
    3332:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    3334:	2b00      	cmp	r3, #0
    3336:	d006      	beq.n	3346 <Vector12C+0x36>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
    3338:	4b07      	ldr	r3, [pc, #28]	; (3358 <Vector12C+0x48>)
    333a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    333c:	4a06      	ldr	r2, [pc, #24]	; (3358 <Vector12C+0x48>)
    333e:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
    3340:	4610      	mov	r0, r2
    3342:	9901      	ldr	r1, [sp, #4]
    3344:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3346:	f7fd fa9b 	bl	880 <_dbg_check_leave_isr>
    334a:	f7ff fa51 	bl	27f0 <_port_irq_epilogue>
}
    334e:	b003      	add	sp, #12
    3350:	f85d fb04 	ldr.w	pc, [sp], #4
    3354:	40026400 	.word	0x40026400
    3358:	20000e04 	.word	0x20000e04
    335c:	f3af 8000 	nop.w

00003360 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
    3360:	b500      	push	{lr}
    3362:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3364:	f7fe fa84 	bl	1870 <_stats_increase_irq>
    3368:	f7fd fa6a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
    336c:	4b0c      	ldr	r3, [pc, #48]	; (33a0 <Vector130+0x40>)
    336e:	685b      	ldr	r3, [r3, #4]
    3370:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3374:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
    3376:	4b0a      	ldr	r3, [pc, #40]	; (33a0 <Vector130+0x40>)
    3378:	9a01      	ldr	r2, [sp, #4]
    337a:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[12].dma_func)
    337c:	4b09      	ldr	r3, [pc, #36]	; (33a4 <Vector130+0x44>)
    337e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    3380:	2b00      	cmp	r3, #0
    3382:	d006      	beq.n	3392 <Vector130+0x32>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
    3384:	4b07      	ldr	r3, [pc, #28]	; (33a4 <Vector130+0x44>)
    3386:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    3388:	4a06      	ldr	r2, [pc, #24]	; (33a4 <Vector130+0x44>)
    338a:	6e52      	ldr	r2, [r2, #100]	; 0x64
    338c:	4610      	mov	r0, r2
    338e:	9901      	ldr	r1, [sp, #4]
    3390:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3392:	f7fd fa75 	bl	880 <_dbg_check_leave_isr>
    3396:	f7ff fa2b 	bl	27f0 <_port_irq_epilogue>
}
    339a:	b003      	add	sp, #12
    339c:	f85d fb04 	ldr.w	pc, [sp], #4
    33a0:	40026400 	.word	0x40026400
    33a4:	20000e04 	.word	0x20000e04
    33a8:	f3af 8000 	nop.w
    33ac:	f3af 8000 	nop.w

000033b0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
    33b0:	b500      	push	{lr}
    33b2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    33b4:	f7fe fa5c 	bl	1870 <_stats_increase_irq>
    33b8:	f7fd fa42 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
    33bc:	4b0d      	ldr	r3, [pc, #52]	; (33f4 <Vector150+0x44>)
    33be:	685b      	ldr	r3, [r3, #4]
    33c0:	099b      	lsrs	r3, r3, #6
    33c2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    33c6:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
    33c8:	4b0a      	ldr	r3, [pc, #40]	; (33f4 <Vector150+0x44>)
    33ca:	9a01      	ldr	r2, [sp, #4]
    33cc:	0192      	lsls	r2, r2, #6
    33ce:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[13].dma_func)
    33d0:	4b09      	ldr	r3, [pc, #36]	; (33f8 <Vector150+0x48>)
    33d2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    33d4:	2b00      	cmp	r3, #0
    33d6:	d006      	beq.n	33e6 <Vector150+0x36>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
    33d8:	4b07      	ldr	r3, [pc, #28]	; (33f8 <Vector150+0x48>)
    33da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    33dc:	4a06      	ldr	r2, [pc, #24]	; (33f8 <Vector150+0x48>)
    33de:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    33e0:	4610      	mov	r0, r2
    33e2:	9901      	ldr	r1, [sp, #4]
    33e4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    33e6:	f7fd fa4b 	bl	880 <_dbg_check_leave_isr>
    33ea:	f7ff fa01 	bl	27f0 <_port_irq_epilogue>
}
    33ee:	b003      	add	sp, #12
    33f0:	f85d fb04 	ldr.w	pc, [sp], #4
    33f4:	40026400 	.word	0x40026400
    33f8:	20000e04 	.word	0x20000e04
    33fc:	f3af 8000 	nop.w

00003400 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
    3400:	b500      	push	{lr}
    3402:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3404:	f7fe fa34 	bl	1870 <_stats_increase_irq>
    3408:	f7fd fa1a 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
    340c:	4b0d      	ldr	r3, [pc, #52]	; (3444 <Vector154+0x44>)
    340e:	685b      	ldr	r3, [r3, #4]
    3410:	0c1b      	lsrs	r3, r3, #16
    3412:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3416:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
    3418:	4b0a      	ldr	r3, [pc, #40]	; (3444 <Vector154+0x44>)
    341a:	9a01      	ldr	r2, [sp, #4]
    341c:	0412      	lsls	r2, r2, #16
    341e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[14].dma_func)
    3420:	4b09      	ldr	r3, [pc, #36]	; (3448 <Vector154+0x48>)
    3422:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    3424:	2b00      	cmp	r3, #0
    3426:	d006      	beq.n	3436 <Vector154+0x36>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
    3428:	4b07      	ldr	r3, [pc, #28]	; (3448 <Vector154+0x48>)
    342a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    342c:	4a06      	ldr	r2, [pc, #24]	; (3448 <Vector154+0x48>)
    342e:	6f52      	ldr	r2, [r2, #116]	; 0x74
    3430:	4610      	mov	r0, r2
    3432:	9901      	ldr	r1, [sp, #4]
    3434:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3436:	f7fd fa23 	bl	880 <_dbg_check_leave_isr>
    343a:	f7ff f9d9 	bl	27f0 <_port_irq_epilogue>
}
    343e:	b003      	add	sp, #12
    3440:	f85d fb04 	ldr.w	pc, [sp], #4
    3444:	40026400 	.word	0x40026400
    3448:	20000e04 	.word	0x20000e04
    344c:	f3af 8000 	nop.w

00003450 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
    3450:	b500      	push	{lr}
    3452:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3454:	f7fe fa0c 	bl	1870 <_stats_increase_irq>
    3458:	f7fd f9f2 	bl	840 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
    345c:	4b0d      	ldr	r3, [pc, #52]	; (3494 <Vector158+0x44>)
    345e:	685b      	ldr	r3, [r3, #4]
    3460:	0d9b      	lsrs	r3, r3, #22
    3462:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3466:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
    3468:	4b0a      	ldr	r3, [pc, #40]	; (3494 <Vector158+0x44>)
    346a:	9a01      	ldr	r2, [sp, #4]
    346c:	0592      	lsls	r2, r2, #22
    346e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[15].dma_func)
    3470:	4b09      	ldr	r3, [pc, #36]	; (3498 <Vector158+0x48>)
    3472:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    3474:	2b00      	cmp	r3, #0
    3476:	d006      	beq.n	3486 <Vector158+0x36>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
    3478:	4b07      	ldr	r3, [pc, #28]	; (3498 <Vector158+0x48>)
    347a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    347c:	4a06      	ldr	r2, [pc, #24]	; (3498 <Vector158+0x48>)
    347e:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
    3480:	4610      	mov	r0, r2
    3482:	9901      	ldr	r1, [sp, #4]
    3484:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3486:	f7fd f9fb 	bl	880 <_dbg_check_leave_isr>
    348a:	f7ff f9b1 	bl	27f0 <_port_irq_epilogue>
}
    348e:	b003      	add	sp, #12
    3490:	f85d fb04 	ldr.w	pc, [sp], #4
    3494:	40026400 	.word	0x40026400
    3498:	20000e04 	.word	0x20000e04
    349c:	f3af 8000 	nop.w

000034a0 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
    34a0:	b082      	sub	sp, #8
  unsigned i;

  dma_streams_mask = 0U;
    34a2:	4b16      	ldr	r3, [pc, #88]	; (34fc <dmaInit+0x5c>)
    34a4:	2200      	movs	r2, #0
    34a6:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    34a8:	2300      	movs	r3, #0
    34aa:	9301      	str	r3, [sp, #4]
    34ac:	e011      	b.n	34d2 <dmaInit+0x32>
    _stm32_dma_streams[i].stream->CR = 0U;
    34ae:	4914      	ldr	r1, [pc, #80]	; (3500 <dmaInit+0x60>)
    34b0:	9a01      	ldr	r2, [sp, #4]
    34b2:	4613      	mov	r3, r2
    34b4:	005b      	lsls	r3, r3, #1
    34b6:	4413      	add	r3, r2
    34b8:	009b      	lsls	r3, r3, #2
    34ba:	440b      	add	r3, r1
    34bc:	681b      	ldr	r3, [r3, #0]
    34be:	2200      	movs	r2, #0
    34c0:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
    34c2:	4b10      	ldr	r3, [pc, #64]	; (3504 <dmaInit+0x64>)
    34c4:	9a01      	ldr	r2, [sp, #4]
    34c6:	2100      	movs	r1, #0
    34c8:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    34cc:	9b01      	ldr	r3, [sp, #4]
    34ce:	3301      	adds	r3, #1
    34d0:	9301      	str	r3, [sp, #4]
    34d2:	9b01      	ldr	r3, [sp, #4]
    34d4:	2b0f      	cmp	r3, #15
    34d6:	d9ea      	bls.n	34ae <dmaInit+0xe>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
    34d8:	4b0b      	ldr	r3, [pc, #44]	; (3508 <dmaInit+0x68>)
    34da:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    34de:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
    34e0:	4b09      	ldr	r3, [pc, #36]	; (3508 <dmaInit+0x68>)
    34e2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    34e6:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
    34e8:	4b08      	ldr	r3, [pc, #32]	; (350c <dmaInit+0x6c>)
    34ea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    34ee:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
    34f0:	4b06      	ldr	r3, [pc, #24]	; (350c <dmaInit+0x6c>)
    34f2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    34f6:	60da      	str	r2, [r3, #12]
}
    34f8:	b002      	add	sp, #8
    34fa:	4770      	bx	lr
    34fc:	20000e00 	.word	0x20000e00
    3500:	000047f0 	.word	0x000047f0
    3504:	20000e04 	.word	0x20000e04
    3508:	40026000 	.word	0x40026000
    350c:	40026400 	.word	0x40026400

00003510 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    3510:	b082      	sub	sp, #8
    3512:	2320      	movs	r3, #32
    3514:	9301      	str	r3, [sp, #4]
    3516:	9b01      	ldr	r3, [sp, #4]
    3518:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    351c:	b002      	add	sp, #8
    351e:	4770      	bx	lr

00003520 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    3520:	b082      	sub	sp, #8
    3522:	2300      	movs	r3, #0
    3524:	9301      	str	r3, [sp, #4]
    3526:	9b01      	ldr	r3, [sp, #4]
    3528:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    352c:	b002      	add	sp, #8
    352e:	4770      	bx	lr

00003530 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    3530:	b508      	push	{r3, lr}

  port_lock();
    3532:	f7ff ffed 	bl	3510 <port_lock>
}
    3536:	bd08      	pop	{r3, pc}
    3538:	f3af 8000 	nop.w
    353c:	f3af 8000 	nop.w

00003540 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    3540:	b508      	push	{r3, lr}

  port_unlock();
    3542:	f7ff ffed 	bl	3520 <port_unlock>
}
    3546:	bd08      	pop	{r3, pc}
    3548:	f3af 8000 	nop.w
    354c:	f3af 8000 	nop.w

00003550 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    3550:	b508      	push	{r3, lr}

  port_lock_from_isr();
    3552:	f7ff ffed 	bl	3530 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    3556:	f7fe f9cb 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    355a:	f7fd f941 	bl	7e0 <_dbg_check_lock_from_isr>
}
    355e:	bd08      	pop	{r3, pc}

00003560 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    3560:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    3562:	f7fd f955 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    3566:	f7fe f9cb 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    356a:	f7ff ffe9 	bl	3540 <port_unlock_from_isr>
}
    356e:	bd08      	pop	{r3, pc}

00003570 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    3570:	b508      	push	{r3, lr}

  chSysLockFromISR();
    3572:	f7ff ffed 	bl	3550 <chSysLockFromISR>
}
    3576:	bd08      	pop	{r3, pc}
    3578:	f3af 8000 	nop.w
    357c:	f3af 8000 	nop.w

00003580 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    3580:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    3582:	f7ff ffed 	bl	3560 <chSysUnlockFromISR>
}
    3586:	bd08      	pop	{r3, pc}
    3588:	f3af 8000 	nop.w
    358c:	f3af 8000 	nop.w

00003590 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
    3590:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
    3592:	f7fd f89d 	bl	6d0 <chSysTimerHandlerI>
}
    3596:	bd08      	pop	{r3, pc}
    3598:	f3af 8000 	nop.w
    359c:	f3af 8000 	nop.w

000035a0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
    35a0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    35a2:	f7fe f965 	bl	1870 <_stats_increase_irq>
    35a6:	f7fd f94b 	bl	840 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    35aa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    35ae:	691b      	ldr	r3, [r3, #16]
    35b0:	f003 0302 	and.w	r3, r3, #2
    35b4:	2b00      	cmp	r3, #0
    35b6:	d009      	beq.n	35cc <VectorB0+0x2c>
    STM32_ST_TIM->SR = 0U;
    35b8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    35bc:	2200      	movs	r2, #0
    35be:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
    35c0:	f7ff ffd6 	bl	3570 <osalSysLockFromISR>
    osalOsTimerHandlerI();
    35c4:	f7ff ffe4 	bl	3590 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
    35c8:	f7ff ffda 	bl	3580 <osalSysUnlockFromISR>
  }

  OSAL_IRQ_EPILOGUE();
    35cc:	f7fd f958 	bl	880 <_dbg_check_leave_isr>
    35d0:	f7ff f90e 	bl	27f0 <_port_irq_epilogue>
}
    35d4:	bd08      	pop	{r3, pc}
    35d6:	bf00      	nop
    35d8:	f3af 8000 	nop.w
    35dc:	f3af 8000 	nop.w

000035e0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
    35e0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
    35e2:	4b19      	ldr	r3, [pc, #100]	; (3648 <st_lld_init+0x68>)
    35e4:	4a18      	ldr	r2, [pc, #96]	; (3648 <st_lld_init+0x68>)
    35e6:	6c12      	ldr	r2, [r2, #64]	; 0x40
    35e8:	f042 0201 	orr.w	r2, r2, #1
    35ec:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
    35ee:	4b17      	ldr	r3, [pc, #92]	; (364c <st_lld_init+0x6c>)
    35f0:	4a16      	ldr	r2, [pc, #88]	; (364c <st_lld_init+0x6c>)
    35f2:	6892      	ldr	r2, [r2, #8]
    35f4:	f042 0201 	orr.w	r2, r2, #1
    35f8:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
    35fa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    35fe:	f242 02cf 	movw	r2, #8399	; 0x20cf
    3602:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
    3604:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3608:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    360c:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
    360e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3612:	2200      	movs	r2, #0
    3614:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
    3616:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    361a:	2200      	movs	r2, #0
    361c:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
    361e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3622:	2200      	movs	r2, #0
    3624:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
    3626:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    362a:	2200      	movs	r2, #0
    362c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
    362e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3632:	2201      	movs	r2, #1
    3634:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
    3636:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    363a:	2201      	movs	r2, #1
    363c:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
    363e:	201c      	movs	r0, #28
    3640:	2108      	movs	r1, #8
    3642:	f7ff fb9d 	bl	2d80 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    3646:	bd08      	pop	{r3, pc}
    3648:	40023800 	.word	0x40023800
    364c:	e0042000 	.word	0xe0042000

00003650 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    3650:	b082      	sub	sp, #8
    3652:	2320      	movs	r3, #32
    3654:	9301      	str	r3, [sp, #4]
    3656:	9b01      	ldr	r3, [sp, #4]
    3658:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    365c:	b002      	add	sp, #8
    365e:	4770      	bx	lr

00003660 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    3660:	b082      	sub	sp, #8
    3662:	2300      	movs	r3, #0
    3664:	9301      	str	r3, [sp, #4]
    3666:	9b01      	ldr	r3, [sp, #4]
    3668:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    366c:	b002      	add	sp, #8
    366e:	4770      	bx	lr

00003670 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    3670:	b508      	push	{r3, lr}

  port_lock();
    3672:	f7ff ffed 	bl	3650 <port_lock>
}
    3676:	bd08      	pop	{r3, pc}
    3678:	f3af 8000 	nop.w
    367c:	f3af 8000 	nop.w

00003680 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    3680:	b508      	push	{r3, lr}

  port_unlock();
    3682:	f7ff ffed 	bl	3660 <port_unlock>
}
    3686:	bd08      	pop	{r3, pc}
    3688:	f3af 8000 	nop.w
    368c:	f3af 8000 	nop.w

00003690 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    3690:	b508      	push	{r3, lr}

  port_lock_from_isr();
    3692:	f7ff ffed 	bl	3670 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    3696:	f7fe f92b 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    369a:	f7fd f8a1 	bl	7e0 <_dbg_check_lock_from_isr>
}
    369e:	bd08      	pop	{r3, pc}

000036a0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    36a0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    36a2:	f7fd f8b5 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    36a6:	f7fe f92b 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    36aa:	f7ff ffe9 	bl	3680 <port_unlock_from_isr>
}
    36ae:	bd08      	pop	{r3, pc}

000036b0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    36b0:	b508      	push	{r3, lr}

  chSysLockFromISR();
    36b2:	f7ff ffed 	bl	3690 <chSysLockFromISR>
}
    36b6:	bd08      	pop	{r3, pc}
    36b8:	f3af 8000 	nop.w
    36bc:	f3af 8000 	nop.w

000036c0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    36c0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    36c2:	f7ff ffed 	bl	36a0 <chSysUnlockFromISR>
}
    36c6:	bd08      	pop	{r3, pc}
    36c8:	f3af 8000 	nop.w
    36cc:	f3af 8000 	nop.w

000036d0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    36d0:	b500      	push	{lr}
    36d2:	b083      	sub	sp, #12
    36d4:	9001      	str	r0, [sp, #4]
    36d6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
    36d8:	9801      	ldr	r0, [sp, #4]
    36da:	9900      	ldr	r1, [sp, #0]
    36dc:	f7fd ff98 	bl	1610 <chThdResumeI>
}
    36e0:	b003      	add	sp, #12
    36e2:	f85d fb04 	ldr.w	pc, [sp], #4
    36e6:	bf00      	nop
    36e8:	f3af 8000 	nop.w
    36ec:	f3af 8000 	nop.w

000036f0 <Vector88>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
    36f0:	b500      	push	{lr}
    36f2:	b083      	sub	sp, #12
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();
    36f4:	f7fe f8bc 	bl	1870 <_stats_increase_irq>
    36f8:	f7fd f8a2 	bl	840 <_dbg_check_enter_isr>

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
    36fc:	4b58      	ldr	r3, [pc, #352]	; (3860 <Vector88+0x170>)
    36fe:	681b      	ldr	r3, [r3, #0]
    3700:	9301      	str	r3, [sp, #4]
  ADC1->SR = 0;
    3702:	4b57      	ldr	r3, [pc, #348]	; (3860 <Vector88+0x170>)
    3704:	2200      	movs	r2, #0
    3706:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    3708:	9b01      	ldr	r3, [sp, #4]
    370a:	f003 0320 	and.w	r3, r3, #32
    370e:	2b00      	cmp	r3, #0
    3710:	d02d      	beq.n	376e <Vector88+0x7e>
    3712:	4b54      	ldr	r3, [pc, #336]	; (3864 <Vector88+0x174>)
    3714:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3716:	681b      	ldr	r3, [r3, #0]
    3718:	685b      	ldr	r3, [r3, #4]
    371a:	2b00      	cmp	r3, #0
    371c:	d027      	beq.n	376e <Vector88+0x7e>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
    371e:	4b51      	ldr	r3, [pc, #324]	; (3864 <Vector88+0x174>)
    3720:	691b      	ldr	r3, [r3, #16]
    3722:	2b00      	cmp	r3, #0
    3724:	d023      	beq.n	376e <Vector88+0x7e>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    3726:	484f      	ldr	r0, [pc, #316]	; (3864 <Vector88+0x174>)
    3728:	f000 f8fa 	bl	3920 <adc_lld_stop_conversion>
    372c:	4b4d      	ldr	r3, [pc, #308]	; (3864 <Vector88+0x174>)
    372e:	691b      	ldr	r3, [r3, #16]
    3730:	689b      	ldr	r3, [r3, #8]
    3732:	2b00      	cmp	r3, #0
    3734:	d00f      	beq.n	3756 <Vector88+0x66>
    3736:	4b4b      	ldr	r3, [pc, #300]	; (3864 <Vector88+0x174>)
    3738:	2205      	movs	r2, #5
    373a:	701a      	strb	r2, [r3, #0]
    373c:	4b49      	ldr	r3, [pc, #292]	; (3864 <Vector88+0x174>)
    373e:	691b      	ldr	r3, [r3, #16]
    3740:	689b      	ldr	r3, [r3, #8]
    3742:	4848      	ldr	r0, [pc, #288]	; (3864 <Vector88+0x174>)
    3744:	2101      	movs	r1, #1
    3746:	4798      	blx	r3
    3748:	4b46      	ldr	r3, [pc, #280]	; (3864 <Vector88+0x174>)
    374a:	781b      	ldrb	r3, [r3, #0]
    374c:	2b05      	cmp	r3, #5
    374e:	d102      	bne.n	3756 <Vector88+0x66>
    3750:	4b44      	ldr	r3, [pc, #272]	; (3864 <Vector88+0x174>)
    3752:	2202      	movs	r2, #2
    3754:	701a      	strb	r2, [r3, #0]
    3756:	4b43      	ldr	r3, [pc, #268]	; (3864 <Vector88+0x174>)
    3758:	2200      	movs	r2, #0
    375a:	611a      	str	r2, [r3, #16]
    375c:	f7ff ffa8 	bl	36b0 <osalSysLockFromISR>
    3760:	4841      	ldr	r0, [pc, #260]	; (3868 <Vector88+0x178>)
    3762:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3766:	f7ff ffb3 	bl	36d0 <osalThreadResumeI>
    376a:	f7ff ffa9 	bl	36c0 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC1 */

#if STM32_ADC_USE_ADC2
  sr = ADC2->SR;
    376e:	4b3f      	ldr	r3, [pc, #252]	; (386c <Vector88+0x17c>)
    3770:	681b      	ldr	r3, [r3, #0]
    3772:	9301      	str	r3, [sp, #4]
  ADC2->SR = 0;
    3774:	4b3d      	ldr	r3, [pc, #244]	; (386c <Vector88+0x17c>)
    3776:	2200      	movs	r2, #0
    3778:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD2.dmastp) > 0)) {
    377a:	9b01      	ldr	r3, [sp, #4]
    377c:	f003 0320 	and.w	r3, r3, #32
    3780:	2b00      	cmp	r3, #0
    3782:	d02d      	beq.n	37e0 <Vector88+0xf0>
    3784:	4b3a      	ldr	r3, [pc, #232]	; (3870 <Vector88+0x180>)
    3786:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3788:	681b      	ldr	r3, [r3, #0]
    378a:	685b      	ldr	r3, [r3, #4]
    378c:	2b00      	cmp	r3, #0
    378e:	d027      	beq.n	37e0 <Vector88+0xf0>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD2.grpp != NULL)
    3790:	4b37      	ldr	r3, [pc, #220]	; (3870 <Vector88+0x180>)
    3792:	691b      	ldr	r3, [r3, #16]
    3794:	2b00      	cmp	r3, #0
    3796:	d023      	beq.n	37e0 <Vector88+0xf0>
      _adc_isr_error_code(&ADCD2, ADC_ERR_OVERFLOW);
    3798:	4835      	ldr	r0, [pc, #212]	; (3870 <Vector88+0x180>)
    379a:	f000 f8c1 	bl	3920 <adc_lld_stop_conversion>
    379e:	4b34      	ldr	r3, [pc, #208]	; (3870 <Vector88+0x180>)
    37a0:	691b      	ldr	r3, [r3, #16]
    37a2:	689b      	ldr	r3, [r3, #8]
    37a4:	2b00      	cmp	r3, #0
    37a6:	d00f      	beq.n	37c8 <Vector88+0xd8>
    37a8:	4b31      	ldr	r3, [pc, #196]	; (3870 <Vector88+0x180>)
    37aa:	2205      	movs	r2, #5
    37ac:	701a      	strb	r2, [r3, #0]
    37ae:	4b30      	ldr	r3, [pc, #192]	; (3870 <Vector88+0x180>)
    37b0:	691b      	ldr	r3, [r3, #16]
    37b2:	689b      	ldr	r3, [r3, #8]
    37b4:	482e      	ldr	r0, [pc, #184]	; (3870 <Vector88+0x180>)
    37b6:	2101      	movs	r1, #1
    37b8:	4798      	blx	r3
    37ba:	4b2d      	ldr	r3, [pc, #180]	; (3870 <Vector88+0x180>)
    37bc:	781b      	ldrb	r3, [r3, #0]
    37be:	2b05      	cmp	r3, #5
    37c0:	d102      	bne.n	37c8 <Vector88+0xd8>
    37c2:	4b2b      	ldr	r3, [pc, #172]	; (3870 <Vector88+0x180>)
    37c4:	2202      	movs	r2, #2
    37c6:	701a      	strb	r2, [r3, #0]
    37c8:	4b29      	ldr	r3, [pc, #164]	; (3870 <Vector88+0x180>)
    37ca:	2200      	movs	r2, #0
    37cc:	611a      	str	r2, [r3, #16]
    37ce:	f7ff ff6f 	bl	36b0 <osalSysLockFromISR>
    37d2:	4828      	ldr	r0, [pc, #160]	; (3874 <Vector88+0x184>)
    37d4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    37d8:	f7ff ff7a 	bl	36d0 <osalThreadResumeI>
    37dc:	f7ff ff70 	bl	36c0 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC2 */

#if STM32_ADC_USE_ADC3
  sr = ADC3->SR;
    37e0:	4b25      	ldr	r3, [pc, #148]	; (3878 <Vector88+0x188>)
    37e2:	681b      	ldr	r3, [r3, #0]
    37e4:	9301      	str	r3, [sp, #4]
  ADC3->SR = 0;
    37e6:	4b24      	ldr	r3, [pc, #144]	; (3878 <Vector88+0x188>)
    37e8:	2200      	movs	r2, #0
    37ea:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD3.dmastp) > 0)) {
    37ec:	9b01      	ldr	r3, [sp, #4]
    37ee:	f003 0320 	and.w	r3, r3, #32
    37f2:	2b00      	cmp	r3, #0
    37f4:	d02d      	beq.n	3852 <Vector88+0x162>
    37f6:	4b21      	ldr	r3, [pc, #132]	; (387c <Vector88+0x18c>)
    37f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    37fa:	681b      	ldr	r3, [r3, #0]
    37fc:	685b      	ldr	r3, [r3, #4]
    37fe:	2b00      	cmp	r3, #0
    3800:	d027      	beq.n	3852 <Vector88+0x162>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD3.grpp != NULL)
    3802:	4b1e      	ldr	r3, [pc, #120]	; (387c <Vector88+0x18c>)
    3804:	691b      	ldr	r3, [r3, #16]
    3806:	2b00      	cmp	r3, #0
    3808:	d023      	beq.n	3852 <Vector88+0x162>
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
    380a:	481c      	ldr	r0, [pc, #112]	; (387c <Vector88+0x18c>)
    380c:	f000 f888 	bl	3920 <adc_lld_stop_conversion>
    3810:	4b1a      	ldr	r3, [pc, #104]	; (387c <Vector88+0x18c>)
    3812:	691b      	ldr	r3, [r3, #16]
    3814:	689b      	ldr	r3, [r3, #8]
    3816:	2b00      	cmp	r3, #0
    3818:	d00f      	beq.n	383a <Vector88+0x14a>
    381a:	4b18      	ldr	r3, [pc, #96]	; (387c <Vector88+0x18c>)
    381c:	2205      	movs	r2, #5
    381e:	701a      	strb	r2, [r3, #0]
    3820:	4b16      	ldr	r3, [pc, #88]	; (387c <Vector88+0x18c>)
    3822:	691b      	ldr	r3, [r3, #16]
    3824:	689b      	ldr	r3, [r3, #8]
    3826:	4815      	ldr	r0, [pc, #84]	; (387c <Vector88+0x18c>)
    3828:	2101      	movs	r1, #1
    382a:	4798      	blx	r3
    382c:	4b13      	ldr	r3, [pc, #76]	; (387c <Vector88+0x18c>)
    382e:	781b      	ldrb	r3, [r3, #0]
    3830:	2b05      	cmp	r3, #5
    3832:	d102      	bne.n	383a <Vector88+0x14a>
    3834:	4b11      	ldr	r3, [pc, #68]	; (387c <Vector88+0x18c>)
    3836:	2202      	movs	r2, #2
    3838:	701a      	strb	r2, [r3, #0]
    383a:	4b10      	ldr	r3, [pc, #64]	; (387c <Vector88+0x18c>)
    383c:	2200      	movs	r2, #0
    383e:	611a      	str	r2, [r3, #16]
    3840:	f7ff ff36 	bl	36b0 <osalSysLockFromISR>
    3844:	480e      	ldr	r0, [pc, #56]	; (3880 <Vector88+0x190>)
    3846:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    384a:	f7ff ff41 	bl	36d0 <osalThreadResumeI>
    384e:	f7ff ff37 	bl	36c0 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
    3852:	f7fd f815 	bl	880 <_dbg_check_leave_isr>
    3856:	f7fe ffcb 	bl	27f0 <_port_irq_epilogue>
}
    385a:	b003      	add	sp, #12
    385c:	f85d fb04 	ldr.w	pc, [sp], #4
    3860:	40012000 	.word	0x40012000
    3864:	20000e84 	.word	0x20000e84
    3868:	20000e98 	.word	0x20000e98
    386c:	40012100 	.word	0x40012100
    3870:	20000eb8 	.word	0x20000eb8
    3874:	20000ecc 	.word	0x20000ecc
    3878:	40012200 	.word	0x40012200
    387c:	20000eec 	.word	0x20000eec
    3880:	20000f00 	.word	0x20000f00
    3884:	f3af 8000 	nop.w
    3888:	f3af 8000 	nop.w
    388c:	f3af 8000 	nop.w

00003890 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
    3890:	b508      	push	{r3, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
    3892:	4814      	ldr	r0, [pc, #80]	; (38e4 <adc_lld_init+0x54>)
    3894:	f7ff f88c 	bl	29b0 <adcObjectInit>
  ADCD1.adc = ADC1;
    3898:	4b12      	ldr	r3, [pc, #72]	; (38e4 <adc_lld_init+0x54>)
    389a:	4a13      	ldr	r2, [pc, #76]	; (38e8 <adc_lld_init+0x58>)
    389c:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
    389e:	4b11      	ldr	r3, [pc, #68]	; (38e4 <adc_lld_init+0x54>)
    38a0:	4a12      	ldr	r2, [pc, #72]	; (38ec <adc_lld_init+0x5c>)
    38a2:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
    38a4:	4b0f      	ldr	r3, [pc, #60]	; (38e4 <adc_lld_init+0x54>)
    38a6:	4a12      	ldr	r2, [pc, #72]	; (38f0 <adc_lld_init+0x60>)
    38a8:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

#if STM32_ADC_USE_ADC2
  /* Driver initialization.*/
  adcObjectInit(&ADCD2);
    38aa:	4812      	ldr	r0, [pc, #72]	; (38f4 <adc_lld_init+0x64>)
    38ac:	f7ff f880 	bl	29b0 <adcObjectInit>
  ADCD2.adc = ADC2;
    38b0:	4b10      	ldr	r3, [pc, #64]	; (38f4 <adc_lld_init+0x64>)
    38b2:	4a11      	ldr	r2, [pc, #68]	; (38f8 <adc_lld_init+0x68>)
    38b4:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD2.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC2_DMA_STREAM);
    38b6:	4b0f      	ldr	r3, [pc, #60]	; (38f4 <adc_lld_init+0x64>)
    38b8:	4a10      	ldr	r2, [pc, #64]	; (38fc <adc_lld_init+0x6c>)
    38ba:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD2.dmamode = STM32_DMA_CR_CHSEL(ADC2_DMA_CHANNEL) |
    38bc:	4b0d      	ldr	r3, [pc, #52]	; (38f4 <adc_lld_init+0x64>)
    38be:	4a10      	ldr	r2, [pc, #64]	; (3900 <adc_lld_init+0x70>)
    38c0:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

#if STM32_ADC_USE_ADC3
  /* Driver initialization.*/
  adcObjectInit(&ADCD3);
    38c2:	4810      	ldr	r0, [pc, #64]	; (3904 <adc_lld_init+0x74>)
    38c4:	f7ff f874 	bl	29b0 <adcObjectInit>
  ADCD3.adc = ADC3;
    38c8:	4b0e      	ldr	r3, [pc, #56]	; (3904 <adc_lld_init+0x74>)
    38ca:	4a0f      	ldr	r2, [pc, #60]	; (3908 <adc_lld_init+0x78>)
    38cc:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD3.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC3_DMA_STREAM);
    38ce:	4b0d      	ldr	r3, [pc, #52]	; (3904 <adc_lld_init+0x74>)
    38d0:	4a0e      	ldr	r2, [pc, #56]	; (390c <adc_lld_init+0x7c>)
    38d2:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD3.dmamode = STM32_DMA_CR_CHSEL(ADC3_DMA_CHANNEL) |
    38d4:	4b0b      	ldr	r3, [pc, #44]	; (3904 <adc_lld_init+0x74>)
    38d6:	4a0e      	ldr	r2, [pc, #56]	; (3910 <adc_lld_init+0x80>)
    38d8:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled because sharing.*/
  nvicEnableVector(STM32_ADC_NUMBER, STM32_ADC_IRQ_PRIORITY);
    38da:	2012      	movs	r0, #18
    38dc:	2106      	movs	r1, #6
    38de:	f7ff fa4f 	bl	2d80 <nvicEnableVector>
}
    38e2:	bd08      	pop	{r3, pc}
    38e4:	20000e84 	.word	0x20000e84
    38e8:	40012000 	.word	0x40012000
    38ec:	00004880 	.word	0x00004880
    38f0:	00022c16 	.word	0x00022c16
    38f4:	20000eb8 	.word	0x20000eb8
    38f8:	40012100 	.word	0x40012100
    38fc:	00004868 	.word	0x00004868
    3900:	02022c16 	.word	0x02022c16
    3904:	20000eec 	.word	0x20000eec
    3908:	40012200 	.word	0x40012200
    390c:	0000485c 	.word	0x0000485c
    3910:	04022c16 	.word	0x04022c16
    3914:	f3af 8000 	nop.w
    3918:	f3af 8000 	nop.w
    391c:	f3af 8000 	nop.w

00003920 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
    3920:	b082      	sub	sp, #8
    3922:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
    3924:	9b01      	ldr	r3, [sp, #4]
    3926:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3928:	681b      	ldr	r3, [r3, #0]
    392a:	9a01      	ldr	r2, [sp, #4]
    392c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    392e:	6812      	ldr	r2, [r2, #0]
    3930:	6812      	ldr	r2, [r2, #0]
    3932:	f022 021f 	bic.w	r2, r2, #31
    3936:	601a      	str	r2, [r3, #0]
    3938:	bf00      	nop
    393a:	9b01      	ldr	r3, [sp, #4]
    393c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    393e:	681b      	ldr	r3, [r3, #0]
    3940:	681b      	ldr	r3, [r3, #0]
    3942:	f003 0301 	and.w	r3, r3, #1
    3946:	2b00      	cmp	r3, #0
    3948:	d1f7      	bne.n	393a <adc_lld_stop_conversion+0x1a>
    394a:	9b01      	ldr	r3, [sp, #4]
    394c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    394e:	685b      	ldr	r3, [r3, #4]
    3950:	9a01      	ldr	r2, [sp, #4]
    3952:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    3954:	7a12      	ldrb	r2, [r2, #8]
    3956:	213d      	movs	r1, #61	; 0x3d
    3958:	fa01 f202 	lsl.w	r2, r1, r2
    395c:	601a      	str	r2, [r3, #0]
  adcp->adc->CR1 = 0;
    395e:	9b01      	ldr	r3, [sp, #4]
    3960:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3962:	2200      	movs	r2, #0
    3964:	605a      	str	r2, [r3, #4]
  adcp->adc->CR2 = 0;
    3966:	9b01      	ldr	r3, [sp, #4]
    3968:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    396a:	2200      	movs	r2, #0
    396c:	609a      	str	r2, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
    396e:	9b01      	ldr	r3, [sp, #4]
    3970:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3972:	2201      	movs	r2, #1
    3974:	609a      	str	r2, [r3, #8]
}
    3976:	b002      	add	sp, #8
    3978:	4770      	bx	lr
    397a:	bf00      	nop
    397c:	f3af 8000 	nop.w

00003980 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
    3980:	b082      	sub	sp, #8
    3982:	9001      	str	r0, [sp, #4]
    3984:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
    3986:	9b00      	ldr	r3, [sp, #0]
    3988:	685a      	ldr	r2, [r3, #4]
    398a:	9b01      	ldr	r3, [sp, #4]
    398c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
    398e:	9b00      	ldr	r3, [sp, #0]
    3990:	689a      	ldr	r2, [r3, #8]
    3992:	9b01      	ldr	r3, [sp, #4]
    3994:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
    3996:	9b00      	ldr	r3, [sp, #0]
    3998:	68da      	ldr	r2, [r3, #12]
    399a:	9b01      	ldr	r3, [sp, #4]
    399c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
    399e:	9b00      	ldr	r3, [sp, #0]
    39a0:	691a      	ldr	r2, [r3, #16]
    39a2:	9b01      	ldr	r3, [sp, #4]
    39a4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
    39a6:	9b00      	ldr	r3, [sp, #0]
    39a8:	695a      	ldr	r2, [r3, #20]
    39aa:	9b01      	ldr	r3, [sp, #4]
    39ac:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
    39ae:	9b00      	ldr	r3, [sp, #0]
    39b0:	699a      	ldr	r2, [r3, #24]
    39b2:	9b01      	ldr	r3, [sp, #4]
    39b4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
    39b6:	9b00      	ldr	r3, [sp, #0]
    39b8:	681a      	ldr	r2, [r3, #0]
    39ba:	9b01      	ldr	r3, [sp, #4]
    39bc:	601a      	str	r2, [r3, #0]
}
    39be:	b002      	add	sp, #8
    39c0:	4770      	bx	lr
    39c2:	bf00      	nop
    39c4:	f3af 8000 	nop.w
    39c8:	f3af 8000 	nop.w
    39cc:	f3af 8000 	nop.w

000039d0 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    39d0:	b500      	push	{lr}
    39d2:	b083      	sub	sp, #12
    39d4:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
    39d6:	4a24      	ldr	r2, [pc, #144]	; (3a68 <_pal_lld_init+0x98>)
    39d8:	4b23      	ldr	r3, [pc, #140]	; (3a68 <_pal_lld_init+0x98>)
    39da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    39dc:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    39e0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    39e4:	6313      	str	r3, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
    39e6:	4a20      	ldr	r2, [pc, #128]	; (3a68 <_pal_lld_init+0x98>)
    39e8:	4b1f      	ldr	r3, [pc, #124]	; (3a68 <_pal_lld_init+0x98>)
    39ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    39ec:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    39f0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    39f4:	6513      	str	r3, [r2, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
    39f6:	9b01      	ldr	r3, [sp, #4]
    39f8:	481c      	ldr	r0, [pc, #112]	; (3a6c <_pal_lld_init+0x9c>)
    39fa:	4619      	mov	r1, r3
    39fc:	f7ff ffc0 	bl	3980 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
    3a00:	9b01      	ldr	r3, [sp, #4]
    3a02:	331c      	adds	r3, #28
    3a04:	481a      	ldr	r0, [pc, #104]	; (3a70 <_pal_lld_init+0xa0>)
    3a06:	4619      	mov	r1, r3
    3a08:	f7ff ffba 	bl	3980 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
    3a0c:	9b01      	ldr	r3, [sp, #4]
    3a0e:	3338      	adds	r3, #56	; 0x38
    3a10:	4818      	ldr	r0, [pc, #96]	; (3a74 <_pal_lld_init+0xa4>)
    3a12:	4619      	mov	r1, r3
    3a14:	f7ff ffb4 	bl	3980 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
    3a18:	9b01      	ldr	r3, [sp, #4]
    3a1a:	3354      	adds	r3, #84	; 0x54
    3a1c:	4816      	ldr	r0, [pc, #88]	; (3a78 <_pal_lld_init+0xa8>)
    3a1e:	4619      	mov	r1, r3
    3a20:	f7ff ffae 	bl	3980 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
    3a24:	9b01      	ldr	r3, [sp, #4]
    3a26:	3370      	adds	r3, #112	; 0x70
    3a28:	4814      	ldr	r0, [pc, #80]	; (3a7c <_pal_lld_init+0xac>)
    3a2a:	4619      	mov	r1, r3
    3a2c:	f7ff ffa8 	bl	3980 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
    3a30:	9b01      	ldr	r3, [sp, #4]
    3a32:	338c      	adds	r3, #140	; 0x8c
    3a34:	4812      	ldr	r0, [pc, #72]	; (3a80 <_pal_lld_init+0xb0>)
    3a36:	4619      	mov	r1, r3
    3a38:	f7ff ffa2 	bl	3980 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
    3a3c:	9b01      	ldr	r3, [sp, #4]
    3a3e:	33a8      	adds	r3, #168	; 0xa8
    3a40:	4810      	ldr	r0, [pc, #64]	; (3a84 <_pal_lld_init+0xb4>)
    3a42:	4619      	mov	r1, r3
    3a44:	f7ff ff9c 	bl	3980 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
    3a48:	9b01      	ldr	r3, [sp, #4]
    3a4a:	33c4      	adds	r3, #196	; 0xc4
    3a4c:	480e      	ldr	r0, [pc, #56]	; (3a88 <_pal_lld_init+0xb8>)
    3a4e:	4619      	mov	r1, r3
    3a50:	f7ff ff96 	bl	3980 <initgpio>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
    3a54:	9b01      	ldr	r3, [sp, #4]
    3a56:	33e0      	adds	r3, #224	; 0xe0
    3a58:	480c      	ldr	r0, [pc, #48]	; (3a8c <_pal_lld_init+0xbc>)
    3a5a:	4619      	mov	r1, r3
    3a5c:	f7ff ff90 	bl	3980 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
    3a60:	b003      	add	sp, #12
    3a62:	f85d fb04 	ldr.w	pc, [sp], #4
    3a66:	bf00      	nop
    3a68:	40023800 	.word	0x40023800
    3a6c:	40020000 	.word	0x40020000
    3a70:	40020400 	.word	0x40020400
    3a74:	40020800 	.word	0x40020800
    3a78:	40020c00 	.word	0x40020c00
    3a7c:	40021000 	.word	0x40021000
    3a80:	40021400 	.word	0x40021400
    3a84:	40021800 	.word	0x40021800
    3a88:	40021c00 	.word	0x40021c00
    3a8c:	40022000 	.word	0x40022000

00003a90 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    3a90:	b08e      	sub	sp, #56	; 0x38
    3a92:	9003      	str	r0, [sp, #12]
    3a94:	9102      	str	r1, [sp, #8]
    3a96:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
    3a98:	9b01      	ldr	r3, [sp, #4]
    3a9a:	f003 0303 	and.w	r3, r3, #3
    3a9e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
    3aa0:	9b01      	ldr	r3, [sp, #4]
    3aa2:	f003 0304 	and.w	r3, r3, #4
    3aa6:	089b      	lsrs	r3, r3, #2
    3aa8:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
    3aaa:	9b01      	ldr	r3, [sp, #4]
    3aac:	f003 0318 	and.w	r3, r3, #24
    3ab0:	08db      	lsrs	r3, r3, #3
    3ab2:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
    3ab4:	9b01      	ldr	r3, [sp, #4]
    3ab6:	f003 0360 	and.w	r3, r3, #96	; 0x60
    3aba:	095b      	lsrs	r3, r3, #5
    3abc:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
    3abe:	9b01      	ldr	r3, [sp, #4]
    3ac0:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
    3ac4:	09db      	lsrs	r3, r3, #7
    3ac6:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
    3ac8:	2300      	movs	r3, #0
    3aca:	9309      	str	r3, [sp, #36]	; 0x24
  while (TRUE) {
    if ((mask & 1) != 0) {
    3acc:	9b02      	ldr	r3, [sp, #8]
    3ace:	f003 0301 	and.w	r3, r3, #1
    3ad2:	2b00      	cmp	r3, #0
    3ad4:	d054      	beq.n	3b80 <_pal_lld_setgroupmode+0xf0>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
    3ad6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3ad8:	f003 0307 	and.w	r3, r3, #7
    3adc:	009b      	lsls	r3, r3, #2
    3ade:	9a08      	ldr	r2, [sp, #32]
    3ae0:	fa02 f303 	lsl.w	r3, r2, r3
    3ae4:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
    3ae6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3ae8:	f003 0307 	and.w	r3, r3, #7
    3aec:	009b      	lsls	r3, r3, #2
    3aee:	220f      	movs	r2, #15
    3af0:	fa02 f303 	lsl.w	r3, r2, r3
    3af4:	9306      	str	r3, [sp, #24]
      if (bit < 8)
    3af6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3af8:	2b07      	cmp	r3, #7
    3afa:	d809      	bhi.n	3b10 <_pal_lld_setgroupmode+0x80>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
    3afc:	9b03      	ldr	r3, [sp, #12]
    3afe:	6a1a      	ldr	r2, [r3, #32]
    3b00:	9b06      	ldr	r3, [sp, #24]
    3b02:	43db      	mvns	r3, r3
    3b04:	401a      	ands	r2, r3
    3b06:	9b07      	ldr	r3, [sp, #28]
    3b08:	431a      	orrs	r2, r3
    3b0a:	9b03      	ldr	r3, [sp, #12]
    3b0c:	621a      	str	r2, [r3, #32]
    3b0e:	e008      	b.n	3b22 <_pal_lld_setgroupmode+0x92>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
    3b10:	9b03      	ldr	r3, [sp, #12]
    3b12:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    3b14:	9b06      	ldr	r3, [sp, #24]
    3b16:	43db      	mvns	r3, r3
    3b18:	401a      	ands	r2, r3
    3b1a:	9b07      	ldr	r3, [sp, #28]
    3b1c:	431a      	orrs	r2, r3
    3b1e:	9b03      	ldr	r3, [sp, #12]
    3b20:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
    3b22:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3b24:	2201      	movs	r2, #1
    3b26:	fa02 f303 	lsl.w	r3, r2, r3
    3b2a:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
    3b2c:	9b03      	ldr	r3, [sp, #12]
    3b2e:	685a      	ldr	r2, [r3, #4]
    3b30:	9b05      	ldr	r3, [sp, #20]
    3b32:	43db      	mvns	r3, r3
    3b34:	401a      	ands	r2, r3
    3b36:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    3b38:	431a      	orrs	r2, r3
    3b3a:	9b03      	ldr	r3, [sp, #12]
    3b3c:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
    3b3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3b40:	005b      	lsls	r3, r3, #1
    3b42:	2203      	movs	r2, #3
    3b44:	fa02 f303 	lsl.w	r3, r2, r3
    3b48:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
    3b4a:	9b03      	ldr	r3, [sp, #12]
    3b4c:	689a      	ldr	r2, [r3, #8]
    3b4e:	9b04      	ldr	r3, [sp, #16]
    3b50:	43db      	mvns	r3, r3
    3b52:	401a      	ands	r2, r3
    3b54:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3b56:	431a      	orrs	r2, r3
    3b58:	9b03      	ldr	r3, [sp, #12]
    3b5a:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
    3b5c:	9b03      	ldr	r3, [sp, #12]
    3b5e:	68da      	ldr	r2, [r3, #12]
    3b60:	9b04      	ldr	r3, [sp, #16]
    3b62:	43db      	mvns	r3, r3
    3b64:	401a      	ands	r2, r3
    3b66:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    3b68:	431a      	orrs	r2, r3
    3b6a:	9b03      	ldr	r3, [sp, #12]
    3b6c:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
    3b6e:	9b03      	ldr	r3, [sp, #12]
    3b70:	681a      	ldr	r2, [r3, #0]
    3b72:	9b04      	ldr	r3, [sp, #16]
    3b74:	43db      	mvns	r3, r3
    3b76:	401a      	ands	r2, r3
    3b78:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    3b7a:	431a      	orrs	r2, r3
    3b7c:	9b03      	ldr	r3, [sp, #12]
    3b7e:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
    3b80:	9b02      	ldr	r3, [sp, #8]
    3b82:	085b      	lsrs	r3, r3, #1
    3b84:	9302      	str	r3, [sp, #8]
    if (!mask)
    3b86:	9b02      	ldr	r3, [sp, #8]
    3b88:	2b00      	cmp	r3, #0
    3b8a:	d100      	bne.n	3b8e <_pal_lld_setgroupmode+0xfe>
      return;
    3b8c:	e00f      	b.n	3bae <_pal_lld_setgroupmode+0x11e>
    otyper <<= 1;
    3b8e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    3b90:	005b      	lsls	r3, r3, #1
    3b92:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
    3b94:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3b96:	009b      	lsls	r3, r3, #2
    3b98:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
    3b9a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    3b9c:	009b      	lsls	r3, r3, #2
    3b9e:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
    3ba0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    3ba2:	009b      	lsls	r3, r3, #2
    3ba4:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
    3ba6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3ba8:	3301      	adds	r3, #1
    3baa:	9309      	str	r3, [sp, #36]	; 0x24
  }
    3bac:	e78e      	b.n	3acc <_pal_lld_setgroupmode+0x3c>
}
    3bae:	b00e      	add	sp, #56	; 0x38
    3bb0:	4770      	bx	lr
    3bb2:	bf00      	nop
    3bb4:	f3af 8000 	nop.w
    3bb8:	f3af 8000 	nop.w
    3bbc:	f3af 8000 	nop.w

00003bc0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    3bc0:	b082      	sub	sp, #8
    3bc2:	2320      	movs	r3, #32
    3bc4:	9301      	str	r3, [sp, #4]
    3bc6:	9b01      	ldr	r3, [sp, #4]
    3bc8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    3bcc:	b002      	add	sp, #8
    3bce:	4770      	bx	lr

00003bd0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    3bd0:	b082      	sub	sp, #8
    3bd2:	2300      	movs	r3, #0
    3bd4:	9301      	str	r3, [sp, #4]
    3bd6:	9b01      	ldr	r3, [sp, #4]
    3bd8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    3bdc:	b002      	add	sp, #8
    3bde:	4770      	bx	lr

00003be0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    3be0:	b508      	push	{r3, lr}

  port_lock();
    3be2:	f7ff ffed 	bl	3bc0 <port_lock>
}
    3be6:	bd08      	pop	{r3, pc}
    3be8:	f3af 8000 	nop.w
    3bec:	f3af 8000 	nop.w

00003bf0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    3bf0:	b508      	push	{r3, lr}

  port_unlock();
    3bf2:	f7ff ffed 	bl	3bd0 <port_unlock>
}
    3bf6:	bd08      	pop	{r3, pc}
    3bf8:	f3af 8000 	nop.w
    3bfc:	f3af 8000 	nop.w

00003c00 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    3c00:	b508      	push	{r3, lr}

  port_lock_from_isr();
    3c02:	f7ff ffed 	bl	3be0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    3c06:	f7fd fe73 	bl	18f0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    3c0a:	f7fc fde9 	bl	7e0 <_dbg_check_lock_from_isr>
}
    3c0e:	bd08      	pop	{r3, pc}

00003c10 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    3c10:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    3c12:	f7fc fdfd 	bl	810 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    3c16:	f7fd fe73 	bl	1900 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    3c1a:	f7ff ffe9 	bl	3bf0 <port_unlock_from_isr>
}
    3c1e:	bd08      	pop	{r3, pc}

00003c20 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
    3c20:	b500      	push	{lr}
    3c22:	b083      	sub	sp, #12
    3c24:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    3c26:	f7fc fe4b 	bl	8c0 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    3c2a:	9b01      	ldr	r3, [sp, #4]
    3c2c:	695a      	ldr	r2, [r3, #20]
    3c2e:	9b01      	ldr	r3, [sp, #4]
    3c30:	699b      	ldr	r3, [r3, #24]
    3c32:	429a      	cmp	r2, r3
    3c34:	d105      	bne.n	3c42 <chOQIsEmptyI+0x22>
    3c36:	9b01      	ldr	r3, [sp, #4]
    3c38:	689b      	ldr	r3, [r3, #8]
    3c3a:	2b00      	cmp	r3, #0
    3c3c:	d001      	beq.n	3c42 <chOQIsEmptyI+0x22>
    3c3e:	2301      	movs	r3, #1
    3c40:	e000      	b.n	3c44 <chOQIsEmptyI+0x24>
    3c42:	2300      	movs	r3, #0
    3c44:	f003 0301 	and.w	r3, r3, #1
    3c48:	b2db      	uxtb	r3, r3
}
    3c4a:	4618      	mov	r0, r3
    3c4c:	b003      	add	sp, #12
    3c4e:	f85d fb04 	ldr.w	pc, [sp], #4
    3c52:	bf00      	nop
    3c54:	f3af 8000 	nop.w
    3c58:	f3af 8000 	nop.w
    3c5c:	f3af 8000 	nop.w

00003c60 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    3c60:	b508      	push	{r3, lr}

  chSysLockFromISR();
    3c62:	f7ff ffcd 	bl	3c00 <chSysLockFromISR>
}
    3c66:	bd08      	pop	{r3, pc}
    3c68:	f3af 8000 	nop.w
    3c6c:	f3af 8000 	nop.w

00003c70 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    3c70:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    3c72:	f7ff ffcd 	bl	3c10 <chSysUnlockFromISR>
}
    3c76:	bd08      	pop	{r3, pc}
    3c78:	f3af 8000 	nop.w
    3c7c:	f3af 8000 	nop.w

00003c80 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    3c80:	b500      	push	{lr}
    3c82:	b083      	sub	sp, #12
    3c84:	9001      	str	r0, [sp, #4]
    3c86:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
    3c88:	9801      	ldr	r0, [sp, #4]
    3c8a:	9900      	ldr	r1, [sp, #0]
    3c8c:	f7fd ff90 	bl	1bb0 <chEvtBroadcastFlagsI>
}
    3c90:	b003      	add	sp, #12
    3c92:	f85d fb04 	ldr.w	pc, [sp], #4
    3c96:	bf00      	nop
    3c98:	f3af 8000 	nop.w
    3c9c:	f3af 8000 	nop.w

00003ca0 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
    3ca0:	b084      	sub	sp, #16
    3ca2:	9001      	str	r0, [sp, #4]
    3ca4:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
    3ca6:	9b01      	ldr	r3, [sp, #4]
    3ca8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
    3cac:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
    3cae:	9b01      	ldr	r3, [sp, #4]
    3cb0:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
    3cb4:	4b1d      	ldr	r3, [pc, #116]	; (3d2c <usart_init+0x8c>)
    3cb6:	429a      	cmp	r2, r3
    3cb8:	d005      	beq.n	3cc6 <usart_init+0x26>
    3cba:	9b01      	ldr	r3, [sp, #4]
    3cbc:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
    3cc0:	4b1b      	ldr	r3, [pc, #108]	; (3d30 <usart_init+0x90>)
    3cc2:	429a      	cmp	r2, r3
    3cc4:	d107      	bne.n	3cd6 <usart_init+0x36>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
    3cc6:	9b00      	ldr	r3, [sp, #0]
    3cc8:	681b      	ldr	r3, [r3, #0]
    3cca:	4a1a      	ldr	r2, [pc, #104]	; (3d34 <usart_init+0x94>)
    3ccc:	fbb2 f2f3 	udiv	r2, r2, r3
    3cd0:	9b03      	ldr	r3, [sp, #12]
    3cd2:	609a      	str	r2, [r3, #8]
    3cd4:	e006      	b.n	3ce4 <usart_init+0x44>
  else
    u->BRR = STM32_PCLK1 / config->speed;
    3cd6:	9b00      	ldr	r3, [sp, #0]
    3cd8:	681b      	ldr	r3, [r3, #0]
    3cda:	4a17      	ldr	r2, [pc, #92]	; (3d38 <usart_init+0x98>)
    3cdc:	fbb2 f2f3 	udiv	r2, r2, r3
    3ce0:	9b03      	ldr	r3, [sp, #12]
    3ce2:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
    3ce4:	9b00      	ldr	r3, [sp, #0]
    3ce6:	88db      	ldrh	r3, [r3, #6]
    3ce8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    3cec:	b29b      	uxth	r3, r3
    3cee:	461a      	mov	r2, r3
    3cf0:	9b03      	ldr	r3, [sp, #12]
    3cf2:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
    3cf4:	9b00      	ldr	r3, [sp, #0]
    3cf6:	891b      	ldrh	r3, [r3, #8]
    3cf8:	f043 0301 	orr.w	r3, r3, #1
    3cfc:	b29b      	uxth	r3, r3
    3cfe:	461a      	mov	r2, r3
    3d00:	9b03      	ldr	r3, [sp, #12]
    3d02:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
    3d04:	9b00      	ldr	r3, [sp, #0]
    3d06:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
    3d08:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
    3d0c:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
    3d10:	b29b      	uxth	r3, r3
    3d12:	461a      	mov	r2, r3
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
    3d14:	9b03      	ldr	r3, [sp, #12]
    3d16:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
    3d18:	9b03      	ldr	r3, [sp, #12]
    3d1a:	2200      	movs	r2, #0
    3d1c:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
    3d1e:	9b03      	ldr	r3, [sp, #12]
    3d20:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
    3d22:	9b03      	ldr	r3, [sp, #12]
    3d24:	685b      	ldr	r3, [r3, #4]
}
    3d26:	b004      	add	sp, #16
    3d28:	4770      	bx	lr
    3d2a:	bf00      	nop
    3d2c:	40011000 	.word	0x40011000
    3d30:	40011400 	.word	0x40011400
    3d34:	0501bd00 	.word	0x0501bd00
    3d38:	0280de80 	.word	0x0280de80
    3d3c:	f3af 8000 	nop.w

00003d40 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
    3d40:	b500      	push	{lr}
    3d42:	b085      	sub	sp, #20
    3d44:	9001      	str	r0, [sp, #4]
    3d46:	460b      	mov	r3, r1
    3d48:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
    3d4c:	2300      	movs	r3, #0
    3d4e:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
    3d50:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    3d54:	f003 0308 	and.w	r3, r3, #8
    3d58:	2b00      	cmp	r3, #0
    3d5a:	d003      	beq.n	3d64 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
    3d5c:	9b03      	ldr	r3, [sp, #12]
    3d5e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    3d62:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
    3d64:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    3d68:	f003 0301 	and.w	r3, r3, #1
    3d6c:	2b00      	cmp	r3, #0
    3d6e:	d003      	beq.n	3d78 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
    3d70:	9b03      	ldr	r3, [sp, #12]
    3d72:	f043 0320 	orr.w	r3, r3, #32
    3d76:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
    3d78:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    3d7c:	f003 0302 	and.w	r3, r3, #2
    3d80:	2b00      	cmp	r3, #0
    3d82:	d003      	beq.n	3d8c <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
    3d84:	9b03      	ldr	r3, [sp, #12]
    3d86:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    3d8a:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
    3d8c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    3d90:	f003 0304 	and.w	r3, r3, #4
    3d94:	2b00      	cmp	r3, #0
    3d96:	d003      	beq.n	3da0 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
    3d98:	9b03      	ldr	r3, [sp, #12]
    3d9a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    3d9e:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
    3da0:	9b01      	ldr	r3, [sp, #4]
    3da2:	3304      	adds	r3, #4
    3da4:	4618      	mov	r0, r3
    3da6:	9903      	ldr	r1, [sp, #12]
    3da8:	f7ff ff6a 	bl	3c80 <osalEventBroadcastFlagsI>
}
    3dac:	b005      	add	sp, #20
    3dae:	f85d fb04 	ldr.w	pc, [sp], #4
    3db2:	bf00      	nop
    3db4:	f3af 8000 	nop.w
    3db8:	f3af 8000 	nop.w
    3dbc:	f3af 8000 	nop.w

00003dc0 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
    3dc0:	b500      	push	{lr}
    3dc2:	b087      	sub	sp, #28
    3dc4:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
    3dc6:	9b01      	ldr	r3, [sp, #4]
    3dc8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
    3dcc:	9304      	str	r3, [sp, #16]
  uint16_t cr1 = u->CR1;
    3dce:	9b04      	ldr	r3, [sp, #16]
    3dd0:	68db      	ldr	r3, [r3, #12]
    3dd2:	f8ad 300e 	strh.w	r3, [sp, #14]
  uint16_t sr = u->SR;
    3dd6:	9b04      	ldr	r3, [sp, #16]
    3dd8:	681b      	ldr	r3, [r3, #0]
    3dda:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    3dde:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3de2:	f403 7380 	and.w	r3, r3, #256	; 0x100
    3de6:	2b00      	cmp	r3, #0
    3de8:	d00e      	beq.n	3e08 <serve_interrupt+0x48>
    osalSysLockFromISR();
    3dea:	f7ff ff39 	bl	3c60 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    3dee:	9b01      	ldr	r3, [sp, #4]
    3df0:	3304      	adds	r3, #4
    3df2:	4618      	mov	r0, r3
    3df4:	f44f 7100 	mov.w	r1, #512	; 0x200
    3df8:	f7ff ff42 	bl	3c80 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
    3dfc:	9b04      	ldr	r3, [sp, #16]
    3dfe:	f46f 7280 	mvn.w	r2, #256	; 0x100
    3e02:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
    3e04:	f7ff ff34 	bl	3c70 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  osalSysLockFromISR();
    3e08:	f7ff ff2a 	bl	3c60 <osalSysLockFromISR>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
    3e0c:	e01f      	b.n	3e4e <serve_interrupt+0x8e>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
    3e0e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3e12:	f003 030f 	and.w	r3, r3, #15
    3e16:	2b00      	cmp	r3, #0
    3e18:	d005      	beq.n	3e26 <serve_interrupt+0x66>
      set_error(sdp, sr);
    3e1a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3e1e:	9801      	ldr	r0, [sp, #4]
    3e20:	4619      	mov	r1, r3
    3e22:	f7ff ff8d 	bl	3d40 <set_error>
    b = u->DR;
    3e26:	9b04      	ldr	r3, [sp, #16]
    3e28:	685b      	ldr	r3, [r3, #4]
    3e2a:	f88d 300d 	strb.w	r3, [sp, #13]
    if (sr & USART_SR_RXNE)
    3e2e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3e32:	f003 0320 	and.w	r3, r3, #32
    3e36:	2b00      	cmp	r3, #0
    3e38:	d005      	beq.n	3e46 <serve_interrupt+0x86>
      sdIncomingDataI(sdp, b);
    3e3a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    3e3e:	9801      	ldr	r0, [sp, #4]
    3e40:	4619      	mov	r1, r3
    3e42:	f7fe ff65 	bl	2d10 <sdIncomingDataI>
    sr = u->SR;
    3e46:	9b04      	ldr	r3, [sp, #16]
    3e48:	681b      	ldr	r3, [r3, #0]
    3e4a:	f8ad 3016 	strh.w	r3, [sp, #22]
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
    3e4e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3e52:	f003 032f 	and.w	r3, r3, #47	; 0x2f
    3e56:	2b00      	cmp	r3, #0
    3e58:	d1d9      	bne.n	3e0e <serve_interrupt+0x4e>
    b = u->DR;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
  }
  osalSysUnlockFromISR();
    3e5a:	f7ff ff09 	bl	3c70 <osalSysUnlockFromISR>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    3e5e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    3e62:	f003 0380 	and.w	r3, r3, #128	; 0x80
    3e66:	2b00      	cmp	r3, #0
    3e68:	d024      	beq.n	3eb4 <serve_interrupt+0xf4>
    3e6a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3e6e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    3e72:	2b00      	cmp	r3, #0
    3e74:	d01e      	beq.n	3eb4 <serve_interrupt+0xf4>
    msg_t b;
    osalSysLockFromISR();
    3e76:	f7ff fef3 	bl	3c60 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
    3e7a:	9b01      	ldr	r3, [sp, #4]
    3e7c:	3330      	adds	r3, #48	; 0x30
    3e7e:	4618      	mov	r0, r3
    3e80:	f7fe fa4e 	bl	2320 <chOQGetI>
    3e84:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
    3e86:	9b02      	ldr	r3, [sp, #8]
    3e88:	2b00      	cmp	r3, #0
    3e8a:	da0e      	bge.n	3eaa <serve_interrupt+0xea>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    3e8c:	9b01      	ldr	r3, [sp, #4]
    3e8e:	3304      	adds	r3, #4
    3e90:	4618      	mov	r0, r3
    3e92:	2108      	movs	r1, #8
    3e94:	f7ff fef4 	bl	3c80 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    3e98:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    3e9c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    3ea0:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    3ea4:	9b04      	ldr	r3, [sp, #16]
    3ea6:	60da      	str	r2, [r3, #12]
    3ea8:	e002      	b.n	3eb0 <serve_interrupt+0xf0>
    }
    else
      u->DR = b;
    3eaa:	9a02      	ldr	r2, [sp, #8]
    3eac:	9b04      	ldr	r3, [sp, #16]
    3eae:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
    3eb0:	f7ff fede 	bl	3c70 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    3eb4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    3eb8:	f003 0340 	and.w	r3, r3, #64	; 0x40
    3ebc:	2b00      	cmp	r3, #0
    3ebe:	d01b      	beq.n	3ef8 <serve_interrupt+0x138>
    osalSysLockFromISR();
    3ec0:	f7ff fece 	bl	3c60 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
    3ec4:	9b01      	ldr	r3, [sp, #4]
    3ec6:	3330      	adds	r3, #48	; 0x30
    3ec8:	4618      	mov	r0, r3
    3eca:	f7ff fea9 	bl	3c20 <chOQIsEmptyI>
    3ece:	4603      	mov	r3, r0
    3ed0:	2b00      	cmp	r3, #0
    3ed2:	d005      	beq.n	3ee0 <serve_interrupt+0x120>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    3ed4:	9b01      	ldr	r3, [sp, #4]
    3ed6:	3304      	adds	r3, #4
    3ed8:	4618      	mov	r0, r3
    3eda:	2110      	movs	r1, #16
    3edc:	f7ff fed0 	bl	3c80 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
    3ee0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    3ee4:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    3ee8:	9b04      	ldr	r3, [sp, #16]
    3eea:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
    3eec:	9b04      	ldr	r3, [sp, #16]
    3eee:	f06f 0240 	mvn.w	r2, #64	; 0x40
    3ef2:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
    3ef4:	f7ff febc 	bl	3c70 <osalSysUnlockFromISR>
  }
}
    3ef8:	b007      	add	sp, #28
    3efa:	f85d fb04 	ldr.w	pc, [sp], #4
    3efe:	bf00      	nop

00003f00 <notify3>:
  USART2->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {
    3f00:	b082      	sub	sp, #8
    3f02:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE;
    3f04:	4b03      	ldr	r3, [pc, #12]	; (3f14 <notify3+0x14>)
    3f06:	4a03      	ldr	r2, [pc, #12]	; (3f14 <notify3+0x14>)
    3f08:	68d2      	ldr	r2, [r2, #12]
    3f0a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    3f0e:	60da      	str	r2, [r3, #12]
}
    3f10:	b002      	add	sp, #8
    3f12:	4770      	bx	lr
    3f14:	40004800 	.word	0x40004800
    3f18:	f3af 8000 	nop.w
    3f1c:	f3af 8000 	nop.w

00003f20 <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
    3f20:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    3f22:	f7fd fca5 	bl	1870 <_stats_increase_irq>
    3f26:	f7fc fc8b 	bl	840 <_dbg_check_enter_isr>

  serve_interrupt(&SD3);
    3f2a:	4804      	ldr	r0, [pc, #16]	; (3f3c <VectorDC+0x1c>)
    3f2c:	f7ff ff48 	bl	3dc0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
    3f30:	f7fc fca6 	bl	880 <_dbg_check_leave_isr>
    3f34:	f7fe fc5c 	bl	27f0 <_port_irq_epilogue>
}
    3f38:	bd08      	pop	{r3, pc}
    3f3a:	bf00      	nop
    3f3c:	20000f20 	.word	0x20000f20

00003f40 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
    3f40:	b508      	push	{r3, lr}
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
    3f42:	4805      	ldr	r0, [pc, #20]	; (3f58 <sd_lld_init+0x18>)
    3f44:	2100      	movs	r1, #0
    3f46:	4a05      	ldr	r2, [pc, #20]	; (3f5c <sd_lld_init+0x1c>)
    3f48:	f7fe fe8a 	bl	2c60 <sdObjectInit>
  SD3.usart = USART3;
    3f4c:	4b02      	ldr	r3, [pc, #8]	; (3f58 <sd_lld_init+0x18>)
    3f4e:	4a04      	ldr	r2, [pc, #16]	; (3f60 <sd_lld_init+0x20>)
    3f50:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
    3f54:	bd08      	pop	{r3, pc}
    3f56:	bf00      	nop
    3f58:	20000f20 	.word	0x20000f20
    3f5c:	00003f01 	.word	0x00003f01
    3f60:	40004800 	.word	0x40004800
    3f64:	f3af 8000 	nop.w
    3f68:	f3af 8000 	nop.w
    3f6c:	f3af 8000 	nop.w

00003f70 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
    3f70:	b500      	push	{lr}
    3f72:	b083      	sub	sp, #12
    3f74:	9001      	str	r0, [sp, #4]
    3f76:	9100      	str	r1, [sp, #0]

  if (config == NULL)
    3f78:	9b00      	ldr	r3, [sp, #0]
    3f7a:	2b00      	cmp	r3, #0
    3f7c:	d101      	bne.n	3f82 <sd_lld_start+0x12>
    config = &default_config;
    3f7e:	4b0d      	ldr	r3, [pc, #52]	; (3fb4 <sd_lld_start+0x44>)
    3f80:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
    3f82:	9b01      	ldr	r3, [sp, #4]
    3f84:	7a1b      	ldrb	r3, [r3, #8]
    3f86:	2b01      	cmp	r3, #1
    3f88:	d10d      	bne.n	3fa6 <sd_lld_start+0x36>
      rccEnableUSART2(FALSE);
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
    3f8a:	9a01      	ldr	r2, [sp, #4]
    3f8c:	4b0a      	ldr	r3, [pc, #40]	; (3fb8 <sd_lld_start+0x48>)
    3f8e:	429a      	cmp	r2, r3
    3f90:	d109      	bne.n	3fa6 <sd_lld_start+0x36>
      rccEnableUSART3(FALSE);
    3f92:	4b0a      	ldr	r3, [pc, #40]	; (3fbc <sd_lld_start+0x4c>)
    3f94:	4a09      	ldr	r2, [pc, #36]	; (3fbc <sd_lld_start+0x4c>)
    3f96:	6c12      	ldr	r2, [r2, #64]	; 0x40
    3f98:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
    3f9c:	641a      	str	r2, [r3, #64]	; 0x40
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
    3f9e:	2027      	movs	r0, #39	; 0x27
    3fa0:	210c      	movs	r1, #12
    3fa2:	f7fe feed 	bl	2d80 <nvicEnableVector>
      rccEnableUART8(FALSE);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
    3fa6:	9801      	ldr	r0, [sp, #4]
    3fa8:	9900      	ldr	r1, [sp, #0]
    3faa:	f7ff fe79 	bl	3ca0 <usart_init>
}
    3fae:	b003      	add	sp, #12
    3fb0:	f85d fb04 	ldr.w	pc, [sp], #4
    3fb4:	000048b0 	.word	0x000048b0
    3fb8:	20000f20 	.word	0x20000f20
    3fbc:	40023800 	.word	0x40023800

00003fc0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
    3fc0:	b508      	push	{r3, lr}

  stm32_clock_init();
    3fc2:	f7fe ff5d 	bl	2e80 <stm32_clock_init>
}
    3fc6:	bd08      	pop	{r3, pc}
    3fc8:	f3af 8000 	nop.w
    3fcc:	f3af 8000 	nop.w

00003fd0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
    3fd0:	4770      	bx	lr
    3fd2:	bf00      	nop
    3fd4:	f3af 8000 	nop.w
    3fd8:	f3af 8000 	nop.w
    3fdc:	f3af 8000 	nop.w

00003fe0 <main>:
#include "main.h"

uint8_t cca_exp_io_mode;


int main(void) {
    3fe0:	b500      	push	{lr}
    3fe2:	b085      	sub	sp, #20
	halInit();
    3fe4:	f7fe fc44 	bl	2870 <halInit>
	chSysInit();
    3fe8:	f7fc fb1a 	bl	620 <chSysInit>
	thread_t *listener,*writer;
	
	
	palWriteGroup(GPIOD,0xFFFFU,0,0x0000U);//all ports low
    3fec:	4b16      	ldr	r3, [pc, #88]	; (4048 <__ram2_size__+0x48>)
    3fee:	4a17      	ldr	r2, [pc, #92]	; (404c <__ram2_size__+0x4c>)
    3ff0:	619a      	str	r2, [r3, #24]
	chThdSetPriority(NORMALPRIO);
    3ff2:	2040      	movs	r0, #64	; 0x40
    3ff4:	f7fd fa74 	bl	14e0 <chThdSetPriority>
	init_IO();
    3ff8:	f000 f832 	bl	4060 <init_IO>
	init_protocol();
    3ffc:	f000 f868 	bl	40d0 <init_protocol>
    listener = chThdCreateStatic(serialListen, sizeof(serialListen), LOWPRIO, rxListen, NULL);
    4000:	2300      	movs	r3, #0
    4002:	9300      	str	r3, [sp, #0]
    4004:	4812      	ldr	r0, [pc, #72]	; (4050 <__ram2_size__+0x50>)
    4006:	f44f 71b4 	mov.w	r1, #360	; 0x168
    400a:	2202      	movs	r2, #2
    400c:	4b11      	ldr	r3, [pc, #68]	; (4054 <__ram2_size__+0x54>)
    400e:	f7fd fa37 	bl	1480 <chThdCreateStatic>
    4012:	9003      	str	r0, [sp, #12]
    writer = chThdCreateStatic(serialTalk, sizeof(serialTalk), LOWPRIO, txWrite, NULL);
    4014:	2300      	movs	r3, #0
    4016:	9300      	str	r3, [sp, #0]
    4018:	480f      	ldr	r0, [pc, #60]	; (4058 <__ram2_size__+0x58>)
    401a:	f44f 71b4 	mov.w	r1, #360	; 0x168
    401e:	2202      	movs	r2, #2
    4020:	4b0e      	ldr	r3, [pc, #56]	; (405c <__ram2_size__+0x5c>)
    4022:	f7fd fa2d 	bl	1480 <chThdCreateStatic>
    4026:	9002      	str	r0, [sp, #8]
    
	while(!0)
	{
		palWriteGroup(GPIOD,0xFFFFU,0,0xFFFFU);//all ports high
    4028:	4b07      	ldr	r3, [pc, #28]	; (4048 <__ram2_size__+0x48>)
    402a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    402e:	619a      	str	r2, [r3, #24]
		chThdSleepMilliseconds(1000);
    4030:	f242 7010 	movw	r0, #10000	; 0x2710
    4034:	f7fd fa8c 	bl	1550 <chThdSleep>
		palWriteGroup(GPIOD,0xFFFFU,0,0x0000U);
    4038:	4b03      	ldr	r3, [pc, #12]	; (4048 <__ram2_size__+0x48>)
    403a:	4a04      	ldr	r2, [pc, #16]	; (404c <__ram2_size__+0x4c>)
    403c:	619a      	str	r2, [r3, #24]
		chThdSleepMilliseconds(1000);
    403e:	f242 7010 	movw	r0, #10000	; 0x2710
    4042:	f7fd fa85 	bl	1550 <chThdSleep>
	}
    4046:	e7ef      	b.n	4028 <__ram2_size__+0x28>
    4048:	40020c00 	.word	0x40020c00
    404c:	ffff0000 	.word	0xffff0000
    4050:	20000ff8 	.word	0x20000ff8
    4054:	00004131 	.word	0x00004131
    4058:	20001160 	.word	0x20001160
    405c:	00004451 	.word	0x00004451

00004060 <init_IO>:
	return 0;/*never reach here*/
}


void init_IO(void)
{
    4060:	b508      	push	{r3, lr}
	//adc_configure();
	//btn b portlarn (16 tane) pull up input olarak a
	palSetGroupMode(GPIOB, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
    4062:	4814      	ldr	r0, [pc, #80]	; (40b4 <init_IO+0x54>)
    4064:	f64f 71ff 	movw	r1, #65535	; 0xffff
    4068:	2220      	movs	r2, #32
    406a:	f7ff fd11 	bl	3a90 <_pal_lld_setgroupmode>
	
	//set_cca_exp_io_mode();
	
	if( cca_exp_io_mode == CCA_EXP_IO_MODE_OUTPUT)
    406e:	4b12      	ldr	r3, [pc, #72]	; (40b8 <init_IO+0x58>)
    4070:	781b      	ldrb	r3, [r3, #0]
    4072:	2b00      	cmp	r3, #0
    4074:	d10c      	bne.n	4090 <init_IO+0x30>
	{
		palSetGroupMode(GPIOD, PAL_GROUP_MASK(16), 0, PAL_MODE_OUTPUT_PUSHPULL);
    4076:	4811      	ldr	r0, [pc, #68]	; (40bc <init_IO+0x5c>)
    4078:	f64f 71ff 	movw	r1, #65535	; 0xffff
    407c:	2201      	movs	r2, #1
    407e:	f7ff fd07 	bl	3a90 <_pal_lld_setgroupmode>
		palSetGroupMode(GPIOE, PAL_GROUP_MASK(16), 0, PAL_MODE_OUTPUT_PUSHPULL);
    4082:	480f      	ldr	r0, [pc, #60]	; (40c0 <init_IO+0x60>)
    4084:	f64f 71ff 	movw	r1, #65535	; 0xffff
    4088:	2201      	movs	r2, #1
    408a:	f7ff fd01 	bl	3a90 <_pal_lld_setgroupmode>
    408e:	e00f      	b.n	40b0 <init_IO+0x50>
	}
	else if( cca_exp_io_mode == CCA_EXP_IO_MODE_INPUT)
    4090:	4b09      	ldr	r3, [pc, #36]	; (40b8 <init_IO+0x58>)
    4092:	781b      	ldrb	r3, [r3, #0]
    4094:	2b01      	cmp	r3, #1
    4096:	d10b      	bne.n	40b0 <init_IO+0x50>
	{
		palSetGroupMode(GPIOD, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
    4098:	4808      	ldr	r0, [pc, #32]	; (40bc <init_IO+0x5c>)
    409a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    409e:	2220      	movs	r2, #32
    40a0:	f7ff fcf6 	bl	3a90 <_pal_lld_setgroupmode>
		palSetGroupMode(GPIOE, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
    40a4:	4806      	ldr	r0, [pc, #24]	; (40c0 <init_IO+0x60>)
    40a6:	f64f 71ff 	movw	r1, #65535	; 0xffff
    40aa:	2220      	movs	r2, #32
    40ac:	f7ff fcf0 	bl	3a90 <_pal_lld_setgroupmode>
	}
	else
	{
		;// Never reach here
	}
	return;
    40b0:	bf00      	nop
}
    40b2:	bd08      	pop	{r3, pc}
    40b4:	40020400 	.word	0x40020400
    40b8:	200012c8 	.word	0x200012c8
    40bc:	40020c00 	.word	0x40020c00
    40c0:	40021000 	.word	0x40021000
    40c4:	f3af 8000 	nop.w
    40c8:	f3af 8000 	nop.w
    40cc:	f3af 8000 	nop.w

000040d0 <init_protocol>:
memory_pool_t mpool;
uint8_t protocol_01_buffer[64] __attribute__((aligned(sizeof(stkalign_t))));*/

//init
void init_protocol(void)
{
    40d0:	b508      	push	{r3, lr}
	sdStart(&SD1, NULL);*///sd1 onun bunun ocuu mu neden almyo insan delirtiyo ?
	//chMBObjectInit(&serialMbox, txMailboxArea, 16);
	//chPoolObjectInit(&mpool, sizeof(void *), NULL);//uint8_t << void * thus we write void *
	//chPoolLoadArray(&mpool,protocol_01_buffer,64);//acayip yerlere gnderiyo 2.ve sonraki malloclar iin
	
	chMBObjectInit(&recievebox, recieveboxArea, 16);
    40d2:	4811      	ldr	r0, [pc, #68]	; (4118 <init_protocol+0x48>)
    40d4:	4911      	ldr	r1, [pc, #68]	; (411c <init_protocol+0x4c>)
    40d6:	2210      	movs	r2, #16
    40d8:	f7fd fe12 	bl	1d00 <chMBObjectInit>
	chPoolObjectInit(&packetPool, sizeof(protocol_01), NULL);
    40dc:	4810      	ldr	r0, [pc, #64]	; (4120 <init_protocol+0x50>)
    40de:	2120      	movs	r1, #32
    40e0:	2200      	movs	r2, #0
    40e2:	f7fe fa95 	bl	2610 <chPoolObjectInit>
	chPoolLoadArray(&packetPool,protocol_01_buffer,32);
    40e6:	480e      	ldr	r0, [pc, #56]	; (4120 <init_protocol+0x50>)
    40e8:	490e      	ldr	r1, [pc, #56]	; (4124 <init_protocol+0x54>)
    40ea:	2220      	movs	r2, #32
    40ec:	f7fe fab0 	bl	2650 <chPoolLoadArray>
	
	palSetPadMode(GPIOB, 10, PAL_MODE_ALTERNATE(7)); // used function : USART3_TX
    40f0:	480d      	ldr	r0, [pc, #52]	; (4128 <init_protocol+0x58>)
    40f2:	f44f 6180 	mov.w	r1, #1024	; 0x400
    40f6:	f240 3282 	movw	r2, #898	; 0x382
    40fa:	f7ff fcc9 	bl	3a90 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOB, 11, PAL_MODE_ALTERNATE(7)); // used function : USART3_RX
    40fe:	480a      	ldr	r0, [pc, #40]	; (4128 <init_protocol+0x58>)
    4100:	f44f 6100 	mov.w	r1, #2048	; 0x800
    4104:	f240 3282 	movw	r2, #898	; 0x382
    4108:	f7ff fcc2 	bl	3a90 <_pal_lld_setgroupmode>
	sdStart(&SD3, NULL);
    410c:	4807      	ldr	r0, [pc, #28]	; (412c <init_protocol+0x5c>)
    410e:	2100      	movs	r1, #0
    4110:	f7fe fdd6 	bl	2cc0 <sdStart>
	return;
    4114:	bf00      	nop
}
    4116:	bd08      	pop	{r3, pc}
    4118:	2000130c 	.word	0x2000130c
    411c:	200012cc 	.word	0x200012cc
    4120:	20001334 	.word	0x20001334
    4124:	20001340 	.word	0x20001340
    4128:	40020400 	.word	0x40020400
    412c:	20000f20 	.word	0x20000f20

00004130 <rxListen>:
	return;
}


void *rxListen(void *arg)
{
    4130:	b500      	push	{lr}
    4132:	b097      	sub	sp, #92	; 0x5c
    4134:	9001      	str	r0, [sp, #4]
	(void)(arg);
	uint8_t i = 0;
    4136:	2300      	movs	r3, #0
    4138:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
	char buffer[64];
	protocol_01 *temp;
	while(!0)//classic infinite thread loop
	{
		while(i < 25)
    413c:	e010      	b.n	4160 <rxListen+0x30>
    413e:	e00f      	b.n	4160 <rxListen+0x30>
		{
			sdRead(&SD3, &buffer[i], 1);//wait until read
    4140:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
    4144:	aa02      	add	r2, sp, #8
    4146:	4413      	add	r3, r2
    4148:	48ae      	ldr	r0, [pc, #696]	; (4404 <rxListen+0x2d4>)
    414a:	4619      	mov	r1, r3
    414c:	2201      	movs	r2, #1
    414e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4152:	f7fe f815 	bl	2180 <chIQReadTimeout>
			i++;
    4156:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
    415a:	3301      	adds	r3, #1
    415c:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
	uint8_t i = 0;
	char buffer[64];
	protocol_01 *temp;
	while(!0)//classic infinite thread loop
	{
		while(i < 25)
    4160:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
    4164:	2b18      	cmp	r3, #24
    4166:	d9eb      	bls.n	4140 <rxListen+0x10>
		{
			sdRead(&SD3, &buffer[i], 1);//wait until read
			i++;
		}
		//control if message valid
		if(buffer[0] != SOH || buffer[24] != EOT)//if its not a valid frame
    4168:	f89d 3008 	ldrb.w	r3, [sp, #8]
    416c:	2b01      	cmp	r3, #1
    416e:	d103      	bne.n	4178 <rxListen+0x48>
    4170:	f89d 3020 	ldrb.w	r3, [sp, #32]
    4174:	2b04      	cmp	r3, #4
    4176:	d038      	beq.n	41ea <rxListen+0xba>
		{
			uint8_t last = i, index;
    4178:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
    417c:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
			i = 0;
    4180:	2300      	movs	r3, #0
    4182:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
			while(buffer[i] != SOH)//find a start
    4186:	e004      	b.n	4192 <rxListen+0x62>
				i++;
    4188:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
    418c:	3301      	adds	r3, #1
    418e:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
		//control if message valid
		if(buffer[0] != SOH || buffer[24] != EOT)//if its not a valid frame
		{
			uint8_t last = i, index;
			i = 0;
			while(buffer[i] != SOH)//find a start
    4192:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
    4196:	a916      	add	r1, sp, #88	; 0x58
    4198:	440b      	add	r3, r1
    419a:	f813 3c50 	ldrb.w	r3, [r3, #-80]
    419e:	2b01      	cmp	r3, #1
    41a0:	d1f2      	bne.n	4188 <rxListen+0x58>
				i++;
			for(index = 0; index < last; index++)//copy contents to head
    41a2:	2300      	movs	r3, #0
    41a4:	f88d 3056 	strb.w	r3, [sp, #86]	; 0x56
    41a8:	e013      	b.n	41d2 <rxListen+0xa2>
				buffer[index] = buffer[i++];
    41aa:	f89d 1056 	ldrb.w	r1, [sp, #86]	; 0x56
    41ae:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
    41b2:	1c5a      	adds	r2, r3, #1
    41b4:	f88d 2057 	strb.w	r2, [sp, #87]	; 0x57
    41b8:	aa16      	add	r2, sp, #88	; 0x58
    41ba:	4413      	add	r3, r2
    41bc:	f813 2c50 	ldrb.w	r2, [r3, #-80]
    41c0:	ab16      	add	r3, sp, #88	; 0x58
    41c2:	440b      	add	r3, r1
    41c4:	f803 2c50 	strb.w	r2, [r3, #-80]
		{
			uint8_t last = i, index;
			i = 0;
			while(buffer[i] != SOH)//find a start
				i++;
			for(index = 0; index < last; index++)//copy contents to head
    41c8:	f89d 3056 	ldrb.w	r3, [sp, #86]	; 0x56
    41cc:	3301      	adds	r3, #1
    41ce:	f88d 3056 	strb.w	r3, [sp, #86]	; 0x56
    41d2:	f89d 2056 	ldrb.w	r2, [sp, #86]	; 0x56
    41d6:	f89d 304b 	ldrb.w	r3, [sp, #75]	; 0x4b
    41da:	429a      	cmp	r2, r3
    41dc:	d3e5      	bcc.n	41aa <rxListen+0x7a>
				buffer[index] = buffer[i++];
			i = index;
    41de:	f89d 3056 	ldrb.w	r3, [sp, #86]	; 0x56
    41e2:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
			continue;
    41e6:	bf00      	nop
				for(index = 0; index + 1 < i; index++)/*There may some other packet start within so just remove SOH*/
					buffer[index] = buffer[1 + index];
				i = i - 1; 
			//}
		}
	}
    41e8:	e7a9      	b.n	413e <rxListen+0xe>
		}
		else//valid message
		{
			/*Maybe first check if this packet to us
			 * if it isn't then we don't need to do all this stuff*/
			uint16_t crc = 0, index;
    41ea:	2300      	movs	r3, #0
    41ec:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
			temp = (protocol_01 *)chPoolAlloc(&packetPool);
    41f0:	4885      	ldr	r0, [pc, #532]	; (4408 <rxListen+0x2d8>)
    41f2:	f7fe fa85 	bl	2700 <chPoolAlloc>
    41f6:	9013      	str	r0, [sp, #76]	; 0x4c
			//0 is SOH
			temp->src = 0;//do i need to do this ?
    41f8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    41fa:	2200      	movs	r2, #0
    41fc:	609a      	str	r2, [r3, #8]
			temp->dest = 0;
    41fe:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4200:	2200      	movs	r2, #0
    4202:	60da      	str	r2, [r3, #12]
			temp->digital_io = 0;
    4204:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4206:	2200      	movs	r2, #0
    4208:	611a      	str	r2, [r3, #16]
			temp->analog_io[0] = 0;
    420a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    420c:	2200      	movs	r2, #0
    420e:	829a      	strh	r2, [r3, #20]
			temp->analog_io[1] = 0;
    4210:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4212:	2200      	movs	r2, #0
    4214:	82da      	strh	r2, [r3, #22]
			temp->analog_io[2] = 0;
    4216:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4218:	2200      	movs	r2, #0
    421a:	831a      	strh	r2, [r3, #24]
			temp->analog_io[3] = 0;
    421c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    421e:	2200      	movs	r2, #0
    4220:	835a      	strh	r2, [r3, #26]
			
			temp->src &= buffer[2] << 24;
    4222:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4224:	689a      	ldr	r2, [r3, #8]
    4226:	f89d 300a 	ldrb.w	r3, [sp, #10]
    422a:	061b      	lsls	r3, r3, #24
    422c:	401a      	ands	r2, r3
    422e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4230:	609a      	str	r2, [r3, #8]
			temp->src &= buffer[3] << 16;
    4232:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4234:	689a      	ldr	r2, [r3, #8]
    4236:	f89d 300b 	ldrb.w	r3, [sp, #11]
    423a:	041b      	lsls	r3, r3, #16
    423c:	401a      	ands	r2, r3
    423e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4240:	609a      	str	r2, [r3, #8]
			temp->src &= buffer[4] << 8;
    4242:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4244:	689a      	ldr	r2, [r3, #8]
    4246:	f89d 300c 	ldrb.w	r3, [sp, #12]
    424a:	021b      	lsls	r3, r3, #8
    424c:	401a      	ands	r2, r3
    424e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4250:	609a      	str	r2, [r3, #8]
			temp->src &= buffer[5];
    4252:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4254:	689a      	ldr	r2, [r3, #8]
    4256:	f89d 300d 	ldrb.w	r3, [sp, #13]
    425a:	401a      	ands	r2, r3
    425c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    425e:	609a      	str	r2, [r3, #8]
			temp->dest &= buffer[6] << 24;
    4260:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4262:	68da      	ldr	r2, [r3, #12]
    4264:	f89d 300e 	ldrb.w	r3, [sp, #14]
    4268:	061b      	lsls	r3, r3, #24
    426a:	401a      	ands	r2, r3
    426c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    426e:	60da      	str	r2, [r3, #12]
			temp->dest &= buffer[7] << 16;
    4270:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4272:	68da      	ldr	r2, [r3, #12]
    4274:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4278:	041b      	lsls	r3, r3, #16
    427a:	401a      	ands	r2, r3
    427c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    427e:	60da      	str	r2, [r3, #12]
			temp->dest &= buffer[8] << 8;
    4280:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4282:	68da      	ldr	r2, [r3, #12]
    4284:	f89d 3010 	ldrb.w	r3, [sp, #16]
    4288:	021b      	lsls	r3, r3, #8
    428a:	401a      	ands	r2, r3
    428c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    428e:	60da      	str	r2, [r3, #12]
			temp->dest &= buffer[9];
    4290:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4292:	68da      	ldr	r2, [r3, #12]
    4294:	f89d 3011 	ldrb.w	r3, [sp, #17]
    4298:	401a      	ands	r2, r3
    429a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    429c:	60da      	str	r2, [r3, #12]
			temp->digital_io &= buffer[10] << 24;
    429e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    42a0:	691a      	ldr	r2, [r3, #16]
    42a2:	f89d 3012 	ldrb.w	r3, [sp, #18]
    42a6:	061b      	lsls	r3, r3, #24
    42a8:	401a      	ands	r2, r3
    42aa:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    42ac:	611a      	str	r2, [r3, #16]
			temp->digital_io &= buffer[11] << 16;
    42ae:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    42b0:	691a      	ldr	r2, [r3, #16]
    42b2:	f89d 3013 	ldrb.w	r3, [sp, #19]
    42b6:	041b      	lsls	r3, r3, #16
    42b8:	401a      	ands	r2, r3
    42ba:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    42bc:	611a      	str	r2, [r3, #16]
			temp->digital_io &= buffer[12] << 8;
    42be:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    42c0:	691a      	ldr	r2, [r3, #16]
    42c2:	f89d 3014 	ldrb.w	r3, [sp, #20]
    42c6:	021b      	lsls	r3, r3, #8
    42c8:	401a      	ands	r2, r3
    42ca:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    42cc:	611a      	str	r2, [r3, #16]
			temp->digital_io &= buffer[13];
    42ce:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    42d0:	691a      	ldr	r2, [r3, #16]
    42d2:	f89d 3015 	ldrb.w	r3, [sp, #21]
    42d6:	401a      	ands	r2, r3
    42d8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    42da:	611a      	str	r2, [r3, #16]
			temp->analog_io[0] &= buffer[14] << 8;
    42dc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    42de:	8a9b      	ldrh	r3, [r3, #20]
    42e0:	b29a      	uxth	r2, r3
    42e2:	f89d 3016 	ldrb.w	r3, [sp, #22]
    42e6:	021b      	lsls	r3, r3, #8
    42e8:	b29b      	uxth	r3, r3
    42ea:	4013      	ands	r3, r2
    42ec:	b29b      	uxth	r3, r3
    42ee:	b29a      	uxth	r2, r3
    42f0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    42f2:	829a      	strh	r2, [r3, #20]
			temp->analog_io[0] &= buffer[15];
    42f4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    42f6:	8a9a      	ldrh	r2, [r3, #20]
    42f8:	f89d 3017 	ldrb.w	r3, [sp, #23]
    42fc:	4013      	ands	r3, r2
    42fe:	b29a      	uxth	r2, r3
    4300:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4302:	829a      	strh	r2, [r3, #20]
			temp->analog_io[1] &= buffer[16] << 8;
    4304:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4306:	8adb      	ldrh	r3, [r3, #22]
    4308:	b29a      	uxth	r2, r3
    430a:	f89d 3018 	ldrb.w	r3, [sp, #24]
    430e:	021b      	lsls	r3, r3, #8
    4310:	b29b      	uxth	r3, r3
    4312:	4013      	ands	r3, r2
    4314:	b29b      	uxth	r3, r3
    4316:	b29a      	uxth	r2, r3
    4318:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    431a:	82da      	strh	r2, [r3, #22]
			temp->analog_io[1] &= buffer[17];
    431c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    431e:	8ada      	ldrh	r2, [r3, #22]
    4320:	f89d 3019 	ldrb.w	r3, [sp, #25]
    4324:	4013      	ands	r3, r2
    4326:	b29a      	uxth	r2, r3
    4328:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    432a:	82da      	strh	r2, [r3, #22]
			temp->analog_io[2] &= buffer[18] << 8;
    432c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    432e:	8b1b      	ldrh	r3, [r3, #24]
    4330:	b29a      	uxth	r2, r3
    4332:	f89d 301a 	ldrb.w	r3, [sp, #26]
    4336:	021b      	lsls	r3, r3, #8
    4338:	b29b      	uxth	r3, r3
    433a:	4013      	ands	r3, r2
    433c:	b29b      	uxth	r3, r3
    433e:	b29a      	uxth	r2, r3
    4340:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4342:	831a      	strh	r2, [r3, #24]
			temp->analog_io[2] &= buffer[19];
    4344:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4346:	8b1a      	ldrh	r2, [r3, #24]
    4348:	f89d 301b 	ldrb.w	r3, [sp, #27]
    434c:	4013      	ands	r3, r2
    434e:	b29a      	uxth	r2, r3
    4350:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4352:	831a      	strh	r2, [r3, #24]
			temp->analog_io[3] &= buffer[20] << 8;
    4354:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    4356:	8b5b      	ldrh	r3, [r3, #26]
    4358:	b29a      	uxth	r2, r3
    435a:	f89d 301c 	ldrb.w	r3, [sp, #28]
    435e:	021b      	lsls	r3, r3, #8
    4360:	b29b      	uxth	r3, r3
    4362:	4013      	ands	r3, r2
    4364:	b29b      	uxth	r3, r3
    4366:	b29a      	uxth	r2, r3
    4368:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    436a:	835a      	strh	r2, [r3, #26]
			temp->analog_io[3] &= buffer[21];
    436c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    436e:	8b5a      	ldrh	r2, [r3, #26]
    4370:	f89d 301d 	ldrb.w	r3, [sp, #29]
    4374:	4013      	ands	r3, r2
    4376:	b29a      	uxth	r2, r3
    4378:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    437a:	835a      	strh	r2, [r3, #26]
			crc &= buffer[22] << 8;
    437c:	f89d 301e 	ldrb.w	r3, [sp, #30]
    4380:	021b      	lsls	r3, r3, #8
    4382:	b29a      	uxth	r2, r3
    4384:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
    4388:	4013      	ands	r3, r2
    438a:	b29b      	uxth	r3, r3
    438c:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
			crc &= buffer[23];
    4390:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4394:	461a      	mov	r2, r3
    4396:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
    439a:	4013      	ands	r3, r2
    439c:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
			//24 is EOT
			/*CONTROL CRC*/
			//if(crc control)//no crc for this time
			//{
				/*push to rx buffer*/
				chMBPost(&recievebox, temp, TIME_INFINITE);//dikkat--zaman sonsuz mu olmal
    43a0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    43a2:	481a      	ldr	r0, [pc, #104]	; (440c <rxListen+0x2dc>)
    43a4:	4619      	mov	r1, r3
    43a6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    43aa:	f7fd fce1 	bl	1d70 <chMBPost>
				
				/*move next part to start of the buffer*/
				for(index = 0; index + 25 < i; index++)
    43ae:	2300      	movs	r3, #0
    43b0:	f8ad 3054 	strh.w	r3, [sp, #84]	; 0x54
    43b4:	e011      	b.n	43da <rxListen+0x2aa>
					buffer[index] = buffer[25 + index];
    43b6:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    43ba:	f8bd 2054 	ldrh.w	r2, [sp, #84]	; 0x54
    43be:	3219      	adds	r2, #25
    43c0:	a916      	add	r1, sp, #88	; 0x58
    43c2:	440a      	add	r2, r1
    43c4:	f812 2c50 	ldrb.w	r2, [r2, #-80]
    43c8:	a916      	add	r1, sp, #88	; 0x58
    43ca:	440b      	add	r3, r1
    43cc:	f803 2c50 	strb.w	r2, [r3, #-80]
			//{
				/*push to rx buffer*/
				chMBPost(&recievebox, temp, TIME_INFINITE);//dikkat--zaman sonsuz mu olmal
				
				/*move next part to start of the buffer*/
				for(index = 0; index + 25 < i; index++)
    43d0:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    43d4:	3301      	adds	r3, #1
    43d6:	f8ad 3054 	strh.w	r3, [sp, #84]	; 0x54
    43da:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    43de:	f103 0219 	add.w	r2, r3, #25
    43e2:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
    43e6:	429a      	cmp	r2, r3
    43e8:	dbe5      	blt.n	43b6 <rxListen+0x286>
					buffer[index] = buffer[25 + index];
				i = i - 25;
    43ea:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
    43ee:	3b19      	subs	r3, #25
    43f0:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
			//}
			//else/*if crc fails remove prepared frame*/
			//{
				chPoolFree(&packetPool,temp);
    43f4:	4804      	ldr	r0, [pc, #16]	; (4408 <rxListen+0x2d8>)
    43f6:	9913      	ldr	r1, [sp, #76]	; 0x4c
    43f8:	f7fe f9b2 	bl	2760 <chPoolFree>
				
				for(index = 0; index + 1 < i; index++)/*There may some other packet start within so just remove SOH*/
    43fc:	2300      	movs	r3, #0
    43fe:	f8ad 3054 	strh.w	r3, [sp, #84]	; 0x54
    4402:	e017      	b.n	4434 <rxListen+0x304>
    4404:	20000f2c 	.word	0x20000f2c
    4408:	20001334 	.word	0x20001334
    440c:	2000130c 	.word	0x2000130c
					buffer[index] = buffer[1 + index];
    4410:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    4414:	f8bd 2054 	ldrh.w	r2, [sp, #84]	; 0x54
    4418:	3201      	adds	r2, #1
    441a:	a916      	add	r1, sp, #88	; 0x58
    441c:	440a      	add	r2, r1
    441e:	f812 2c50 	ldrb.w	r2, [r2, #-80]
    4422:	a916      	add	r1, sp, #88	; 0x58
    4424:	440b      	add	r3, r1
    4426:	f803 2c50 	strb.w	r2, [r3, #-80]
			//}
			//else/*if crc fails remove prepared frame*/
			//{
				chPoolFree(&packetPool,temp);
				
				for(index = 0; index + 1 < i; index++)/*There may some other packet start within so just remove SOH*/
    442a:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    442e:	3301      	adds	r3, #1
    4430:	f8ad 3054 	strh.w	r3, [sp, #84]	; 0x54
    4434:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    4438:	1c5a      	adds	r2, r3, #1
    443a:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
    443e:	429a      	cmp	r2, r3
    4440:	dbe6      	blt.n	4410 <rxListen+0x2e0>
					buffer[index] = buffer[1 + index];
				i = i - 1; 
    4442:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
    4446:	3b01      	subs	r3, #1
    4448:	f88d 3057 	strb.w	r3, [sp, #87]	; 0x57
			//}
		}
	}
    444c:	e677      	b.n	413e <rxListen+0xe>
    444e:	bf00      	nop

00004450 <txWrite>:
	return NULL;/*Never reach here*/
}


void *txWrite(void *arg)
{
    4450:	b500      	push	{lr}
    4452:	b085      	sub	sp, #20
    4454:	9001      	str	r0, [sp, #4]
	(void)(arg);
	protocol_01 *toSend;
	while(!0)
	{
		if(chMBFetch(&recievebox, &toSend, TIME_INFINITE) == MSG_OK)//semafora gerek yok kendi kendine waiting srasna giriyo(ieride zaten semafor var)
    4456:	ab03      	add	r3, sp, #12
    4458:	480b      	ldr	r0, [pc, #44]	; (4488 <txWrite+0x38>)
    445a:	4619      	mov	r1, r3
    445c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    4460:	f7fd fcd6 	bl	1e10 <chMBFetch>
    4464:	4603      	mov	r3, r0
    4466:	2b00      	cmp	r3, #0
    4468:	d10d      	bne.n	4486 <txWrite+0x36>
		{
			sdWrite(&SD3, toSend,1);
    446a:	9b03      	ldr	r3, [sp, #12]
    446c:	4807      	ldr	r0, [pc, #28]	; (448c <txWrite+0x3c>)
    446e:	4619      	mov	r1, r3
    4470:	2201      	movs	r2, #1
    4472:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4476:	f7fd ff83 	bl	2380 <chOQWriteTimeout>
			chPoolFree(&packetPool, toSend);
    447a:	9b03      	ldr	r3, [sp, #12]
    447c:	4804      	ldr	r0, [pc, #16]	; (4490 <txWrite+0x40>)
    447e:	4619      	mov	r1, r3
    4480:	f7fe f96e 	bl	2760 <chPoolFree>
		}
	}
    4484:	e7e7      	b.n	4456 <txWrite+0x6>
    4486:	e7e6      	b.n	4456 <txWrite+0x6>
    4488:	2000130c 	.word	0x2000130c
    448c:	20000f50 	.word	0x20000f50
    4490:	20001334 	.word	0x20001334
    4494:	f3af 8000 	nop.w
    4498:	f3af 8000 	nop.w
    449c:	f3af 8000 	nop.w
    44a0:	656c6469 	.word	0x656c6469
	...
    44b0:	31235653 	.word	0x31235653
    44b4:	00000000 	.word	0x00000000
    44b8:	32235653 	.word	0x32235653
    44bc:	00000000 	.word	0x00000000
    44c0:	33235653 	.word	0x33235653
    44c4:	00000000 	.word	0x00000000
    44c8:	34235653 	.word	0x34235653
    44cc:	00000000 	.word	0x00000000
    44d0:	35235653 	.word	0x35235653
    44d4:	00000000 	.word	0x00000000
    44d8:	36235653 	.word	0x36235653
    44dc:	00000000 	.word	0x00000000
    44e0:	37235653 	.word	0x37235653
    44e4:	00000000 	.word	0x00000000
    44e8:	38235653 	.word	0x38235653
    44ec:	00000000 	.word	0x00000000
    44f0:	39235653 	.word	0x39235653
    44f4:	00000000 	.word	0x00000000
    44f8:	31235653 	.word	0x31235653
    44fc:	00000030 	.word	0x00000030
    4500:	31235653 	.word	0x31235653
    4504:	00000031 	.word	0x00000031
	...
    4510:	63617473 	.word	0x63617473
    4514:	766f206b 	.word	0x766f206b
    4518:	6c667265 	.word	0x6c667265
    451c:	0000776f 	.word	0x0000776f

00004520 <__func__.6011>:
    4520:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

00004530 <__func__.6628>:
    4530:	54566863 65536f44 00004974 00000000     chVTDoSetI......

00004540 <__func__.6636>:
    4540:	54566863 65526f44 49746573 00000000     chVTDoResetI....

00004550 <__func__.6625>:
    4550:	63536863 61655268 00497964 00000000     chSchReadyI.....

00004560 <__func__.6637>:
    4560:	68546863 65724364 49657461 00000000     chThdCreateI....

00004570 <__func__.5925>:
    4570:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004580 <__func__.6653>:
    4580:	68546863 74655364 6f697250 79746972     chThdSetPriority
	...

000045a0 <__func__.6096>:
    45a0:	68546863 656c5364 00537065 00000000     chThdSleepS.....

000045b0 <__func__.6681>:
    45b0:	68546863 69784564 00005374 00000000     chThdExitS......

000045c0 <__func__.6703>:
    45c0:	68546863 73655264 49656d75 00000000     chThdResumeI....

000045d0 <__func__.6108>:
    45d0:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
    45e0:	00497478 00000000 00000000 00000000     xtI.............

000045f0 <ch_debug>:
    45f0:	6e69616d 18021600 08600404 1814100c     main......`.....
    4600:	2221201c 00000000 00000000 00000000     . !"............

00004610 <__func__.6621>:
    4610:	65536863 6a624f6d 49746365 0074696e     chSemObjectInit.

00004620 <__func__.6652>:
    4620:	65536863 6961576d 6d695474 74756f65     chSemWaitTimeout
    4630:	00000053 00000000 00000000 00000000     S...............

00004640 <__func__.6660>:
    4640:	65536863 6769536d 496c616e 00000000     chSemSignalI....

00004650 <__func__.6620>:
    4650:	744d6863 6a624f78 49746365 0074696e     chMtxObjectInit.

00004660 <__func__.6645>:
    4660:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
    4670:	49736761 00000000 00000000 00000000     agsI............

00004680 <__func__.6662>:
    4680:	76456863 67695374 496c616e 00000000     chEvtSignalI....

00004690 <__func__.6622>:
    4690:	424d6863 656a624f 6e497463 00007469     chMBObjectInit..

000046a0 <__func__.5925>:
    46a0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000046b0 <__func__.6642>:
    46b0:	424d6863 74736f50 00000053 00000000     chMBPostS.......

000046c0 <__func__.6678>:
    46c0:	424d6863 63746546 00005368 00000000     chMBFetchS......

000046d0 <__func__.5925>:
    46d0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000046e0 <__func__.6648>:
    46e0:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.

000046f0 <__func__.6684>:
    46f0:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

00004710 <__func__.5925>:
    4710:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004720 <__func__.6622>:
    4720:	6f506863 624f6c6f 7463656a 74696e49     chPoolObjectInit
	...

00004740 <__func__.6628>:
    4740:	6f506863 6f4c6c6f 72416461 00796172     chPoolLoadArray.

00004750 <__func__.6636>:
    4750:	6f506863 6c416c6f 49636f6c 00000000     chPoolAllocI....

00004760 <__func__.5925>:
    4760:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004770 <__func__.6646>:
    4770:	6f506863 72466c6f 00496565 00000000     chPoolFreeI.....

00004780 <__func__.7143>:
    4780:	74537473 41747261 6d72616c 00000000     stStartAlarm....

00004790 <__func__.7150>:
    4790:	65537473 616c4174 00006d72 00000000     stSetAlarm......

000047a0 <vmt>:
    47a0:	00002af1 00002b21 00002b51 00002b81     .*..!+..Q+...+..
    47b0:	00002ba1 00002bd1 00002bf1 00002c21     .+...+...+..!,..

000047c0 <__func__.7188>:
    47c0:	74536473 00747261 00000000 00000000     sdStart.........

000047d0 <__func__.5925>:
    47d0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000047e0 <__func__.7197>:
    47e0:	6e496473 696d6f63 6144676e 00496174     sdIncomingDataI.

000047f0 <_stm32_dma_streams>:
    47f0:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
    4800:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
    4810:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
    4820:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
    4830:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
    4840:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
    4850:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
    4860:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
    4870:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
    4880:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
    4890:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
    48a0:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

000048b0 <default_config>:
    48b0:	00002580 40000000 00000000 00000000     .%.....@........

000048c0 <pal_default_config>:
    48c0:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
    48d0:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
    48e0:	00000240 ffffffff 55514515 0000ffff     @........EQU....
    48f0:	04000000 00000040 02208001 00000000     ....@..... .....
    4900:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
    4910:	00060600 55000100 00000000 ffffffff     .......U........
    4920:	00555055 00000fff 00000000 00000000     UPU.............
    4930:	00000040 00000000 ffffffff 00000000     @...............
    4940:	0000ffff 00000000 00000000 00000000     ................
    4950:	00000000 ffffffff 00000000 0000ffff     ................
	...
    4970:	ffffffff 00000000 0000ffff 00000000     ................
	...
    498c:	ffffffff 00000000 0000ffff 00000000     ................
	...
    49a8:	ffffffff 00000000 0000ffff 00000000     ................
    49b8:	00000000                                ....
