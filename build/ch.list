
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

000001c0 <Reset_Handler>:
     1c0:	b672      	cpsid	i
     1c2:	4821      	ldr	r0, [pc, #132]	; (248 <endfiniloop+0x4>)
     1c4:	f380 8809 	msr	PSP, r0
     1c8:	2002      	movs	r0, #2
     1ca:	f380 8814 	msr	CONTROL, r0
     1ce:	f3bf 8f6f 	isb	sy
     1d2:	f000 f95d 	bl	490 <__core_init>
     1d6:	f004 fa53 	bl	4680 <__early_init>
     1da:	481c      	ldr	r0, [pc, #112]	; (24c <endfiniloop+0x8>)
     1dc:	491c      	ldr	r1, [pc, #112]	; (250 <endfiniloop+0xc>)
     1de:	4a1d      	ldr	r2, [pc, #116]	; (254 <endfiniloop+0x10>)

000001e0 <msloop>:
     1e0:	4291      	cmp	r1, r2
     1e2:	bf3c      	itt	cc
     1e4:	f841 0b04 	strcc.w	r0, [r1], #4
     1e8:	e7fa      	bcc.n	1e0 <msloop>
     1ea:	491b      	ldr	r1, [pc, #108]	; (258 <endfiniloop+0x14>)
     1ec:	4a16      	ldr	r2, [pc, #88]	; (248 <endfiniloop+0x4>)

000001ee <psloop>:
     1ee:	4291      	cmp	r1, r2
     1f0:	bf3c      	itt	cc
     1f2:	f841 0b04 	strcc.w	r0, [r1], #4
     1f6:	e7fa      	bcc.n	1ee <psloop>
     1f8:	4918      	ldr	r1, [pc, #96]	; (25c <endfiniloop+0x18>)
     1fa:	4a19      	ldr	r2, [pc, #100]	; (260 <endfiniloop+0x1c>)
     1fc:	4b19      	ldr	r3, [pc, #100]	; (264 <endfiniloop+0x20>)

000001fe <dloop>:
     1fe:	429a      	cmp	r2, r3
     200:	bf3e      	ittt	cc
     202:	f851 0b04 	ldrcc.w	r0, [r1], #4
     206:	f842 0b04 	strcc.w	r0, [r2], #4
     20a:	e7f8      	bcc.n	1fe <dloop>
     20c:	2000      	movs	r0, #0
     20e:	4916      	ldr	r1, [pc, #88]	; (268 <endfiniloop+0x24>)
     210:	4a16      	ldr	r2, [pc, #88]	; (26c <endfiniloop+0x28>)

00000212 <bloop>:
     212:	4291      	cmp	r1, r2
     214:	bf3c      	itt	cc
     216:	f841 0b04 	strcc.w	r0, [r1], #4
     21a:	e7fa      	bcc.n	212 <bloop>
     21c:	f000 f940 	bl	4a0 <__late_init>
     220:	4c13      	ldr	r4, [pc, #76]	; (270 <endfiniloop+0x2c>)
     222:	4d14      	ldr	r5, [pc, #80]	; (274 <endfiniloop+0x30>)

00000224 <initloop>:
     224:	42ac      	cmp	r4, r5
     226:	da03      	bge.n	230 <endinitloop>
     228:	f854 1b04 	ldr.w	r1, [r4], #4
     22c:	4788      	blx	r1
     22e:	e7f9      	b.n	224 <initloop>

00000230 <endinitloop>:
     230:	f000 f846 	bl	2c0 <main>
     234:	4c10      	ldr	r4, [pc, #64]	; (278 <endfiniloop+0x34>)
     236:	4d11      	ldr	r5, [pc, #68]	; (27c <endfiniloop+0x38>)

00000238 <finiloop>:
     238:	42ac      	cmp	r4, r5
     23a:	da03      	bge.n	244 <endfiniloop>
     23c:	f854 1b04 	ldr.w	r1, [r4], #4
     240:	4788      	blx	r1
     242:	e7f9      	b.n	238 <finiloop>

00000244 <endfiniloop>:
     244:	f000 b934 	b.w	4b0 <__default_exit>
     248:	20000800 	.word	0x20000800
     24c:	55555555 	.word	0x55555555
     250:	20000000 	.word	0x20000000
     254:	20000400 	.word	0x20000400
     258:	20000400 	.word	0x20000400
     25c:	00004bf0 	.word	0x00004bf0
     260:	20000800 	.word	0x20000800
     264:	20000800 	.word	0x20000800
     268:	20000800 	.word	0x20000800
     26c:	20001278 	.word	0x20001278
     270:	000001c0 	.word	0x000001c0
     274:	000001c0 	.word	0x000001c0
     278:	000001c0 	.word	0x000001c0
     27c:	000001c0 	.word	0x000001c0

00000280 <_port_switch>:
     280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     284:	f8c1 d00c 	str.w	sp, [r1, #12]
     288:	f8d0 d00c 	ldr.w	sp, [r0, #12]
     28c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00000290 <_port_thread_start>:
     290:	f000 fb76 	bl	980 <_dbg_check_unlock>
     294:	f001 fc5c 	bl	1b50 <_stats_stop_measure_crit_thd>
     298:	2300      	movs	r3, #0
     29a:	f383 8811 	msr	BASEPRI, r3
     29e:	4628      	mov	r0, r5
     2a0:	47a0      	blx	r4
     2a2:	2000      	movs	r0, #0
     2a4:	f001 fa5c 	bl	1760 <chThdExit>

000002a8 <_port_switch_from_isr>:
     2a8:	f001 fc4a 	bl	1b40 <_stats_start_measure_crit_thd>
     2ac:	f000 fb50 	bl	950 <_dbg_check_lock>
     2b0:	f001 f836 	bl	1320 <chSchDoReschedule>
     2b4:	f000 fb64 	bl	980 <_dbg_check_unlock>
     2b8:	f001 fc4a 	bl	1b50 <_stats_stop_measure_crit_thd>

000002bc <_port_exit_from_isr>:
     2bc:	df00      	svc	0
     2be:	e7fe      	b.n	2be <_port_exit_from_isr+0x2>

000002c0 <main>:
#include "main.h"

uint8_t cca_exp_io_mode;


int main(void) {
     2c0:	b500      	push	{lr}
     2c2:	b085      	sub	sp, #20
	halInit();
     2c4:	f002 fe34 	bl	2f30 <halInit>
	chSysInit();
     2c8:	f000 fa92 	bl	7f0 <chSysInit>
	thread_t *listener,*writer;
	
	
	palWriteGroup(GPIOD,0xFFFFU,0,0x0000U);//all ports low
     2cc:	4b10      	ldr	r3, [pc, #64]	; (310 <main+0x50>)
     2ce:	4a11      	ldr	r2, [pc, #68]	; (314 <main+0x54>)
     2d0:	619a      	str	r2, [r3, #24]
	chThdSetPriority(NORMALPRIO);
     2d2:	2040      	movs	r0, #64	; 0x40
     2d4:	f001 f9fc 	bl	16d0 <chThdSetPriority>
	init_IO();
     2d8:	f000 f82a 	bl	330 <init_IO>
	init_protocol();
     2dc:	f000 f860 	bl	3a0 <init_protocol>
    listener = chThdCreateStatic(serialListen, sizeof(serialListen), LOWPRIO, rxListen, NULL);
     2e0:	2300      	movs	r3, #0
     2e2:	9300      	str	r3, [sp, #0]
     2e4:	480c      	ldr	r0, [pc, #48]	; (318 <main+0x58>)
     2e6:	f44f 7194 	mov.w	r1, #296	; 0x128
     2ea:	2202      	movs	r2, #2
     2ec:	4b0b      	ldr	r3, [pc, #44]	; (31c <main+0x5c>)
     2ee:	f001 f9bf 	bl	1670 <chThdCreateStatic>
     2f2:	9003      	str	r0, [sp, #12]
    writer = chThdCreateStatic(serialTalk, sizeof(serialTalk), LOWPRIO, txWrite, NULL);
     2f4:	2300      	movs	r3, #0
     2f6:	9300      	str	r3, [sp, #0]
     2f8:	4809      	ldr	r0, [pc, #36]	; (320 <main+0x60>)
     2fa:	f44f 7194 	mov.w	r1, #296	; 0x128
     2fe:	2202      	movs	r2, #2
     300:	4b08      	ldr	r3, [pc, #32]	; (324 <main+0x64>)
     302:	f001 f9b5 	bl	1670 <chThdCreateStatic>
     306:	9002      	str	r0, [sp, #8]
    chThdWait(listener);
     308:	9803      	ldr	r0, [sp, #12]
     30a:	f001 fa79 	bl	1800 <chThdWait>
	{/*
		palWriteGroup(GPIOD,0x000FU,0,0x000FU);//all ports high
		chThdSleepMilliseconds(1000);
		palWriteGroup(GPIOD,0x000FU,0,0x0000U);
		chThdSleepMilliseconds(1000);*/
	}
     30e:	e7fe      	b.n	30e <main+0x4e>
     310:	40020c00 	.word	0x40020c00
     314:	ffff0000 	.word	0xffff0000
     318:	20000800 	.word	0x20000800
     31c:	000003f1 	.word	0x000003f1
     320:	20000928 	.word	0x20000928
     324:	00000431 	.word	0x00000431
     328:	f3af 8000 	nop.w
     32c:	f3af 8000 	nop.w

00000330 <init_IO>:
	return 0;/*never reach here*/
}


void init_IO(void)
{
     330:	b508      	push	{r3, lr}
	//adc_configure();
	//bütün b portlarını (16 tane) pull up input olarak aç
	palSetGroupMode(GPIOB, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
     332:	4814      	ldr	r0, [pc, #80]	; (384 <init_IO+0x54>)
     334:	f64f 71ff 	movw	r1, #65535	; 0xffff
     338:	2220      	movs	r2, #32
     33a:	f003 ff09 	bl	4150 <_pal_lld_setgroupmode>
	
	//set_cca_exp_io_mode();
	
	if( cca_exp_io_mode == CCA_EXP_IO_MODE_OUTPUT)
     33e:	4b12      	ldr	r3, [pc, #72]	; (388 <init_IO+0x58>)
     340:	781b      	ldrb	r3, [r3, #0]
     342:	2b00      	cmp	r3, #0
     344:	d10c      	bne.n	360 <init_IO+0x30>
	{
		palSetGroupMode(GPIOD, PAL_GROUP_MASK(16), 0, PAL_MODE_OUTPUT_PUSHPULL);
     346:	4811      	ldr	r0, [pc, #68]	; (38c <init_IO+0x5c>)
     348:	f64f 71ff 	movw	r1, #65535	; 0xffff
     34c:	2201      	movs	r2, #1
     34e:	f003 feff 	bl	4150 <_pal_lld_setgroupmode>
		palSetGroupMode(GPIOE, PAL_GROUP_MASK(16), 0, PAL_MODE_OUTPUT_PUSHPULL);
     352:	480f      	ldr	r0, [pc, #60]	; (390 <init_IO+0x60>)
     354:	f64f 71ff 	movw	r1, #65535	; 0xffff
     358:	2201      	movs	r2, #1
     35a:	f003 fef9 	bl	4150 <_pal_lld_setgroupmode>
     35e:	e00f      	b.n	380 <init_IO+0x50>
	}
	else if( cca_exp_io_mode == CCA_EXP_IO_MODE_INPUT)
     360:	4b09      	ldr	r3, [pc, #36]	; (388 <init_IO+0x58>)
     362:	781b      	ldrb	r3, [r3, #0]
     364:	2b01      	cmp	r3, #1
     366:	d10b      	bne.n	380 <init_IO+0x50>
	{
		palSetGroupMode(GPIOD, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
     368:	4808      	ldr	r0, [pc, #32]	; (38c <init_IO+0x5c>)
     36a:	f64f 71ff 	movw	r1, #65535	; 0xffff
     36e:	2220      	movs	r2, #32
     370:	f003 feee 	bl	4150 <_pal_lld_setgroupmode>
		palSetGroupMode(GPIOE, PAL_GROUP_MASK(16), 0, PAL_MODE_INPUT_PULLUP);
     374:	4806      	ldr	r0, [pc, #24]	; (390 <init_IO+0x60>)
     376:	f64f 71ff 	movw	r1, #65535	; 0xffff
     37a:	2220      	movs	r2, #32
     37c:	f003 fee8 	bl	4150 <_pal_lld_setgroupmode>
	}
	else
	{
		;// Never reach here
	}
	return;
     380:	bf00      	nop
}
     382:	bd08      	pop	{r3, pc}
     384:	40020400 	.word	0x40020400
     388:	20000a50 	.word	0x20000a50
     38c:	40020c00 	.word	0x40020c00
     390:	40021000 	.word	0x40021000
     394:	f3af 8000 	nop.w
     398:	f3af 8000 	nop.w
     39c:	f3af 8000 	nop.w

000003a0 <init_protocol>:
/*MEMORYPOOL_DECL(mpool, 64, NULL);//sayı kaç olmalı belli değil
msg_t protocol_01_buffer[64];*/
msg_t buffer;

void init_protocol(void)
{
     3a0:	b508      	push	{r3, lr}
	buffer = 0;
     3a2:	4b0e      	ldr	r3, [pc, #56]	; (3dc <init_protocol+0x3c>)
     3a4:	2200      	movs	r2, #0
     3a6:	601a      	str	r2, [r3, #0]
	chMBObjectInit(&serialMbox, txMailboxArea, 16);
     3a8:	480d      	ldr	r0, [pc, #52]	; (3e0 <init_protocol+0x40>)
     3aa:	490e      	ldr	r1, [pc, #56]	; (3e4 <init_protocol+0x44>)
     3ac:	2210      	movs	r2, #16
     3ae:	f002 f81f 	bl	23f0 <chMBObjectInit>
	//chPoolLoadArray(&mpool,protocol_01_buffer,64);
	palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(7));
     3b2:	480d      	ldr	r0, [pc, #52]	; (3e8 <init_protocol+0x48>)
     3b4:	f44f 7100 	mov.w	r1, #512	; 0x200
     3b8:	f240 3282 	movw	r2, #898	; 0x382
     3bc:	f003 fec8 	bl	4150 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(7));
     3c0:	4809      	ldr	r0, [pc, #36]	; (3e8 <init_protocol+0x48>)
     3c2:	f44f 6180 	mov.w	r1, #1024	; 0x400
     3c6:	f240 3282 	movw	r2, #898	; 0x382
     3ca:	f003 fec1 	bl	4150 <_pal_lld_setgroupmode>
	sdStart(&SD1, NULL);
     3ce:	4807      	ldr	r0, [pc, #28]	; (3ec <init_protocol+0x4c>)
     3d0:	2100      	movs	r1, #0
     3d2:	f002 ffd5 	bl	3380 <sdStart>
	return;
     3d6:	bf00      	nop
}
     3d8:	bd08      	pop	{r3, pc}
     3da:	bf00      	nop
     3dc:	20000abc 	.word	0x20000abc
     3e0:	20000a94 	.word	0x20000a94
     3e4:	20000a54 	.word	0x20000a54
     3e8:	40020000 	.word	0x40020000
     3ec:	200011e0 	.word	0x200011e0

000003f0 <rxListen>:

void *rxListen(void *arg)
{
     3f0:	b500      	push	{lr}
     3f2:	b083      	sub	sp, #12
     3f4:	9001      	str	r0, [sp, #4]
	//msg_t *buffer;
	while(!0)
	{
		//buffer = (msg_t *)chPoolAlloc(&mpool);
		sdRead(&SD1, &buffer, 2);
     3f6:	4809      	ldr	r0, [pc, #36]	; (41c <__main_stack_size__+0x1c>)
     3f8:	4909      	ldr	r1, [pc, #36]	; (420 <__main_stack_size__+0x20>)
     3fa:	2202      	movs	r2, #2
     3fc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     400:	f002 fa36 	bl	2870 <chIQReadTimeout>
		chThdSleepMilliseconds(100);
     404:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
     408:	f001 f99a 	bl	1740 <chThdSleep>
		chMBPost(&serialMbox, buffer, TIME_IMMEDIATE);
     40c:	4b04      	ldr	r3, [pc, #16]	; (420 <__main_stack_size__+0x20>)
     40e:	681b      	ldr	r3, [r3, #0]
     410:	4804      	ldr	r0, [pc, #16]	; (424 <__main_stack_size__+0x24>)
     412:	4619      	mov	r1, r3
     414:	2200      	movs	r2, #0
     416:	f002 f823 	bl	2460 <chMBPost>
	}
     41a:	e7ec      	b.n	3f6 <rxListen+0x6>
     41c:	200011ec 	.word	0x200011ec
     420:	20000abc 	.word	0x20000abc
     424:	20000a94 	.word	0x20000a94
     428:	f3af 8000 	nop.w
     42c:	f3af 8000 	nop.w

00000430 <txWrite>:
	return NULL;
}

void *txWrite(void *arg)
{
     430:	b500      	push	{lr}
     432:	b085      	sub	sp, #20
     434:	9001      	str	r0, [sp, #4]
	msg_t toSend;
	while(!0)
	{
		if(chMBFetch(&serialMbox, &toSend, TIME_IMMEDIATE) == MSG_OK)
     436:	ab02      	add	r3, sp, #8
     438:	4810      	ldr	r0, [pc, #64]	; (47c <txWrite+0x4c>)
     43a:	4619      	mov	r1, r3
     43c:	2200      	movs	r2, #0
     43e:	f002 f85f 	bl	2500 <chMBFetch>
     442:	4603      	mov	r3, r0
     444:	2b00      	cmp	r3, #0
     446:	d113      	bne.n	470 <txWrite+0x40>
		{
			//palWriteGroup(GPIOD,0xFFFFU,0,toSend);
			uint16_t a = sdWrite(&SD1, &toSend,2);
     448:	ab02      	add	r3, sp, #8
     44a:	480d      	ldr	r0, [pc, #52]	; (480 <txWrite+0x50>)
     44c:	4619      	mov	r1, r3
     44e:	2202      	movs	r2, #2
     450:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     454:	f002 fb0c 	bl	2a70 <chOQWriteTimeout>
     458:	4603      	mov	r3, r0
     45a:	f8ad 300e 	strh.w	r3, [sp, #14]
			palWriteGroup(GPIOD,0xFFFFU,0,a);
     45e:	4b09      	ldr	r3, [pc, #36]	; (484 <txWrite+0x54>)
     460:	f8bd 200e 	ldrh.w	r2, [sp, #14]
     464:	43d2      	mvns	r2, r2
     466:	0411      	lsls	r1, r2, #16
     468:	f8bd 200e 	ldrh.w	r2, [sp, #14]
     46c:	430a      	orrs	r2, r1
     46e:	619a      	str	r2, [r3, #24]
		}
		//toSend = (msg_t)*ptrtoSend;
		//chPoolFree(&mpool, &toSend);
		chThdSleepMilliseconds(500);
     470:	f241 3088 	movw	r0, #5000	; 0x1388
     474:	f001 f964 	bl	1740 <chThdSleep>
		
	}
     478:	e7dd      	b.n	436 <txWrite+0x6>
     47a:	bf00      	nop
     47c:	20000a94 	.word	0x20000a94
     480:	20001210 	.word	0x20001210
     484:	40020c00 	.word	0x40020c00
     488:	f3af 8000 	nop.w
     48c:	f3af 8000 	nop.w

00000490 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
     490:	4770      	bx	lr
     492:	bf00      	nop
     494:	f3af 8000 	nop.w
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w

000004a0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
     4a0:	4770      	bx	lr
     4a2:	bf00      	nop
     4a4:	f3af 8000 	nop.w
     4a8:	f3af 8000 	nop.w
     4ac:	f3af 8000 	nop.w

000004b0 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
     4b0:	e7fe      	b.n	4b0 <__default_exit>
     4b2:	bf00      	nop
     4b4:	f3af 8000 	nop.w
     4b8:	f3af 8000 	nop.w
     4bc:	f3af 8000 	nop.w

000004c0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
     4c0:	e7fe      	b.n	4c0 <_unhandled_exception>
     4c2:	bf00      	nop
     4c4:	f3af 8000 	nop.w
     4c8:	f3af 8000 	nop.w
     4cc:	f3af 8000 	nop.w

000004d0 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
     4d0:	b084      	sub	sp, #16
     4d2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
     4d4:	9b01      	ldr	r3, [sp, #4]
     4d6:	f003 0307 	and.w	r3, r3, #7
     4da:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
     4dc:	4b0a      	ldr	r3, [pc, #40]	; (508 <NVIC_SetPriorityGrouping+0x38>)
     4de:	68db      	ldr	r3, [r3, #12]
     4e0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
     4e2:	9a02      	ldr	r2, [sp, #8]
     4e4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
     4e8:	4013      	ands	r3, r2
     4ea:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
     4ec:	9b03      	ldr	r3, [sp, #12]
     4ee:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
     4f0:	9b02      	ldr	r3, [sp, #8]
     4f2:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
     4f4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
     4f8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     4fc:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
     4fe:	4b02      	ldr	r3, [pc, #8]	; (508 <NVIC_SetPriorityGrouping+0x38>)
     500:	9a02      	ldr	r2, [sp, #8]
     502:	60da      	str	r2, [r3, #12]
}
     504:	b004      	add	sp, #16
     506:	4770      	bx	lr
     508:	e000ed00 	.word	0xe000ed00
     50c:	f3af 8000 	nop.w

00000510 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
     510:	b082      	sub	sp, #8
     512:	4603      	mov	r3, r0
     514:	9100      	str	r1, [sp, #0]
     516:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
     51a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
     51e:	2b00      	cmp	r3, #0
     520:	da0c      	bge.n	53c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     522:	490c      	ldr	r1, [pc, #48]	; (554 <NVIC_SetPriority+0x44>)
     524:	f89d 3007 	ldrb.w	r3, [sp, #7]
     528:	f003 030f 	and.w	r3, r3, #15
     52c:	3b04      	subs	r3, #4
     52e:	9a00      	ldr	r2, [sp, #0]
     530:	b2d2      	uxtb	r2, r2
     532:	0112      	lsls	r2, r2, #4
     534:	b2d2      	uxtb	r2, r2
     536:	440b      	add	r3, r1
     538:	761a      	strb	r2, [r3, #24]
     53a:	e009      	b.n	550 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     53c:	4906      	ldr	r1, [pc, #24]	; (558 <NVIC_SetPriority+0x48>)
     53e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
     542:	9a00      	ldr	r2, [sp, #0]
     544:	b2d2      	uxtb	r2, r2
     546:	0112      	lsls	r2, r2, #4
     548:	b2d2      	uxtb	r2, r2
     54a:	440b      	add	r3, r1
     54c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
     550:	b002      	add	sp, #8
     552:	4770      	bx	lr
     554:	e000ed00 	.word	0xe000ed00
     558:	e000e100 	.word	0xe000e100
     55c:	f3af 8000 	nop.w

00000560 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
     560:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
     562:	4b0e      	ldr	r3, [pc, #56]	; (59c <port_init+0x3c>)
     564:	2200      	movs	r2, #0
     566:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
     568:	2003      	movs	r0, #3
     56a:	f7ff ffb1 	bl	4d0 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
     56e:	4b0c      	ldr	r3, [pc, #48]	; (5a0 <port_init+0x40>)
     570:	4a0b      	ldr	r2, [pc, #44]	; (5a0 <port_init+0x40>)
     572:	68d2      	ldr	r2, [r2, #12]
     574:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
     578:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
     57a:	4b0a      	ldr	r3, [pc, #40]	; (5a4 <port_init+0x44>)
     57c:	4a09      	ldr	r2, [pc, #36]	; (5a4 <port_init+0x44>)
     57e:	6812      	ldr	r2, [r2, #0]
     580:	f042 0201 	orr.w	r2, r2, #1
     584:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
     586:	f06f 0004 	mvn.w	r0, #4
     58a:	2101      	movs	r1, #1
     58c:	f7ff ffc0 	bl	510 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
     590:	f06f 0001 	mvn.w	r0, #1
     594:	2102      	movs	r1, #2
     596:	f7ff ffbb 	bl	510 <NVIC_SetPriority>
}
     59a:	bd08      	pop	{r3, pc}
     59c:	e000ed00 	.word	0xe000ed00
     5a0:	e000edf0 	.word	0xe000edf0
     5a4:	e0001000 	.word	0xe0001000
     5a8:	f3af 8000 	nop.w
     5ac:	f3af 8000 	nop.w

000005b0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     5b0:	b082      	sub	sp, #8
     5b2:	2320      	movs	r3, #32
     5b4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     5b6:	9b01      	ldr	r3, [sp, #4]
     5b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     5bc:	b002      	add	sp, #8
     5be:	4770      	bx	lr

000005c0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     5c0:	b082      	sub	sp, #8
     5c2:	2300      	movs	r3, #0
     5c4:	9301      	str	r3, [sp, #4]
     5c6:	9b01      	ldr	r3, [sp, #4]
     5c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     5cc:	b002      	add	sp, #8
     5ce:	4770      	bx	lr

000005d0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     5d0:	b508      	push	{r3, lr}

  port_lock();
     5d2:	f7ff ffed 	bl	5b0 <port_lock>
}
     5d6:	bd08      	pop	{r3, pc}
     5d8:	f3af 8000 	nop.w
     5dc:	f3af 8000 	nop.w

000005e0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     5e0:	b508      	push	{r3, lr}

  port_unlock();
     5e2:	f7ff ffed 	bl	5c0 <port_unlock>
}
     5e6:	bd08      	pop	{r3, pc}
     5e8:	f3af 8000 	nop.w
     5ec:	f3af 8000 	nop.w

000005f0 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
     5f0:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
     5f2:	4770      	bx	lr
     5f4:	f3af 8000 	nop.w
     5f8:	f3af 8000 	nop.w
     5fc:	f3af 8000 	nop.w

00000600 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
     600:	b082      	sub	sp, #8
     602:	2300      	movs	r3, #0
     604:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     606:	9b01      	ldr	r3, [sp, #4]
     608:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
     60c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
     60e:	b002      	add	sp, #8
     610:	4770      	bx	lr
     612:	bf00      	nop
     614:	f3af 8000 	nop.w
     618:	f3af 8000 	nop.w
     61c:	f3af 8000 	nop.w

00000620 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
     620:	4770      	bx	lr
     622:	bf00      	nop
     624:	f3af 8000 	nop.w
     628:	f3af 8000 	nop.w
     62c:	f3af 8000 	nop.w

00000630 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     630:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     634:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     636:	4618      	mov	r0, r3
     638:	4770      	bx	lr
     63a:	bf00      	nop
     63c:	f3af 8000 	nop.w

00000640 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
     640:	b508      	push	{r3, lr}

  stStopAlarm();
     642:	f002 fcdd 	bl	3000 <stStopAlarm>
}
     646:	bd08      	pop	{r3, pc}
     648:	f3af 8000 	nop.w
     64c:	f3af 8000 	nop.w

00000650 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
     650:	b500      	push	{lr}
     652:	b083      	sub	sp, #12
     654:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
     656:	9801      	ldr	r0, [sp, #4]
     658:	f002 fcda 	bl	3010 <stSetAlarm>
}
     65c:	b003      	add	sp, #12
     65e:	f85d fb04 	ldr.w	pc, [sp], #4
     662:	bf00      	nop
     664:	f3af 8000 	nop.w
     668:	f3af 8000 	nop.w
     66c:	f3af 8000 	nop.w

00000670 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     670:	b508      	push	{r3, lr}

  return stGetCounter();
     672:	f7ff ffdd 	bl	630 <st_lld_get_counter>
     676:	4603      	mov	r3, r0
}
     678:	4618      	mov	r0, r3
     67a:	bd08      	pop	{r3, pc}
     67c:	f3af 8000 	nop.w

00000680 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
     680:	b508      	push	{r3, lr}

  _dbg_check_enable();
     682:	f000 f94d 	bl	920 <_dbg_check_enable>
  port_enable();
     686:	f7ff ffbb 	bl	600 <port_enable>
}
     68a:	bd08      	pop	{r3, pc}
     68c:	f3af 8000 	nop.w

00000690 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
     690:	b508      	push	{r3, lr}

  port_lock_from_isr();
     692:	f7ff ff9d 	bl	5d0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
     696:	f001 fa63 	bl	1b60 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
     69a:	f000 f989 	bl	9b0 <_dbg_check_lock_from_isr>
}
     69e:	bd08      	pop	{r3, pc}

000006a0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
     6a0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
     6a2:	f000 f99d 	bl	9e0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
     6a6:	f001 fa63 	bl	1b70 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
     6aa:	f7ff ff99 	bl	5e0 <port_unlock_from_isr>
}
     6ae:	bd08      	pop	{r3, pc}

000006b0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     6b0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     6b2:	f7ff ffdd 	bl	670 <port_timer_get_time>
     6b6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     6b8:	4618      	mov	r0, r3
     6ba:	bd08      	pop	{r3, pc}
     6bc:	f3af 8000 	nop.w

000006c0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
     6c0:	b500      	push	{lr}
     6c2:	b085      	sub	sp, #20

  chDbgCheckClassI();
     6c4:	f000 f9e4 	bl	a90 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
     6c8:	4b33      	ldr	r3, [pc, #204]	; (798 <chVTDoTickI+0xd8>)
     6ca:	69db      	ldr	r3, [r3, #28]
     6cc:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
     6ce:	f7ff ffef 	bl	6b0 <chVTGetSystemTimeX>
     6d2:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
     6d4:	e02a      	b.n	72c <chVTDoTickI+0x6c>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
     6d6:	4b30      	ldr	r3, [pc, #192]	; (798 <chVTDoTickI+0xd8>)
     6d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     6da:	9b03      	ldr	r3, [sp, #12]
     6dc:	689b      	ldr	r3, [r3, #8]
     6de:	441a      	add	r2, r3
     6e0:	4b2d      	ldr	r3, [pc, #180]	; (798 <chVTDoTickI+0xd8>)
     6e2:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     6e4:	9b03      	ldr	r3, [sp, #12]
     6e6:	681b      	ldr	r3, [r3, #0]
     6e8:	4a2c      	ldr	r2, [pc, #176]	; (79c <chVTDoTickI+0xdc>)
     6ea:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
     6ec:	9b03      	ldr	r3, [sp, #12]
     6ee:	681a      	ldr	r2, [r3, #0]
     6f0:	4b29      	ldr	r3, [pc, #164]	; (798 <chVTDoTickI+0xd8>)
     6f2:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
     6f4:	9b03      	ldr	r3, [sp, #12]
     6f6:	68db      	ldr	r3, [r3, #12]
     6f8:	9300      	str	r3, [sp, #0]
    vtp->vt_func = NULL;
     6fa:	9b03      	ldr	r3, [sp, #12]
     6fc:	2200      	movs	r2, #0
     6fe:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
     700:	4b25      	ldr	r3, [pc, #148]	; (798 <chVTDoTickI+0xd8>)
     702:	69da      	ldr	r2, [r3, #28]
     704:	4b25      	ldr	r3, [pc, #148]	; (79c <chVTDoTickI+0xdc>)
     706:	429a      	cmp	r2, r3
     708:	d101      	bne.n	70e <chVTDoTickI+0x4e>
      port_timer_stop_alarm();
     70a:	f7ff ff99 	bl	640 <port_timer_stop_alarm>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
     70e:	f7ff ffc7 	bl	6a0 <chSysUnlockFromISR>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
     712:	9b03      	ldr	r3, [sp, #12]
     714:	691a      	ldr	r2, [r3, #16]
     716:	9b00      	ldr	r3, [sp, #0]
     718:	4610      	mov	r0, r2
     71a:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
     71c:	f7ff ffb8 	bl	690 <chSysLockFromISR>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
     720:	4b1d      	ldr	r3, [pc, #116]	; (798 <chVTDoTickI+0xd8>)
     722:	69db      	ldr	r3, [r3, #28]
     724:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
     726:	f7ff ffc3 	bl	6b0 <chVTGetSystemTimeX>
     72a:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
     72c:	9b03      	ldr	r3, [sp, #12]
     72e:	689a      	ldr	r2, [r3, #8]
     730:	4b19      	ldr	r3, [pc, #100]	; (798 <chVTDoTickI+0xd8>)
     732:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     734:	9902      	ldr	r1, [sp, #8]
     736:	1acb      	subs	r3, r1, r3
     738:	429a      	cmp	r2, r3
     73a:	d9cc      	bls.n	6d6 <chVTDoTickI+0x16>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
     73c:	4b16      	ldr	r3, [pc, #88]	; (798 <chVTDoTickI+0xd8>)
     73e:	69da      	ldr	r2, [r3, #28]
     740:	4b16      	ldr	r3, [pc, #88]	; (79c <chVTDoTickI+0xdc>)
     742:	429a      	cmp	r2, r3
     744:	d100      	bne.n	748 <chVTDoTickI+0x88>
    return;
     746:	e023      	b.n	790 <chVTDoTickI+0xd0>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
     748:	4b13      	ldr	r3, [pc, #76]	; (798 <chVTDoTickI+0xd8>)
     74a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     74c:	9b03      	ldr	r3, [sp, #12]
     74e:	689b      	ldr	r3, [r3, #8]
     750:	441a      	add	r2, r3
     752:	9b02      	ldr	r3, [sp, #8]
     754:	1ad3      	subs	r3, r2, r3
     756:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
     758:	9b01      	ldr	r3, [sp, #4]
     75a:	2b01      	cmp	r3, #1
     75c:	d801      	bhi.n	762 <chVTDoTickI+0xa2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
     75e:	2302      	movs	r3, #2
     760:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
     762:	9a02      	ldr	r2, [sp, #8]
     764:	9b01      	ldr	r3, [sp, #4]
     766:	4413      	add	r3, r2
     768:	4618      	mov	r0, r3
     76a:	f7ff ff71 	bl	650 <port_timer_set_alarm>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
     76e:	f7ff ff9f 	bl	6b0 <chVTGetSystemTimeX>
     772:	4602      	mov	r2, r0
     774:	4b08      	ldr	r3, [pc, #32]	; (798 <chVTDoTickI+0xd8>)
     776:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     778:	1ad2      	subs	r2, r2, r3
     77a:	9902      	ldr	r1, [sp, #8]
     77c:	9b01      	ldr	r3, [sp, #4]
     77e:	4419      	add	r1, r3
     780:	4b05      	ldr	r3, [pc, #20]	; (798 <chVTDoTickI+0xd8>)
     782:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     784:	1acb      	subs	r3, r1, r3
     786:	429a      	cmp	r2, r3
     788:	d902      	bls.n	790 <chVTDoTickI+0xd0>
     78a:	4805      	ldr	r0, [pc, #20]	; (7a0 <chVTDoTickI+0xe0>)
     78c:	f000 f878 	bl	880 <chSysHalt>
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     790:	b005      	add	sp, #20
     792:	f85d fb04 	ldr.w	pc, [sp], #4
     796:	bf00      	nop
     798:	20000ac0 	.word	0x20000ac0
     79c:	20000adc 	.word	0x20000adc
     7a0:	00004720 	.word	0x00004720
     7a4:	f3af 8000 	nop.w
     7a8:	f3af 8000 	nop.w
     7ac:	f3af 8000 	nop.w

000007b0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
     7b0:	b082      	sub	sp, #8
     7b2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
     7b4:	4b02      	ldr	r3, [pc, #8]	; (7c0 <chRegSetThreadName+0x10>)
     7b6:	699b      	ldr	r3, [r3, #24]
     7b8:	9a01      	ldr	r2, [sp, #4]
     7ba:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
     7bc:	b002      	add	sp, #8
     7be:	4770      	bx	lr
     7c0:	20000ac0 	.word	0x20000ac0
     7c4:	f3af 8000 	nop.w
     7c8:	f3af 8000 	nop.w
     7cc:	f3af 8000 	nop.w

000007d0 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
     7d0:	b082      	sub	sp, #8
     7d2:	9001      	str	r0, [sp, #4]
     7d4:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
     7d6:	9b01      	ldr	r3, [sp, #4]
     7d8:	9a00      	ldr	r2, [sp, #0]
     7da:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
     7dc:	b002      	add	sp, #8
     7de:	4770      	bx	lr

000007e0 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
     7e0:	b500      	push	{lr}
     7e2:	b083      	sub	sp, #12
     7e4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
     7e6:	f7ff ff1b 	bl	620 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
  }
     7ea:	e7fc      	b.n	7e6 <_idle_thread+0x6>
     7ec:	f3af 8000 	nop.w

000007f0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
     7f0:	b500      	push	{lr}
     7f2:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
     7f4:	f7ff feb4 	bl	560 <port_init>
  _scheduler_init();
     7f8:	f000 fbc2 	bl	f80 <_scheduler_init>
  _vt_init();
     7fc:	f000 f9f8 	bl	bf0 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
     800:	f001 f8de 	bl	19c0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
     804:	f002 f9cc 	bl	2ba0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
     808:	f002 fa1a 	bl	2c40 <_heap_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  _stats_init();
     80c:	f001 f950 	bl	1ab0 <_stats_init>
#endif
#if CH_DBG_ENABLE_TRACE == TRUE
  _dbg_trace_init();
     810:	f000 f96e 	bl	af0 <_dbg_trace_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
     814:	4812      	ldr	r0, [pc, #72]	; (860 <chSysInit+0x70>)
     816:	2140      	movs	r1, #64	; 0x40
     818:	f000 fe8a 	bl	1530 <_thread_init>
     81c:	4602      	mov	r2, r0
     81e:	4b11      	ldr	r3, [pc, #68]	; (864 <chSysInit+0x74>)
     820:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
     822:	4b10      	ldr	r3, [pc, #64]	; (864 <chSysInit+0x74>)
     824:	699b      	ldr	r3, [r3, #24]
     826:	2201      	movs	r2, #1
     828:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
     82c:	4b0d      	ldr	r3, [pc, #52]	; (864 <chSysInit+0x74>)
     82e:	699b      	ldr	r3, [r3, #24]
     830:	4a0d      	ldr	r2, [pc, #52]	; (868 <chSysInit+0x78>)
     832:	61da      	str	r2, [r3, #28]
#endif
  chSysEnable();
     834:	f7ff ff24 	bl	680 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
     838:	480c      	ldr	r0, [pc, #48]	; (86c <chSysInit+0x7c>)
     83a:	f7ff ffb9 	bl	7b0 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
     83e:	2300      	movs	r3, #0
     840:	9300      	str	r3, [sp, #0]
     842:	480b      	ldr	r0, [pc, #44]	; (870 <chSysInit+0x80>)
     844:	21f8      	movs	r1, #248	; 0xf8
     846:	2201      	movs	r2, #1
     848:	4b0a      	ldr	r3, [pc, #40]	; (874 <chSysInit+0x84>)
     84a:	f000 ff11 	bl	1670 <chThdCreateStatic>
     84e:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
     850:	9803      	ldr	r0, [sp, #12]
     852:	4909      	ldr	r1, [pc, #36]	; (878 <chSysInit+0x88>)
     854:	f7ff ffbc 	bl	7d0 <chRegSetThreadNameX>
  }
#endif
}
     858:	b005      	add	sp, #20
     85a:	f85d fb04 	ldr.w	pc, [sp], #4
     85e:	bf00      	nop
     860:	20000f00 	.word	0x20000f00
     864:	20000ac0 	.word	0x20000ac0
     868:	20000400 	.word	0x20000400
     86c:	00004820 	.word	0x00004820
     870:	20000fa0 	.word	0x20000fa0
     874:	000007e1 	.word	0x000007e1
     878:	000046a0 	.word	0x000046a0
     87c:	f3af 8000 	nop.w

00000880 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
     880:	b500      	push	{lr}
     882:	b083      	sub	sp, #12
     884:	9001      	str	r0, [sp, #4]

  port_disable();
     886:	f7ff feb3 	bl	5f0 <port_disable>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
     88a:	4b02      	ldr	r3, [pc, #8]	; (894 <chSysHalt+0x14>)
     88c:	9a01      	ldr	r2, [sp, #4]
     88e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
     890:	e7fe      	b.n	890 <chSysHalt+0x10>
     892:	bf00      	nop
     894:	20000ac0 	.word	0x20000ac0
     898:	f3af 8000 	nop.w
     89c:	f3af 8000 	nop.w

000008a0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     8a0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
     8a2:	f000 f8f5 	bl	a90 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
     8a6:	f7ff ff0b 	bl	6c0 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
     8aa:	bd08      	pop	{r3, pc}
     8ac:	f3af 8000 	nop.w

000008b0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     8b0:	b082      	sub	sp, #8
     8b2:	2320      	movs	r3, #32
     8b4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
     8b6:	9b01      	ldr	r3, [sp, #4]
     8b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     8bc:	b002      	add	sp, #8
     8be:	4770      	bx	lr

000008c0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     8c0:	b082      	sub	sp, #8
     8c2:	2300      	movs	r3, #0
     8c4:	9301      	str	r3, [sp, #4]
     8c6:	9b01      	ldr	r3, [sp, #4]
     8c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     8cc:	b002      	add	sp, #8
     8ce:	4770      	bx	lr

000008d0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     8d0:	b508      	push	{r3, lr}

  port_lock();
     8d2:	f7ff ffed 	bl	8b0 <port_lock>
}
     8d6:	bd08      	pop	{r3, pc}
     8d8:	f3af 8000 	nop.w
     8dc:	f3af 8000 	nop.w

000008e0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     8e0:	b508      	push	{r3, lr}

  port_unlock();
     8e2:	f7ff ffed 	bl	8c0 <port_unlock>
}
     8e6:	bd08      	pop	{r3, pc}
     8e8:	f3af 8000 	nop.w
     8ec:	f3af 8000 	nop.w

000008f0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     8f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     8f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     8f6:	4618      	mov	r0, r3
     8f8:	4770      	bx	lr
     8fa:	bf00      	nop
     8fc:	f3af 8000 	nop.w

00000900 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     900:	b508      	push	{r3, lr}

  return stGetCounter();
     902:	f7ff fff5 	bl	8f0 <st_lld_get_counter>
     906:	4603      	mov	r3, r0
}
     908:	4618      	mov	r0, r3
     90a:	bd08      	pop	{r3, pc}
     90c:	f3af 8000 	nop.w

00000910 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     910:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     912:	f7ff fff5 	bl	900 <port_timer_get_time>
     916:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     918:	4618      	mov	r0, r3
     91a:	bd08      	pop	{r3, pc}
     91c:	f3af 8000 	nop.w

00000920 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
     920:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     922:	4b06      	ldr	r3, [pc, #24]	; (93c <_dbg_check_enable+0x1c>)
     924:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     926:	2b00      	cmp	r3, #0
     928:	d103      	bne.n	932 <_dbg_check_enable+0x12>
     92a:	4b04      	ldr	r3, [pc, #16]	; (93c <_dbg_check_enable+0x1c>)
     92c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     92e:	2b00      	cmp	r3, #0
     930:	d002      	beq.n	938 <_dbg_check_enable+0x18>
    chSysHalt("SV#3");
     932:	4803      	ldr	r0, [pc, #12]	; (940 <_dbg_check_enable+0x20>)
     934:	f7ff ffa4 	bl	880 <chSysHalt>
  }
}
     938:	bd08      	pop	{r3, pc}
     93a:	bf00      	nop
     93c:	20000ac0 	.word	0x20000ac0
     940:	000046c0 	.word	0x000046c0
     944:	f3af 8000 	nop.w
     948:	f3af 8000 	nop.w
     94c:	f3af 8000 	nop.w

00000950 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
     950:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     952:	4b07      	ldr	r3, [pc, #28]	; (970 <_dbg_check_lock+0x20>)
     954:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     956:	2b00      	cmp	r3, #0
     958:	d103      	bne.n	962 <_dbg_check_lock+0x12>
     95a:	4b05      	ldr	r3, [pc, #20]	; (970 <_dbg_check_lock+0x20>)
     95c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     95e:	2b00      	cmp	r3, #0
     960:	d002      	beq.n	968 <_dbg_check_lock+0x18>
    chSysHalt("SV#4");
     962:	4804      	ldr	r0, [pc, #16]	; (974 <_dbg_check_lock+0x24>)
     964:	f7ff ff8c 	bl	880 <chSysHalt>
  }
  _dbg_enter_lock();
     968:	4b01      	ldr	r3, [pc, #4]	; (970 <_dbg_check_lock+0x20>)
     96a:	2201      	movs	r2, #1
     96c:	635a      	str	r2, [r3, #52]	; 0x34
}
     96e:	bd08      	pop	{r3, pc}
     970:	20000ac0 	.word	0x20000ac0
     974:	000046c8 	.word	0x000046c8
     978:	f3af 8000 	nop.w
     97c:	f3af 8000 	nop.w

00000980 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
     980:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     982:	4b07      	ldr	r3, [pc, #28]	; (9a0 <_dbg_check_unlock+0x20>)
     984:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     986:	2b00      	cmp	r3, #0
     988:	d103      	bne.n	992 <_dbg_check_unlock+0x12>
     98a:	4b05      	ldr	r3, [pc, #20]	; (9a0 <_dbg_check_unlock+0x20>)
     98c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     98e:	2b00      	cmp	r3, #0
     990:	dc02      	bgt.n	998 <_dbg_check_unlock+0x18>
    chSysHalt("SV#5");
     992:	4804      	ldr	r0, [pc, #16]	; (9a4 <_dbg_check_unlock+0x24>)
     994:	f7ff ff74 	bl	880 <chSysHalt>
  }
  _dbg_leave_lock();
     998:	4b01      	ldr	r3, [pc, #4]	; (9a0 <_dbg_check_unlock+0x20>)
     99a:	2200      	movs	r2, #0
     99c:	635a      	str	r2, [r3, #52]	; 0x34
}
     99e:	bd08      	pop	{r3, pc}
     9a0:	20000ac0 	.word	0x20000ac0
     9a4:	000046d0 	.word	0x000046d0
     9a8:	f3af 8000 	nop.w
     9ac:	f3af 8000 	nop.w

000009b0 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
     9b0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     9b2:	4b07      	ldr	r3, [pc, #28]	; (9d0 <_dbg_check_lock_from_isr+0x20>)
     9b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     9b6:	2b00      	cmp	r3, #0
     9b8:	dd03      	ble.n	9c2 <_dbg_check_lock_from_isr+0x12>
     9ba:	4b05      	ldr	r3, [pc, #20]	; (9d0 <_dbg_check_lock_from_isr+0x20>)
     9bc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     9be:	2b00      	cmp	r3, #0
     9c0:	d002      	beq.n	9c8 <_dbg_check_lock_from_isr+0x18>
    chSysHalt("SV#6");
     9c2:	4804      	ldr	r0, [pc, #16]	; (9d4 <_dbg_check_lock_from_isr+0x24>)
     9c4:	f7ff ff5c 	bl	880 <chSysHalt>
  }
  _dbg_enter_lock();
     9c8:	4b01      	ldr	r3, [pc, #4]	; (9d0 <_dbg_check_lock_from_isr+0x20>)
     9ca:	2201      	movs	r2, #1
     9cc:	635a      	str	r2, [r3, #52]	; 0x34
}
     9ce:	bd08      	pop	{r3, pc}
     9d0:	20000ac0 	.word	0x20000ac0
     9d4:	000046d8 	.word	0x000046d8
     9d8:	f3af 8000 	nop.w
     9dc:	f3af 8000 	nop.w

000009e0 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
     9e0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     9e2:	4b07      	ldr	r3, [pc, #28]	; (a00 <_dbg_check_unlock_from_isr+0x20>)
     9e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     9e6:	2b00      	cmp	r3, #0
     9e8:	dd03      	ble.n	9f2 <_dbg_check_unlock_from_isr+0x12>
     9ea:	4b05      	ldr	r3, [pc, #20]	; (a00 <_dbg_check_unlock_from_isr+0x20>)
     9ec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     9ee:	2b00      	cmp	r3, #0
     9f0:	dc02      	bgt.n	9f8 <_dbg_check_unlock_from_isr+0x18>
    chSysHalt("SV#7");
     9f2:	4804      	ldr	r0, [pc, #16]	; (a04 <_dbg_check_unlock_from_isr+0x24>)
     9f4:	f7ff ff44 	bl	880 <chSysHalt>
  }
  _dbg_leave_lock();
     9f8:	4b01      	ldr	r3, [pc, #4]	; (a00 <_dbg_check_unlock_from_isr+0x20>)
     9fa:	2200      	movs	r2, #0
     9fc:	635a      	str	r2, [r3, #52]	; 0x34
}
     9fe:	bd08      	pop	{r3, pc}
     a00:	20000ac0 	.word	0x20000ac0
     a04:	000046e0 	.word	0x000046e0
     a08:	f3af 8000 	nop.w
     a0c:	f3af 8000 	nop.w

00000a10 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
     a10:	b508      	push	{r3, lr}

  port_lock_from_isr();
     a12:	f7ff ff5d 	bl	8d0 <port_lock_from_isr>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     a16:	4b09      	ldr	r3, [pc, #36]	; (a3c <_dbg_check_enter_isr+0x2c>)
     a18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     a1a:	2b00      	cmp	r3, #0
     a1c:	db03      	blt.n	a26 <_dbg_check_enter_isr+0x16>
     a1e:	4b07      	ldr	r3, [pc, #28]	; (a3c <_dbg_check_enter_isr+0x2c>)
     a20:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     a22:	2b00      	cmp	r3, #0
     a24:	d002      	beq.n	a2c <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
     a26:	4806      	ldr	r0, [pc, #24]	; (a40 <_dbg_check_enter_isr+0x30>)
     a28:	f7ff ff2a 	bl	880 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
     a2c:	4b03      	ldr	r3, [pc, #12]	; (a3c <_dbg_check_enter_isr+0x2c>)
     a2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     a30:	1c5a      	adds	r2, r3, #1
     a32:	4b02      	ldr	r3, [pc, #8]	; (a3c <_dbg_check_enter_isr+0x2c>)
     a34:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
     a36:	f7ff ff53 	bl	8e0 <port_unlock_from_isr>
}
     a3a:	bd08      	pop	{r3, pc}
     a3c:	20000ac0 	.word	0x20000ac0
     a40:	000046e8 	.word	0x000046e8
     a44:	f3af 8000 	nop.w
     a48:	f3af 8000 	nop.w
     a4c:	f3af 8000 	nop.w

00000a50 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
     a50:	b508      	push	{r3, lr}

  port_lock_from_isr();
     a52:	f7ff ff3d 	bl	8d0 <port_lock_from_isr>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     a56:	4b09      	ldr	r3, [pc, #36]	; (a7c <_dbg_check_leave_isr+0x2c>)
     a58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     a5a:	2b00      	cmp	r3, #0
     a5c:	dd03      	ble.n	a66 <_dbg_check_leave_isr+0x16>
     a5e:	4b07      	ldr	r3, [pc, #28]	; (a7c <_dbg_check_leave_isr+0x2c>)
     a60:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     a62:	2b00      	cmp	r3, #0
     a64:	d002      	beq.n	a6c <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
     a66:	4806      	ldr	r0, [pc, #24]	; (a80 <_dbg_check_leave_isr+0x30>)
     a68:	f7ff ff0a 	bl	880 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
     a6c:	4b03      	ldr	r3, [pc, #12]	; (a7c <_dbg_check_leave_isr+0x2c>)
     a6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     a70:	1e5a      	subs	r2, r3, #1
     a72:	4b02      	ldr	r3, [pc, #8]	; (a7c <_dbg_check_leave_isr+0x2c>)
     a74:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
     a76:	f7ff ff33 	bl	8e0 <port_unlock_from_isr>
}
     a7a:	bd08      	pop	{r3, pc}
     a7c:	20000ac0 	.word	0x20000ac0
     a80:	000046f0 	.word	0x000046f0
     a84:	f3af 8000 	nop.w
     a88:	f3af 8000 	nop.w
     a8c:	f3af 8000 	nop.w

00000a90 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
     a90:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     a92:	4b06      	ldr	r3, [pc, #24]	; (aac <chDbgCheckClassI+0x1c>)
     a94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     a96:	2b00      	cmp	r3, #0
     a98:	db03      	blt.n	aa2 <chDbgCheckClassI+0x12>
     a9a:	4b04      	ldr	r3, [pc, #16]	; (aac <chDbgCheckClassI+0x1c>)
     a9c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     a9e:	2b00      	cmp	r3, #0
     aa0:	dc02      	bgt.n	aa8 <chDbgCheckClassI+0x18>
    chSysHalt("SV#10");
     aa2:	4803      	ldr	r0, [pc, #12]	; (ab0 <chDbgCheckClassI+0x20>)
     aa4:	f7ff feec 	bl	880 <chSysHalt>
  }
}
     aa8:	bd08      	pop	{r3, pc}
     aaa:	bf00      	nop
     aac:	20000ac0 	.word	0x20000ac0
     ab0:	000046f8 	.word	0x000046f8
     ab4:	f3af 8000 	nop.w
     ab8:	f3af 8000 	nop.w
     abc:	f3af 8000 	nop.w

00000ac0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
     ac0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
     ac2:	4b06      	ldr	r3, [pc, #24]	; (adc <chDbgCheckClassS+0x1c>)
     ac4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     ac6:	2b00      	cmp	r3, #0
     ac8:	d103      	bne.n	ad2 <chDbgCheckClassS+0x12>
     aca:	4b04      	ldr	r3, [pc, #16]	; (adc <chDbgCheckClassS+0x1c>)
     acc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     ace:	2b00      	cmp	r3, #0
     ad0:	dc02      	bgt.n	ad8 <chDbgCheckClassS+0x18>
    chSysHalt("SV#11");
     ad2:	4803      	ldr	r0, [pc, #12]	; (ae0 <chDbgCheckClassS+0x20>)
     ad4:	f7ff fed4 	bl	880 <chSysHalt>
  }
}
     ad8:	bd08      	pop	{r3, pc}
     ada:	bf00      	nop
     adc:	20000ac0 	.word	0x20000ac0
     ae0:	00004700 	.word	0x00004700
     ae4:	f3af 8000 	nop.w
     ae8:	f3af 8000 	nop.w
     aec:	f3af 8000 	nop.w

00000af0 <_dbg_trace_init>:
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
     af0:	4b03      	ldr	r3, [pc, #12]	; (b00 <_dbg_trace_init+0x10>)
     af2:	2240      	movs	r2, #64	; 0x40
     af4:	639a      	str	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
     af6:	4b02      	ldr	r3, [pc, #8]	; (b00 <_dbg_trace_init+0x10>)
     af8:	4a02      	ldr	r2, [pc, #8]	; (b04 <_dbg_trace_init+0x14>)
     afa:	63da      	str	r2, [r3, #60]	; 0x3c
}
     afc:	4770      	bx	lr
     afe:	bf00      	nop
     b00:	20000ac0 	.word	0x20000ac0
     b04:	20000b00 	.word	0x20000b00
     b08:	f3af 8000 	nop.w
     b0c:	f3af 8000 	nop.w

00000b10 <_dbg_trace>:
 *
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {
     b10:	b510      	push	{r4, lr}
     b12:	b082      	sub	sp, #8
     b14:	9001      	str	r0, [sp, #4]

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
     b16:	4b13      	ldr	r3, [pc, #76]	; (b64 <_dbg_trace+0x54>)
     b18:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
     b1a:	f7ff fef9 	bl	910 <chVTGetSystemTimeX>
     b1e:	4603      	mov	r3, r0
     b20:	6023      	str	r3, [r4, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
     b22:	4b10      	ldr	r3, [pc, #64]	; (b64 <_dbg_trace+0x54>)
     b24:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     b26:	4a0f      	ldr	r2, [pc, #60]	; (b64 <_dbg_trace+0x54>)
     b28:	6992      	ldr	r2, [r2, #24]
     b2a:	605a      	str	r2, [r3, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
     b2c:	4b0d      	ldr	r3, [pc, #52]	; (b64 <_dbg_trace+0x54>)
     b2e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     b30:	9a01      	ldr	r2, [sp, #4]
     b32:	6a52      	ldr	r2, [r2, #36]	; 0x24
     b34:	609a      	str	r2, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
     b36:	4b0b      	ldr	r3, [pc, #44]	; (b64 <_dbg_trace+0x54>)
     b38:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     b3a:	9a01      	ldr	r2, [sp, #4]
     b3c:	f892 2020 	ldrb.w	r2, [r2, #32]
     b40:	731a      	strb	r2, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
     b42:	4b08      	ldr	r3, [pc, #32]	; (b64 <_dbg_trace+0x54>)
     b44:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
     b46:	f103 0210 	add.w	r2, r3, #16
     b4a:	4b06      	ldr	r3, [pc, #24]	; (b64 <_dbg_trace+0x54>)
     b4c:	63da      	str	r2, [r3, #60]	; 0x3c
     b4e:	4b05      	ldr	r3, [pc, #20]	; (b64 <_dbg_trace+0x54>)
     b50:	6bda      	ldr	r2, [r3, #60]	; 0x3c
     b52:	4b05      	ldr	r3, [pc, #20]	; (b68 <_dbg_trace+0x58>)
     b54:	429a      	cmp	r2, r3
     b56:	d302      	bcc.n	b5e <_dbg_trace+0x4e>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
     b58:	4b02      	ldr	r3, [pc, #8]	; (b64 <_dbg_trace+0x54>)
     b5a:	4a04      	ldr	r2, [pc, #16]	; (b6c <_dbg_trace+0x5c>)
     b5c:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
     b5e:	b002      	add	sp, #8
     b60:	bd10      	pop	{r4, pc}
     b62:	bf00      	nop
     b64:	20000ac0 	.word	0x20000ac0
     b68:	20000f00 	.word	0x20000f00
     b6c:	20000b00 	.word	0x20000b00

00000b70 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
     b70:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     b74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
     b76:	4618      	mov	r0, r3
     b78:	4770      	bx	lr
     b7a:	bf00      	nop
     b7c:	f3af 8000 	nop.w

00000b80 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
     b80:	b500      	push	{lr}
     b82:	b083      	sub	sp, #12
     b84:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
     b86:	9801      	ldr	r0, [sp, #4]
     b88:	f002 fa22 	bl	2fd0 <stStartAlarm>
}
     b8c:	b003      	add	sp, #12
     b8e:	f85d fb04 	ldr.w	pc, [sp], #4
     b92:	bf00      	nop
     b94:	f3af 8000 	nop.w
     b98:	f3af 8000 	nop.w
     b9c:	f3af 8000 	nop.w

00000ba0 <port_timer_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
     ba0:	b508      	push	{r3, lr}

  stStopAlarm();
     ba2:	f002 fa2d 	bl	3000 <stStopAlarm>
}
     ba6:	bd08      	pop	{r3, pc}
     ba8:	f3af 8000 	nop.w
     bac:	f3af 8000 	nop.w

00000bb0 <port_timer_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
     bb0:	b500      	push	{lr}
     bb2:	b083      	sub	sp, #12
     bb4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
     bb6:	9801      	ldr	r0, [sp, #4]
     bb8:	f002 fa2a 	bl	3010 <stSetAlarm>
}
     bbc:	b003      	add	sp, #12
     bbe:	f85d fb04 	ldr.w	pc, [sp], #4
     bc2:	bf00      	nop
     bc4:	f3af 8000 	nop.w
     bc8:	f3af 8000 	nop.w
     bcc:	f3af 8000 	nop.w

00000bd0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
     bd0:	b508      	push	{r3, lr}

  return stGetCounter();
     bd2:	f7ff ffcd 	bl	b70 <st_lld_get_counter>
     bd6:	4603      	mov	r3, r0
}
     bd8:	4618      	mov	r0, r3
     bda:	bd08      	pop	{r3, pc}
     bdc:	f3af 8000 	nop.w

00000be0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
     be0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
     be2:	f7ff fff5 	bl	bd0 <port_timer_get_time>
     be6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     be8:	4618      	mov	r0, r3
     bea:	bd08      	pop	{r3, pc}
     bec:	f3af 8000 	nop.w

00000bf0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
     bf0:	4b06      	ldr	r3, [pc, #24]	; (c0c <_vt_init+0x1c>)
     bf2:	4a07      	ldr	r2, [pc, #28]	; (c10 <_vt_init+0x20>)
     bf4:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
     bf6:	4b05      	ldr	r3, [pc, #20]	; (c0c <_vt_init+0x1c>)
     bf8:	4a05      	ldr	r2, [pc, #20]	; (c10 <_vt_init+0x20>)
     bfa:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
     bfc:	4b03      	ldr	r3, [pc, #12]	; (c0c <_vt_init+0x1c>)
     bfe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     c02:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
     c04:	4b01      	ldr	r3, [pc, #4]	; (c0c <_vt_init+0x1c>)
     c06:	2200      	movs	r2, #0
     c08:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     c0a:	4770      	bx	lr
     c0c:	20000ac0 	.word	0x20000ac0
     c10:	20000adc 	.word	0x20000adc
     c14:	f3af 8000 	nop.w
     c18:	f3af 8000 	nop.w
     c1c:	f3af 8000 	nop.w

00000c20 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
     c20:	b500      	push	{lr}
     c22:	b089      	sub	sp, #36	; 0x24
     c24:	9003      	str	r0, [sp, #12]
     c26:	9102      	str	r1, [sp, #8]
     c28:	9201      	str	r2, [sp, #4]
     c2a:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
     c2c:	f7ff ff30 	bl	a90 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
     c30:	9b03      	ldr	r3, [sp, #12]
     c32:	2b00      	cmp	r3, #0
     c34:	d005      	beq.n	c42 <chVTDoSetI+0x22>
     c36:	9b01      	ldr	r3, [sp, #4]
     c38:	2b00      	cmp	r3, #0
     c3a:	d002      	beq.n	c42 <chVTDoSetI+0x22>
     c3c:	9b02      	ldr	r3, [sp, #8]
     c3e:	2b00      	cmp	r3, #0
     c40:	d102      	bne.n	c48 <chVTDoSetI+0x28>
     c42:	483a      	ldr	r0, [pc, #232]	; (d2c <chVTDoSetI+0x10c>)
     c44:	f7ff fe1c 	bl	880 <chSysHalt>

  vtp->vt_par = par;
     c48:	9b03      	ldr	r3, [sp, #12]
     c4a:	9a00      	ldr	r2, [sp, #0]
     c4c:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
     c4e:	9b03      	ldr	r3, [sp, #12]
     c50:	9a01      	ldr	r2, [sp, #4]
     c52:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
     c54:	f7ff ffc4 	bl	be0 <chVTGetSystemTimeX>
     c58:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
     c5a:	9b02      	ldr	r3, [sp, #8]
     c5c:	2b01      	cmp	r3, #1
     c5e:	d801      	bhi.n	c64 <chVTDoSetI+0x44>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
     c60:	2302      	movs	r3, #2
     c62:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
     c64:	4b32      	ldr	r3, [pc, #200]	; (d30 <chVTDoSetI+0x110>)
     c66:	69da      	ldr	r2, [r3, #28]
     c68:	4b32      	ldr	r3, [pc, #200]	; (d34 <chVTDoSetI+0x114>)
     c6a:	429a      	cmp	r2, r3
     c6c:	d119      	bne.n	ca2 <chVTDoSetI+0x82>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
     c6e:	4b30      	ldr	r3, [pc, #192]	; (d30 <chVTDoSetI+0x110>)
     c70:	9a05      	ldr	r2, [sp, #20]
     c72:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
     c74:	4b2e      	ldr	r3, [pc, #184]	; (d30 <chVTDoSetI+0x110>)
     c76:	9a03      	ldr	r2, [sp, #12]
     c78:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
     c7a:	4b2d      	ldr	r3, [pc, #180]	; (d30 <chVTDoSetI+0x110>)
     c7c:	9a03      	ldr	r2, [sp, #12]
     c7e:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
     c80:	9b03      	ldr	r3, [sp, #12]
     c82:	4a2c      	ldr	r2, [pc, #176]	; (d34 <chVTDoSetI+0x114>)
     c84:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
     c86:	9b03      	ldr	r3, [sp, #12]
     c88:	4a2a      	ldr	r2, [pc, #168]	; (d34 <chVTDoSetI+0x114>)
     c8a:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
     c8c:	9b03      	ldr	r3, [sp, #12]
     c8e:	9a02      	ldr	r2, [sp, #8]
     c90:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
     c92:	4b27      	ldr	r3, [pc, #156]	; (d30 <chVTDoSetI+0x110>)
     c94:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     c96:	9b02      	ldr	r3, [sp, #8]
     c98:	4413      	add	r3, r2
     c9a:	4618      	mov	r0, r3
     c9c:	f7ff ff70 	bl	b80 <port_timer_start_alarm>

      return;
     ca0:	e040      	b.n	d24 <chVTDoSetI+0x104>
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
     ca2:	9a05      	ldr	r2, [sp, #20]
     ca4:	9b02      	ldr	r3, [sp, #8]
     ca6:	441a      	add	r2, r3
     ca8:	4b21      	ldr	r3, [pc, #132]	; (d30 <chVTDoSetI+0x110>)
     caa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     cac:	1ad3      	subs	r3, r2, r3
     cae:	9306      	str	r3, [sp, #24]
    if (delta < ch.vtlist.vt_next->vt_delta) {
     cb0:	4b1f      	ldr	r3, [pc, #124]	; (d30 <chVTDoSetI+0x110>)
     cb2:	69db      	ldr	r3, [r3, #28]
     cb4:	689a      	ldr	r2, [r3, #8]
     cb6:	9b06      	ldr	r3, [sp, #24]
     cb8:	429a      	cmp	r2, r3
     cba:	d906      	bls.n	cca <chVTDoSetI+0xaa>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
     cbc:	4b1c      	ldr	r3, [pc, #112]	; (d30 <chVTDoSetI+0x110>)
     cbe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     cc0:	9b06      	ldr	r3, [sp, #24]
     cc2:	4413      	add	r3, r2
     cc4:	4618      	mov	r0, r3
     cc6:	f7ff ff73 	bl	bb0 <port_timer_set_alarm>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
     cca:	4b19      	ldr	r3, [pc, #100]	; (d30 <chVTDoSetI+0x110>)
     ccc:	69db      	ldr	r3, [r3, #28]
     cce:	9307      	str	r3, [sp, #28]
  while (p->vt_delta < delta) {
     cd0:	e007      	b.n	ce2 <chVTDoSetI+0xc2>
    delta -= p->vt_delta;
     cd2:	9b07      	ldr	r3, [sp, #28]
     cd4:	689b      	ldr	r3, [r3, #8]
     cd6:	9a06      	ldr	r2, [sp, #24]
     cd8:	1ad3      	subs	r3, r2, r3
     cda:	9306      	str	r3, [sp, #24]
    p = p->vt_next;
     cdc:	9b07      	ldr	r3, [sp, #28]
     cde:	681b      	ldr	r3, [r3, #0]
     ce0:	9307      	str	r3, [sp, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
     ce2:	9b07      	ldr	r3, [sp, #28]
     ce4:	689a      	ldr	r2, [r3, #8]
     ce6:	9b06      	ldr	r3, [sp, #24]
     ce8:	429a      	cmp	r2, r3
     cea:	d3f2      	bcc.n	cd2 <chVTDoSetI+0xb2>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
     cec:	9b03      	ldr	r3, [sp, #12]
     cee:	9a07      	ldr	r2, [sp, #28]
     cf0:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
     cf2:	9b03      	ldr	r3, [sp, #12]
     cf4:	681b      	ldr	r3, [r3, #0]
     cf6:	685a      	ldr	r2, [r3, #4]
     cf8:	9b03      	ldr	r3, [sp, #12]
     cfa:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
     cfc:	9b03      	ldr	r3, [sp, #12]
     cfe:	685b      	ldr	r3, [r3, #4]
     d00:	9a03      	ldr	r2, [sp, #12]
     d02:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
     d04:	9b07      	ldr	r3, [sp, #28]
     d06:	9a03      	ldr	r2, [sp, #12]
     d08:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
     d0a:	9b03      	ldr	r3, [sp, #12]
     d0c:	9a06      	ldr	r2, [sp, #24]
     d0e:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
     d10:	9b07      	ldr	r3, [sp, #28]
     d12:	689a      	ldr	r2, [r3, #8]
     d14:	9b06      	ldr	r3, [sp, #24]
     d16:	1ad2      	subs	r2, r2, r3
     d18:	9b07      	ldr	r3, [sp, #28]
     d1a:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
     d1c:	4b04      	ldr	r3, [pc, #16]	; (d30 <chVTDoSetI+0x110>)
     d1e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     d22:	625a      	str	r2, [r3, #36]	; 0x24
}
     d24:	b009      	add	sp, #36	; 0x24
     d26:	f85d fb04 	ldr.w	pc, [sp], #4
     d2a:	bf00      	nop
     d2c:	00004730 	.word	0x00004730
     d30:	20000ac0 	.word	0x20000ac0
     d34:	20000adc 	.word	0x20000adc
     d38:	f3af 8000 	nop.w
     d3c:	f3af 8000 	nop.w

00000d40 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
     d40:	b500      	push	{lr}
     d42:	b085      	sub	sp, #20
     d44:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     d46:	f7ff fea3 	bl	a90 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
     d4a:	9b01      	ldr	r3, [sp, #4]
     d4c:	2b00      	cmp	r3, #0
     d4e:	d102      	bne.n	d56 <chVTDoResetI+0x16>
     d50:	4836      	ldr	r0, [pc, #216]	; (e2c <chVTDoResetI+0xec>)
     d52:	f7ff fd95 	bl	880 <chSysHalt>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
     d56:	9b01      	ldr	r3, [sp, #4]
     d58:	68db      	ldr	r3, [r3, #12]
     d5a:	2b00      	cmp	r3, #0
     d5c:	d102      	bne.n	d64 <chVTDoResetI+0x24>
     d5e:	4833      	ldr	r0, [pc, #204]	; (e2c <chVTDoResetI+0xec>)
     d60:	f7ff fd8e 	bl	880 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
     d64:	4b32      	ldr	r3, [pc, #200]	; (e30 <chVTDoResetI+0xf0>)
     d66:	69da      	ldr	r2, [r3, #28]
     d68:	9b01      	ldr	r3, [sp, #4]
     d6a:	429a      	cmp	r2, r3
     d6c:	d01c      	beq.n	da8 <chVTDoResetI+0x68>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
     d6e:	9b01      	ldr	r3, [sp, #4]
     d70:	685b      	ldr	r3, [r3, #4]
     d72:	9a01      	ldr	r2, [sp, #4]
     d74:	6812      	ldr	r2, [r2, #0]
     d76:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
     d78:	9b01      	ldr	r3, [sp, #4]
     d7a:	681b      	ldr	r3, [r3, #0]
     d7c:	9a01      	ldr	r2, [sp, #4]
     d7e:	6852      	ldr	r2, [r2, #4]
     d80:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
     d82:	9b01      	ldr	r3, [sp, #4]
     d84:	2200      	movs	r2, #0
     d86:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
     d88:	9b01      	ldr	r3, [sp, #4]
     d8a:	681a      	ldr	r2, [r3, #0]
     d8c:	4b29      	ldr	r3, [pc, #164]	; (e34 <chVTDoResetI+0xf4>)
     d8e:	429a      	cmp	r2, r3
     d90:	d009      	beq.n	da6 <chVTDoResetI+0x66>
      vtp->vt_next->vt_delta += vtp->vt_delta;
     d92:	9b01      	ldr	r3, [sp, #4]
     d94:	681b      	ldr	r3, [r3, #0]
     d96:	9a01      	ldr	r2, [sp, #4]
     d98:	6812      	ldr	r2, [r2, #0]
     d9a:	6891      	ldr	r1, [r2, #8]
     d9c:	9a01      	ldr	r2, [sp, #4]
     d9e:	6892      	ldr	r2, [r2, #8]
     da0:	440a      	add	r2, r1
     da2:	609a      	str	r2, [r3, #8]

    return;
     da4:	e03e      	b.n	e24 <chVTDoResetI+0xe4>
     da6:	e03d      	b.n	e24 <chVTDoResetI+0xe4>
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
     da8:	9b01      	ldr	r3, [sp, #4]
     daa:	681a      	ldr	r2, [r3, #0]
     dac:	4b20      	ldr	r3, [pc, #128]	; (e30 <chVTDoResetI+0xf0>)
     dae:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     db0:	4b1f      	ldr	r3, [pc, #124]	; (e30 <chVTDoResetI+0xf0>)
     db2:	69db      	ldr	r3, [r3, #28]
     db4:	4a1f      	ldr	r2, [pc, #124]	; (e34 <chVTDoResetI+0xf4>)
     db6:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
     db8:	9b01      	ldr	r3, [sp, #4]
     dba:	2200      	movs	r2, #0
     dbc:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
     dbe:	4b1c      	ldr	r3, [pc, #112]	; (e30 <chVTDoResetI+0xf0>)
     dc0:	69da      	ldr	r2, [r3, #28]
     dc2:	4b1c      	ldr	r3, [pc, #112]	; (e34 <chVTDoResetI+0xf4>)
     dc4:	429a      	cmp	r2, r3
     dc6:	d102      	bne.n	dce <chVTDoResetI+0x8e>
    port_timer_stop_alarm();
     dc8:	f7ff feea 	bl	ba0 <port_timer_stop_alarm>

    return;
     dcc:	e02a      	b.n	e24 <chVTDoResetI+0xe4>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
     dce:	4b18      	ldr	r3, [pc, #96]	; (e30 <chVTDoResetI+0xf0>)
     dd0:	69db      	ldr	r3, [r3, #28]
     dd2:	4a17      	ldr	r2, [pc, #92]	; (e30 <chVTDoResetI+0xf0>)
     dd4:	69d2      	ldr	r2, [r2, #28]
     dd6:	6891      	ldr	r1, [r2, #8]
     dd8:	9a01      	ldr	r2, [sp, #4]
     dda:	6892      	ldr	r2, [r2, #8]
     ddc:	440a      	add	r2, r1
     dde:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
     de0:	f7ff fefe 	bl	be0 <chVTGetSystemTimeX>
     de4:	4602      	mov	r2, r0
     de6:	4b12      	ldr	r3, [pc, #72]	; (e30 <chVTDoResetI+0xf0>)
     de8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     dea:	1ad3      	subs	r3, r2, r3
     dec:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
     dee:	4b10      	ldr	r3, [pc, #64]	; (e30 <chVTDoResetI+0xf0>)
     df0:	69db      	ldr	r3, [r3, #28]
     df2:	689a      	ldr	r2, [r3, #8]
     df4:	9b02      	ldr	r3, [sp, #8]
     df6:	429a      	cmp	r2, r3
     df8:	d800      	bhi.n	dfc <chVTDoResetI+0xbc>
    return;
     dfa:	e013      	b.n	e24 <chVTDoResetI+0xe4>
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
     dfc:	4b0c      	ldr	r3, [pc, #48]	; (e30 <chVTDoResetI+0xf0>)
     dfe:	69db      	ldr	r3, [r3, #28]
     e00:	689a      	ldr	r2, [r3, #8]
     e02:	9b02      	ldr	r3, [sp, #8]
     e04:	1ad3      	subs	r3, r2, r3
     e06:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
     e08:	9b03      	ldr	r3, [sp, #12]
     e0a:	2b01      	cmp	r3, #1
     e0c:	d801      	bhi.n	e12 <chVTDoResetI+0xd2>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
     e0e:	2302      	movs	r3, #2
     e10:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
     e12:	4b07      	ldr	r3, [pc, #28]	; (e30 <chVTDoResetI+0xf0>)
     e14:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     e16:	9b02      	ldr	r3, [sp, #8]
     e18:	441a      	add	r2, r3
     e1a:	9b03      	ldr	r3, [sp, #12]
     e1c:	4413      	add	r3, r2
     e1e:	4618      	mov	r0, r3
     e20:	f7ff fec6 	bl	bb0 <port_timer_set_alarm>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     e24:	b005      	add	sp, #20
     e26:	f85d fb04 	ldr.w	pc, [sp], #4
     e2a:	bf00      	nop
     e2c:	00004740 	.word	0x00004740
     e30:	20000ac0 	.word	0x20000ac0
     e34:	20000adc 	.word	0x20000adc
     e38:	f3af 8000 	nop.w
     e3c:	f3af 8000 	nop.w

00000e40 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
     e40:	b082      	sub	sp, #8
     e42:	2320      	movs	r3, #32
     e44:	9301      	str	r3, [sp, #4]
     e46:	9b01      	ldr	r3, [sp, #4]
     e48:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     e4c:	b002      	add	sp, #8
     e4e:	4770      	bx	lr

00000e50 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
     e50:	b082      	sub	sp, #8
     e52:	2300      	movs	r3, #0
     e54:	9301      	str	r3, [sp, #4]
     e56:	9b01      	ldr	r3, [sp, #4]
     e58:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
     e5c:	b002      	add	sp, #8
     e5e:	4770      	bx	lr

00000e60 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
     e60:	b508      	push	{r3, lr}

  port_lock();
     e62:	f7ff ffed 	bl	e40 <port_lock>
}
     e66:	bd08      	pop	{r3, pc}
     e68:	f3af 8000 	nop.w
     e6c:	f3af 8000 	nop.w

00000e70 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
     e70:	b508      	push	{r3, lr}

  port_unlock();
     e72:	f7ff ffed 	bl	e50 <port_unlock>
}
     e76:	bd08      	pop	{r3, pc}
     e78:	f3af 8000 	nop.w
     e7c:	f3af 8000 	nop.w

00000e80 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
     e80:	b082      	sub	sp, #8
     e82:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
     e84:	9b01      	ldr	r3, [sp, #4]
     e86:	9a01      	ldr	r2, [sp, #4]
     e88:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
     e8a:	9b01      	ldr	r3, [sp, #4]
     e8c:	9a01      	ldr	r2, [sp, #4]
     e8e:	605a      	str	r2, [r3, #4]
}
     e90:	b002      	add	sp, #8
     e92:	4770      	bx	lr
     e94:	f3af 8000 	nop.w
     e98:	f3af 8000 	nop.w
     e9c:	f3af 8000 	nop.w

00000ea0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
     ea0:	b084      	sub	sp, #16
     ea2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
     ea4:	9b01      	ldr	r3, [sp, #4]
     ea6:	681b      	ldr	r3, [r3, #0]
     ea8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
     eaa:	9b03      	ldr	r3, [sp, #12]
     eac:	681a      	ldr	r2, [r3, #0]
     eae:	9b01      	ldr	r3, [sp, #4]
     eb0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
     eb2:	9b01      	ldr	r3, [sp, #4]
     eb4:	681b      	ldr	r3, [r3, #0]
     eb6:	9a01      	ldr	r2, [sp, #4]
     eb8:	605a      	str	r2, [r3, #4]

  return tp;
     eba:	9b03      	ldr	r3, [sp, #12]
}
     ebc:	4618      	mov	r0, r3
     ebe:	b004      	add	sp, #16
     ec0:	4770      	bx	lr
     ec2:	bf00      	nop
     ec4:	f3af 8000 	nop.w
     ec8:	f3af 8000 	nop.w
     ecc:	f3af 8000 	nop.w

00000ed0 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
     ed0:	b082      	sub	sp, #8
     ed2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
     ed4:	9b01      	ldr	r3, [sp, #4]
     ed6:	685b      	ldr	r3, [r3, #4]
     ed8:	9a01      	ldr	r2, [sp, #4]
     eda:	6812      	ldr	r2, [r2, #0]
     edc:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
     ede:	9b01      	ldr	r3, [sp, #4]
     ee0:	681b      	ldr	r3, [r3, #0]
     ee2:	9a01      	ldr	r2, [sp, #4]
     ee4:	6852      	ldr	r2, [r2, #4]
     ee6:	605a      	str	r2, [r3, #4]

  return tp;
     ee8:	9b01      	ldr	r3, [sp, #4]
}
     eea:	4618      	mov	r0, r3
     eec:	b002      	add	sp, #8
     eee:	4770      	bx	lr

00000ef0 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
     ef0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
     ef2:	f7ff fdcd 	bl	a90 <chDbgCheckClassI>

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
     ef6:	4b06      	ldr	r3, [pc, #24]	; (f10 <chSchIsRescRequiredI+0x20>)
     ef8:	681b      	ldr	r3, [r3, #0]
     efa:	689a      	ldr	r2, [r3, #8]
     efc:	4b04      	ldr	r3, [pc, #16]	; (f10 <chSchIsRescRequiredI+0x20>)
     efe:	699b      	ldr	r3, [r3, #24]
     f00:	689b      	ldr	r3, [r3, #8]
     f02:	429a      	cmp	r2, r3
     f04:	bf94      	ite	ls
     f06:	2300      	movls	r3, #0
     f08:	2301      	movhi	r3, #1
     f0a:	b2db      	uxtb	r3, r3
}
     f0c:	4618      	mov	r0, r3
     f0e:	bd08      	pop	{r3, pc}
     f10:	20000ac0 	.word	0x20000ac0
     f14:	f3af 8000 	nop.w
     f18:	f3af 8000 	nop.w
     f1c:	f3af 8000 	nop.w

00000f20 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
     f20:	b508      	push	{r3, lr}

  port_lock_from_isr();
     f22:	f7ff ff9d 	bl	e60 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
     f26:	f000 fe1b 	bl	1b60 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
     f2a:	f7ff fd41 	bl	9b0 <_dbg_check_lock_from_isr>
}
     f2e:	bd08      	pop	{r3, pc}

00000f30 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
     f30:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
     f32:	f7ff fd55 	bl	9e0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
     f36:	f000 fe1b 	bl	1b70 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
     f3a:	f7ff ff99 	bl	e70 <port_unlock_from_isr>
}
     f3e:	bd08      	pop	{r3, pc}

00000f40 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
     f40:	b500      	push	{lr}
     f42:	b083      	sub	sp, #12
     f44:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     f46:	f7ff fda3 	bl	a90 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
     f4a:	9b01      	ldr	r3, [sp, #4]
     f4c:	68db      	ldr	r3, [r3, #12]
     f4e:	2b00      	cmp	r3, #0
     f50:	bf0c      	ite	eq
     f52:	2300      	moveq	r3, #0
     f54:	2301      	movne	r3, #1
     f56:	b2db      	uxtb	r3, r3
}
     f58:	4618      	mov	r0, r3
     f5a:	b003      	add	sp, #12
     f5c:	f85d fb04 	ldr.w	pc, [sp], #4

00000f60 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
     f60:	b500      	push	{lr}
     f62:	b083      	sub	sp, #12
     f64:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
     f66:	f7ff fd93 	bl	a90 <chDbgCheckClassI>

  sp->s_cnt++;
     f6a:	9b01      	ldr	r3, [sp, #4]
     f6c:	689b      	ldr	r3, [r3, #8]
     f6e:	1c5a      	adds	r2, r3, #1
     f70:	9b01      	ldr	r3, [sp, #4]
     f72:	609a      	str	r2, [r3, #8]
}
     f74:	b003      	add	sp, #12
     f76:	f85d fb04 	ldr.w	pc, [sp], #4
     f7a:	bf00      	nop
     f7c:	f3af 8000 	nop.w

00000f80 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
     f80:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
     f82:	4806      	ldr	r0, [pc, #24]	; (f9c <_scheduler_init+0x1c>)
     f84:	f7ff ff7c 	bl	e80 <queue_init>
  ch.rlist.r_prio = NOPRIO;
     f88:	4b04      	ldr	r3, [pc, #16]	; (f9c <_scheduler_init+0x1c>)
     f8a:	2200      	movs	r2, #0
     f8c:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
     f8e:	4b03      	ldr	r3, [pc, #12]	; (f9c <_scheduler_init+0x1c>)
     f90:	4a02      	ldr	r2, [pc, #8]	; (f9c <_scheduler_init+0x1c>)
     f92:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
     f94:	4b01      	ldr	r3, [pc, #4]	; (f9c <_scheduler_init+0x1c>)
     f96:	4a01      	ldr	r2, [pc, #4]	; (f9c <_scheduler_init+0x1c>)
     f98:	615a      	str	r2, [r3, #20]
#endif
}
     f9a:	bd08      	pop	{r3, pc}
     f9c:	20000ac0 	.word	0x20000ac0

00000fa0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     fa0:	b500      	push	{lr}
     fa2:	b085      	sub	sp, #20
     fa4:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
     fa6:	f7ff fd73 	bl	a90 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
     faa:	9b01      	ldr	r3, [sp, #4]
     fac:	2b00      	cmp	r3, #0
     fae:	d102      	bne.n	fb6 <chSchReadyI+0x16>
     fb0:	4818      	ldr	r0, [pc, #96]	; (1014 <__ram5_size__+0x14>)
     fb2:	f7ff fc65 	bl	880 <chSysHalt>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
     fb6:	9b01      	ldr	r3, [sp, #4]
     fb8:	f893 3020 	ldrb.w	r3, [r3, #32]
     fbc:	2b00      	cmp	r3, #0
     fbe:	d004      	beq.n	fca <chSchReadyI+0x2a>
     fc0:	9b01      	ldr	r3, [sp, #4]
     fc2:	f893 3020 	ldrb.w	r3, [r3, #32]
     fc6:	2b0f      	cmp	r3, #15
     fc8:	d102      	bne.n	fd0 <chSchReadyI+0x30>
     fca:	4812      	ldr	r0, [pc, #72]	; (1014 <__ram5_size__+0x14>)
     fcc:	f7ff fc58 	bl	880 <chSysHalt>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
     fd0:	9b01      	ldr	r3, [sp, #4]
     fd2:	2200      	movs	r2, #0
     fd4:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
     fd8:	4b0f      	ldr	r3, [pc, #60]	; (1018 <__ram5_size__+0x18>)
     fda:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
     fdc:	9b03      	ldr	r3, [sp, #12]
     fde:	681b      	ldr	r3, [r3, #0]
     fe0:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
     fe2:	9b03      	ldr	r3, [sp, #12]
     fe4:	689a      	ldr	r2, [r3, #8]
     fe6:	9b01      	ldr	r3, [sp, #4]
     fe8:	689b      	ldr	r3, [r3, #8]
     fea:	429a      	cmp	r2, r3
     fec:	d2f6      	bcs.n	fdc <chSchReadyI+0x3c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
     fee:	9b01      	ldr	r3, [sp, #4]
     ff0:	9a03      	ldr	r2, [sp, #12]
     ff2:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
     ff4:	9b03      	ldr	r3, [sp, #12]
     ff6:	685a      	ldr	r2, [r3, #4]
     ff8:	9b01      	ldr	r3, [sp, #4]
     ffa:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
     ffc:	9b01      	ldr	r3, [sp, #4]
     ffe:	685b      	ldr	r3, [r3, #4]
    1000:	9a01      	ldr	r2, [sp, #4]
    1002:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
    1004:	9b03      	ldr	r3, [sp, #12]
    1006:	9a01      	ldr	r2, [sp, #4]
    1008:	605a      	str	r2, [r3, #4]

  return tp;
    100a:	9b01      	ldr	r3, [sp, #4]
}
    100c:	4618      	mov	r0, r3
    100e:	b005      	add	sp, #20
    1010:	f85d fb04 	ldr.w	pc, [sp], #4
    1014:	00004750 	.word	0x00004750
    1018:	20000ac0 	.word	0x20000ac0
    101c:	f3af 8000 	nop.w

00001020 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
    1020:	b510      	push	{r4, lr}
    1022:	b084      	sub	sp, #16
    1024:	4603      	mov	r3, r0
    1026:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();
    102a:	f7ff fd49 	bl	ac0 <chDbgCheckClassS>

  otp = currp;
    102e:	4b19      	ldr	r3, [pc, #100]	; (1094 <chSchGoSleepS+0x74>)
    1030:	699b      	ldr	r3, [r3, #24]
    1032:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
    1034:	9b03      	ldr	r3, [sp, #12]
    1036:	f89d 2007 	ldrb.w	r2, [sp, #7]
    103a:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
    103e:	4815      	ldr	r0, [pc, #84]	; (1094 <chSchGoSleepS+0x74>)
    1040:	f7ff ff2e 	bl	ea0 <queue_fifo_remove>
    1044:	4602      	mov	r2, r0
    1046:	4b13      	ldr	r3, [pc, #76]	; (1094 <chSchGoSleepS+0x74>)
    1048:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
    104a:	4b12      	ldr	r3, [pc, #72]	; (1094 <chSchGoSleepS+0x74>)
    104c:	699b      	ldr	r3, [r3, #24]
    104e:	2201      	movs	r2, #1
    1050:	f883 2020 	strb.w	r2, [r3, #32]
  chSysSwitch(currp, otp);
    1054:	9803      	ldr	r0, [sp, #12]
    1056:	f7ff fd5b 	bl	b10 <_dbg_trace>
    105a:	4b0e      	ldr	r3, [pc, #56]	; (1094 <chSchGoSleepS+0x74>)
    105c:	699b      	ldr	r3, [r3, #24]
    105e:	4618      	mov	r0, r3
    1060:	9903      	ldr	r1, [sp, #12]
    1062:	f000 fd4d 	bl	1b00 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    1066:	f3ef 8309 	mrs	r3, PSP
    106a:	461c      	mov	r4, r3
  return(result);
    106c:	4623      	mov	r3, r4
    106e:	9302      	str	r3, [sp, #8]
    1070:	9b02      	ldr	r3, [sp, #8]
    1072:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    1076:	9b03      	ldr	r3, [sp, #12]
    1078:	69db      	ldr	r3, [r3, #28]
    107a:	429a      	cmp	r2, r3
    107c:	d202      	bcs.n	1084 <chSchGoSleepS+0x64>
    107e:	4806      	ldr	r0, [pc, #24]	; (1098 <chSchGoSleepS+0x78>)
    1080:	f7ff fbfe 	bl	880 <chSysHalt>
    1084:	4b03      	ldr	r3, [pc, #12]	; (1094 <chSchGoSleepS+0x74>)
    1086:	699b      	ldr	r3, [r3, #24]
    1088:	4618      	mov	r0, r3
    108a:	9903      	ldr	r1, [sp, #12]
    108c:	f7ff f8f8 	bl	280 <_port_switch>
}
    1090:	b004      	add	sp, #16
    1092:	bd10      	pop	{r4, pc}
    1094:	20000ac0 	.word	0x20000ac0
    1098:	00004710 	.word	0x00004710
    109c:	f3af 8000 	nop.w

000010a0 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
    10a0:	b500      	push	{lr}
    10a2:	b085      	sub	sp, #20
    10a4:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
    10a6:	9b01      	ldr	r3, [sp, #4]
    10a8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
    10aa:	f7ff ff39 	bl	f20 <chSysLockFromISR>
  switch (tp->p_state) {
    10ae:	9b03      	ldr	r3, [sp, #12]
    10b0:	f893 3020 	ldrb.w	r3, [r3, #32]
    10b4:	2b07      	cmp	r3, #7
    10b6:	d824      	bhi.n	1102 <wakeup+0x62>
    10b8:	a201      	add	r2, pc, #4	; (adr r2, 10c0 <wakeup+0x20>)
    10ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    10be:	bf00      	nop
    10c0:	000010e1 	.word	0x000010e1
    10c4:	00001103 	.word	0x00001103
    10c8:	00001103 	.word	0x00001103
    10cc:	000010e7 	.word	0x000010e7
    10d0:	000010fb 	.word	0x000010fb
    10d4:	000010f1 	.word	0x000010f1
    10d8:	00001103 	.word	0x00001103
    10dc:	000010fb 	.word	0x000010fb
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    10e0:	f7ff ff26 	bl	f30 <chSysUnlockFromISR>
    return;
    10e4:	e017      	b.n	1116 <wakeup+0x76>
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    10e6:	9b03      	ldr	r3, [sp, #12]
    10e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    10ea:	2200      	movs	r2, #0
    10ec:	601a      	str	r2, [r3, #0]
    break;
    10ee:	e009      	b.n	1104 <wakeup+0x64>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
    10f0:	9b03      	ldr	r3, [sp, #12]
    10f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    10f4:	4618      	mov	r0, r3
    10f6:	f7ff ff33 	bl	f60 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
    10fa:	9803      	ldr	r0, [sp, #12]
    10fc:	f7ff fee8 	bl	ed0 <queue_dequeue>
    break;
    1100:	e000      	b.n	1104 <wakeup+0x64>
  default:
    /* Any other state, nothing to do.*/
    break;
    1102:	bf00      	nop
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
    1104:	9b03      	ldr	r3, [sp, #12]
    1106:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    110a:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
    110c:	9803      	ldr	r0, [sp, #12]
    110e:	f7ff ff47 	bl	fa0 <chSchReadyI>
  chSysUnlockFromISR();
    1112:	f7ff ff0d 	bl	f30 <chSysUnlockFromISR>
}
    1116:	b005      	add	sp, #20
    1118:	f85d fb04 	ldr.w	pc, [sp], #4
    111c:	f3af 8000 	nop.w

00001120 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
    1120:	b500      	push	{lr}
    1122:	b089      	sub	sp, #36	; 0x24
    1124:	4603      	mov	r3, r0
    1126:	9100      	str	r1, [sp, #0]
    1128:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
    112c:	f7ff fcc8 	bl	ac0 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
    1130:	9b00      	ldr	r3, [sp, #0]
    1132:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1136:	d019      	beq.n	116c <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
    1138:	4b12      	ldr	r3, [pc, #72]	; (1184 <chSchGoSleepTimeoutS+0x64>)
    113a:	699b      	ldr	r3, [r3, #24]
    113c:	aa03      	add	r2, sp, #12
    113e:	4610      	mov	r0, r2
    1140:	9900      	ldr	r1, [sp, #0]
    1142:	4a11      	ldr	r2, [pc, #68]	; (1188 <chSchGoSleepTimeoutS+0x68>)
    1144:	f7ff fd6c 	bl	c20 <chVTDoSetI>
    chSchGoSleepS(newstate);
    1148:	f89d 3007 	ldrb.w	r3, [sp, #7]
    114c:	4618      	mov	r0, r3
    114e:	f7ff ff67 	bl	1020 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
    1152:	ab03      	add	r3, sp, #12
    1154:	4618      	mov	r0, r3
    1156:	f7ff fef3 	bl	f40 <chVTIsArmedI>
    115a:	4603      	mov	r3, r0
    115c:	2b00      	cmp	r3, #0
    115e:	d004      	beq.n	116a <chSchGoSleepTimeoutS+0x4a>
      chVTDoResetI(&vt);
    1160:	ab03      	add	r3, sp, #12
    1162:	4618      	mov	r0, r3
    1164:	f7ff fdec 	bl	d40 <chVTDoResetI>
    1168:	e005      	b.n	1176 <chSchGoSleepTimeoutS+0x56>
    116a:	e004      	b.n	1176 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
    116c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1170:	4618      	mov	r0, r3
    1172:	f7ff ff55 	bl	1020 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
    1176:	4b03      	ldr	r3, [pc, #12]	; (1184 <chSchGoSleepTimeoutS+0x64>)
    1178:	699b      	ldr	r3, [r3, #24]
    117a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
    117c:	4618      	mov	r0, r3
    117e:	b009      	add	sp, #36	; 0x24
    1180:	f85d fb04 	ldr.w	pc, [sp], #4
    1184:	20000ac0 	.word	0x20000ac0
    1188:	000010a1 	.word	0x000010a1
    118c:	f3af 8000 	nop.w

00001190 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
    1190:	b510      	push	{r4, lr}
    1192:	b084      	sub	sp, #16
    1194:	9001      	str	r0, [sp, #4]
    1196:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
    1198:	f7ff fc92 	bl	ac0 <chDbgCheckClassS>

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
    119c:	9b01      	ldr	r3, [sp, #4]
    119e:	9a00      	ldr	r2, [sp, #0]
    11a0:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    11a2:	9b01      	ldr	r3, [sp, #4]
    11a4:	689a      	ldr	r2, [r3, #8]
    11a6:	4b19      	ldr	r3, [pc, #100]	; (120c <chSchWakeupS+0x7c>)
    11a8:	699b      	ldr	r3, [r3, #24]
    11aa:	689b      	ldr	r3, [r3, #8]
    11ac:	429a      	cmp	r2, r3
    11ae:	d803      	bhi.n	11b8 <chSchWakeupS+0x28>
    (void) chSchReadyI(ntp);
    11b0:	9801      	ldr	r0, [sp, #4]
    11b2:	f7ff fef5 	bl	fa0 <chSchReadyI>
    11b6:	e026      	b.n	1206 <chSchWakeupS+0x76>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    11b8:	4b14      	ldr	r3, [pc, #80]	; (120c <chSchWakeupS+0x7c>)
    11ba:	699b      	ldr	r3, [r3, #24]
    11bc:	4618      	mov	r0, r3
    11be:	f7ff feef 	bl	fa0 <chSchReadyI>
    11c2:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
    11c4:	4b11      	ldr	r3, [pc, #68]	; (120c <chSchWakeupS+0x7c>)
    11c6:	9a01      	ldr	r2, [sp, #4]
    11c8:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    11ca:	9b01      	ldr	r3, [sp, #4]
    11cc:	2201      	movs	r2, #1
    11ce:	f883 2020 	strb.w	r2, [r3, #32]
    chSysSwitch(ntp, otp);
    11d2:	9803      	ldr	r0, [sp, #12]
    11d4:	f7ff fc9c 	bl	b10 <_dbg_trace>
    11d8:	9801      	ldr	r0, [sp, #4]
    11da:	9903      	ldr	r1, [sp, #12]
    11dc:	f000 fc90 	bl	1b00 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    11e0:	f3ef 8309 	mrs	r3, PSP
    11e4:	461c      	mov	r4, r3
  return(result);
    11e6:	4623      	mov	r3, r4
    11e8:	9302      	str	r3, [sp, #8]
    11ea:	9b02      	ldr	r3, [sp, #8]
    11ec:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    11f0:	9b03      	ldr	r3, [sp, #12]
    11f2:	69db      	ldr	r3, [r3, #28]
    11f4:	429a      	cmp	r2, r3
    11f6:	d202      	bcs.n	11fe <chSchWakeupS+0x6e>
    11f8:	4805      	ldr	r0, [pc, #20]	; (1210 <chSchWakeupS+0x80>)
    11fa:	f7ff fb41 	bl	880 <chSysHalt>
    11fe:	9801      	ldr	r0, [sp, #4]
    1200:	9903      	ldr	r1, [sp, #12]
    1202:	f7ff f83d 	bl	280 <_port_switch>
  }
}
    1206:	b004      	add	sp, #16
    1208:	bd10      	pop	{r4, pc}
    120a:	bf00      	nop
    120c:	20000ac0 	.word	0x20000ac0
    1210:	00004710 	.word	0x00004710
    1214:	f3af 8000 	nop.w
    1218:	f3af 8000 	nop.w
    121c:	f3af 8000 	nop.w

00001220 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
    1220:	b508      	push	{r3, lr}

  chDbgCheckClassS();
    1222:	f7ff fc4d 	bl	ac0 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
    1226:	f7ff fe63 	bl	ef0 <chSchIsRescRequiredI>
    122a:	4603      	mov	r3, r0
    122c:	2b00      	cmp	r3, #0
    122e:	d001      	beq.n	1234 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
    1230:	f000 f81e 	bl	1270 <chSchDoRescheduleAhead>
  }
}
    1234:	bd08      	pop	{r3, pc}
    1236:	bf00      	nop
    1238:	f3af 8000 	nop.w
    123c:	f3af 8000 	nop.w

00001240 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
    1240:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
    1242:	4b09      	ldr	r3, [pc, #36]	; (1268 <chSchIsPreemptionRequired+0x28>)
    1244:	681b      	ldr	r3, [r3, #0]
    1246:	689b      	ldr	r3, [r3, #8]
    1248:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
    124a:	4b07      	ldr	r3, [pc, #28]	; (1268 <chSchIsPreemptionRequired+0x28>)
    124c:	699b      	ldr	r3, [r3, #24]
    124e:	689b      	ldr	r3, [r3, #8]
    1250:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
    1252:	9a01      	ldr	r2, [sp, #4]
    1254:	9b00      	ldr	r3, [sp, #0]
    1256:	429a      	cmp	r2, r3
    1258:	bf94      	ite	ls
    125a:	2300      	movls	r3, #0
    125c:	2301      	movhi	r3, #1
    125e:	b2db      	uxtb	r3, r3
#endif
}
    1260:	4618      	mov	r0, r3
    1262:	b002      	add	sp, #8
    1264:	4770      	bx	lr
    1266:	bf00      	nop
    1268:	20000ac0 	.word	0x20000ac0
    126c:	f3af 8000 	nop.w

00001270 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
    1270:	b510      	push	{r4, lr}
    1272:	b084      	sub	sp, #16
  thread_t *otp, *cp;

  otp = currp;
    1274:	4b25      	ldr	r3, [pc, #148]	; (130c <chSchDoRescheduleAhead+0x9c>)
    1276:	699b      	ldr	r3, [r3, #24]
    1278:	9302      	str	r3, [sp, #8]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
    127a:	4824      	ldr	r0, [pc, #144]	; (130c <chSchDoRescheduleAhead+0x9c>)
    127c:	f7ff fe10 	bl	ea0 <queue_fifo_remove>
    1280:	4602      	mov	r2, r0
    1282:	4b22      	ldr	r3, [pc, #136]	; (130c <chSchDoRescheduleAhead+0x9c>)
    1284:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
    1286:	4b21      	ldr	r3, [pc, #132]	; (130c <chSchDoRescheduleAhead+0x9c>)
    1288:	699b      	ldr	r3, [r3, #24]
    128a:	2201      	movs	r2, #1
    128c:	f883 2020 	strb.w	r2, [r3, #32]

  otp->p_state = CH_STATE_READY;
    1290:	9b02      	ldr	r3, [sp, #8]
    1292:	2200      	movs	r2, #0
    1294:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
    1298:	4b1c      	ldr	r3, [pc, #112]	; (130c <chSchDoRescheduleAhead+0x9c>)
    129a:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
    129c:	9b03      	ldr	r3, [sp, #12]
    129e:	681b      	ldr	r3, [r3, #0]
    12a0:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio > otp->p_prio);
    12a2:	9b03      	ldr	r3, [sp, #12]
    12a4:	689a      	ldr	r2, [r3, #8]
    12a6:	9b02      	ldr	r3, [sp, #8]
    12a8:	689b      	ldr	r3, [r3, #8]
    12aa:	429a      	cmp	r2, r3
    12ac:	d8f6      	bhi.n	129c <chSchDoRescheduleAhead+0x2c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
    12ae:	9b02      	ldr	r3, [sp, #8]
    12b0:	9a03      	ldr	r2, [sp, #12]
    12b2:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
    12b4:	9b03      	ldr	r3, [sp, #12]
    12b6:	685a      	ldr	r2, [r3, #4]
    12b8:	9b02      	ldr	r3, [sp, #8]
    12ba:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
    12bc:	9b02      	ldr	r3, [sp, #8]
    12be:	685b      	ldr	r3, [r3, #4]
    12c0:	9a02      	ldr	r2, [sp, #8]
    12c2:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
    12c4:	9b03      	ldr	r3, [sp, #12]
    12c6:	9a02      	ldr	r2, [sp, #8]
    12c8:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
    12ca:	9802      	ldr	r0, [sp, #8]
    12cc:	f7ff fc20 	bl	b10 <_dbg_trace>
    12d0:	4b0e      	ldr	r3, [pc, #56]	; (130c <chSchDoRescheduleAhead+0x9c>)
    12d2:	699b      	ldr	r3, [r3, #24]
    12d4:	4618      	mov	r0, r3
    12d6:	9902      	ldr	r1, [sp, #8]
    12d8:	f000 fc12 	bl	1b00 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    12dc:	f3ef 8309 	mrs	r3, PSP
    12e0:	461c      	mov	r4, r3
  return(result);
    12e2:	4623      	mov	r3, r4
    12e4:	9301      	str	r3, [sp, #4]
    12e6:	9b01      	ldr	r3, [sp, #4]
    12e8:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
    12ec:	9b02      	ldr	r3, [sp, #8]
    12ee:	69db      	ldr	r3, [r3, #28]
    12f0:	429a      	cmp	r2, r3
    12f2:	d202      	bcs.n	12fa <chSchDoRescheduleAhead+0x8a>
    12f4:	4806      	ldr	r0, [pc, #24]	; (1310 <chSchDoRescheduleAhead+0xa0>)
    12f6:	f7ff fac3 	bl	880 <chSysHalt>
    12fa:	4b04      	ldr	r3, [pc, #16]	; (130c <chSchDoRescheduleAhead+0x9c>)
    12fc:	699b      	ldr	r3, [r3, #24]
    12fe:	4618      	mov	r0, r3
    1300:	9902      	ldr	r1, [sp, #8]
    1302:	f7fe ffbd 	bl	280 <_port_switch>
}
    1306:	b004      	add	sp, #16
    1308:	bd10      	pop	{r4, pc}
    130a:	bf00      	nop
    130c:	20000ac0 	.word	0x20000ac0
    1310:	00004710 	.word	0x00004710
    1314:	f3af 8000 	nop.w
    1318:	f3af 8000 	nop.w
    131c:	f3af 8000 	nop.w

00001320 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    1320:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
    1322:	f7ff ffa5 	bl	1270 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
    1326:	bd08      	pop	{r3, pc}
    1328:	f3af 8000 	nop.w
    132c:	f3af 8000 	nop.w

00001330 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1330:	b082      	sub	sp, #8
    1332:	2320      	movs	r3, #32
    1334:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    1336:	9b01      	ldr	r3, [sp, #4]
    1338:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    133c:	b002      	add	sp, #8
    133e:	4770      	bx	lr

00001340 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1340:	b082      	sub	sp, #8
    1342:	2300      	movs	r3, #0
    1344:	9301      	str	r3, [sp, #4]
    1346:	9b01      	ldr	r3, [sp, #4]
    1348:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    134c:	b002      	add	sp, #8
    134e:	4770      	bx	lr

00001350 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
    1350:	b082      	sub	sp, #8
    1352:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
    1354:	9b01      	ldr	r3, [sp, #4]
    1356:	9a01      	ldr	r2, [sp, #4]
    1358:	601a      	str	r2, [r3, #0]
}
    135a:	b002      	add	sp, #8
    135c:	4770      	bx	lr
    135e:	bf00      	nop

00001360 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
    1360:	b082      	sub	sp, #8
    1362:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
    1364:	9b01      	ldr	r3, [sp, #4]
    1366:	681a      	ldr	r2, [r3, #0]
    1368:	9b01      	ldr	r3, [sp, #4]
    136a:	429a      	cmp	r2, r3
    136c:	bf0c      	ite	eq
    136e:	2300      	moveq	r3, #0
    1370:	2301      	movne	r3, #1
    1372:	b2db      	uxtb	r3, r3
}
    1374:	4618      	mov	r0, r3
    1376:	b002      	add	sp, #8
    1378:	4770      	bx	lr
    137a:	bf00      	nop
    137c:	f3af 8000 	nop.w

00001380 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1380:	b082      	sub	sp, #8
    1382:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1384:	9b01      	ldr	r3, [sp, #4]
    1386:	9a01      	ldr	r2, [sp, #4]
    1388:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    138a:	9b01      	ldr	r3, [sp, #4]
    138c:	9a01      	ldr	r2, [sp, #4]
    138e:	605a      	str	r2, [r3, #4]
}
    1390:	b002      	add	sp, #8
    1392:	4770      	bx	lr
    1394:	f3af 8000 	nop.w
    1398:	f3af 8000 	nop.w
    139c:	f3af 8000 	nop.w

000013a0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
    13a0:	b082      	sub	sp, #8
    13a2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
    13a4:	9b01      	ldr	r3, [sp, #4]
    13a6:	681a      	ldr	r2, [r3, #0]
    13a8:	9b01      	ldr	r3, [sp, #4]
    13aa:	429a      	cmp	r2, r3
    13ac:	bf0c      	ite	eq
    13ae:	2300      	moveq	r3, #0
    13b0:	2301      	movne	r3, #1
    13b2:	b2db      	uxtb	r3, r3
}
    13b4:	4618      	mov	r0, r3
    13b6:	b002      	add	sp, #8
    13b8:	4770      	bx	lr
    13ba:	bf00      	nop
    13bc:	f3af 8000 	nop.w

000013c0 <list_insert>:

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {
    13c0:	b082      	sub	sp, #8
    13c2:	9001      	str	r0, [sp, #4]
    13c4:	9100      	str	r1, [sp, #0]

  tp->p_next = tlp->p_next;
    13c6:	9b00      	ldr	r3, [sp, #0]
    13c8:	681a      	ldr	r2, [r3, #0]
    13ca:	9b01      	ldr	r3, [sp, #4]
    13cc:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
    13ce:	9b00      	ldr	r3, [sp, #0]
    13d0:	9a01      	ldr	r2, [sp, #4]
    13d2:	601a      	str	r2, [r3, #0]
}
    13d4:	b002      	add	sp, #8
    13d6:	4770      	bx	lr
    13d8:	f3af 8000 	nop.w
    13dc:	f3af 8000 	nop.w

000013e0 <list_remove>:

static inline thread_t *list_remove(threads_list_t *tlp) {
    13e0:	b084      	sub	sp, #16
    13e2:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
    13e4:	9b01      	ldr	r3, [sp, #4]
    13e6:	681b      	ldr	r3, [r3, #0]
    13e8:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
    13ea:	9b03      	ldr	r3, [sp, #12]
    13ec:	681a      	ldr	r2, [r3, #0]
    13ee:	9b01      	ldr	r3, [sp, #4]
    13f0:	601a      	str	r2, [r3, #0]

  return tp;
    13f2:	9b03      	ldr	r3, [sp, #12]
}
    13f4:	4618      	mov	r0, r3
    13f6:	b004      	add	sp, #16
    13f8:	4770      	bx	lr
    13fa:	bf00      	nop
    13fc:	f3af 8000 	nop.w

00001400 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
    1400:	b082      	sub	sp, #8
    1402:	9001      	str	r0, [sp, #4]
    1404:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
    1406:	9b01      	ldr	r3, [sp, #4]
    1408:	9a00      	ldr	r2, [sp, #0]
    140a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
    140c:	9b00      	ldr	r3, [sp, #0]
    140e:	685a      	ldr	r2, [r3, #4]
    1410:	9b01      	ldr	r3, [sp, #4]
    1412:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    1414:	9b01      	ldr	r3, [sp, #4]
    1416:	685b      	ldr	r3, [r3, #4]
    1418:	9a01      	ldr	r2, [sp, #4]
    141a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
    141c:	9b00      	ldr	r3, [sp, #0]
    141e:	9a01      	ldr	r2, [sp, #4]
    1420:	605a      	str	r2, [r3, #4]
}
    1422:	b002      	add	sp, #8
    1424:	4770      	bx	lr
    1426:	bf00      	nop
    1428:	f3af 8000 	nop.w
    142c:	f3af 8000 	nop.w

00001430 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
    1430:	b084      	sub	sp, #16
    1432:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
    1434:	9b01      	ldr	r3, [sp, #4]
    1436:	681b      	ldr	r3, [r3, #0]
    1438:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
    143a:	9b03      	ldr	r3, [sp, #12]
    143c:	681a      	ldr	r2, [r3, #0]
    143e:	9b01      	ldr	r3, [sp, #4]
    1440:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1442:	9b01      	ldr	r3, [sp, #4]
    1444:	681b      	ldr	r3, [r3, #0]
    1446:	9a01      	ldr	r2, [sp, #4]
    1448:	605a      	str	r2, [r3, #4]

  return tp;
    144a:	9b03      	ldr	r3, [sp, #12]
}
    144c:	4618      	mov	r0, r3
    144e:	b004      	add	sp, #16
    1450:	4770      	bx	lr
    1452:	bf00      	nop
    1454:	f3af 8000 	nop.w
    1458:	f3af 8000 	nop.w
    145c:	f3af 8000 	nop.w

00001460 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1460:	b508      	push	{r3, lr}

  port_lock();
    1462:	f7ff ff65 	bl	1330 <port_lock>
  _stats_start_measure_crit_thd();
    1466:	f000 fb6b 	bl	1b40 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    146a:	f7ff fa71 	bl	950 <_dbg_check_lock>
}
    146e:	bd08      	pop	{r3, pc}

00001470 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1470:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1472:	f7ff fa85 	bl	980 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1476:	f000 fb6b 	bl	1b50 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    147a:	4b09      	ldr	r3, [pc, #36]	; (14a0 <chSysUnlock+0x30>)
    147c:	681a      	ldr	r2, [r3, #0]
    147e:	4b08      	ldr	r3, [pc, #32]	; (14a0 <chSysUnlock+0x30>)
    1480:	429a      	cmp	r2, r3
    1482:	d00a      	beq.n	149a <chSysUnlock+0x2a>
    1484:	4b06      	ldr	r3, [pc, #24]	; (14a0 <chSysUnlock+0x30>)
    1486:	699b      	ldr	r3, [r3, #24]
    1488:	689a      	ldr	r2, [r3, #8]
    148a:	4b05      	ldr	r3, [pc, #20]	; (14a0 <chSysUnlock+0x30>)
    148c:	681b      	ldr	r3, [r3, #0]
    148e:	689b      	ldr	r3, [r3, #8]
    1490:	429a      	cmp	r2, r3
    1492:	d202      	bcs.n	149a <chSysUnlock+0x2a>
    1494:	4803      	ldr	r0, [pc, #12]	; (14a4 <chSysUnlock+0x34>)
    1496:	f7ff f9f3 	bl	880 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    149a:	f7ff ff51 	bl	1340 <port_unlock>
}
    149e:	bd08      	pop	{r3, pc}
    14a0:	20000ac0 	.word	0x20000ac0
    14a4:	00004770 	.word	0x00004770
    14a8:	f3af 8000 	nop.w
    14ac:	f3af 8000 	nop.w

000014b0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
    14b0:	b500      	push	{lr}
    14b2:	b083      	sub	sp, #12
    14b4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
    14b6:	9b01      	ldr	r3, [sp, #4]
    14b8:	2b00      	cmp	r3, #0
    14ba:	d102      	bne.n	14c2 <chThdSleepS+0x12>
    14bc:	4804      	ldr	r0, [pc, #16]	; (14d0 <chThdSleepS+0x20>)
    14be:	f7ff f9df 	bl	880 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
    14c2:	2008      	movs	r0, #8
    14c4:	9901      	ldr	r1, [sp, #4]
    14c6:	f7ff fe2b 	bl	1120 <chSchGoSleepTimeoutS>
}
    14ca:	b003      	add	sp, #12
    14cc:	f85d fb04 	ldr.w	pc, [sp], #4
    14d0:	000047a0 	.word	0x000047a0
    14d4:	f3af 8000 	nop.w
    14d8:	f3af 8000 	nop.w
    14dc:	f3af 8000 	nop.w

000014e0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    14e0:	b500      	push	{lr}
    14e2:	b085      	sub	sp, #20
    14e4:	9001      	str	r0, [sp, #4]
    14e6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
    14e8:	9801      	ldr	r0, [sp, #4]
    14ea:	f7ff ff59 	bl	13a0 <queue_notempty>
    14ee:	4603      	mov	r3, r0
    14f0:	f083 0301 	eor.w	r3, r3, #1
    14f4:	b2db      	uxtb	r3, r3
    14f6:	2b00      	cmp	r3, #0
    14f8:	d002      	beq.n	1500 <chThdDoDequeueNextI+0x20>
    14fa:	480c      	ldr	r0, [pc, #48]	; (152c <chThdDoDequeueNextI+0x4c>)
    14fc:	f7ff f9c0 	bl	880 <chSysHalt>

  tp = queue_fifo_remove(tqp);
    1500:	9801      	ldr	r0, [sp, #4]
    1502:	f7ff ff95 	bl	1430 <queue_fifo_remove>
    1506:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
    1508:	9b03      	ldr	r3, [sp, #12]
    150a:	f893 3020 	ldrb.w	r3, [r3, #32]
    150e:	2b04      	cmp	r3, #4
    1510:	d002      	beq.n	1518 <chThdDoDequeueNextI+0x38>
    1512:	4806      	ldr	r0, [pc, #24]	; (152c <chThdDoDequeueNextI+0x4c>)
    1514:	f7ff f9b4 	bl	880 <chSysHalt>

  tp->p_u.rdymsg = msg;
    1518:	9b03      	ldr	r3, [sp, #12]
    151a:	9a00      	ldr	r2, [sp, #0]
    151c:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
    151e:	9803      	ldr	r0, [sp, #12]
    1520:	f7ff fd3e 	bl	fa0 <chSchReadyI>
}
    1524:	b005      	add	sp, #20
    1526:	f85d fb04 	ldr.w	pc, [sp], #4
    152a:	bf00      	nop
    152c:	000047e0 	.word	0x000047e0

00001530 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
    1530:	b500      	push	{lr}
    1532:	b083      	sub	sp, #12
    1534:	9001      	str	r0, [sp, #4]
    1536:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
    1538:	9b01      	ldr	r3, [sp, #4]
    153a:	9a00      	ldr	r2, [sp, #0]
    153c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
    153e:	9b01      	ldr	r3, [sp, #4]
    1540:	2202      	movs	r2, #2
    1542:	f883 2020 	strb.w	r2, [r3, #32]
  tp->p_flags = CH_FLAG_MODE_STATIC;
    1546:	9b01      	ldr	r3, [sp, #4]
    1548:	2200      	movs	r2, #0
    154a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
    154e:	9b01      	ldr	r3, [sp, #4]
    1550:	9a00      	ldr	r2, [sp, #0]
    1552:	641a      	str	r2, [r3, #64]	; 0x40
  tp->p_mtxlist = NULL;
    1554:	9b01      	ldr	r3, [sp, #4]
    1556:	2200      	movs	r2, #0
    1558:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
    155a:	9b01      	ldr	r3, [sp, #4]
    155c:	2200      	movs	r2, #0
    155e:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
    1560:	9b01      	ldr	r3, [sp, #4]
    1562:	2201      	movs	r2, #1
    1564:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
    1568:	9b01      	ldr	r3, [sp, #4]
    156a:	2200      	movs	r2, #0
    156c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
    156e:	9b01      	ldr	r3, [sp, #4]
    1570:	4a15      	ldr	r2, [pc, #84]	; (15c8 <_thread_init+0x98>)
    1572:	611a      	str	r2, [r3, #16]
    1574:	4b14      	ldr	r3, [pc, #80]	; (15c8 <_thread_init+0x98>)
    1576:	695a      	ldr	r2, [r3, #20]
    1578:	9b01      	ldr	r3, [sp, #4]
    157a:	615a      	str	r2, [r3, #20]
    157c:	9b01      	ldr	r3, [sp, #4]
    157e:	695b      	ldr	r3, [r3, #20]
    1580:	9a01      	ldr	r2, [sp, #4]
    1582:	611a      	str	r2, [r3, #16]
    1584:	4b10      	ldr	r3, [pc, #64]	; (15c8 <_thread_init+0x98>)
    1586:	9a01      	ldr	r2, [sp, #4]
    1588:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
    158a:	9b01      	ldr	r3, [sp, #4]
    158c:	3328      	adds	r3, #40	; 0x28
    158e:	4618      	mov	r0, r3
    1590:	f7ff fede 	bl	1350 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
    1594:	9b01      	ldr	r3, [sp, #4]
    1596:	332c      	adds	r3, #44	; 0x2c
    1598:	4618      	mov	r0, r3
    159a:	f7ff fef1 	bl	1380 <queue_init>
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
    159e:	9b01      	ldr	r3, [sp, #4]
    15a0:	f103 0260 	add.w	r2, r3, #96	; 0x60
    15a4:	9b01      	ldr	r3, [sp, #4]
    15a6:	61da      	str	r2, [r3, #28]
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->p_stats);
    15a8:	9b01      	ldr	r3, [sp, #4]
    15aa:	3348      	adds	r3, #72	; 0x48
    15ac:	4618      	mov	r0, r3
    15ae:	f000 fa27 	bl	1a00 <chTMObjectInit>
  chTMStartMeasurementX(&tp->p_stats);
    15b2:	9b01      	ldr	r3, [sp, #4]
    15b4:	3348      	adds	r3, #72	; 0x48
    15b6:	4618      	mov	r0, r3
    15b8:	f000 fa3a 	bl	1a30 <chTMStartMeasurementX>
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
    15bc:	9b01      	ldr	r3, [sp, #4]
}
    15be:	4618      	mov	r0, r3
    15c0:	b003      	add	sp, #12
    15c2:	f85d fb04 	ldr.w	pc, [sp], #4
    15c6:	bf00      	nop
    15c8:	20000ac0 	.word	0x20000ac0
    15cc:	f3af 8000 	nop.w

000015d0 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
    15d0:	b084      	sub	sp, #16
    15d2:	9003      	str	r0, [sp, #12]
    15d4:	9102      	str	r1, [sp, #8]
    15d6:	4613      	mov	r3, r2
    15d8:	f88d 3007 	strb.w	r3, [sp, #7]

  while (startp < endp) {
    15dc:	e005      	b.n	15ea <_thread_memfill+0x1a>
    *startp++ = v;
    15de:	9b03      	ldr	r3, [sp, #12]
    15e0:	1c5a      	adds	r2, r3, #1
    15e2:	9203      	str	r2, [sp, #12]
    15e4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    15e8:	701a      	strb	r2, [r3, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    15ea:	9a03      	ldr	r2, [sp, #12]
    15ec:	9b02      	ldr	r3, [sp, #8]
    15ee:	429a      	cmp	r2, r3
    15f0:	d3f5      	bcc.n	15de <_thread_memfill+0xe>
    *startp++ = v;
  }
}
    15f2:	b004      	add	sp, #16
    15f4:	4770      	bx	lr
    15f6:	bf00      	nop
    15f8:	f3af 8000 	nop.w
    15fc:	f3af 8000 	nop.w

00001600 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
    1600:	b500      	push	{lr}
    1602:	b087      	sub	sp, #28
    1604:	9003      	str	r0, [sp, #12]
    1606:	9102      	str	r1, [sp, #8]
    1608:	9201      	str	r2, [sp, #4]
    160a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
    160c:	9b03      	ldr	r3, [sp, #12]
    160e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
    1610:	f7ff fa3e 	bl	a90 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
    1614:	9b03      	ldr	r3, [sp, #12]
    1616:	2b00      	cmp	r3, #0
    1618:	d008      	beq.n	162c <chThdCreateI+0x2c>
    161a:	9b02      	ldr	r3, [sp, #8]
    161c:	2be7      	cmp	r3, #231	; 0xe7
    161e:	d905      	bls.n	162c <chThdCreateI+0x2c>
    1620:	9b01      	ldr	r3, [sp, #4]
    1622:	2b7f      	cmp	r3, #127	; 0x7f
    1624:	d802      	bhi.n	162c <chThdCreateI+0x2c>
    1626:	9b00      	ldr	r3, [sp, #0]
    1628:	2b00      	cmp	r3, #0
    162a:	d102      	bne.n	1632 <chThdCreateI+0x32>
    162c:	480e      	ldr	r0, [pc, #56]	; (1668 <chThdCreateI+0x68>)
    162e:	f7ff f927 	bl	880 <chSysHalt>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    1632:	9b02      	ldr	r3, [sp, #8]
    1634:	3b24      	subs	r3, #36	; 0x24
    1636:	9a03      	ldr	r2, [sp, #12]
    1638:	441a      	add	r2, r3
    163a:	9b05      	ldr	r3, [sp, #20]
    163c:	60da      	str	r2, [r3, #12]
    163e:	9b05      	ldr	r3, [sp, #20]
    1640:	68db      	ldr	r3, [r3, #12]
    1642:	9a00      	ldr	r2, [sp, #0]
    1644:	601a      	str	r2, [r3, #0]
    1646:	9b05      	ldr	r3, [sp, #20]
    1648:	68db      	ldr	r3, [r3, #12]
    164a:	9a08      	ldr	r2, [sp, #32]
    164c:	605a      	str	r2, [r3, #4]
    164e:	9b05      	ldr	r3, [sp, #20]
    1650:	68db      	ldr	r3, [r3, #12]
    1652:	4a06      	ldr	r2, [pc, #24]	; (166c <chThdCreateI+0x6c>)
    1654:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
    1656:	9805      	ldr	r0, [sp, #20]
    1658:	9901      	ldr	r1, [sp, #4]
    165a:	f7ff ff69 	bl	1530 <_thread_init>
    165e:	4603      	mov	r3, r0
}
    1660:	4618      	mov	r0, r3
    1662:	b007      	add	sp, #28
    1664:	f85d fb04 	ldr.w	pc, [sp], #4
    1668:	00004760 	.word	0x00004760
    166c:	00000291 	.word	0x00000291

00001670 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
    1670:	b500      	push	{lr}
    1672:	b089      	sub	sp, #36	; 0x24
    1674:	9005      	str	r0, [sp, #20]
    1676:	9104      	str	r1, [sp, #16]
    1678:	9203      	str	r2, [sp, #12]
    167a:	9302      	str	r3, [sp, #8]
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
    167c:	9b05      	ldr	r3, [sp, #20]
    167e:	3360      	adds	r3, #96	; 0x60
    1680:	9805      	ldr	r0, [sp, #20]
    1682:	4619      	mov	r1, r3
    1684:	22ff      	movs	r2, #255	; 0xff
    1686:	f7ff ffa3 	bl	15d0 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
    168a:	9b05      	ldr	r3, [sp, #20]
    168c:	f103 0260 	add.w	r2, r3, #96	; 0x60
    1690:	9905      	ldr	r1, [sp, #20]
    1692:	9b04      	ldr	r3, [sp, #16]
    1694:	440b      	add	r3, r1
    1696:	4610      	mov	r0, r2
    1698:	4619      	mov	r1, r3
    169a:	2255      	movs	r2, #85	; 0x55
    169c:	f7ff ff98 	bl	15d0 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
    16a0:	f7ff fede 	bl	1460 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
    16a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    16a6:	9300      	str	r3, [sp, #0]
    16a8:	9805      	ldr	r0, [sp, #20]
    16aa:	9904      	ldr	r1, [sp, #16]
    16ac:	9a03      	ldr	r2, [sp, #12]
    16ae:	9b02      	ldr	r3, [sp, #8]
    16b0:	f7ff ffa6 	bl	1600 <chThdCreateI>
    16b4:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
    16b6:	9807      	ldr	r0, [sp, #28]
    16b8:	2100      	movs	r1, #0
    16ba:	f7ff fd69 	bl	1190 <chSchWakeupS>
  chSysUnlock();
    16be:	f7ff fed7 	bl	1470 <chSysUnlock>

  return tp;
    16c2:	9b07      	ldr	r3, [sp, #28]
}
    16c4:	4618      	mov	r0, r3
    16c6:	b009      	add	sp, #36	; 0x24
    16c8:	f85d fb04 	ldr.w	pc, [sp], #4
    16cc:	f3af 8000 	nop.w

000016d0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
    16d0:	b500      	push	{lr}
    16d2:	b085      	sub	sp, #20
    16d4:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
    16d6:	9b01      	ldr	r3, [sp, #4]
    16d8:	2b7f      	cmp	r3, #127	; 0x7f
    16da:	d902      	bls.n	16e2 <chThdSetPriority+0x12>
    16dc:	4813      	ldr	r0, [pc, #76]	; (172c <chThdSetPriority+0x5c>)
    16de:	f7ff f8cf 	bl	880 <chSysHalt>

  chSysLock();
    16e2:	f7ff febd 	bl	1460 <chSysLock>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
    16e6:	4b12      	ldr	r3, [pc, #72]	; (1730 <chThdSetPriority+0x60>)
    16e8:	699b      	ldr	r3, [r3, #24]
    16ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    16ec:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
    16ee:	4b10      	ldr	r3, [pc, #64]	; (1730 <chThdSetPriority+0x60>)
    16f0:	699b      	ldr	r3, [r3, #24]
    16f2:	689a      	ldr	r2, [r3, #8]
    16f4:	4b0e      	ldr	r3, [pc, #56]	; (1730 <chThdSetPriority+0x60>)
    16f6:	699b      	ldr	r3, [r3, #24]
    16f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    16fa:	429a      	cmp	r2, r3
    16fc:	d005      	beq.n	170a <chThdSetPriority+0x3a>
    16fe:	4b0c      	ldr	r3, [pc, #48]	; (1730 <chThdSetPriority+0x60>)
    1700:	699b      	ldr	r3, [r3, #24]
    1702:	689a      	ldr	r2, [r3, #8]
    1704:	9b01      	ldr	r3, [sp, #4]
    1706:	429a      	cmp	r2, r3
    1708:	d203      	bcs.n	1712 <chThdSetPriority+0x42>
    currp->p_prio = newprio;
    170a:	4b09      	ldr	r3, [pc, #36]	; (1730 <chThdSetPriority+0x60>)
    170c:	699b      	ldr	r3, [r3, #24]
    170e:	9a01      	ldr	r2, [sp, #4]
    1710:	609a      	str	r2, [r3, #8]
  }
  currp->p_realprio = newprio;
    1712:	4b07      	ldr	r3, [pc, #28]	; (1730 <chThdSetPriority+0x60>)
    1714:	699b      	ldr	r3, [r3, #24]
    1716:	9a01      	ldr	r2, [sp, #4]
    1718:	641a      	str	r2, [r3, #64]	; 0x40
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
    171a:	f7ff fd81 	bl	1220 <chSchRescheduleS>
  chSysUnlock();
    171e:	f7ff fea7 	bl	1470 <chSysUnlock>

  return oldprio;
    1722:	9b03      	ldr	r3, [sp, #12]
}
    1724:	4618      	mov	r0, r3
    1726:	b005      	add	sp, #20
    1728:	f85d fb04 	ldr.w	pc, [sp], #4
    172c:	00004780 	.word	0x00004780
    1730:	20000ac0 	.word	0x20000ac0
    1734:	f3af 8000 	nop.w
    1738:	f3af 8000 	nop.w
    173c:	f3af 8000 	nop.w

00001740 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
    1740:	b500      	push	{lr}
    1742:	b083      	sub	sp, #12
    1744:	9001      	str	r0, [sp, #4]

  chSysLock();
    1746:	f7ff fe8b 	bl	1460 <chSysLock>
  chThdSleepS(time);
    174a:	9801      	ldr	r0, [sp, #4]
    174c:	f7ff feb0 	bl	14b0 <chThdSleepS>
  chSysUnlock();
    1750:	f7ff fe8e 	bl	1470 <chSysUnlock>
}
    1754:	b003      	add	sp, #12
    1756:	f85d fb04 	ldr.w	pc, [sp], #4
    175a:	bf00      	nop
    175c:	f3af 8000 	nop.w

00001760 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
    1760:	b500      	push	{lr}
    1762:	b083      	sub	sp, #12
    1764:	9001      	str	r0, [sp, #4]

  chSysLock();
    1766:	f7ff fe7b 	bl	1460 <chSysLock>
  chThdExitS(msg);
    176a:	9801      	ldr	r0, [sp, #4]
    176c:	f000 f808 	bl	1780 <chThdExitS>
  /* The thread never returns here.*/
}
    1770:	b003      	add	sp, #12
    1772:	f85d fb04 	ldr.w	pc, [sp], #4
    1776:	bf00      	nop
    1778:	f3af 8000 	nop.w
    177c:	f3af 8000 	nop.w

00001780 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
    1780:	b500      	push	{lr}
    1782:	b085      	sub	sp, #20
    1784:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
    1786:	4b19      	ldr	r3, [pc, #100]	; (17ec <chThdExitS+0x6c>)
    1788:	699b      	ldr	r3, [r3, #24]
    178a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
    178c:	9b03      	ldr	r3, [sp, #12]
    178e:	9a01      	ldr	r2, [sp, #4]
    1790:	625a      	str	r2, [r3, #36]	; 0x24
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    1792:	e008      	b.n	17a6 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->p_waiting));
    1794:	9b03      	ldr	r3, [sp, #12]
    1796:	3328      	adds	r3, #40	; 0x28
    1798:	4618      	mov	r0, r3
    179a:	f7ff fe21 	bl	13e0 <list_remove>
    179e:	4603      	mov	r3, r0
    17a0:	4618      	mov	r0, r3
    17a2:	f7ff fbfd 	bl	fa0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    17a6:	9b03      	ldr	r3, [sp, #12]
    17a8:	3328      	adds	r3, #40	; 0x28
    17aa:	4618      	mov	r0, r3
    17ac:	f7ff fdd8 	bl	1360 <list_notempty>
    17b0:	4603      	mov	r3, r0
    17b2:	2b00      	cmp	r3, #0
    17b4:	d1ee      	bne.n	1794 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    17b6:	9b03      	ldr	r3, [sp, #12]
    17b8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    17bc:	f003 0303 	and.w	r3, r3, #3
    17c0:	2b00      	cmp	r3, #0
    17c2:	d109      	bne.n	17d8 <chThdExitS+0x58>
    REG_REMOVE(tp);
    17c4:	9b03      	ldr	r3, [sp, #12]
    17c6:	695b      	ldr	r3, [r3, #20]
    17c8:	9a03      	ldr	r2, [sp, #12]
    17ca:	6912      	ldr	r2, [r2, #16]
    17cc:	611a      	str	r2, [r3, #16]
    17ce:	9b03      	ldr	r3, [sp, #12]
    17d0:	691b      	ldr	r3, [r3, #16]
    17d2:	9a03      	ldr	r2, [sp, #12]
    17d4:	6952      	ldr	r2, [r2, #20]
    17d6:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
    17d8:	200f      	movs	r0, #15
    17da:	f7ff fc21 	bl	1020 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
    17de:	4804      	ldr	r0, [pc, #16]	; (17f0 <chThdExitS+0x70>)
    17e0:	f7ff f84e 	bl	880 <chSysHalt>
}
    17e4:	b005      	add	sp, #20
    17e6:	f85d fb04 	ldr.w	pc, [sp], #4
    17ea:	bf00      	nop
    17ec:	20000ac0 	.word	0x20000ac0
    17f0:	000047b0 	.word	0x000047b0
    17f4:	f3af 8000 	nop.w
    17f8:	f3af 8000 	nop.w
    17fc:	f3af 8000 	nop.w

00001800 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
    1800:	b500      	push	{lr}
    1802:	b085      	sub	sp, #20
    1804:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL);
    1806:	9b01      	ldr	r3, [sp, #4]
    1808:	2b00      	cmp	r3, #0
    180a:	d102      	bne.n	1812 <chThdWait+0x12>
    180c:	4818      	ldr	r0, [pc, #96]	; (1870 <chThdWait+0x70>)
    180e:	f7ff f837 	bl	880 <chSysHalt>

  chSysLock();
    1812:	f7ff fe25 	bl	1460 <chSysLock>
  chDbgAssert(tp != currp, "waiting self");
    1816:	4b17      	ldr	r3, [pc, #92]	; (1874 <chThdWait+0x74>)
    1818:	699a      	ldr	r2, [r3, #24]
    181a:	9b01      	ldr	r3, [sp, #4]
    181c:	429a      	cmp	r2, r3
    181e:	d102      	bne.n	1826 <chThdWait+0x26>
    1820:	4813      	ldr	r0, [pc, #76]	; (1870 <chThdWait+0x70>)
    1822:	f7ff f82d 	bl	880 <chSysHalt>
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
    1826:	9b01      	ldr	r3, [sp, #4]
    1828:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    182c:	2b00      	cmp	r3, #0
    182e:	d102      	bne.n	1836 <chThdWait+0x36>
    1830:	480f      	ldr	r0, [pc, #60]	; (1870 <chThdWait+0x70>)
    1832:	f7ff f825 	bl	880 <chSysHalt>
#endif
  if (tp->p_state != CH_STATE_FINAL) {
    1836:	9b01      	ldr	r3, [sp, #4]
    1838:	f893 3020 	ldrb.w	r3, [r3, #32]
    183c:	2b0f      	cmp	r3, #15
    183e:	d00a      	beq.n	1856 <chThdWait+0x56>
    list_insert(currp, &tp->p_waiting);
    1840:	4b0c      	ldr	r3, [pc, #48]	; (1874 <chThdWait+0x74>)
    1842:	699a      	ldr	r2, [r3, #24]
    1844:	9b01      	ldr	r3, [sp, #4]
    1846:	3328      	adds	r3, #40	; 0x28
    1848:	4610      	mov	r0, r2
    184a:	4619      	mov	r1, r3
    184c:	f7ff fdb8 	bl	13c0 <list_insert>
    chSchGoSleepS(CH_STATE_WTEXIT);
    1850:	2009      	movs	r0, #9
    1852:	f7ff fbe5 	bl	1020 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
    1856:	9b01      	ldr	r3, [sp, #4]
    1858:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    185a:	9303      	str	r3, [sp, #12]
  chSysUnlock();
    185c:	f7ff fe08 	bl	1470 <chSysUnlock>

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
    1860:	9801      	ldr	r0, [sp, #4]
    1862:	f000 f9c5 	bl	1bf0 <chThdRelease>
#endif

  return msg;
    1866:	9b03      	ldr	r3, [sp, #12]
}
    1868:	4618      	mov	r0, r3
    186a:	b005      	add	sp, #20
    186c:	f85d fb04 	ldr.w	pc, [sp], #4
    1870:	000047c0 	.word	0x000047c0
    1874:	20000ac0 	.word	0x20000ac0
    1878:	f3af 8000 	nop.w
    187c:	f3af 8000 	nop.w

00001880 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    1880:	b500      	push	{lr}
    1882:	b085      	sub	sp, #20
    1884:	9001      	str	r0, [sp, #4]
    1886:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
    1888:	9b01      	ldr	r3, [sp, #4]
    188a:	681b      	ldr	r3, [r3, #0]
    188c:	2b00      	cmp	r3, #0
    188e:	d013      	beq.n	18b8 <chThdResumeI+0x38>
    thread_t *tp = *trp;
    1890:	9b01      	ldr	r3, [sp, #4]
    1892:	681b      	ldr	r3, [r3, #0]
    1894:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
    1896:	9b03      	ldr	r3, [sp, #12]
    1898:	f893 3020 	ldrb.w	r3, [r3, #32]
    189c:	2b03      	cmp	r3, #3
    189e:	d002      	beq.n	18a6 <chThdResumeI+0x26>
    18a0:	4807      	ldr	r0, [pc, #28]	; (18c0 <chThdResumeI+0x40>)
    18a2:	f7fe ffed 	bl	880 <chSysHalt>
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    18a6:	9b01      	ldr	r3, [sp, #4]
    18a8:	2200      	movs	r2, #0
    18aa:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
    18ac:	9b03      	ldr	r3, [sp, #12]
    18ae:	9a00      	ldr	r2, [sp, #0]
    18b0:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    18b2:	9803      	ldr	r0, [sp, #12]
    18b4:	f7ff fb74 	bl	fa0 <chSchReadyI>
  }
}
    18b8:	b005      	add	sp, #20
    18ba:	f85d fb04 	ldr.w	pc, [sp], #4
    18be:	bf00      	nop
    18c0:	000047d0 	.word	0x000047d0
    18c4:	f3af 8000 	nop.w
    18c8:	f3af 8000 	nop.w
    18cc:	f3af 8000 	nop.w

000018d0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
    18d0:	b500      	push	{lr}
    18d2:	b083      	sub	sp, #12
    18d4:	9001      	str	r0, [sp, #4]
    18d6:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
    18d8:	9b00      	ldr	r3, [sp, #0]
    18da:	2b00      	cmp	r3, #0
    18dc:	d102      	bne.n	18e4 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
    18de:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    18e2:	e00a      	b.n	18fa <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
    18e4:	4b07      	ldr	r3, [pc, #28]	; (1904 <chThdEnqueueTimeoutS+0x34>)
    18e6:	699b      	ldr	r3, [r3, #24]
    18e8:	4618      	mov	r0, r3
    18ea:	9901      	ldr	r1, [sp, #4]
    18ec:	f7ff fd88 	bl	1400 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    18f0:	2004      	movs	r0, #4
    18f2:	9900      	ldr	r1, [sp, #0]
    18f4:	f7ff fc14 	bl	1120 <chSchGoSleepTimeoutS>
    18f8:	4603      	mov	r3, r0
}
    18fa:	4618      	mov	r0, r3
    18fc:	b003      	add	sp, #12
    18fe:	f85d fb04 	ldr.w	pc, [sp], #4
    1902:	bf00      	nop
    1904:	20000ac0 	.word	0x20000ac0
    1908:	f3af 8000 	nop.w
    190c:	f3af 8000 	nop.w

00001910 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    1910:	b500      	push	{lr}
    1912:	b083      	sub	sp, #12
    1914:	9001      	str	r0, [sp, #4]
    1916:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
    1918:	9801      	ldr	r0, [sp, #4]
    191a:	f7ff fd41 	bl	13a0 <queue_notempty>
    191e:	4603      	mov	r3, r0
    1920:	2b00      	cmp	r3, #0
    1922:	d003      	beq.n	192c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
    1924:	9801      	ldr	r0, [sp, #4]
    1926:	9900      	ldr	r1, [sp, #0]
    1928:	f7ff fdda 	bl	14e0 <chThdDoDequeueNextI>
  }
}
    192c:	b003      	add	sp, #12
    192e:	f85d fb04 	ldr.w	pc, [sp], #4
    1932:	bf00      	nop
    1934:	f3af 8000 	nop.w
    1938:	f3af 8000 	nop.w
    193c:	f3af 8000 	nop.w

00001940 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
    1940:	4b01      	ldr	r3, [pc, #4]	; (1948 <port_rt_get_counter_value+0x8>)
    1942:	685b      	ldr	r3, [r3, #4]
}
    1944:	4618      	mov	r0, r3
    1946:	4770      	bx	lr
    1948:	e0001000 	.word	0xe0001000
    194c:	f3af 8000 	nop.w

00001950 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
    1950:	b084      	sub	sp, #16
    1952:	9003      	str	r0, [sp, #12]
    1954:	9102      	str	r1, [sp, #8]
    1956:	9201      	str	r2, [sp, #4]

  tmp->n++;
    1958:	9b03      	ldr	r3, [sp, #12]
    195a:	68db      	ldr	r3, [r3, #12]
    195c:	1c5a      	adds	r2, r3, #1
    195e:	9b03      	ldr	r3, [sp, #12]
    1960:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
    1962:	9b03      	ldr	r3, [sp, #12]
    1964:	689b      	ldr	r3, [r3, #8]
    1966:	9a02      	ldr	r2, [sp, #8]
    1968:	1ad2      	subs	r2, r2, r3
    196a:	9b01      	ldr	r3, [sp, #4]
    196c:	1ad2      	subs	r2, r2, r3
    196e:	9b03      	ldr	r3, [sp, #12]
    1970:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
    1972:	9b03      	ldr	r3, [sp, #12]
    1974:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
    1978:	9b03      	ldr	r3, [sp, #12]
    197a:	689b      	ldr	r3, [r3, #8]
    197c:	461a      	mov	r2, r3
    197e:	f04f 0300 	mov.w	r3, #0
    1982:	1812      	adds	r2, r2, r0
    1984:	eb43 0301 	adc.w	r3, r3, r1
    1988:	9903      	ldr	r1, [sp, #12]
    198a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
    198e:	9b03      	ldr	r3, [sp, #12]
    1990:	689a      	ldr	r2, [r3, #8]
    1992:	9b03      	ldr	r3, [sp, #12]
    1994:	685b      	ldr	r3, [r3, #4]
    1996:	429a      	cmp	r2, r3
    1998:	d904      	bls.n	19a4 <tm_stop+0x54>
    tmp->worst = tmp->last;
    199a:	9b03      	ldr	r3, [sp, #12]
    199c:	689a      	ldr	r2, [r3, #8]
    199e:	9b03      	ldr	r3, [sp, #12]
    19a0:	605a      	str	r2, [r3, #4]
    19a2:	e009      	b.n	19b8 <tm_stop+0x68>
  }
  else if (tmp->last < tmp->best) {
    19a4:	9b03      	ldr	r3, [sp, #12]
    19a6:	689a      	ldr	r2, [r3, #8]
    19a8:	9b03      	ldr	r3, [sp, #12]
    19aa:	681b      	ldr	r3, [r3, #0]
    19ac:	429a      	cmp	r2, r3
    19ae:	d203      	bcs.n	19b8 <tm_stop+0x68>
    tmp->best = tmp->last;
    19b0:	9b03      	ldr	r3, [sp, #12]
    19b2:	689a      	ldr	r2, [r3, #8]
    19b4:	9b03      	ldr	r3, [sp, #12]
    19b6:	601a      	str	r2, [r3, #0]
  }
  /*lint -restore*/
}
    19b8:	b004      	add	sp, #16
    19ba:	4770      	bx	lr
    19bc:	f3af 8000 	nop.w

000019c0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
    19c0:	b500      	push	{lr}
    19c2:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
    19c4:	4b0b      	ldr	r3, [pc, #44]	; (19f4 <_tm_init+0x34>)
    19c6:	2200      	movs	r2, #0
    19c8:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
  chTMObjectInit(&tm);
    19cc:	466b      	mov	r3, sp
    19ce:	4618      	mov	r0, r3
    19d0:	f000 f816 	bl	1a00 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
    19d4:	466b      	mov	r3, sp
    19d6:	4618      	mov	r0, r3
    19d8:	f000 f82a 	bl	1a30 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
    19dc:	466b      	mov	r3, sp
    19de:	4618      	mov	r0, r3
    19e0:	f000 f836 	bl	1a50 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
    19e4:	9a02      	ldr	r2, [sp, #8]
    19e6:	4b03      	ldr	r3, [pc, #12]	; (19f4 <_tm_init+0x34>)
    19e8:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
}
    19ec:	b007      	add	sp, #28
    19ee:	f85d fb04 	ldr.w	pc, [sp], #4
    19f2:	bf00      	nop
    19f4:	20000ac0 	.word	0x20000ac0
    19f8:	f3af 8000 	nop.w
    19fc:	f3af 8000 	nop.w

00001a00 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
    1a00:	b082      	sub	sp, #8
    1a02:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
    1a04:	9b01      	ldr	r3, [sp, #4]
    1a06:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    1a0a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
    1a0c:	9b01      	ldr	r3, [sp, #4]
    1a0e:	2200      	movs	r2, #0
    1a10:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
    1a12:	9b01      	ldr	r3, [sp, #4]
    1a14:	2200      	movs	r2, #0
    1a16:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
    1a18:	9b01      	ldr	r3, [sp, #4]
    1a1a:	2200      	movs	r2, #0
    1a1c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
    1a1e:	9901      	ldr	r1, [sp, #4]
    1a20:	f04f 0200 	mov.w	r2, #0
    1a24:	f04f 0300 	mov.w	r3, #0
    1a28:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
    1a2c:	b002      	add	sp, #8
    1a2e:	4770      	bx	lr

00001a30 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
    1a30:	b500      	push	{lr}
    1a32:	b083      	sub	sp, #12
    1a34:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
    1a36:	f7ff ff83 	bl	1940 <port_rt_get_counter_value>
    1a3a:	4602      	mov	r2, r0
    1a3c:	9b01      	ldr	r3, [sp, #4]
    1a3e:	609a      	str	r2, [r3, #8]
}
    1a40:	b003      	add	sp, #12
    1a42:	f85d fb04 	ldr.w	pc, [sp], #4
    1a46:	bf00      	nop
    1a48:	f3af 8000 	nop.w
    1a4c:	f3af 8000 	nop.w

00001a50 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
    1a50:	b500      	push	{lr}
    1a52:	b083      	sub	sp, #12
    1a54:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
    1a56:	f7ff ff73 	bl	1940 <port_rt_get_counter_value>
    1a5a:	4602      	mov	r2, r0
    1a5c:	4b05      	ldr	r3, [pc, #20]	; (1a74 <chTMStopMeasurementX+0x24>)
    1a5e:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
    1a62:	9801      	ldr	r0, [sp, #4]
    1a64:	4611      	mov	r1, r2
    1a66:	461a      	mov	r2, r3
    1a68:	f7ff ff72 	bl	1950 <tm_stop>
}
    1a6c:	b003      	add	sp, #12
    1a6e:	f85d fb04 	ldr.w	pc, [sp], #4
    1a72:	bf00      	nop
    1a74:	20000ac0 	.word	0x20000ac0
    1a78:	f3af 8000 	nop.w
    1a7c:	f3af 8000 	nop.w

00001a80 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
    1a80:	b500      	push	{lr}
    1a82:	b083      	sub	sp, #12
    1a84:	9001      	str	r0, [sp, #4]
    1a86:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
    1a88:	f7ff ff5a 	bl	1940 <port_rt_get_counter_value>
    1a8c:	4602      	mov	r2, r0
    1a8e:	9b00      	ldr	r3, [sp, #0]
    1a90:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
    1a92:	9b00      	ldr	r3, [sp, #0]
    1a94:	689b      	ldr	r3, [r3, #8]
    1a96:	9801      	ldr	r0, [sp, #4]
    1a98:	4619      	mov	r1, r3
    1a9a:	2200      	movs	r2, #0
    1a9c:	f7ff ff58 	bl	1950 <tm_stop>
}
    1aa0:	b003      	add	sp, #12
    1aa2:	f85d fb04 	ldr.w	pc, [sp], #4
    1aa6:	bf00      	nop
    1aa8:	f3af 8000 	nop.w
    1aac:	f3af 8000 	nop.w

00001ab0 <_stats_init>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
    1ab0:	b508      	push	{r3, lr}

  ch.kernel_stats.n_irq = (ucnt_t)0;
    1ab2:	4b07      	ldr	r3, [pc, #28]	; (1ad0 <_stats_init+0x20>)
    1ab4:	2200      	movs	r2, #0
    1ab6:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
    1aba:	4b05      	ldr	r3, [pc, #20]	; (1ad0 <_stats_init+0x20>)
    1abc:	2200      	movs	r2, #0
    1abe:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
    1ac2:	4804      	ldr	r0, [pc, #16]	; (1ad4 <_stats_init+0x24>)
    1ac4:	f7ff ff9c 	bl	1a00 <chTMObjectInit>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
    1ac8:	4803      	ldr	r0, [pc, #12]	; (1ad8 <_stats_init+0x28>)
    1aca:	f7ff ff99 	bl	1a00 <chTMObjectInit>
}
    1ace:	bd08      	pop	{r3, pc}
    1ad0:	20000ac0 	.word	0x20000ac0
    1ad4:	20000f70 	.word	0x20000f70
    1ad8:	20000f88 	.word	0x20000f88
    1adc:	f3af 8000 	nop.w

00001ae0 <_stats_increase_irq>:
/**
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {

  ch.kernel_stats.n_irq++;
    1ae0:	4b03      	ldr	r3, [pc, #12]	; (1af0 <_stats_increase_irq+0x10>)
    1ae2:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
    1ae6:	1c5a      	adds	r2, r3, #1
    1ae8:	4b01      	ldr	r3, [pc, #4]	; (1af0 <_stats_increase_irq+0x10>)
    1aea:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
}
    1aee:	4770      	bx	lr
    1af0:	20000ac0 	.word	0x20000ac0
    1af4:	f3af 8000 	nop.w
    1af8:	f3af 8000 	nop.w
    1afc:	f3af 8000 	nop.w

00001b00 <_stats_ctxswc>:
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
    1b00:	b500      	push	{lr}
    1b02:	b083      	sub	sp, #12
    1b04:	9001      	str	r0, [sp, #4]
    1b06:	9100      	str	r1, [sp, #0]

  ch.kernel_stats.n_ctxswc++;
    1b08:	4b09      	ldr	r3, [pc, #36]	; (1b30 <_stats_ctxswc+0x30>)
    1b0a:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
    1b0e:	1c5a      	adds	r2, r3, #1
    1b10:	4b07      	ldr	r3, [pc, #28]	; (1b30 <_stats_ctxswc+0x30>)
    1b12:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
    1b16:	9b00      	ldr	r3, [sp, #0]
    1b18:	f103 0248 	add.w	r2, r3, #72	; 0x48
    1b1c:	9b01      	ldr	r3, [sp, #4]
    1b1e:	3348      	adds	r3, #72	; 0x48
    1b20:	4610      	mov	r0, r2
    1b22:	4619      	mov	r1, r3
    1b24:	f7ff ffac 	bl	1a80 <chTMChainMeasurementToX>
}
    1b28:	b003      	add	sp, #12
    1b2a:	f85d fb04 	ldr.w	pc, [sp], #4
    1b2e:	bf00      	nop
    1b30:	20000ac0 	.word	0x20000ac0
    1b34:	f3af 8000 	nop.w
    1b38:	f3af 8000 	nop.w
    1b3c:	f3af 8000 	nop.w

00001b40 <_stats_start_measure_crit_thd>:

/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {
    1b40:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
    1b42:	4802      	ldr	r0, [pc, #8]	; (1b4c <_stats_start_measure_crit_thd+0xc>)
    1b44:	f7ff ff74 	bl	1a30 <chTMStartMeasurementX>
}
    1b48:	bd08      	pop	{r3, pc}
    1b4a:	bf00      	nop
    1b4c:	20000f70 	.word	0x20000f70

00001b50 <_stats_stop_measure_crit_thd>:

/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {
    1b50:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
    1b52:	4802      	ldr	r0, [pc, #8]	; (1b5c <_stats_stop_measure_crit_thd+0xc>)
    1b54:	f7ff ff7c 	bl	1a50 <chTMStopMeasurementX>
}
    1b58:	bd08      	pop	{r3, pc}
    1b5a:	bf00      	nop
    1b5c:	20000f70 	.word	0x20000f70

00001b60 <_stats_start_measure_crit_isr>:

/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {
    1b60:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
    1b62:	4802      	ldr	r0, [pc, #8]	; (1b6c <_stats_start_measure_crit_isr+0xc>)
    1b64:	f7ff ff64 	bl	1a30 <chTMStartMeasurementX>
}
    1b68:	bd08      	pop	{r3, pc}
    1b6a:	bf00      	nop
    1b6c:	20000f88 	.word	0x20000f88

00001b70 <_stats_stop_measure_crit_isr>:

/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {
    1b70:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
    1b72:	4802      	ldr	r0, [pc, #8]	; (1b7c <_stats_stop_measure_crit_isr+0xc>)
    1b74:	f7ff ff6c 	bl	1a50 <chTMStopMeasurementX>
}
    1b78:	bd08      	pop	{r3, pc}
    1b7a:	bf00      	nop
    1b7c:	20000f88 	.word	0x20000f88

00001b80 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1b80:	b082      	sub	sp, #8
    1b82:	2320      	movs	r3, #32
    1b84:	9301      	str	r3, [sp, #4]
    1b86:	9b01      	ldr	r3, [sp, #4]
    1b88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1b8c:	b002      	add	sp, #8
    1b8e:	4770      	bx	lr

00001b90 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1b90:	b082      	sub	sp, #8
    1b92:	2300      	movs	r3, #0
    1b94:	9301      	str	r3, [sp, #4]
    1b96:	9b01      	ldr	r3, [sp, #4]
    1b98:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1b9c:	b002      	add	sp, #8
    1b9e:	4770      	bx	lr

00001ba0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1ba0:	b508      	push	{r3, lr}

  port_lock();
    1ba2:	f7ff ffed 	bl	1b80 <port_lock>
  _stats_start_measure_crit_thd();
    1ba6:	f7ff ffcb 	bl	1b40 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1baa:	f7fe fed1 	bl	950 <_dbg_check_lock>
}
    1bae:	bd08      	pop	{r3, pc}

00001bb0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    1bb0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    1bb2:	f7fe fee5 	bl	980 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    1bb6:	f7ff ffcb 	bl	1b50 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    1bba:	4b09      	ldr	r3, [pc, #36]	; (1be0 <chSysUnlock+0x30>)
    1bbc:	681a      	ldr	r2, [r3, #0]
    1bbe:	4b08      	ldr	r3, [pc, #32]	; (1be0 <chSysUnlock+0x30>)
    1bc0:	429a      	cmp	r2, r3
    1bc2:	d00a      	beq.n	1bda <chSysUnlock+0x2a>
    1bc4:	4b06      	ldr	r3, [pc, #24]	; (1be0 <chSysUnlock+0x30>)
    1bc6:	699b      	ldr	r3, [r3, #24]
    1bc8:	689a      	ldr	r2, [r3, #8]
    1bca:	4b05      	ldr	r3, [pc, #20]	; (1be0 <chSysUnlock+0x30>)
    1bcc:	681b      	ldr	r3, [r3, #0]
    1bce:	689b      	ldr	r3, [r3, #8]
    1bd0:	429a      	cmp	r2, r3
    1bd2:	d202      	bcs.n	1bda <chSysUnlock+0x2a>
    1bd4:	4803      	ldr	r0, [pc, #12]	; (1be4 <chSysUnlock+0x34>)
    1bd6:	f7fe fe53 	bl	880 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    1bda:	f7ff ffd9 	bl	1b90 <port_unlock>
}
    1bde:	bd08      	pop	{r3, pc}
    1be0:	20000ac0 	.word	0x20000ac0
    1be4:	00004800 	.word	0x00004800
    1be8:	f3af 8000 	nop.w
    1bec:	f3af 8000 	nop.w

00001bf0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
    1bf0:	b500      	push	{lr}
    1bf2:	b085      	sub	sp, #20
    1bf4:	9001      	str	r0, [sp, #4]
  trefs_t refs;

  chSysLock();
    1bf6:	f7ff ffd3 	bl	1ba0 <chSysLock>
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
    1bfa:	9b01      	ldr	r3, [sp, #4]
    1bfc:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    1c00:	2b00      	cmp	r3, #0
    1c02:	d102      	bne.n	1c0a <chThdRelease+0x1a>
    1c04:	4823      	ldr	r0, [pc, #140]	; (1c94 <chThdRelease+0xa4>)
    1c06:	f7fe fe3b 	bl	880 <chSysHalt>
  tp->p_refs--;
    1c0a:	9b01      	ldr	r3, [sp, #4]
    1c0c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    1c10:	3b01      	subs	r3, #1
    1c12:	b2da      	uxtb	r2, r3
    1c14:	9b01      	ldr	r3, [sp, #4]
    1c16:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  refs = tp->p_refs;
    1c1a:	9b01      	ldr	r3, [sp, #4]
    1c1c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    1c20:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
    1c24:	f7ff ffc4 	bl	1bb0 <chSysUnlock>

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    1c28:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1c2c:	2b00      	cmp	r3, #0
    1c2e:	d12d      	bne.n	1c8c <chThdRelease+0x9c>
    1c30:	9b01      	ldr	r3, [sp, #4]
    1c32:	f893 3020 	ldrb.w	r3, [r3, #32]
    1c36:	2b0f      	cmp	r3, #15
    1c38:	d128      	bne.n	1c8c <chThdRelease+0x9c>
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
    1c3a:	9b01      	ldr	r3, [sp, #4]
    1c3c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    1c40:	f003 0303 	and.w	r3, r3, #3
    1c44:	2b01      	cmp	r3, #1
    1c46:	d002      	beq.n	1c4e <chThdRelease+0x5e>
    1c48:	2b02      	cmp	r3, #2
    1c4a:	d00e      	beq.n	1c6a <chThdRelease+0x7a>
      break;
#endif
    default:
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    1c4c:	e01e      	b.n	1c8c <chThdRelease+0x9c>
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
    1c4e:	9b01      	ldr	r3, [sp, #4]
    1c50:	695b      	ldr	r3, [r3, #20]
    1c52:	9a01      	ldr	r2, [sp, #4]
    1c54:	6912      	ldr	r2, [r2, #16]
    1c56:	611a      	str	r2, [r3, #16]
    1c58:	9b01      	ldr	r3, [sp, #4]
    1c5a:	691b      	ldr	r3, [r3, #16]
    1c5c:	9a01      	ldr	r2, [sp, #4]
    1c5e:	6952      	ldr	r2, [r2, #20]
    1c60:	615a      	str	r2, [r3, #20]
#endif
      chHeapFree(tp);
    1c62:	9801      	ldr	r0, [sp, #4]
    1c64:	f001 f804 	bl	2c70 <chHeapFree>
      break;
    1c68:	e010      	b.n	1c8c <chThdRelease+0x9c>
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
    1c6a:	9b01      	ldr	r3, [sp, #4]
    1c6c:	695b      	ldr	r3, [r3, #20]
    1c6e:	9a01      	ldr	r2, [sp, #4]
    1c70:	6912      	ldr	r2, [r2, #16]
    1c72:	611a      	str	r2, [r3, #16]
    1c74:	9b01      	ldr	r3, [sp, #4]
    1c76:	691b      	ldr	r3, [r3, #16]
    1c78:	9a01      	ldr	r2, [sp, #4]
    1c7a:	6952      	ldr	r2, [r2, #20]
    1c7c:	615a      	str	r2, [r3, #20]
#endif
      chPoolFree(tp->p_mpool, tp);
    1c7e:	9b01      	ldr	r3, [sp, #4]
    1c80:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    1c82:	4618      	mov	r0, r3
    1c84:	9901      	ldr	r1, [sp, #4]
    1c86:	f001 f8cb 	bl	2e20 <chPoolFree>
      break;
    1c8a:	bf00      	nop
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
}
    1c8c:	b005      	add	sp, #20
    1c8e:	f85d fb04 	ldr.w	pc, [sp], #4
    1c92:	bf00      	nop
    1c94:	00004810 	.word	0x00004810
    1c98:	f3af 8000 	nop.w
    1c9c:	f3af 8000 	nop.w

00001ca0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1ca0:	b082      	sub	sp, #8
    1ca2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1ca4:	9b01      	ldr	r3, [sp, #4]
    1ca6:	9a01      	ldr	r2, [sp, #4]
    1ca8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    1caa:	9b01      	ldr	r3, [sp, #4]
    1cac:	9a01      	ldr	r2, [sp, #4]
    1cae:	605a      	str	r2, [r3, #4]
}
    1cb0:	b002      	add	sp, #8
    1cb2:	4770      	bx	lr
    1cb4:	f3af 8000 	nop.w
    1cb8:	f3af 8000 	nop.w
    1cbc:	f3af 8000 	nop.w

00001cc0 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
    1cc0:	b082      	sub	sp, #8
    1cc2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
    1cc4:	9b01      	ldr	r3, [sp, #4]
    1cc6:	681a      	ldr	r2, [r3, #0]
    1cc8:	9b01      	ldr	r3, [sp, #4]
    1cca:	429a      	cmp	r2, r3
    1ccc:	bf14      	ite	ne
    1cce:	2300      	movne	r3, #0
    1cd0:	2301      	moveq	r3, #1
    1cd2:	b2db      	uxtb	r3, r3
}
    1cd4:	4618      	mov	r0, r3
    1cd6:	b002      	add	sp, #8
    1cd8:	4770      	bx	lr
    1cda:	bf00      	nop
    1cdc:	f3af 8000 	nop.w

00001ce0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
    1ce0:	b082      	sub	sp, #8
    1ce2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
    1ce4:	9b01      	ldr	r3, [sp, #4]
    1ce6:	681a      	ldr	r2, [r3, #0]
    1ce8:	9b01      	ldr	r3, [sp, #4]
    1cea:	429a      	cmp	r2, r3
    1cec:	bf0c      	ite	eq
    1cee:	2300      	moveq	r3, #0
    1cf0:	2301      	movne	r3, #1
    1cf2:	b2db      	uxtb	r3, r3
}
    1cf4:	4618      	mov	r0, r3
    1cf6:	b002      	add	sp, #8
    1cf8:	4770      	bx	lr
    1cfa:	bf00      	nop
    1cfc:	f3af 8000 	nop.w

00001d00 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
    1d00:	b082      	sub	sp, #8
    1d02:	9001      	str	r0, [sp, #4]
    1d04:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
    1d06:	9b01      	ldr	r3, [sp, #4]
    1d08:	9a00      	ldr	r2, [sp, #0]
    1d0a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
    1d0c:	9b00      	ldr	r3, [sp, #0]
    1d0e:	685a      	ldr	r2, [r3, #4]
    1d10:	9b01      	ldr	r3, [sp, #4]
    1d12:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    1d14:	9b01      	ldr	r3, [sp, #4]
    1d16:	685b      	ldr	r3, [r3, #4]
    1d18:	9a01      	ldr	r2, [sp, #4]
    1d1a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
    1d1c:	9b00      	ldr	r3, [sp, #0]
    1d1e:	9a01      	ldr	r2, [sp, #4]
    1d20:	605a      	str	r2, [r3, #4]
}
    1d22:	b002      	add	sp, #8
    1d24:	4770      	bx	lr
    1d26:	bf00      	nop
    1d28:	f3af 8000 	nop.w
    1d2c:	f3af 8000 	nop.w

00001d30 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
    1d30:	b084      	sub	sp, #16
    1d32:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
    1d34:	9b01      	ldr	r3, [sp, #4]
    1d36:	681b      	ldr	r3, [r3, #0]
    1d38:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
    1d3a:	9b03      	ldr	r3, [sp, #12]
    1d3c:	681a      	ldr	r2, [r3, #0]
    1d3e:	9b01      	ldr	r3, [sp, #4]
    1d40:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1d42:	9b01      	ldr	r3, [sp, #4]
    1d44:	681b      	ldr	r3, [r3, #0]
    1d46:	9a01      	ldr	r2, [sp, #4]
    1d48:	605a      	str	r2, [r3, #4]

  return tp;
    1d4a:	9b03      	ldr	r3, [sp, #12]
}
    1d4c:	4618      	mov	r0, r3
    1d4e:	b004      	add	sp, #16
    1d50:	4770      	bx	lr
    1d52:	bf00      	nop
    1d54:	f3af 8000 	nop.w
    1d58:	f3af 8000 	nop.w
    1d5c:	f3af 8000 	nop.w

00001d60 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
    1d60:	b500      	push	{lr}
    1d62:	b083      	sub	sp, #12
    1d64:	9001      	str	r0, [sp, #4]
    1d66:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
    1d68:	9b01      	ldr	r3, [sp, #4]
    1d6a:	2b00      	cmp	r3, #0
    1d6c:	d002      	beq.n	1d74 <chSemObjectInit+0x14>
    1d6e:	9b00      	ldr	r3, [sp, #0]
    1d70:	2b00      	cmp	r3, #0
    1d72:	da02      	bge.n	1d7a <chSemObjectInit+0x1a>
    1d74:	4806      	ldr	r0, [pc, #24]	; (1d90 <chSemObjectInit+0x30>)
    1d76:	f7fe fd83 	bl	880 <chSysHalt>

  queue_init(&sp->s_queue);
    1d7a:	9b01      	ldr	r3, [sp, #4]
    1d7c:	4618      	mov	r0, r3
    1d7e:	f7ff ff8f 	bl	1ca0 <queue_init>
  sp->s_cnt = n;
    1d82:	9b01      	ldr	r3, [sp, #4]
    1d84:	9a00      	ldr	r2, [sp, #0]
    1d86:	609a      	str	r2, [r3, #8]
}
    1d88:	b003      	add	sp, #12
    1d8a:	f85d fb04 	ldr.w	pc, [sp], #4
    1d8e:	bf00      	nop
    1d90:	00004840 	.word	0x00004840
    1d94:	f3af 8000 	nop.w
    1d98:	f3af 8000 	nop.w
    1d9c:	f3af 8000 	nop.w

00001da0 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
    1da0:	b500      	push	{lr}
    1da2:	b083      	sub	sp, #12
    1da4:	9001      	str	r0, [sp, #4]
    1da6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
    1da8:	f7fe fe8a 	bl	ac0 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
    1dac:	9b01      	ldr	r3, [sp, #4]
    1dae:	2b00      	cmp	r3, #0
    1db0:	d102      	bne.n	1db8 <chSemWaitTimeoutS+0x18>
    1db2:	4826      	ldr	r0, [pc, #152]	; (1e4c <chSemWaitTimeoutS+0xac>)
    1db4:	f7fe fd64 	bl	880 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
    1db8:	9b01      	ldr	r3, [sp, #4]
    1dba:	689b      	ldr	r3, [r3, #8]
    1dbc:	2b00      	cmp	r3, #0
    1dbe:	db09      	blt.n	1dd4 <chSemWaitTimeoutS+0x34>
    1dc0:	9b01      	ldr	r3, [sp, #4]
    1dc2:	4618      	mov	r0, r3
    1dc4:	f7ff ff7c 	bl	1cc0 <queue_isempty>
    1dc8:	4603      	mov	r3, r0
    1dca:	f083 0301 	eor.w	r3, r3, #1
    1dce:	b2db      	uxtb	r3, r3
    1dd0:	2b00      	cmp	r3, #0
    1dd2:	d010      	beq.n	1df6 <chSemWaitTimeoutS+0x56>
    1dd4:	9b01      	ldr	r3, [sp, #4]
    1dd6:	689b      	ldr	r3, [r3, #8]
    1dd8:	2b00      	cmp	r3, #0
    1dda:	da09      	bge.n	1df0 <chSemWaitTimeoutS+0x50>
    1ddc:	9b01      	ldr	r3, [sp, #4]
    1dde:	4618      	mov	r0, r3
    1de0:	f7ff ff7e 	bl	1ce0 <queue_notempty>
    1de4:	4603      	mov	r3, r0
    1de6:	f083 0301 	eor.w	r3, r3, #1
    1dea:	b2db      	uxtb	r3, r3
    1dec:	2b00      	cmp	r3, #0
    1dee:	d002      	beq.n	1df6 <chSemWaitTimeoutS+0x56>
    1df0:	4816      	ldr	r0, [pc, #88]	; (1e4c <chSemWaitTimeoutS+0xac>)
    1df2:	f7fe fd45 	bl	880 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    1df6:	9b01      	ldr	r3, [sp, #4]
    1df8:	689b      	ldr	r3, [r3, #8]
    1dfa:	1e5a      	subs	r2, r3, #1
    1dfc:	9b01      	ldr	r3, [sp, #4]
    1dfe:	609a      	str	r2, [r3, #8]
    1e00:	9b01      	ldr	r3, [sp, #4]
    1e02:	689b      	ldr	r3, [r3, #8]
    1e04:	2b00      	cmp	r3, #0
    1e06:	da1b      	bge.n	1e40 <chSemWaitTimeoutS+0xa0>
    if (TIME_IMMEDIATE == time) {
    1e08:	9b00      	ldr	r3, [sp, #0]
    1e0a:	2b00      	cmp	r3, #0
    1e0c:	d107      	bne.n	1e1e <chSemWaitTimeoutS+0x7e>
      sp->s_cnt++;
    1e0e:	9b01      	ldr	r3, [sp, #4]
    1e10:	689b      	ldr	r3, [r3, #8]
    1e12:	1c5a      	adds	r2, r3, #1
    1e14:	9b01      	ldr	r3, [sp, #4]
    1e16:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
    1e18:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1e1c:	e011      	b.n	1e42 <chSemWaitTimeoutS+0xa2>
    }
    currp->p_u.wtsemp = sp;
    1e1e:	4b0c      	ldr	r3, [pc, #48]	; (1e50 <chSemWaitTimeoutS+0xb0>)
    1e20:	699b      	ldr	r3, [r3, #24]
    1e22:	9a01      	ldr	r2, [sp, #4]
    1e24:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->s_queue);
    1e26:	4b0a      	ldr	r3, [pc, #40]	; (1e50 <chSemWaitTimeoutS+0xb0>)
    1e28:	699a      	ldr	r2, [r3, #24]
    1e2a:	9b01      	ldr	r3, [sp, #4]
    1e2c:	4610      	mov	r0, r2
    1e2e:	4619      	mov	r1, r3
    1e30:	f7ff ff66 	bl	1d00 <queue_insert>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
    1e34:	2005      	movs	r0, #5
    1e36:	9900      	ldr	r1, [sp, #0]
    1e38:	f7ff f972 	bl	1120 <chSchGoSleepTimeoutS>
    1e3c:	4603      	mov	r3, r0
    1e3e:	e000      	b.n	1e42 <chSemWaitTimeoutS+0xa2>
  }

  return MSG_OK;
    1e40:	2300      	movs	r3, #0
}
    1e42:	4618      	mov	r0, r3
    1e44:	b003      	add	sp, #12
    1e46:	f85d fb04 	ldr.w	pc, [sp], #4
    1e4a:	bf00      	nop
    1e4c:	00004850 	.word	0x00004850
    1e50:	20000ac0 	.word	0x20000ac0
    1e54:	f3af 8000 	nop.w
    1e58:	f3af 8000 	nop.w
    1e5c:	f3af 8000 	nop.w

00001e60 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    1e60:	b500      	push	{lr}
    1e62:	b085      	sub	sp, #20
    1e64:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    1e66:	f7fe fe13 	bl	a90 <chDbgCheckClassI>
  chDbgCheck(sp != NULL);
    1e6a:	9b01      	ldr	r3, [sp, #4]
    1e6c:	2b00      	cmp	r3, #0
    1e6e:	d102      	bne.n	1e76 <chSemSignalI+0x16>
    1e70:	481c      	ldr	r0, [pc, #112]	; (1ee4 <chSemSignalI+0x84>)
    1e72:	f7fe fd05 	bl	880 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
    1e76:	9b01      	ldr	r3, [sp, #4]
    1e78:	689b      	ldr	r3, [r3, #8]
    1e7a:	2b00      	cmp	r3, #0
    1e7c:	db09      	blt.n	1e92 <chSemSignalI+0x32>
    1e7e:	9b01      	ldr	r3, [sp, #4]
    1e80:	4618      	mov	r0, r3
    1e82:	f7ff ff1d 	bl	1cc0 <queue_isempty>
    1e86:	4603      	mov	r3, r0
    1e88:	f083 0301 	eor.w	r3, r3, #1
    1e8c:	b2db      	uxtb	r3, r3
    1e8e:	2b00      	cmp	r3, #0
    1e90:	d010      	beq.n	1eb4 <chSemSignalI+0x54>
    1e92:	9b01      	ldr	r3, [sp, #4]
    1e94:	689b      	ldr	r3, [r3, #8]
    1e96:	2b00      	cmp	r3, #0
    1e98:	da09      	bge.n	1eae <chSemSignalI+0x4e>
    1e9a:	9b01      	ldr	r3, [sp, #4]
    1e9c:	4618      	mov	r0, r3
    1e9e:	f7ff ff1f 	bl	1ce0 <queue_notempty>
    1ea2:	4603      	mov	r3, r0
    1ea4:	f083 0301 	eor.w	r3, r3, #1
    1ea8:	b2db      	uxtb	r3, r3
    1eaa:	2b00      	cmp	r3, #0
    1eac:	d002      	beq.n	1eb4 <chSemSignalI+0x54>
    1eae:	480d      	ldr	r0, [pc, #52]	; (1ee4 <chSemSignalI+0x84>)
    1eb0:	f7fe fce6 	bl	880 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
    1eb4:	9b01      	ldr	r3, [sp, #4]
    1eb6:	689b      	ldr	r3, [r3, #8]
    1eb8:	1c5a      	adds	r2, r3, #1
    1eba:	9b01      	ldr	r3, [sp, #4]
    1ebc:	609a      	str	r2, [r3, #8]
    1ebe:	9b01      	ldr	r3, [sp, #4]
    1ec0:	689b      	ldr	r3, [r3, #8]
    1ec2:	2b00      	cmp	r3, #0
    1ec4:	dc0a      	bgt.n	1edc <chSemSignalI+0x7c>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    1ec6:	9b01      	ldr	r3, [sp, #4]
    1ec8:	4618      	mov	r0, r3
    1eca:	f7ff ff31 	bl	1d30 <queue_fifo_remove>
    1ece:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
    1ed0:	9b03      	ldr	r3, [sp, #12]
    1ed2:	2200      	movs	r2, #0
    1ed4:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    1ed6:	9803      	ldr	r0, [sp, #12]
    1ed8:	f7ff f862 	bl	fa0 <chSchReadyI>
  }
}
    1edc:	b005      	add	sp, #20
    1ede:	f85d fb04 	ldr.w	pc, [sp], #4
    1ee2:	bf00      	nop
    1ee4:	00004870 	.word	0x00004870
    1ee8:	f3af 8000 	nop.w
    1eec:	f3af 8000 	nop.w

00001ef0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    1ef0:	b082      	sub	sp, #8
    1ef2:	2320      	movs	r3, #32
    1ef4:	9301      	str	r3, [sp, #4]
    1ef6:	9b01      	ldr	r3, [sp, #4]
    1ef8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1efc:	b002      	add	sp, #8
    1efe:	4770      	bx	lr

00001f00 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    1f00:	b082      	sub	sp, #8
    1f02:	2300      	movs	r3, #0
    1f04:	9301      	str	r3, [sp, #4]
    1f06:	9b01      	ldr	r3, [sp, #4]
    1f08:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    1f0c:	b002      	add	sp, #8
    1f0e:	4770      	bx	lr

00001f10 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    1f10:	b082      	sub	sp, #8
    1f12:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    1f14:	9b01      	ldr	r3, [sp, #4]
    1f16:	9a01      	ldr	r2, [sp, #4]
    1f18:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    1f1a:	9b01      	ldr	r3, [sp, #4]
    1f1c:	9a01      	ldr	r2, [sp, #4]
    1f1e:	605a      	str	r2, [r3, #4]
}
    1f20:	b002      	add	sp, #8
    1f22:	4770      	bx	lr
    1f24:	f3af 8000 	nop.w
    1f28:	f3af 8000 	nop.w
    1f2c:	f3af 8000 	nop.w

00001f30 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
    1f30:	b082      	sub	sp, #8
    1f32:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
    1f34:	9b01      	ldr	r3, [sp, #4]
    1f36:	681a      	ldr	r2, [r3, #0]
    1f38:	9b01      	ldr	r3, [sp, #4]
    1f3a:	429a      	cmp	r2, r3
    1f3c:	bf0c      	ite	eq
    1f3e:	2300      	moveq	r3, #0
    1f40:	2301      	movne	r3, #1
    1f42:	b2db      	uxtb	r3, r3
}
    1f44:	4618      	mov	r0, r3
    1f46:	b002      	add	sp, #8
    1f48:	4770      	bx	lr
    1f4a:	bf00      	nop
    1f4c:	f3af 8000 	nop.w

00001f50 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
    1f50:	b084      	sub	sp, #16
    1f52:	9001      	str	r0, [sp, #4]
    1f54:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
    1f56:	9b00      	ldr	r3, [sp, #0]
    1f58:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
    1f5a:	9b03      	ldr	r3, [sp, #12]
    1f5c:	681b      	ldr	r3, [r3, #0]
    1f5e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    1f60:	9a03      	ldr	r2, [sp, #12]
    1f62:	9b00      	ldr	r3, [sp, #0]
    1f64:	429a      	cmp	r2, r3
    1f66:	d005      	beq.n	1f74 <queue_prio_insert+0x24>
    1f68:	9b03      	ldr	r3, [sp, #12]
    1f6a:	689a      	ldr	r2, [r3, #8]
    1f6c:	9b01      	ldr	r3, [sp, #4]
    1f6e:	689b      	ldr	r3, [r3, #8]
    1f70:	429a      	cmp	r2, r3
    1f72:	d2f2      	bcs.n	1f5a <queue_prio_insert+0xa>
  tp->p_next = cp;
    1f74:	9b01      	ldr	r3, [sp, #4]
    1f76:	9a03      	ldr	r2, [sp, #12]
    1f78:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
    1f7a:	9b03      	ldr	r3, [sp, #12]
    1f7c:	685a      	ldr	r2, [r3, #4]
    1f7e:	9b01      	ldr	r3, [sp, #4]
    1f80:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    1f82:	9b01      	ldr	r3, [sp, #4]
    1f84:	685b      	ldr	r3, [r3, #4]
    1f86:	9a01      	ldr	r2, [sp, #4]
    1f88:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
    1f8a:	9b03      	ldr	r3, [sp, #12]
    1f8c:	9a01      	ldr	r2, [sp, #4]
    1f8e:	605a      	str	r2, [r3, #4]
}
    1f90:	b004      	add	sp, #16
    1f92:	4770      	bx	lr
    1f94:	f3af 8000 	nop.w
    1f98:	f3af 8000 	nop.w
    1f9c:	f3af 8000 	nop.w

00001fa0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
    1fa0:	b084      	sub	sp, #16
    1fa2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
    1fa4:	9b01      	ldr	r3, [sp, #4]
    1fa6:	681b      	ldr	r3, [r3, #0]
    1fa8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
    1faa:	9b03      	ldr	r3, [sp, #12]
    1fac:	681a      	ldr	r2, [r3, #0]
    1fae:	9b01      	ldr	r3, [sp, #4]
    1fb0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1fb2:	9b01      	ldr	r3, [sp, #4]
    1fb4:	681b      	ldr	r3, [r3, #0]
    1fb6:	9a01      	ldr	r2, [sp, #4]
    1fb8:	605a      	str	r2, [r3, #4]

  return tp;
    1fba:	9b03      	ldr	r3, [sp, #12]
}
    1fbc:	4618      	mov	r0, r3
    1fbe:	b004      	add	sp, #16
    1fc0:	4770      	bx	lr
    1fc2:	bf00      	nop
    1fc4:	f3af 8000 	nop.w
    1fc8:	f3af 8000 	nop.w
    1fcc:	f3af 8000 	nop.w

00001fd0 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
    1fd0:	b082      	sub	sp, #8
    1fd2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
    1fd4:	9b01      	ldr	r3, [sp, #4]
    1fd6:	685b      	ldr	r3, [r3, #4]
    1fd8:	9a01      	ldr	r2, [sp, #4]
    1fda:	6812      	ldr	r2, [r2, #0]
    1fdc:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
    1fde:	9b01      	ldr	r3, [sp, #4]
    1fe0:	681b      	ldr	r3, [r3, #0]
    1fe2:	9a01      	ldr	r2, [sp, #4]
    1fe4:	6852      	ldr	r2, [r2, #4]
    1fe6:	605a      	str	r2, [r3, #4]

  return tp;
    1fe8:	9b01      	ldr	r3, [sp, #4]
}
    1fea:	4618      	mov	r0, r3
    1fec:	b002      	add	sp, #8
    1fee:	4770      	bx	lr

00001ff0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    1ff0:	b508      	push	{r3, lr}

  port_lock();
    1ff2:	f7ff ff7d 	bl	1ef0 <port_lock>
  _stats_start_measure_crit_thd();
    1ff6:	f7ff fda3 	bl	1b40 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    1ffa:	f7fe fca9 	bl	950 <_dbg_check_lock>
}
    1ffe:	bd08      	pop	{r3, pc}

00002000 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2000:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2002:	f7fe fcbd 	bl	980 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2006:	f7ff fda3 	bl	1b50 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    200a:	4b09      	ldr	r3, [pc, #36]	; (2030 <chSysUnlock+0x30>)
    200c:	681a      	ldr	r2, [r3, #0]
    200e:	4b08      	ldr	r3, [pc, #32]	; (2030 <chSysUnlock+0x30>)
    2010:	429a      	cmp	r2, r3
    2012:	d00a      	beq.n	202a <chSysUnlock+0x2a>
    2014:	4b06      	ldr	r3, [pc, #24]	; (2030 <chSysUnlock+0x30>)
    2016:	699b      	ldr	r3, [r3, #24]
    2018:	689a      	ldr	r2, [r3, #8]
    201a:	4b05      	ldr	r3, [pc, #20]	; (2030 <chSysUnlock+0x30>)
    201c:	681b      	ldr	r3, [r3, #0]
    201e:	689b      	ldr	r3, [r3, #8]
    2020:	429a      	cmp	r2, r3
    2022:	d202      	bcs.n	202a <chSysUnlock+0x2a>
    2024:	4803      	ldr	r0, [pc, #12]	; (2034 <chSysUnlock+0x34>)
    2026:	f7fe fc2b 	bl	880 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    202a:	f7ff ff69 	bl	1f00 <port_unlock>
}
    202e:	bd08      	pop	{r3, pc}
    2030:	20000ac0 	.word	0x20000ac0
    2034:	00004890 	.word	0x00004890
    2038:	f3af 8000 	nop.w
    203c:	f3af 8000 	nop.w

00002040 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
    2040:	b500      	push	{lr}
    2042:	b083      	sub	sp, #12
    2044:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
    2046:	f7fe fd3b 	bl	ac0 <chDbgCheckClassS>

  return queue_notempty(&mp->m_queue);
    204a:	9b01      	ldr	r3, [sp, #4]
    204c:	4618      	mov	r0, r3
    204e:	f7ff ff6f 	bl	1f30 <queue_notempty>
    2052:	4603      	mov	r3, r0
}
    2054:	4618      	mov	r0, r3
    2056:	b003      	add	sp, #12
    2058:	f85d fb04 	ldr.w	pc, [sp], #4
    205c:	f3af 8000 	nop.w

00002060 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
    2060:	b500      	push	{lr}
    2062:	b083      	sub	sp, #12
    2064:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
    2066:	9b01      	ldr	r3, [sp, #4]
    2068:	2b00      	cmp	r3, #0
    206a:	d102      	bne.n	2072 <chMtxObjectInit+0x12>
    206c:	4806      	ldr	r0, [pc, #24]	; (2088 <chMtxObjectInit+0x28>)
    206e:	f7fe fc07 	bl	880 <chSysHalt>

  queue_init(&mp->m_queue);
    2072:	9b01      	ldr	r3, [sp, #4]
    2074:	4618      	mov	r0, r3
    2076:	f7ff ff4b 	bl	1f10 <queue_init>
  mp->m_owner = NULL;
    207a:	9b01      	ldr	r3, [sp, #4]
    207c:	2200      	movs	r2, #0
    207e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
    2080:	b003      	add	sp, #12
    2082:	f85d fb04 	ldr.w	pc, [sp], #4
    2086:	bf00      	nop
    2088:	00004880 	.word	0x00004880
    208c:	f3af 8000 	nop.w

00002090 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
    2090:	b500      	push	{lr}
    2092:	b083      	sub	sp, #12
    2094:	9001      	str	r0, [sp, #4]

  chSysLock();
    2096:	f7ff ffab 	bl	1ff0 <chSysLock>
  chMtxLockS(mp);
    209a:	9801      	ldr	r0, [sp, #4]
    209c:	f000 f808 	bl	20b0 <chMtxLockS>
  chSysUnlock();
    20a0:	f7ff ffae 	bl	2000 <chSysUnlock>
}
    20a4:	b003      	add	sp, #12
    20a6:	f85d fb04 	ldr.w	pc, [sp], #4
    20aa:	bf00      	nop
    20ac:	f3af 8000 	nop.w

000020b0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
    20b0:	b500      	push	{lr}
    20b2:	b085      	sub	sp, #20
    20b4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
    20b6:	4b3c      	ldr	r3, [pc, #240]	; (21a8 <chMtxLockS+0xf8>)
    20b8:	699b      	ldr	r3, [r3, #24]
    20ba:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
    20bc:	f7fe fd00 	bl	ac0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
    20c0:	9b01      	ldr	r3, [sp, #4]
    20c2:	2b00      	cmp	r3, #0
    20c4:	d102      	bne.n	20cc <chMtxLockS+0x1c>
    20c6:	4839      	ldr	r0, [pc, #228]	; (21ac <chMtxLockS+0xfc>)
    20c8:	f7fe fbda 	bl	880 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
    20cc:	9b01      	ldr	r3, [sp, #4]
    20ce:	689b      	ldr	r3, [r3, #8]
    20d0:	2b00      	cmp	r3, #0
    20d2:	d05b      	beq.n	218c <chMtxLockS+0xdc>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;
    20d4:	9b01      	ldr	r3, [sp, #4]
    20d6:	689b      	ldr	r3, [r3, #8]
    20d8:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
    20da:	e034      	b.n	2146 <chMtxLockS+0x96>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
    20dc:	9b02      	ldr	r3, [sp, #8]
    20de:	689a      	ldr	r2, [r3, #8]
    20e0:	9b03      	ldr	r3, [sp, #12]
    20e2:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
    20e4:	9b03      	ldr	r3, [sp, #12]
    20e6:	f893 3020 	ldrb.w	r3, [r3, #32]
    20ea:	2b06      	cmp	r3, #6
    20ec:	d004      	beq.n	20f8 <chMtxLockS+0x48>
    20ee:	2b07      	cmp	r3, #7
    20f0:	d011      	beq.n	2116 <chMtxLockS+0x66>
    20f2:	2b00      	cmp	r3, #0
    20f4:	d01a      	beq.n	212c <chMtxLockS+0x7c>
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
          break;
        default:
          /* Nothing to do for other states.*/
          break;
    20f6:	e025      	b.n	2144 <chMtxLockS+0x94>

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
    20f8:	9803      	ldr	r0, [sp, #12]
    20fa:	f7ff ff69 	bl	1fd0 <queue_dequeue>
    20fe:	4602      	mov	r2, r0
    2100:	9b03      	ldr	r3, [sp, #12]
    2102:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2104:	4610      	mov	r0, r2
    2106:	4619      	mov	r1, r3
    2108:	f7ff ff22 	bl	1f50 <queue_prio_insert>
          tp = tp->p_u.wtmtxp->m_owner;
    210c:	9b03      	ldr	r3, [sp, #12]
    210e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2110:	689b      	ldr	r3, [r3, #8]
    2112:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
    2114:	e017      	b.n	2146 <chMtxLockS+0x96>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
    2116:	9803      	ldr	r0, [sp, #12]
    2118:	f7ff ff5a 	bl	1fd0 <queue_dequeue>
    211c:	4602      	mov	r2, r0
    211e:	9b03      	ldr	r3, [sp, #12]
    2120:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2122:	4610      	mov	r0, r2
    2124:	4619      	mov	r1, r3
    2126:	f7ff ff13 	bl	1f50 <queue_prio_insert>
          break;
    212a:	e00b      	b.n	2144 <chMtxLockS+0x94>
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
    212c:	9b03      	ldr	r3, [sp, #12]
    212e:	2201      	movs	r2, #1
    2130:	f883 2020 	strb.w	r2, [r3, #32]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
    2134:	9803      	ldr	r0, [sp, #12]
    2136:	f7ff ff4b 	bl	1fd0 <queue_dequeue>
    213a:	4603      	mov	r3, r0
    213c:	4618      	mov	r0, r3
    213e:	f7fe ff2f 	bl	fa0 <chSchReadyI>
          break;
    2142:	bf00      	nop
        default:
          /* Nothing to do for other states.*/
          break;
        }
        break;
    2144:	e005      	b.n	2152 <chMtxLockS+0xa2>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
    2146:	9b03      	ldr	r3, [sp, #12]
    2148:	689a      	ldr	r2, [r3, #8]
    214a:	9b02      	ldr	r3, [sp, #8]
    214c:	689b      	ldr	r3, [r3, #8]
    214e:	429a      	cmp	r2, r3
    2150:	d3c4      	bcc.n	20dc <chMtxLockS+0x2c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
    2152:	9b01      	ldr	r3, [sp, #4]
    2154:	9802      	ldr	r0, [sp, #8]
    2156:	4619      	mov	r1, r3
    2158:	f7ff fefa 	bl	1f50 <queue_prio_insert>
      ctp->p_u.wtmtxp = mp;
    215c:	9b02      	ldr	r3, [sp, #8]
    215e:	9a01      	ldr	r2, [sp, #4]
    2160:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
    2162:	2006      	movs	r0, #6
    2164:	f7fe ff5c 	bl	1020 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->m_owner == ctp, "not owner");
    2168:	9b01      	ldr	r3, [sp, #4]
    216a:	689a      	ldr	r2, [r3, #8]
    216c:	9b02      	ldr	r3, [sp, #8]
    216e:	429a      	cmp	r2, r3
    2170:	d002      	beq.n	2178 <chMtxLockS+0xc8>
    2172:	480e      	ldr	r0, [pc, #56]	; (21ac <chMtxLockS+0xfc>)
    2174:	f7fe fb84 	bl	880 <chSysHalt>
      chDbgAssert(ctp->p_mtxlist == mp, "not owned");
    2178:	9b02      	ldr	r3, [sp, #8]
    217a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    217c:	9b01      	ldr	r3, [sp, #4]
    217e:	429a      	cmp	r2, r3
    2180:	d003      	beq.n	218a <chMtxLockS+0xda>
    2182:	480a      	ldr	r0, [pc, #40]	; (21ac <chMtxLockS+0xfc>)
    2184:	f7fe fb7c 	bl	880 <chSysHalt>
    2188:	e00a      	b.n	21a0 <chMtxLockS+0xf0>
    218a:	e009      	b.n	21a0 <chMtxLockS+0xf0>
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    218c:	9b01      	ldr	r3, [sp, #4]
    218e:	9a02      	ldr	r2, [sp, #8]
    2190:	609a      	str	r2, [r3, #8]
    mp->m_next = ctp->p_mtxlist;
    2192:	9b02      	ldr	r3, [sp, #8]
    2194:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    2196:	9b01      	ldr	r3, [sp, #4]
    2198:	60da      	str	r2, [r3, #12]
    ctp->p_mtxlist = mp;
    219a:	9b02      	ldr	r3, [sp, #8]
    219c:	9a01      	ldr	r2, [sp, #4]
    219e:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
    21a0:	b005      	add	sp, #20
    21a2:	f85d fb04 	ldr.w	pc, [sp], #4
    21a6:	bf00      	nop
    21a8:	20000ac0 	.word	0x20000ac0
    21ac:	000048a0 	.word	0x000048a0

000021b0 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
    21b0:	b500      	push	{lr}
    21b2:	b087      	sub	sp, #28
    21b4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
    21b6:	4b35      	ldr	r3, [pc, #212]	; (228c <chMtxUnlock+0xdc>)
    21b8:	699b      	ldr	r3, [r3, #24]
    21ba:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
    21bc:	9b01      	ldr	r3, [sp, #4]
    21be:	2b00      	cmp	r3, #0
    21c0:	d102      	bne.n	21c8 <chMtxUnlock+0x18>
    21c2:	4833      	ldr	r0, [pc, #204]	; (2290 <chMtxUnlock+0xe0>)
    21c4:	f7fe fb5c 	bl	880 <chSysHalt>

  chSysLock();
    21c8:	f7ff ff12 	bl	1ff0 <chSysLock>

  chDbgAssert(ctp->p_mtxlist != NULL, "owned mutexes list empty");
    21cc:	9b03      	ldr	r3, [sp, #12]
    21ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    21d0:	2b00      	cmp	r3, #0
    21d2:	d102      	bne.n	21da <chMtxUnlock+0x2a>
    21d4:	482e      	ldr	r0, [pc, #184]	; (2290 <chMtxUnlock+0xe0>)
    21d6:	f7fe fb53 	bl	880 <chSysHalt>
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp, "ownership failure");
    21da:	9b03      	ldr	r3, [sp, #12]
    21dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    21de:	689a      	ldr	r2, [r3, #8]
    21e0:	9b03      	ldr	r3, [sp, #12]
    21e2:	429a      	cmp	r2, r3
    21e4:	d002      	beq.n	21ec <chMtxUnlock+0x3c>
    21e6:	482a      	ldr	r0, [pc, #168]	; (2290 <chMtxUnlock+0xe0>)
    21e8:	f7fe fb4a 	bl	880 <chSysHalt>
  chDbgAssert(mp->m_cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->m_cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");
    21ec:	9b03      	ldr	r3, [sp, #12]
    21ee:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    21f0:	9b01      	ldr	r3, [sp, #4]
    21f2:	429a      	cmp	r2, r3
    21f4:	d002      	beq.n	21fc <chMtxUnlock+0x4c>
    21f6:	4826      	ldr	r0, [pc, #152]	; (2290 <chMtxUnlock+0xe0>)
    21f8:	f7fe fb42 	bl	880 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
    21fc:	9b01      	ldr	r3, [sp, #4]
    21fe:	68da      	ldr	r2, [r3, #12]
    2200:	9b03      	ldr	r3, [sp, #12]
    2202:	63da      	str	r2, [r3, #60]	; 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    2204:	9801      	ldr	r0, [sp, #4]
    2206:	f7ff ff1b 	bl	2040 <chMtxQueueNotEmptyS>
    220a:	4603      	mov	r3, r0
    220c:	2b00      	cmp	r3, #0
    220e:	d034      	beq.n	227a <chMtxUnlock+0xca>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
    2210:	9b03      	ldr	r3, [sp, #12]
    2212:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    2214:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
    2216:	9b03      	ldr	r3, [sp, #12]
    2218:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    221a:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
    221c:	e012      	b.n	2244 <chMtxUnlock+0x94>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    221e:	9805      	ldr	r0, [sp, #20]
    2220:	f7ff ff0e 	bl	2040 <chMtxQueueNotEmptyS>
    2224:	4603      	mov	r3, r0
    2226:	2b00      	cmp	r3, #0
    2228:	d009      	beq.n	223e <chMtxUnlock+0x8e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
    222a:	9b05      	ldr	r3, [sp, #20]
    222c:	681b      	ldr	r3, [r3, #0]
    222e:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    2230:	9b04      	ldr	r3, [sp, #16]
    2232:	429a      	cmp	r2, r3
    2234:	d903      	bls.n	223e <chMtxUnlock+0x8e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
    2236:	9b05      	ldr	r3, [sp, #20]
    2238:	681b      	ldr	r3, [r3, #0]
    223a:	689b      	ldr	r3, [r3, #8]
    223c:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
    223e:	9b05      	ldr	r3, [sp, #20]
    2240:	68db      	ldr	r3, [r3, #12]
    2242:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
    2244:	9b05      	ldr	r3, [sp, #20]
    2246:	2b00      	cmp	r3, #0
    2248:	d1e9      	bne.n	221e <chMtxUnlock+0x6e>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
    224a:	9b03      	ldr	r3, [sp, #12]
    224c:	9a04      	ldr	r2, [sp, #16]
    224e:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
    2250:	9b01      	ldr	r3, [sp, #4]
    2252:	4618      	mov	r0, r3
    2254:	f7ff fea4 	bl	1fa0 <queue_fifo_remove>
    2258:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
    225a:	9b01      	ldr	r3, [sp, #4]
    225c:	9a02      	ldr	r2, [sp, #8]
    225e:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
    2260:	9b02      	ldr	r3, [sp, #8]
    2262:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    2264:	9b01      	ldr	r3, [sp, #4]
    2266:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
    2268:	9b02      	ldr	r3, [sp, #8]
    226a:	9a01      	ldr	r2, [sp, #4]
    226c:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
    226e:	9802      	ldr	r0, [sp, #8]
    2270:	f7fe fe96 	bl	fa0 <chSchReadyI>
      chSchRescheduleS();
    2274:	f7fe ffd4 	bl	1220 <chSchRescheduleS>
    2278:	e002      	b.n	2280 <chMtxUnlock+0xd0>
    }
    else {
      mp->m_owner = NULL;
    227a:	9b01      	ldr	r3, [sp, #4]
    227c:	2200      	movs	r2, #0
    227e:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
    2280:	f7ff febe 	bl	2000 <chSysUnlock>
}
    2284:	b007      	add	sp, #28
    2286:	f85d fb04 	ldr.w	pc, [sp], #4
    228a:	bf00      	nop
    228c:	20000ac0 	.word	0x20000ac0
    2290:	000048b0 	.word	0x000048b0
    2294:	f3af 8000 	nop.w
    2298:	f3af 8000 	nop.w
    229c:	f3af 8000 	nop.w

000022a0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    22a0:	b500      	push	{lr}
    22a2:	b085      	sub	sp, #20
    22a4:	9001      	str	r0, [sp, #4]
    22a6:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
    22a8:	f7fe fbf2 	bl	a90 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
    22ac:	9b01      	ldr	r3, [sp, #4]
    22ae:	2b00      	cmp	r3, #0
    22b0:	d102      	bne.n	22b8 <chEvtBroadcastFlagsI+0x18>
    22b2:	4814      	ldr	r0, [pc, #80]	; (2304 <chEvtBroadcastFlagsI+0x64>)
    22b4:	f7fe fae4 	bl	880 <chSysHalt>

  elp = esp->es_next;
    22b8:	9b01      	ldr	r3, [sp, #4]
    22ba:	681b      	ldr	r3, [r3, #0]
    22bc:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    22be:	e01a      	b.n	22f6 <chEvtBroadcastFlagsI+0x56>
  /*lint -restore*/
    elp->el_flags |= flags;
    22c0:	9b03      	ldr	r3, [sp, #12]
    22c2:	68da      	ldr	r2, [r3, #12]
    22c4:	9b00      	ldr	r3, [sp, #0]
    22c6:	431a      	orrs	r2, r3
    22c8:	9b03      	ldr	r3, [sp, #12]
    22ca:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    22cc:	9b00      	ldr	r3, [sp, #0]
    22ce:	2b00      	cmp	r3, #0
    22d0:	d006      	beq.n	22e0 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
    22d2:	9b03      	ldr	r3, [sp, #12]
    22d4:	68da      	ldr	r2, [r3, #12]
    22d6:	9b03      	ldr	r3, [sp, #12]
    22d8:	691b      	ldr	r3, [r3, #16]
    22da:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    22dc:	2b00      	cmp	r3, #0
    22de:	d007      	beq.n	22f0 <chEvtBroadcastFlagsI+0x50>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    22e0:	9b03      	ldr	r3, [sp, #12]
    22e2:	685a      	ldr	r2, [r3, #4]
    22e4:	9b03      	ldr	r3, [sp, #12]
    22e6:	689b      	ldr	r3, [r3, #8]
    22e8:	4610      	mov	r0, r2
    22ea:	4619      	mov	r1, r3
    22ec:	f000 f810 	bl	2310 <chEvtSignalI>
    }
    elp = elp->el_next;
    22f0:	9b03      	ldr	r3, [sp, #12]
    22f2:	681b      	ldr	r3, [r3, #0]
    22f4:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    22f6:	9a03      	ldr	r2, [sp, #12]
    22f8:	9b01      	ldr	r3, [sp, #4]
    22fa:	429a      	cmp	r2, r3
    22fc:	d1e0      	bne.n	22c0 <chEvtBroadcastFlagsI+0x20>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
    22fe:	b005      	add	sp, #20
    2300:	f85d fb04 	ldr.w	pc, [sp], #4
    2304:	000048c0 	.word	0x000048c0
    2308:	f3af 8000 	nop.w
    230c:	f3af 8000 	nop.w

00002310 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
    2310:	b500      	push	{lr}
    2312:	b083      	sub	sp, #12
    2314:	9001      	str	r0, [sp, #4]
    2316:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
    2318:	f7fe fbba 	bl	a90 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
    231c:	9b01      	ldr	r3, [sp, #4]
    231e:	2b00      	cmp	r3, #0
    2320:	d102      	bne.n	2328 <chEvtSignalI+0x18>
    2322:	4816      	ldr	r0, [pc, #88]	; (237c <chEvtSignalI+0x6c>)
    2324:	f7fe faac 	bl	880 <chSysHalt>

  tp->p_epending |= events;
    2328:	9b01      	ldr	r3, [sp, #4]
    232a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    232c:	9b00      	ldr	r3, [sp, #0]
    232e:	431a      	orrs	r2, r3
    2330:	9b01      	ldr	r3, [sp, #4]
    2332:	639a      	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    2334:	9b01      	ldr	r3, [sp, #4]
    2336:	f893 3020 	ldrb.w	r3, [r3, #32]
    233a:	2b0a      	cmp	r3, #10
    233c:	d106      	bne.n	234c <chEvtSignalI+0x3c>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    233e:	9b01      	ldr	r3, [sp, #4]
    2340:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    2342:	9b01      	ldr	r3, [sp, #4]
    2344:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2346:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    2348:	2b00      	cmp	r3, #0
    234a:	d10d      	bne.n	2368 <chEvtSignalI+0x58>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
    234c:	9b01      	ldr	r3, [sp, #4]
    234e:	f893 3020 	ldrb.w	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    2352:	2b0b      	cmp	r3, #11
    2354:	d10e      	bne.n	2374 <chEvtSignalI+0x64>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    2356:	9b01      	ldr	r3, [sp, #4]
    2358:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    235a:	9b01      	ldr	r3, [sp, #4]
    235c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    235e:	401a      	ands	r2, r3
    2360:	9b01      	ldr	r3, [sp, #4]
    2362:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
    2364:	429a      	cmp	r2, r3
    2366:	d105      	bne.n	2374 <chEvtSignalI+0x64>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
    2368:	9b01      	ldr	r3, [sp, #4]
    236a:	2200      	movs	r2, #0
    236c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    236e:	9801      	ldr	r0, [sp, #4]
    2370:	f7fe fe16 	bl	fa0 <chSchReadyI>
  }
}
    2374:	b003      	add	sp, #12
    2376:	f85d fb04 	ldr.w	pc, [sp], #4
    237a:	bf00      	nop
    237c:	000048e0 	.word	0x000048e0

00002380 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2380:	b082      	sub	sp, #8
    2382:	2320      	movs	r3, #32
    2384:	9301      	str	r3, [sp, #4]
    2386:	9b01      	ldr	r3, [sp, #4]
    2388:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    238c:	b002      	add	sp, #8
    238e:	4770      	bx	lr

00002390 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2390:	b082      	sub	sp, #8
    2392:	2300      	movs	r3, #0
    2394:	9301      	str	r3, [sp, #4]
    2396:	9b01      	ldr	r3, [sp, #4]
    2398:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    239c:	b002      	add	sp, #8
    239e:	4770      	bx	lr

000023a0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    23a0:	b508      	push	{r3, lr}

  port_lock();
    23a2:	f7ff ffed 	bl	2380 <port_lock>
  _stats_start_measure_crit_thd();
    23a6:	f7ff fbcb 	bl	1b40 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    23aa:	f7fe fad1 	bl	950 <_dbg_check_lock>
}
    23ae:	bd08      	pop	{r3, pc}

000023b0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    23b0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    23b2:	f7fe fae5 	bl	980 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    23b6:	f7ff fbcb 	bl	1b50 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    23ba:	4b09      	ldr	r3, [pc, #36]	; (23e0 <chSysUnlock+0x30>)
    23bc:	681a      	ldr	r2, [r3, #0]
    23be:	4b08      	ldr	r3, [pc, #32]	; (23e0 <chSysUnlock+0x30>)
    23c0:	429a      	cmp	r2, r3
    23c2:	d00a      	beq.n	23da <chSysUnlock+0x2a>
    23c4:	4b06      	ldr	r3, [pc, #24]	; (23e0 <chSysUnlock+0x30>)
    23c6:	699b      	ldr	r3, [r3, #24]
    23c8:	689a      	ldr	r2, [r3, #8]
    23ca:	4b05      	ldr	r3, [pc, #20]	; (23e0 <chSysUnlock+0x30>)
    23cc:	681b      	ldr	r3, [r3, #0]
    23ce:	689b      	ldr	r3, [r3, #8]
    23d0:	429a      	cmp	r2, r3
    23d2:	d202      	bcs.n	23da <chSysUnlock+0x2a>
    23d4:	4803      	ldr	r0, [pc, #12]	; (23e4 <chSysUnlock+0x34>)
    23d6:	f7fe fa53 	bl	880 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    23da:	f7ff ffd9 	bl	2390 <port_unlock>
}
    23de:	bd08      	pop	{r3, pc}
    23e0:	20000ac0 	.word	0x20000ac0
    23e4:	00004900 	.word	0x00004900
    23e8:	f3af 8000 	nop.w
    23ec:	f3af 8000 	nop.w

000023f0 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
    23f0:	b500      	push	{lr}
    23f2:	b085      	sub	sp, #20
    23f4:	9003      	str	r0, [sp, #12]
    23f6:	9102      	str	r1, [sp, #8]
    23f8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
    23fa:	9b03      	ldr	r3, [sp, #12]
    23fc:	2b00      	cmp	r3, #0
    23fe:	d005      	beq.n	240c <chMBObjectInit+0x1c>
    2400:	9b02      	ldr	r3, [sp, #8]
    2402:	2b00      	cmp	r3, #0
    2404:	d002      	beq.n	240c <chMBObjectInit+0x1c>
    2406:	9b01      	ldr	r3, [sp, #4]
    2408:	2b00      	cmp	r3, #0
    240a:	dc02      	bgt.n	2412 <chMBObjectInit+0x22>
    240c:	4810      	ldr	r0, [pc, #64]	; (2450 <chMBObjectInit+0x60>)
    240e:	f7fe fa37 	bl	880 <chSysHalt>

  mbp->mb_buffer = buf;
    2412:	9b03      	ldr	r3, [sp, #12]
    2414:	9a02      	ldr	r2, [sp, #8]
    2416:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
    2418:	9b03      	ldr	r3, [sp, #12]
    241a:	9a02      	ldr	r2, [sp, #8]
    241c:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
    241e:	9b03      	ldr	r3, [sp, #12]
    2420:	9a02      	ldr	r2, [sp, #8]
    2422:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
    2424:	9b01      	ldr	r3, [sp, #4]
    2426:	009b      	lsls	r3, r3, #2
    2428:	9a02      	ldr	r2, [sp, #8]
    242a:	441a      	add	r2, r3
    242c:	9b03      	ldr	r3, [sp, #12]
    242e:	605a      	str	r2, [r3, #4]
  chSemObjectInit(&mbp->mb_emptysem, n);
    2430:	9b03      	ldr	r3, [sp, #12]
    2432:	331c      	adds	r3, #28
    2434:	4618      	mov	r0, r3
    2436:	9901      	ldr	r1, [sp, #4]
    2438:	f7ff fc92 	bl	1d60 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
    243c:	9b03      	ldr	r3, [sp, #12]
    243e:	3310      	adds	r3, #16
    2440:	4618      	mov	r0, r3
    2442:	2100      	movs	r1, #0
    2444:	f7ff fc8c 	bl	1d60 <chSemObjectInit>
}
    2448:	b005      	add	sp, #20
    244a:	f85d fb04 	ldr.w	pc, [sp], #4
    244e:	bf00      	nop
    2450:	000048f0 	.word	0x000048f0
    2454:	f3af 8000 	nop.w
    2458:	f3af 8000 	nop.w
    245c:	f3af 8000 	nop.w

00002460 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    2460:	b500      	push	{lr}
    2462:	b087      	sub	sp, #28
    2464:	9003      	str	r0, [sp, #12]
    2466:	9102      	str	r1, [sp, #8]
    2468:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
    246a:	f7ff ff99 	bl	23a0 <chSysLock>
  rdymsg = chMBPostS(mbp, msg, timeout);
    246e:	9803      	ldr	r0, [sp, #12]
    2470:	9902      	ldr	r1, [sp, #8]
    2472:	9a01      	ldr	r2, [sp, #4]
    2474:	f000 f80c 	bl	2490 <chMBPostS>
    2478:	9005      	str	r0, [sp, #20]
  chSysUnlock();
    247a:	f7ff ff99 	bl	23b0 <chSysUnlock>

  return rdymsg;
    247e:	9b05      	ldr	r3, [sp, #20]
}
    2480:	4618      	mov	r0, r3
    2482:	b007      	add	sp, #28
    2484:	f85d fb04 	ldr.w	pc, [sp], #4
    2488:	f3af 8000 	nop.w
    248c:	f3af 8000 	nop.w

00002490 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    2490:	b500      	push	{lr}
    2492:	b087      	sub	sp, #28
    2494:	9003      	str	r0, [sp, #12]
    2496:	9102      	str	r1, [sp, #8]
    2498:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
    249a:	f7fe fb11 	bl	ac0 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);
    249e:	9b03      	ldr	r3, [sp, #12]
    24a0:	2b00      	cmp	r3, #0
    24a2:	d102      	bne.n	24aa <chMBPostS+0x1a>
    24a4:	4814      	ldr	r0, [pc, #80]	; (24f8 <chMBPostS+0x68>)
    24a6:	f7fe f9eb 	bl	880 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
    24aa:	9b03      	ldr	r3, [sp, #12]
    24ac:	331c      	adds	r3, #28
    24ae:	4618      	mov	r0, r3
    24b0:	9901      	ldr	r1, [sp, #4]
    24b2:	f7ff fc75 	bl	1da0 <chSemWaitTimeoutS>
    24b6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
    24b8:	9b05      	ldr	r3, [sp, #20]
    24ba:	2b00      	cmp	r3, #0
    24bc:	d117      	bne.n	24ee <chMBPostS+0x5e>
    *mbp->mb_wrptr++ = msg;
    24be:	9b03      	ldr	r3, [sp, #12]
    24c0:	689b      	ldr	r3, [r3, #8]
    24c2:	1d19      	adds	r1, r3, #4
    24c4:	9a03      	ldr	r2, [sp, #12]
    24c6:	6091      	str	r1, [r2, #8]
    24c8:	9a02      	ldr	r2, [sp, #8]
    24ca:	601a      	str	r2, [r3, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
    24cc:	9b03      	ldr	r3, [sp, #12]
    24ce:	689a      	ldr	r2, [r3, #8]
    24d0:	9b03      	ldr	r3, [sp, #12]
    24d2:	685b      	ldr	r3, [r3, #4]
    24d4:	429a      	cmp	r2, r3
    24d6:	d303      	bcc.n	24e0 <chMBPostS+0x50>
      mbp->mb_wrptr = mbp->mb_buffer;
    24d8:	9b03      	ldr	r3, [sp, #12]
    24da:	681a      	ldr	r2, [r3, #0]
    24dc:	9b03      	ldr	r3, [sp, #12]
    24de:	609a      	str	r2, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
    24e0:	9b03      	ldr	r3, [sp, #12]
    24e2:	3310      	adds	r3, #16
    24e4:	4618      	mov	r0, r3
    24e6:	f7ff fcbb 	bl	1e60 <chSemSignalI>
    chSchRescheduleS();
    24ea:	f7fe fe99 	bl	1220 <chSchRescheduleS>
  }

  return rdymsg;
    24ee:	9b05      	ldr	r3, [sp, #20]
}
    24f0:	4618      	mov	r0, r3
    24f2:	b007      	add	sp, #28
    24f4:	f85d fb04 	ldr.w	pc, [sp], #4
    24f8:	00004910 	.word	0x00004910
    24fc:	f3af 8000 	nop.w

00002500 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    2500:	b500      	push	{lr}
    2502:	b087      	sub	sp, #28
    2504:	9003      	str	r0, [sp, #12]
    2506:	9102      	str	r1, [sp, #8]
    2508:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
    250a:	f7ff ff49 	bl	23a0 <chSysLock>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
    250e:	9803      	ldr	r0, [sp, #12]
    2510:	9902      	ldr	r1, [sp, #8]
    2512:	9a01      	ldr	r2, [sp, #4]
    2514:	f000 f80c 	bl	2530 <chMBFetchS>
    2518:	9005      	str	r0, [sp, #20]
  chSysUnlock();
    251a:	f7ff ff49 	bl	23b0 <chSysUnlock>

  return rdymsg;
    251e:	9b05      	ldr	r3, [sp, #20]
}
    2520:	4618      	mov	r0, r3
    2522:	b007      	add	sp, #28
    2524:	f85d fb04 	ldr.w	pc, [sp], #4
    2528:	f3af 8000 	nop.w
    252c:	f3af 8000 	nop.w

00002530 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    2530:	b500      	push	{lr}
    2532:	b087      	sub	sp, #28
    2534:	9003      	str	r0, [sp, #12]
    2536:	9102      	str	r1, [sp, #8]
    2538:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
    253a:	f7fe fac1 	bl	ac0 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
    253e:	9b03      	ldr	r3, [sp, #12]
    2540:	2b00      	cmp	r3, #0
    2542:	d002      	beq.n	254a <chMBFetchS+0x1a>
    2544:	9b02      	ldr	r3, [sp, #8]
    2546:	2b00      	cmp	r3, #0
    2548:	d102      	bne.n	2550 <chMBFetchS+0x20>
    254a:	4815      	ldr	r0, [pc, #84]	; (25a0 <chMBFetchS+0x70>)
    254c:	f7fe f998 	bl	880 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
    2550:	9b03      	ldr	r3, [sp, #12]
    2552:	3310      	adds	r3, #16
    2554:	4618      	mov	r0, r3
    2556:	9901      	ldr	r1, [sp, #4]
    2558:	f7ff fc22 	bl	1da0 <chSemWaitTimeoutS>
    255c:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
    255e:	9b05      	ldr	r3, [sp, #20]
    2560:	2b00      	cmp	r3, #0
    2562:	d118      	bne.n	2596 <chMBFetchS+0x66>
    *msgp = *mbp->mb_rdptr++;
    2564:	9b03      	ldr	r3, [sp, #12]
    2566:	68db      	ldr	r3, [r3, #12]
    2568:	1d19      	adds	r1, r3, #4
    256a:	9a03      	ldr	r2, [sp, #12]
    256c:	60d1      	str	r1, [r2, #12]
    256e:	681a      	ldr	r2, [r3, #0]
    2570:	9b02      	ldr	r3, [sp, #8]
    2572:	601a      	str	r2, [r3, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
    2574:	9b03      	ldr	r3, [sp, #12]
    2576:	68da      	ldr	r2, [r3, #12]
    2578:	9b03      	ldr	r3, [sp, #12]
    257a:	685b      	ldr	r3, [r3, #4]
    257c:	429a      	cmp	r2, r3
    257e:	d303      	bcc.n	2588 <chMBFetchS+0x58>
      mbp->mb_rdptr = mbp->mb_buffer;
    2580:	9b03      	ldr	r3, [sp, #12]
    2582:	681a      	ldr	r2, [r3, #0]
    2584:	9b03      	ldr	r3, [sp, #12]
    2586:	60da      	str	r2, [r3, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
    2588:	9b03      	ldr	r3, [sp, #12]
    258a:	331c      	adds	r3, #28
    258c:	4618      	mov	r0, r3
    258e:	f7ff fc67 	bl	1e60 <chSemSignalI>
    chSchRescheduleS();
    2592:	f7fe fe45 	bl	1220 <chSchRescheduleS>
  }

  return rdymsg;
    2596:	9b05      	ldr	r3, [sp, #20]
}
    2598:	4618      	mov	r0, r3
    259a:	b007      	add	sp, #28
    259c:	f85d fb04 	ldr.w	pc, [sp], #4
    25a0:	00004920 	.word	0x00004920
    25a4:	f3af 8000 	nop.w
    25a8:	f3af 8000 	nop.w
    25ac:	f3af 8000 	nop.w

000025b0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    25b0:	b082      	sub	sp, #8
    25b2:	2320      	movs	r3, #32
    25b4:	9301      	str	r3, [sp, #4]
    25b6:	9b01      	ldr	r3, [sp, #4]
    25b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    25bc:	b002      	add	sp, #8
    25be:	4770      	bx	lr

000025c0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    25c0:	b082      	sub	sp, #8
    25c2:	2300      	movs	r3, #0
    25c4:	9301      	str	r3, [sp, #4]
    25c6:	9b01      	ldr	r3, [sp, #4]
    25c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    25cc:	b002      	add	sp, #8
    25ce:	4770      	bx	lr

000025d0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
    25d0:	b082      	sub	sp, #8
    25d2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
    25d4:	9b01      	ldr	r3, [sp, #4]
    25d6:	9a01      	ldr	r2, [sp, #4]
    25d8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
    25da:	9b01      	ldr	r3, [sp, #4]
    25dc:	9a01      	ldr	r2, [sp, #4]
    25de:	605a      	str	r2, [r3, #4]
}
    25e0:	b002      	add	sp, #8
    25e2:	4770      	bx	lr
    25e4:	f3af 8000 	nop.w
    25e8:	f3af 8000 	nop.w
    25ec:	f3af 8000 	nop.w

000025f0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    25f0:	b508      	push	{r3, lr}

  port_lock();
    25f2:	f7ff ffdd 	bl	25b0 <port_lock>
  _stats_start_measure_crit_thd();
    25f6:	f7ff faa3 	bl	1b40 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    25fa:	f7fe f9a9 	bl	950 <_dbg_check_lock>
}
    25fe:	bd08      	pop	{r3, pc}

00002600 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2600:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2602:	f7fe f9bd 	bl	980 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2606:	f7ff faa3 	bl	1b50 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    260a:	4b09      	ldr	r3, [pc, #36]	; (2630 <chSysUnlock+0x30>)
    260c:	681a      	ldr	r2, [r3, #0]
    260e:	4b08      	ldr	r3, [pc, #32]	; (2630 <chSysUnlock+0x30>)
    2610:	429a      	cmp	r2, r3
    2612:	d00a      	beq.n	262a <chSysUnlock+0x2a>
    2614:	4b06      	ldr	r3, [pc, #24]	; (2630 <chSysUnlock+0x30>)
    2616:	699b      	ldr	r3, [r3, #24]
    2618:	689a      	ldr	r2, [r3, #8]
    261a:	4b05      	ldr	r3, [pc, #20]	; (2630 <chSysUnlock+0x30>)
    261c:	681b      	ldr	r3, [r3, #0]
    261e:	689b      	ldr	r3, [r3, #8]
    2620:	429a      	cmp	r2, r3
    2622:	d202      	bcs.n	262a <chSysUnlock+0x2a>
    2624:	4803      	ldr	r0, [pc, #12]	; (2634 <chSysUnlock+0x34>)
    2626:	f7fe f92b 	bl	880 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    262a:	f7ff ffc9 	bl	25c0 <port_unlock>
}
    262e:	bd08      	pop	{r3, pc}
    2630:	20000ac0 	.word	0x20000ac0
    2634:	00004930 	.word	0x00004930
    2638:	f3af 8000 	nop.w
    263c:	f3af 8000 	nop.w

00002640 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
    2640:	b500      	push	{lr}
    2642:	b083      	sub	sp, #12
    2644:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
    2646:	9801      	ldr	r0, [sp, #4]
    2648:	f7ff ffc2 	bl	25d0 <queue_init>
}
    264c:	b003      	add	sp, #12
    264e:	f85d fb04 	ldr.w	pc, [sp], #4
    2652:	bf00      	nop
    2654:	f3af 8000 	nop.w
    2658:	f3af 8000 	nop.w
    265c:	f3af 8000 	nop.w

00002660 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
    2660:	b500      	push	{lr}
    2662:	b083      	sub	sp, #12
    2664:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    2666:	f7fe fa13 	bl	a90 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
    266a:	9b01      	ldr	r3, [sp, #4]
    266c:	689b      	ldr	r3, [r3, #8]
    266e:	2b00      	cmp	r3, #0
    2670:	bf14      	ite	ne
    2672:	2300      	movne	r3, #0
    2674:	2301      	moveq	r3, #1
    2676:	b2db      	uxtb	r3, r3
}
    2678:	4618      	mov	r0, r3
    267a:	b003      	add	sp, #12
    267c:	f85d fb04 	ldr.w	pc, [sp], #4

00002680 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
    2680:	b500      	push	{lr}
    2682:	b083      	sub	sp, #12
    2684:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    2686:	f7fe fa03 	bl	a90 <chDbgCheckClassI>

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
    268a:	9b01      	ldr	r3, [sp, #4]
    268c:	695a      	ldr	r2, [r3, #20]
    268e:	9b01      	ldr	r3, [sp, #4]
    2690:	699b      	ldr	r3, [r3, #24]
    2692:	429a      	cmp	r2, r3
    2694:	d105      	bne.n	26a2 <chIQIsFullI+0x22>
    2696:	9b01      	ldr	r3, [sp, #4]
    2698:	689b      	ldr	r3, [r3, #8]
    269a:	2b00      	cmp	r3, #0
    269c:	d001      	beq.n	26a2 <chIQIsFullI+0x22>
    269e:	2301      	movs	r3, #1
    26a0:	e000      	b.n	26a4 <chIQIsFullI+0x24>
    26a2:	2300      	movs	r3, #0
    26a4:	f003 0301 	and.w	r3, r3, #1
    26a8:	b2db      	uxtb	r3, r3
}
    26aa:	4618      	mov	r0, r3
    26ac:	b003      	add	sp, #12
    26ae:	f85d fb04 	ldr.w	pc, [sp], #4
    26b2:	bf00      	nop
    26b4:	f3af 8000 	nop.w
    26b8:	f3af 8000 	nop.w
    26bc:	f3af 8000 	nop.w

000026c0 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
    26c0:	b500      	push	{lr}
    26c2:	b083      	sub	sp, #12
    26c4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    26c6:	f7fe f9e3 	bl	a90 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    26ca:	9b01      	ldr	r3, [sp, #4]
    26cc:	695a      	ldr	r2, [r3, #20]
    26ce:	9b01      	ldr	r3, [sp, #4]
    26d0:	699b      	ldr	r3, [r3, #24]
    26d2:	429a      	cmp	r2, r3
    26d4:	d105      	bne.n	26e2 <chOQIsEmptyI+0x22>
    26d6:	9b01      	ldr	r3, [sp, #4]
    26d8:	689b      	ldr	r3, [r3, #8]
    26da:	2b00      	cmp	r3, #0
    26dc:	d001      	beq.n	26e2 <chOQIsEmptyI+0x22>
    26de:	2301      	movs	r3, #1
    26e0:	e000      	b.n	26e4 <chOQIsEmptyI+0x24>
    26e2:	2300      	movs	r3, #0
    26e4:	f003 0301 	and.w	r3, r3, #1
    26e8:	b2db      	uxtb	r3, r3
}
    26ea:	4618      	mov	r0, r3
    26ec:	b003      	add	sp, #12
    26ee:	f85d fb04 	ldr.w	pc, [sp], #4
    26f2:	bf00      	nop
    26f4:	f3af 8000 	nop.w
    26f8:	f3af 8000 	nop.w
    26fc:	f3af 8000 	nop.w

00002700 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
    2700:	b500      	push	{lr}
    2702:	b083      	sub	sp, #12
    2704:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    2706:	f7fe f9c3 	bl	a90 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
    270a:	9b01      	ldr	r3, [sp, #4]
    270c:	689b      	ldr	r3, [r3, #8]
    270e:	2b00      	cmp	r3, #0
    2710:	bf14      	ite	ne
    2712:	2300      	movne	r3, #0
    2714:	2301      	moveq	r3, #1
    2716:	b2db      	uxtb	r3, r3
}
    2718:	4618      	mov	r0, r3
    271a:	b003      	add	sp, #12
    271c:	f85d fb04 	ldr.w	pc, [sp], #4

00002720 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
    2720:	b500      	push	{lr}
    2722:	b085      	sub	sp, #20
    2724:	9003      	str	r0, [sp, #12]
    2726:	9102      	str	r1, [sp, #8]
    2728:	9201      	str	r2, [sp, #4]
    272a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
    272c:	9b03      	ldr	r3, [sp, #12]
    272e:	4618      	mov	r0, r3
    2730:	f7ff ff86 	bl	2640 <chThdQueueObjectInit>
  iqp->q_counter = 0;
    2734:	9b03      	ldr	r3, [sp, #12]
    2736:	2200      	movs	r2, #0
    2738:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
    273a:	9b03      	ldr	r3, [sp, #12]
    273c:	9a02      	ldr	r2, [sp, #8]
    273e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
    2740:	9b03      	ldr	r3, [sp, #12]
    2742:	9a02      	ldr	r2, [sp, #8]
    2744:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
    2746:	9b03      	ldr	r3, [sp, #12]
    2748:	9a02      	ldr	r2, [sp, #8]
    274a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
    274c:	9a02      	ldr	r2, [sp, #8]
    274e:	9b01      	ldr	r3, [sp, #4]
    2750:	441a      	add	r2, r3
    2752:	9b03      	ldr	r3, [sp, #12]
    2754:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
    2756:	9b03      	ldr	r3, [sp, #12]
    2758:	9a00      	ldr	r2, [sp, #0]
    275a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
    275c:	9b03      	ldr	r3, [sp, #12]
    275e:	9a06      	ldr	r2, [sp, #24]
    2760:	621a      	str	r2, [r3, #32]
}
    2762:	b005      	add	sp, #20
    2764:	f85d fb04 	ldr.w	pc, [sp], #4
    2768:	f3af 8000 	nop.w
    276c:	f3af 8000 	nop.w

00002770 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
    2770:	b500      	push	{lr}
    2772:	b083      	sub	sp, #12
    2774:	9001      	str	r0, [sp, #4]
    2776:	460b      	mov	r3, r1
    2778:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();
    277c:	f7fe f988 	bl	a90 <chDbgCheckClassI>

  if (chIQIsFullI(iqp)) {
    2780:	9801      	ldr	r0, [sp, #4]
    2782:	f7ff ff7d 	bl	2680 <chIQIsFullI>
    2786:	4603      	mov	r3, r0
    2788:	2b00      	cmp	r3, #0
    278a:	d002      	beq.n	2792 <chIQPutI+0x22>
    return Q_FULL;
    278c:	f06f 0303 	mvn.w	r3, #3
    2790:	e01c      	b.n	27cc <chIQPutI+0x5c>
  }

  iqp->q_counter++;
    2792:	9b01      	ldr	r3, [sp, #4]
    2794:	689b      	ldr	r3, [r3, #8]
    2796:	1c5a      	adds	r2, r3, #1
    2798:	9b01      	ldr	r3, [sp, #4]
    279a:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
    279c:	9b01      	ldr	r3, [sp, #4]
    279e:	695b      	ldr	r3, [r3, #20]
    27a0:	1c59      	adds	r1, r3, #1
    27a2:	9a01      	ldr	r2, [sp, #4]
    27a4:	6151      	str	r1, [r2, #20]
    27a6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    27aa:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
    27ac:	9b01      	ldr	r3, [sp, #4]
    27ae:	695a      	ldr	r2, [r3, #20]
    27b0:	9b01      	ldr	r3, [sp, #4]
    27b2:	691b      	ldr	r3, [r3, #16]
    27b4:	429a      	cmp	r2, r3
    27b6:	d303      	bcc.n	27c0 <chIQPutI+0x50>
    iqp->q_wrptr = iqp->q_buffer;
    27b8:	9b01      	ldr	r3, [sp, #4]
    27ba:	68da      	ldr	r2, [r3, #12]
    27bc:	9b01      	ldr	r3, [sp, #4]
    27be:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
    27c0:	9b01      	ldr	r3, [sp, #4]
    27c2:	4618      	mov	r0, r3
    27c4:	2100      	movs	r1, #0
    27c6:	f7ff f8a3 	bl	1910 <chThdDequeueNextI>

  return Q_OK;
    27ca:	2300      	movs	r3, #0
}
    27cc:	4618      	mov	r0, r3
    27ce:	b003      	add	sp, #12
    27d0:	f85d fb04 	ldr.w	pc, [sp], #4
    27d4:	f3af 8000 	nop.w
    27d8:	f3af 8000 	nop.w
    27dc:	f3af 8000 	nop.w

000027e0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
    27e0:	b500      	push	{lr}
    27e2:	b085      	sub	sp, #20
    27e4:	9001      	str	r0, [sp, #4]
    27e6:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
    27e8:	f7ff ff02 	bl	25f0 <chSysLock>
  if (iqp->q_notify != NULL) {
    27ec:	9b01      	ldr	r3, [sp, #4]
    27ee:	69db      	ldr	r3, [r3, #28]
    27f0:	2b00      	cmp	r3, #0
    27f2:	d004      	beq.n	27fe <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
    27f4:	9b01      	ldr	r3, [sp, #4]
    27f6:	69db      	ldr	r3, [r3, #28]
    27f8:	9801      	ldr	r0, [sp, #4]
    27fa:	4798      	blx	r3
  }

  while (chIQIsEmptyI(iqp)) {
    27fc:	e00d      	b.n	281a <chIQGetTimeout+0x3a>
    27fe:	e00c      	b.n	281a <chIQGetTimeout+0x3a>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
    2800:	9b01      	ldr	r3, [sp, #4]
    2802:	4618      	mov	r0, r3
    2804:	9900      	ldr	r1, [sp, #0]
    2806:	f7ff f863 	bl	18d0 <chThdEnqueueTimeoutS>
    280a:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
    280c:	9b03      	ldr	r3, [sp, #12]
    280e:	2b00      	cmp	r3, #0
    2810:	da03      	bge.n	281a <chIQGetTimeout+0x3a>
      chSysUnlock();
    2812:	f7ff fef5 	bl	2600 <chSysUnlock>
      return msg;
    2816:	9b03      	ldr	r3, [sp, #12]
    2818:	e020      	b.n	285c <chIQGetTimeout+0x7c>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    281a:	9801      	ldr	r0, [sp, #4]
    281c:	f7ff ff20 	bl	2660 <chIQIsEmptyI>
    2820:	4603      	mov	r3, r0
    2822:	2b00      	cmp	r3, #0
    2824:	d1ec      	bne.n	2800 <chIQGetTimeout+0x20>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
    2826:	9b01      	ldr	r3, [sp, #4]
    2828:	689b      	ldr	r3, [r3, #8]
    282a:	1e5a      	subs	r2, r3, #1
    282c:	9b01      	ldr	r3, [sp, #4]
    282e:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
    2830:	9b01      	ldr	r3, [sp, #4]
    2832:	699b      	ldr	r3, [r3, #24]
    2834:	1c59      	adds	r1, r3, #1
    2836:	9a01      	ldr	r2, [sp, #4]
    2838:	6191      	str	r1, [r2, #24]
    283a:	781b      	ldrb	r3, [r3, #0]
    283c:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
    2840:	9b01      	ldr	r3, [sp, #4]
    2842:	699a      	ldr	r2, [r3, #24]
    2844:	9b01      	ldr	r3, [sp, #4]
    2846:	691b      	ldr	r3, [r3, #16]
    2848:	429a      	cmp	r2, r3
    284a:	d303      	bcc.n	2854 <chIQGetTimeout+0x74>
    iqp->q_rdptr = iqp->q_buffer;
    284c:	9b01      	ldr	r3, [sp, #4]
    284e:	68da      	ldr	r2, [r3, #12]
    2850:	9b01      	ldr	r3, [sp, #4]
    2852:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
    2854:	f7ff fed4 	bl	2600 <chSysUnlock>

  return (msg_t)b;
    2858:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    285c:	4618      	mov	r0, r3
    285e:	b005      	add	sp, #20
    2860:	f85d fb04 	ldr.w	pc, [sp], #4
    2864:	f3af 8000 	nop.w
    2868:	f3af 8000 	nop.w
    286c:	f3af 8000 	nop.w

00002870 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
    2870:	b500      	push	{lr}
    2872:	b087      	sub	sp, #28
    2874:	9003      	str	r0, [sp, #12]
    2876:	9102      	str	r1, [sp, #8]
    2878:	9201      	str	r2, [sp, #4]
    287a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
    287c:	9b03      	ldr	r3, [sp, #12]
    287e:	69db      	ldr	r3, [r3, #28]
    2880:	9304      	str	r3, [sp, #16]
  size_t r = 0;
    2882:	2300      	movs	r3, #0
    2884:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
    2886:	9b01      	ldr	r3, [sp, #4]
    2888:	2b00      	cmp	r3, #0
    288a:	d102      	bne.n	2892 <chIQReadTimeout+0x22>
    288c:	4825      	ldr	r0, [pc, #148]	; (2924 <chIQReadTimeout+0xb4>)
    288e:	f7fd fff7 	bl	880 <chSysHalt>

  chSysLock();
    2892:	f7ff fead 	bl	25f0 <chSysLock>
  while (true) {
    if (nfy != NULL) {
    2896:	9b04      	ldr	r3, [sp, #16]
    2898:	2b00      	cmp	r3, #0
    289a:	d003      	beq.n	28a4 <chIQReadTimeout+0x34>
      nfy(iqp);
    289c:	9b04      	ldr	r3, [sp, #16]
    289e:	9803      	ldr	r0, [sp, #12]
    28a0:	4798      	blx	r3
    }

    while (chIQIsEmptyI(iqp)) {
    28a2:	e00c      	b.n	28be <chIQReadTimeout+0x4e>
    28a4:	e00b      	b.n	28be <chIQReadTimeout+0x4e>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
    28a6:	9b03      	ldr	r3, [sp, #12]
    28a8:	4618      	mov	r0, r3
    28aa:	9900      	ldr	r1, [sp, #0]
    28ac:	f7ff f810 	bl	18d0 <chThdEnqueueTimeoutS>
    28b0:	4603      	mov	r3, r0
    28b2:	2b00      	cmp	r3, #0
    28b4:	d003      	beq.n	28be <chIQReadTimeout+0x4e>
        chSysUnlock();
    28b6:	f7ff fea3 	bl	2600 <chSysUnlock>
        return r;
    28ba:	9b05      	ldr	r3, [sp, #20]
    28bc:	e02e      	b.n	291c <chIQReadTimeout+0xac>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
    28be:	9803      	ldr	r0, [sp, #12]
    28c0:	f7ff fece 	bl	2660 <chIQIsEmptyI>
    28c4:	4603      	mov	r3, r0
    28c6:	2b00      	cmp	r3, #0
    28c8:	d1ed      	bne.n	28a6 <chIQReadTimeout+0x36>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
    28ca:	9b03      	ldr	r3, [sp, #12]
    28cc:	689b      	ldr	r3, [r3, #8]
    28ce:	1e5a      	subs	r2, r3, #1
    28d0:	9b03      	ldr	r3, [sp, #12]
    28d2:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
    28d4:	9b02      	ldr	r3, [sp, #8]
    28d6:	1c5a      	adds	r2, r3, #1
    28d8:	9202      	str	r2, [sp, #8]
    28da:	9a03      	ldr	r2, [sp, #12]
    28dc:	6992      	ldr	r2, [r2, #24]
    28de:	1c50      	adds	r0, r2, #1
    28e0:	9903      	ldr	r1, [sp, #12]
    28e2:	6188      	str	r0, [r1, #24]
    28e4:	7812      	ldrb	r2, [r2, #0]
    28e6:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
    28e8:	9b03      	ldr	r3, [sp, #12]
    28ea:	699a      	ldr	r2, [r3, #24]
    28ec:	9b03      	ldr	r3, [sp, #12]
    28ee:	691b      	ldr	r3, [r3, #16]
    28f0:	429a      	cmp	r2, r3
    28f2:	d303      	bcc.n	28fc <chIQReadTimeout+0x8c>
      iqp->q_rdptr = iqp->q_buffer;
    28f4:	9b03      	ldr	r3, [sp, #12]
    28f6:	68da      	ldr	r2, [r3, #12]
    28f8:	9b03      	ldr	r3, [sp, #12]
    28fa:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    28fc:	f7ff fe80 	bl	2600 <chSysUnlock>

    r++;
    2900:	9b05      	ldr	r3, [sp, #20]
    2902:	3301      	adds	r3, #1
    2904:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
    2906:	9b01      	ldr	r3, [sp, #4]
    2908:	3b01      	subs	r3, #1
    290a:	9301      	str	r3, [sp, #4]
    290c:	9b01      	ldr	r3, [sp, #4]
    290e:	2b00      	cmp	r3, #0
    2910:	d101      	bne.n	2916 <chIQReadTimeout+0xa6>
      return r;
    2912:	9b05      	ldr	r3, [sp, #20]
    2914:	e002      	b.n	291c <chIQReadTimeout+0xac>
    }

    chSysLock();
    2916:	f7ff fe6b 	bl	25f0 <chSysLock>
  }
    291a:	e7bc      	b.n	2896 <chIQReadTimeout+0x26>
}
    291c:	4618      	mov	r0, r3
    291e:	b007      	add	sp, #28
    2920:	f85d fb04 	ldr.w	pc, [sp], #4
    2924:	00004940 	.word	0x00004940
    2928:	f3af 8000 	nop.w
    292c:	f3af 8000 	nop.w

00002930 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
    2930:	b500      	push	{lr}
    2932:	b085      	sub	sp, #20
    2934:	9003      	str	r0, [sp, #12]
    2936:	9102      	str	r1, [sp, #8]
    2938:	9201      	str	r2, [sp, #4]
    293a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
    293c:	9b03      	ldr	r3, [sp, #12]
    293e:	4618      	mov	r0, r3
    2940:	f7ff fe7e 	bl	2640 <chThdQueueObjectInit>
  oqp->q_counter = size;
    2944:	9b03      	ldr	r3, [sp, #12]
    2946:	9a01      	ldr	r2, [sp, #4]
    2948:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
    294a:	9b03      	ldr	r3, [sp, #12]
    294c:	9a02      	ldr	r2, [sp, #8]
    294e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
    2950:	9b03      	ldr	r3, [sp, #12]
    2952:	9a02      	ldr	r2, [sp, #8]
    2954:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
    2956:	9b03      	ldr	r3, [sp, #12]
    2958:	9a02      	ldr	r2, [sp, #8]
    295a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
    295c:	9a02      	ldr	r2, [sp, #8]
    295e:	9b01      	ldr	r3, [sp, #4]
    2960:	441a      	add	r2, r3
    2962:	9b03      	ldr	r3, [sp, #12]
    2964:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
    2966:	9b03      	ldr	r3, [sp, #12]
    2968:	9a00      	ldr	r2, [sp, #0]
    296a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
    296c:	9b03      	ldr	r3, [sp, #12]
    296e:	9a06      	ldr	r2, [sp, #24]
    2970:	621a      	str	r2, [r3, #32]
}
    2972:	b005      	add	sp, #20
    2974:	f85d fb04 	ldr.w	pc, [sp], #4
    2978:	f3af 8000 	nop.w
    297c:	f3af 8000 	nop.w

00002980 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    2980:	b500      	push	{lr}
    2982:	b087      	sub	sp, #28
    2984:	9003      	str	r0, [sp, #12]
    2986:	460b      	mov	r3, r1
    2988:	9201      	str	r2, [sp, #4]
    298a:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
    298e:	f7ff fe2f 	bl	25f0 <chSysLock>
  while (chOQIsFullI(oqp)) {
    2992:	e00c      	b.n	29ae <chOQPutTimeout+0x2e>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    2994:	9b03      	ldr	r3, [sp, #12]
    2996:	4618      	mov	r0, r3
    2998:	9901      	ldr	r1, [sp, #4]
    299a:	f7fe ff99 	bl	18d0 <chThdEnqueueTimeoutS>
    299e:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
    29a0:	9b05      	ldr	r3, [sp, #20]
    29a2:	2b00      	cmp	r3, #0
    29a4:	da03      	bge.n	29ae <chOQPutTimeout+0x2e>
      chSysUnlock();
    29a6:	f7ff fe2b 	bl	2600 <chSysUnlock>
      return msg;
    29aa:	9b05      	ldr	r3, [sp, #20]
    29ac:	e027      	b.n	29fe <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    29ae:	9803      	ldr	r0, [sp, #12]
    29b0:	f7ff fea6 	bl	2700 <chOQIsFullI>
    29b4:	4603      	mov	r3, r0
    29b6:	2b00      	cmp	r3, #0
    29b8:	d1ec      	bne.n	2994 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
    29ba:	9b03      	ldr	r3, [sp, #12]
    29bc:	689b      	ldr	r3, [r3, #8]
    29be:	1e5a      	subs	r2, r3, #1
    29c0:	9b03      	ldr	r3, [sp, #12]
    29c2:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
    29c4:	9b03      	ldr	r3, [sp, #12]
    29c6:	695b      	ldr	r3, [r3, #20]
    29c8:	1c59      	adds	r1, r3, #1
    29ca:	9a03      	ldr	r2, [sp, #12]
    29cc:	6151      	str	r1, [r2, #20]
    29ce:	f89d 200b 	ldrb.w	r2, [sp, #11]
    29d2:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
    29d4:	9b03      	ldr	r3, [sp, #12]
    29d6:	695a      	ldr	r2, [r3, #20]
    29d8:	9b03      	ldr	r3, [sp, #12]
    29da:	691b      	ldr	r3, [r3, #16]
    29dc:	429a      	cmp	r2, r3
    29de:	d303      	bcc.n	29e8 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
    29e0:	9b03      	ldr	r3, [sp, #12]
    29e2:	68da      	ldr	r2, [r3, #12]
    29e4:	9b03      	ldr	r3, [sp, #12]
    29e6:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
    29e8:	9b03      	ldr	r3, [sp, #12]
    29ea:	69db      	ldr	r3, [r3, #28]
    29ec:	2b00      	cmp	r3, #0
    29ee:	d003      	beq.n	29f8 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
    29f0:	9b03      	ldr	r3, [sp, #12]
    29f2:	69db      	ldr	r3, [r3, #28]
    29f4:	9803      	ldr	r0, [sp, #12]
    29f6:	4798      	blx	r3
  }
  chSysUnlock();
    29f8:	f7ff fe02 	bl	2600 <chSysUnlock>

  return Q_OK;
    29fc:	2300      	movs	r3, #0
}
    29fe:	4618      	mov	r0, r3
    2a00:	b007      	add	sp, #28
    2a02:	f85d fb04 	ldr.w	pc, [sp], #4
    2a06:	bf00      	nop
    2a08:	f3af 8000 	nop.w
    2a0c:	f3af 8000 	nop.w

00002a10 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
    2a10:	b500      	push	{lr}
    2a12:	b085      	sub	sp, #20
    2a14:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();
    2a16:	f7fe f83b 	bl	a90 <chDbgCheckClassI>

  if (chOQIsEmptyI(oqp)) {
    2a1a:	9801      	ldr	r0, [sp, #4]
    2a1c:	f7ff fe50 	bl	26c0 <chOQIsEmptyI>
    2a20:	4603      	mov	r3, r0
    2a22:	2b00      	cmp	r3, #0
    2a24:	d002      	beq.n	2a2c <chOQGetI+0x1c>
    return Q_EMPTY;
    2a26:	f06f 0302 	mvn.w	r3, #2
    2a2a:	e01d      	b.n	2a68 <chOQGetI+0x58>
  }

  oqp->q_counter++;
    2a2c:	9b01      	ldr	r3, [sp, #4]
    2a2e:	689b      	ldr	r3, [r3, #8]
    2a30:	1c5a      	adds	r2, r3, #1
    2a32:	9b01      	ldr	r3, [sp, #4]
    2a34:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
    2a36:	9b01      	ldr	r3, [sp, #4]
    2a38:	699b      	ldr	r3, [r3, #24]
    2a3a:	1c59      	adds	r1, r3, #1
    2a3c:	9a01      	ldr	r2, [sp, #4]
    2a3e:	6191      	str	r1, [r2, #24]
    2a40:	781b      	ldrb	r3, [r3, #0]
    2a42:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
    2a46:	9b01      	ldr	r3, [sp, #4]
    2a48:	699a      	ldr	r2, [r3, #24]
    2a4a:	9b01      	ldr	r3, [sp, #4]
    2a4c:	691b      	ldr	r3, [r3, #16]
    2a4e:	429a      	cmp	r2, r3
    2a50:	d303      	bcc.n	2a5a <chOQGetI+0x4a>
    oqp->q_rdptr = oqp->q_buffer;
    2a52:	9b01      	ldr	r3, [sp, #4]
    2a54:	68da      	ldr	r2, [r3, #12]
    2a56:	9b01      	ldr	r3, [sp, #4]
    2a58:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
    2a5a:	9b01      	ldr	r3, [sp, #4]
    2a5c:	4618      	mov	r0, r3
    2a5e:	2100      	movs	r1, #0
    2a60:	f7fe ff56 	bl	1910 <chThdDequeueNextI>

  return (msg_t)b;
    2a64:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    2a68:	4618      	mov	r0, r3
    2a6a:	b005      	add	sp, #20
    2a6c:	f85d fb04 	ldr.w	pc, [sp], #4

00002a70 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
    2a70:	b500      	push	{lr}
    2a72:	b087      	sub	sp, #28
    2a74:	9003      	str	r0, [sp, #12]
    2a76:	9102      	str	r1, [sp, #8]
    2a78:	9201      	str	r2, [sp, #4]
    2a7a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
    2a7c:	9b03      	ldr	r3, [sp, #12]
    2a7e:	69db      	ldr	r3, [r3, #28]
    2a80:	9304      	str	r3, [sp, #16]
  size_t w = 0;
    2a82:	2300      	movs	r3, #0
    2a84:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
    2a86:	9b01      	ldr	r3, [sp, #4]
    2a88:	2b00      	cmp	r3, #0
    2a8a:	d102      	bne.n	2a92 <chOQWriteTimeout+0x22>
    2a8c:	4825      	ldr	r0, [pc, #148]	; (2b24 <chOQWriteTimeout+0xb4>)
    2a8e:	f7fd fef7 	bl	880 <chSysHalt>

  chSysLock();
    2a92:	f7ff fdad 	bl	25f0 <chSysLock>
  while (true) {
    while (chOQIsFullI(oqp)) {
    2a96:	e00b      	b.n	2ab0 <chOQWriteTimeout+0x40>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
    2a98:	9b03      	ldr	r3, [sp, #12]
    2a9a:	4618      	mov	r0, r3
    2a9c:	9900      	ldr	r1, [sp, #0]
    2a9e:	f7fe ff17 	bl	18d0 <chThdEnqueueTimeoutS>
    2aa2:	4603      	mov	r3, r0
    2aa4:	2b00      	cmp	r3, #0
    2aa6:	d003      	beq.n	2ab0 <chOQWriteTimeout+0x40>
        chSysUnlock();
    2aa8:	f7ff fdaa 	bl	2600 <chSysUnlock>
        return w;
    2aac:	9b05      	ldr	r3, [sp, #20]
    2aae:	e035      	b.n	2b1c <chOQWriteTimeout+0xac>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
    2ab0:	9803      	ldr	r0, [sp, #12]
    2ab2:	f7ff fe25 	bl	2700 <chOQIsFullI>
    2ab6:	4603      	mov	r3, r0
    2ab8:	2b00      	cmp	r3, #0
    2aba:	d1ed      	bne.n	2a98 <chOQWriteTimeout+0x28>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
    2abc:	9b03      	ldr	r3, [sp, #12]
    2abe:	689b      	ldr	r3, [r3, #8]
    2ac0:	1e5a      	subs	r2, r3, #1
    2ac2:	9b03      	ldr	r3, [sp, #12]
    2ac4:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
    2ac6:	9b03      	ldr	r3, [sp, #12]
    2ac8:	695b      	ldr	r3, [r3, #20]
    2aca:	1c59      	adds	r1, r3, #1
    2acc:	9a03      	ldr	r2, [sp, #12]
    2ace:	6151      	str	r1, [r2, #20]
    2ad0:	9a02      	ldr	r2, [sp, #8]
    2ad2:	1c51      	adds	r1, r2, #1
    2ad4:	9102      	str	r1, [sp, #8]
    2ad6:	7812      	ldrb	r2, [r2, #0]
    2ad8:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
    2ada:	9b03      	ldr	r3, [sp, #12]
    2adc:	695a      	ldr	r2, [r3, #20]
    2ade:	9b03      	ldr	r3, [sp, #12]
    2ae0:	691b      	ldr	r3, [r3, #16]
    2ae2:	429a      	cmp	r2, r3
    2ae4:	d303      	bcc.n	2aee <chOQWriteTimeout+0x7e>
      oqp->q_wrptr = oqp->q_buffer;
    2ae6:	9b03      	ldr	r3, [sp, #12]
    2ae8:	68da      	ldr	r2, [r3, #12]
    2aea:	9b03      	ldr	r3, [sp, #12]
    2aec:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
    2aee:	9b04      	ldr	r3, [sp, #16]
    2af0:	2b00      	cmp	r3, #0
    2af2:	d002      	beq.n	2afa <chOQWriteTimeout+0x8a>
      nfy(oqp);
    2af4:	9b04      	ldr	r3, [sp, #16]
    2af6:	9803      	ldr	r0, [sp, #12]
    2af8:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    2afa:	f7ff fd81 	bl	2600 <chSysUnlock>

    w++;
    2afe:	9b05      	ldr	r3, [sp, #20]
    2b00:	3301      	adds	r3, #1
    2b02:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
    2b04:	9b01      	ldr	r3, [sp, #4]
    2b06:	3b01      	subs	r3, #1
    2b08:	9301      	str	r3, [sp, #4]
    2b0a:	9b01      	ldr	r3, [sp, #4]
    2b0c:	2b00      	cmp	r3, #0
    2b0e:	d101      	bne.n	2b14 <chOQWriteTimeout+0xa4>
      return w;
    2b10:	9b05      	ldr	r3, [sp, #20]
    2b12:	e003      	b.n	2b1c <chOQWriteTimeout+0xac>
    }
    chSysLock();
    2b14:	f7ff fd6c 	bl	25f0 <chSysLock>
  }
    2b18:	bf00      	nop

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
    2b1a:	e7c9      	b.n	2ab0 <chOQWriteTimeout+0x40>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
    2b1c:	4618      	mov	r0, r3
    2b1e:	b007      	add	sp, #28
    2b20:	f85d fb04 	ldr.w	pc, [sp], #4
    2b24:	00004950 	.word	0x00004950
    2b28:	f3af 8000 	nop.w
    2b2c:	f3af 8000 	nop.w

00002b30 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2b30:	b082      	sub	sp, #8
    2b32:	2320      	movs	r3, #32
    2b34:	9301      	str	r3, [sp, #4]
    2b36:	9b01      	ldr	r3, [sp, #4]
    2b38:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2b3c:	b002      	add	sp, #8
    2b3e:	4770      	bx	lr

00002b40 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2b40:	b082      	sub	sp, #8
    2b42:	2300      	movs	r3, #0
    2b44:	9301      	str	r3, [sp, #4]
    2b46:	9b01      	ldr	r3, [sp, #4]
    2b48:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2b4c:	b002      	add	sp, #8
    2b4e:	4770      	bx	lr

00002b50 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    2b50:	b508      	push	{r3, lr}

  port_lock();
    2b52:	f7ff ffed 	bl	2b30 <port_lock>
  _stats_start_measure_crit_thd();
    2b56:	f7fe fff3 	bl	1b40 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2b5a:	f7fd fef9 	bl	950 <_dbg_check_lock>
}
    2b5e:	bd08      	pop	{r3, pc}

00002b60 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2b60:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2b62:	f7fd ff0d 	bl	980 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2b66:	f7fe fff3 	bl	1b50 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    2b6a:	4b09      	ldr	r3, [pc, #36]	; (2b90 <chSysUnlock+0x30>)
    2b6c:	681a      	ldr	r2, [r3, #0]
    2b6e:	4b08      	ldr	r3, [pc, #32]	; (2b90 <chSysUnlock+0x30>)
    2b70:	429a      	cmp	r2, r3
    2b72:	d00a      	beq.n	2b8a <chSysUnlock+0x2a>
    2b74:	4b06      	ldr	r3, [pc, #24]	; (2b90 <chSysUnlock+0x30>)
    2b76:	699b      	ldr	r3, [r3, #24]
    2b78:	689a      	ldr	r2, [r3, #8]
    2b7a:	4b05      	ldr	r3, [pc, #20]	; (2b90 <chSysUnlock+0x30>)
    2b7c:	681b      	ldr	r3, [r3, #0]
    2b7e:	689b      	ldr	r3, [r3, #8]
    2b80:	429a      	cmp	r2, r3
    2b82:	d202      	bcs.n	2b8a <chSysUnlock+0x2a>
    2b84:	4803      	ldr	r0, [pc, #12]	; (2b94 <chSysUnlock+0x34>)
    2b86:	f7fd fe7b 	bl	880 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    2b8a:	f7ff ffd9 	bl	2b40 <port_unlock>
}
    2b8e:	bd08      	pop	{r3, pc}
    2b90:	20000ac0 	.word	0x20000ac0
    2b94:	00004970 	.word	0x00004970
    2b98:	f3af 8000 	nop.w
    2b9c:	f3af 8000 	nop.w

00002ba0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
    2ba0:	4b06      	ldr	r3, [pc, #24]	; (2bbc <_core_init+0x1c>)
    2ba2:	3307      	adds	r3, #7
    2ba4:	f023 0307 	bic.w	r3, r3, #7
    2ba8:	461a      	mov	r2, r3
    2baa:	4b05      	ldr	r3, [pc, #20]	; (2bc0 <_core_init+0x20>)
    2bac:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
    2bae:	4b05      	ldr	r3, [pc, #20]	; (2bc4 <_core_init+0x24>)
    2bb0:	f023 0307 	bic.w	r3, r3, #7
    2bb4:	461a      	mov	r2, r3
    2bb6:	4b04      	ldr	r3, [pc, #16]	; (2bc8 <_core_init+0x28>)
    2bb8:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
    2bba:	4770      	bx	lr
    2bbc:	20001278 	.word	0x20001278
    2bc0:	20001098 	.word	0x20001098
    2bc4:	20020000 	.word	0x20020000
    2bc8:	2000109c 	.word	0x2000109c
    2bcc:	f3af 8000 	nop.w

00002bd0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
    2bd0:	b500      	push	{lr}
    2bd2:	b085      	sub	sp, #20
    2bd4:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
    2bd6:	f7ff ffbb 	bl	2b50 <chSysLock>
  p = chCoreAllocI(size);
    2bda:	9801      	ldr	r0, [sp, #4]
    2bdc:	f000 f808 	bl	2bf0 <chCoreAllocI>
    2be0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
    2be2:	f7ff ffbd 	bl	2b60 <chSysUnlock>

  return p;
    2be6:	9b03      	ldr	r3, [sp, #12]
}
    2be8:	4618      	mov	r0, r3
    2bea:	b005      	add	sp, #20
    2bec:	f85d fb04 	ldr.w	pc, [sp], #4

00002bf0 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
    2bf0:	b500      	push	{lr}
    2bf2:	b085      	sub	sp, #20
    2bf4:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();
    2bf6:	f7fd ff4b 	bl	a90 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
    2bfa:	9b01      	ldr	r3, [sp, #4]
    2bfc:	3307      	adds	r3, #7
    2bfe:	f023 0307 	bic.w	r3, r3, #7
    2c02:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
    2c04:	4b0c      	ldr	r3, [pc, #48]	; (2c38 <chCoreAllocI+0x48>)
    2c06:	681b      	ldr	r3, [r3, #0]
    2c08:	461a      	mov	r2, r3
    2c0a:	4b0c      	ldr	r3, [pc, #48]	; (2c3c <chCoreAllocI+0x4c>)
    2c0c:	681b      	ldr	r3, [r3, #0]
    2c0e:	1ad3      	subs	r3, r2, r3
    2c10:	461a      	mov	r2, r3
    2c12:	9b01      	ldr	r3, [sp, #4]
    2c14:	429a      	cmp	r2, r3
    2c16:	d201      	bcs.n	2c1c <chCoreAllocI+0x2c>
  /*lint -restore*/
    return NULL;
    2c18:	2300      	movs	r3, #0
    2c1a:	e009      	b.n	2c30 <chCoreAllocI+0x40>
  }
  p = nextmem;
    2c1c:	4b07      	ldr	r3, [pc, #28]	; (2c3c <chCoreAllocI+0x4c>)
    2c1e:	681b      	ldr	r3, [r3, #0]
    2c20:	9303      	str	r3, [sp, #12]
  nextmem += size;
    2c22:	4b06      	ldr	r3, [pc, #24]	; (2c3c <chCoreAllocI+0x4c>)
    2c24:	681a      	ldr	r2, [r3, #0]
    2c26:	9b01      	ldr	r3, [sp, #4]
    2c28:	441a      	add	r2, r3
    2c2a:	4b04      	ldr	r3, [pc, #16]	; (2c3c <chCoreAllocI+0x4c>)
    2c2c:	601a      	str	r2, [r3, #0]

  return p;
    2c2e:	9b03      	ldr	r3, [sp, #12]
}
    2c30:	4618      	mov	r0, r3
    2c32:	b005      	add	sp, #20
    2c34:	f85d fb04 	ldr.w	pc, [sp], #4
    2c38:	2000109c 	.word	0x2000109c
    2c3c:	20001098 	.word	0x20001098

00002c40 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
    2c40:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
    2c42:	4b06      	ldr	r3, [pc, #24]	; (2c5c <_heap_init+0x1c>)
    2c44:	4a06      	ldr	r2, [pc, #24]	; (2c60 <_heap_init+0x20>)
    2c46:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
    2c48:	4b04      	ldr	r3, [pc, #16]	; (2c5c <_heap_init+0x1c>)
    2c4a:	2200      	movs	r2, #0
    2c4c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
    2c4e:	4b03      	ldr	r3, [pc, #12]	; (2c5c <_heap_init+0x1c>)
    2c50:	2200      	movs	r2, #0
    2c52:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
    2c54:	4803      	ldr	r0, [pc, #12]	; (2c64 <_heap_init+0x24>)
    2c56:	f7ff fa03 	bl	2060 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
    2c5a:	bd08      	pop	{r3, pc}
    2c5c:	200010a0 	.word	0x200010a0
    2c60:	00002bd1 	.word	0x00002bd1
    2c64:	200010b0 	.word	0x200010b0
    2c68:	f3af 8000 	nop.w
    2c6c:	f3af 8000 	nop.w

00002c70 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
    2c70:	b500      	push	{lr}
    2c72:	b087      	sub	sp, #28
    2c74:	9001      	str	r0, [sp, #4]
  union heap_header *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);
    2c76:	9b01      	ldr	r3, [sp, #4]
    2c78:	2b00      	cmp	r3, #0
    2c7a:	d102      	bne.n	2c82 <chHeapFree+0x12>
    2c7c:	483a      	ldr	r0, [pc, #232]	; (2d68 <chHeapFree+0xf8>)
    2c7e:	f7fd fdff 	bl	880 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
    2c82:	9b01      	ldr	r3, [sp, #4]
    2c84:	3b08      	subs	r3, #8
    2c86:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = hp->h.u.heap;
    2c88:	9b04      	ldr	r3, [sp, #16]
    2c8a:	681b      	ldr	r3, [r3, #0]
    2c8c:	9303      	str	r3, [sp, #12]
  qp = &heapp->h_free;
    2c8e:	9b03      	ldr	r3, [sp, #12]
    2c90:	3308      	adds	r3, #8
    2c92:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
    2c94:	9b03      	ldr	r3, [sp, #12]
    2c96:	3310      	adds	r3, #16
    2c98:	4618      	mov	r0, r3
    2c9a:	f7ff f9f9 	bl	2090 <chMtxLock>
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");
    2c9e:	9a04      	ldr	r2, [sp, #16]
    2ca0:	9b05      	ldr	r3, [sp, #20]
    2ca2:	429a      	cmp	r2, r3
    2ca4:	d30a      	bcc.n	2cbc <chHeapFree+0x4c>
    2ca6:	9b05      	ldr	r3, [sp, #20]
    2ca8:	685b      	ldr	r3, [r3, #4]
    2caa:	3308      	adds	r3, #8
    2cac:	9a05      	ldr	r2, [sp, #20]
    2cae:	441a      	add	r2, r3
    2cb0:	9b04      	ldr	r3, [sp, #16]
    2cb2:	429a      	cmp	r2, r3
    2cb4:	d902      	bls.n	2cbc <chHeapFree+0x4c>
    2cb6:	482c      	ldr	r0, [pc, #176]	; (2d68 <chHeapFree+0xf8>)
    2cb8:	f7fd fde2 	bl	880 <chSysHalt>

    if (((qp == &heapp->h_free) || (hp > qp)) &&
    2cbc:	9b03      	ldr	r3, [sp, #12]
    2cbe:	f103 0208 	add.w	r2, r3, #8
    2cc2:	9b05      	ldr	r3, [sp, #20]
    2cc4:	429a      	cmp	r2, r3
    2cc6:	d003      	beq.n	2cd0 <chHeapFree+0x60>
    2cc8:	9a04      	ldr	r2, [sp, #16]
    2cca:	9b05      	ldr	r3, [sp, #20]
    2ccc:	429a      	cmp	r2, r3
    2cce:	d93e      	bls.n	2d4e <chHeapFree+0xde>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
    2cd0:	9b05      	ldr	r3, [sp, #20]
    2cd2:	681b      	ldr	r3, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
    2cd4:	2b00      	cmp	r3, #0
    2cd6:	d004      	beq.n	2ce2 <chHeapFree+0x72>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
    2cd8:	9b05      	ldr	r3, [sp, #20]
    2cda:	681a      	ldr	r2, [r3, #0]
    2cdc:	9b04      	ldr	r3, [sp, #16]
    2cde:	429a      	cmp	r2, r3
    2ce0:	d935      	bls.n	2d4e <chHeapFree+0xde>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
    2ce2:	9b05      	ldr	r3, [sp, #20]
    2ce4:	681a      	ldr	r2, [r3, #0]
    2ce6:	9b04      	ldr	r3, [sp, #16]
    2ce8:	601a      	str	r2, [r3, #0]
      qp->h.u.next = hp;
    2cea:	9b05      	ldr	r3, [sp, #20]
    2cec:	9a04      	ldr	r2, [sp, #16]
    2cee:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
    2cf0:	9b04      	ldr	r3, [sp, #16]
    2cf2:	685b      	ldr	r3, [r3, #4]
    2cf4:	3308      	adds	r3, #8
    2cf6:	9a04      	ldr	r2, [sp, #16]
    2cf8:	441a      	add	r2, r3
    2cfa:	9b04      	ldr	r3, [sp, #16]
    2cfc:	681b      	ldr	r3, [r3, #0]
    2cfe:	429a      	cmp	r2, r3
    2d00:	d10e      	bne.n	2d20 <chHeapFree+0xb0>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
    2d02:	9b04      	ldr	r3, [sp, #16]
    2d04:	685a      	ldr	r2, [r3, #4]
    2d06:	9b04      	ldr	r3, [sp, #16]
    2d08:	681b      	ldr	r3, [r3, #0]
    2d0a:	685b      	ldr	r3, [r3, #4]
    2d0c:	4413      	add	r3, r2
    2d0e:	f103 0208 	add.w	r2, r3, #8
    2d12:	9b04      	ldr	r3, [sp, #16]
    2d14:	605a      	str	r2, [r3, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
    2d16:	9b04      	ldr	r3, [sp, #16]
    2d18:	681b      	ldr	r3, [r3, #0]
    2d1a:	681a      	ldr	r2, [r3, #0]
    2d1c:	9b04      	ldr	r3, [sp, #16]
    2d1e:	601a      	str	r2, [r3, #0]
      }
      if ((LIMIT(qp) == hp)) {
    2d20:	9b05      	ldr	r3, [sp, #20]
    2d22:	685b      	ldr	r3, [r3, #4]
    2d24:	3308      	adds	r3, #8
    2d26:	9a05      	ldr	r2, [sp, #20]
    2d28:	441a      	add	r2, r3
    2d2a:	9b04      	ldr	r3, [sp, #16]
    2d2c:	429a      	cmp	r2, r3
    2d2e:	d10d      	bne.n	2d4c <chHeapFree+0xdc>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
    2d30:	9b05      	ldr	r3, [sp, #20]
    2d32:	685a      	ldr	r2, [r3, #4]
    2d34:	9b04      	ldr	r3, [sp, #16]
    2d36:	685b      	ldr	r3, [r3, #4]
    2d38:	4413      	add	r3, r2
    2d3a:	f103 0208 	add.w	r2, r3, #8
    2d3e:	9b05      	ldr	r3, [sp, #20]
    2d40:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
    2d42:	9b04      	ldr	r3, [sp, #16]
    2d44:	681a      	ldr	r2, [r3, #0]
    2d46:	9b05      	ldr	r3, [sp, #20]
    2d48:	601a      	str	r2, [r3, #0]
      }
      break;
    2d4a:	e004      	b.n	2d56 <chHeapFree+0xe6>
    2d4c:	e003      	b.n	2d56 <chHeapFree+0xe6>
    }
    qp = qp->h.u.next;
    2d4e:	9b05      	ldr	r3, [sp, #20]
    2d50:	681b      	ldr	r3, [r3, #0]
    2d52:	9305      	str	r3, [sp, #20]
  }
    2d54:	e7a3      	b.n	2c9e <chHeapFree+0x2e>
  H_UNLOCK(heapp);
    2d56:	9b03      	ldr	r3, [sp, #12]
    2d58:	3310      	adds	r3, #16
    2d5a:	4618      	mov	r0, r3
    2d5c:	f7ff fa28 	bl	21b0 <chMtxUnlock>

  return;
    2d60:	bf00      	nop
}
    2d62:	b007      	add	sp, #28
    2d64:	f85d fb04 	ldr.w	pc, [sp], #4
    2d68:	00004980 	.word	0x00004980
    2d6c:	f3af 8000 	nop.w

00002d70 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2d70:	b082      	sub	sp, #8
    2d72:	2320      	movs	r3, #32
    2d74:	9301      	str	r3, [sp, #4]
    2d76:	9b01      	ldr	r3, [sp, #4]
    2d78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2d7c:	b002      	add	sp, #8
    2d7e:	4770      	bx	lr

00002d80 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2d80:	b082      	sub	sp, #8
    2d82:	2300      	movs	r3, #0
    2d84:	9301      	str	r3, [sp, #4]
    2d86:	9b01      	ldr	r3, [sp, #4]
    2d88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2d8c:	b002      	add	sp, #8
    2d8e:	4770      	bx	lr

00002d90 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    2d90:	b508      	push	{r3, lr}

  port_lock();
    2d92:	f7ff ffed 	bl	2d70 <port_lock>
  _stats_start_measure_crit_thd();
    2d96:	f7fe fed3 	bl	1b40 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    2d9a:	f7fd fdd9 	bl	950 <_dbg_check_lock>
}
    2d9e:	bd08      	pop	{r3, pc}

00002da0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    2da0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    2da2:	f7fd fded 	bl	980 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    2da6:	f7fe fed3 	bl	1b50 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    2daa:	4b09      	ldr	r3, [pc, #36]	; (2dd0 <chSysUnlock+0x30>)
    2dac:	681a      	ldr	r2, [r3, #0]
    2dae:	4b08      	ldr	r3, [pc, #32]	; (2dd0 <chSysUnlock+0x30>)
    2db0:	429a      	cmp	r2, r3
    2db2:	d00a      	beq.n	2dca <chSysUnlock+0x2a>
    2db4:	4b06      	ldr	r3, [pc, #24]	; (2dd0 <chSysUnlock+0x30>)
    2db6:	699b      	ldr	r3, [r3, #24]
    2db8:	689a      	ldr	r2, [r3, #8]
    2dba:	4b05      	ldr	r3, [pc, #20]	; (2dd0 <chSysUnlock+0x30>)
    2dbc:	681b      	ldr	r3, [r3, #0]
    2dbe:	689b      	ldr	r3, [r3, #8]
    2dc0:	429a      	cmp	r2, r3
    2dc2:	d202      	bcs.n	2dca <chSysUnlock+0x2a>
    2dc4:	4803      	ldr	r0, [pc, #12]	; (2dd4 <chSysUnlock+0x34>)
    2dc6:	f7fd fd5b 	bl	880 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    2dca:	f7ff ffd9 	bl	2d80 <port_unlock>
}
    2dce:	bd08      	pop	{r3, pc}
    2dd0:	20000ac0 	.word	0x20000ac0
    2dd4:	00004990 	.word	0x00004990
    2dd8:	f3af 8000 	nop.w
    2ddc:	f3af 8000 	nop.w

00002de0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    2de0:	b500      	push	{lr}
    2de2:	b085      	sub	sp, #20
    2de4:	9001      	str	r0, [sp, #4]
    2de6:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
    2de8:	9b00      	ldr	r3, [sp, #0]
    2dea:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
    2dec:	f7fd fe50 	bl	a90 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
    2df0:	9b01      	ldr	r3, [sp, #4]
    2df2:	2b00      	cmp	r3, #0
    2df4:	d002      	beq.n	2dfc <chPoolFreeI+0x1c>
    2df6:	9b00      	ldr	r3, [sp, #0]
    2df8:	2b00      	cmp	r3, #0
    2dfa:	d102      	bne.n	2e02 <chPoolFreeI+0x22>
    2dfc:	4806      	ldr	r0, [pc, #24]	; (2e18 <chPoolFreeI+0x38>)
    2dfe:	f7fd fd3f 	bl	880 <chSysHalt>

  php->ph_next = mp->mp_next;
    2e02:	9b01      	ldr	r3, [sp, #4]
    2e04:	681a      	ldr	r2, [r3, #0]
    2e06:	9b03      	ldr	r3, [sp, #12]
    2e08:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
    2e0a:	9b01      	ldr	r3, [sp, #4]
    2e0c:	9a03      	ldr	r2, [sp, #12]
    2e0e:	601a      	str	r2, [r3, #0]
}
    2e10:	b005      	add	sp, #20
    2e12:	f85d fb04 	ldr.w	pc, [sp], #4
    2e16:	bf00      	nop
    2e18:	000049a0 	.word	0x000049a0
    2e1c:	f3af 8000 	nop.w

00002e20 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
    2e20:	b500      	push	{lr}
    2e22:	b083      	sub	sp, #12
    2e24:	9001      	str	r0, [sp, #4]
    2e26:	9100      	str	r1, [sp, #0]

  chSysLock();
    2e28:	f7ff ffb2 	bl	2d90 <chSysLock>
  chPoolFreeI(mp, objp);
    2e2c:	9801      	ldr	r0, [sp, #4]
    2e2e:	9900      	ldr	r1, [sp, #0]
    2e30:	f7ff ffd6 	bl	2de0 <chPoolFreeI>
  chSysUnlock();
    2e34:	f7ff ffb4 	bl	2da0 <chSysUnlock>
}
    2e38:	b003      	add	sp, #12
    2e3a:	f85d fb04 	ldr.w	pc, [sp], #4
    2e3e:	bf00      	nop

00002e40 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    2e40:	b082      	sub	sp, #8
    2e42:	2320      	movs	r3, #32
    2e44:	9301      	str	r3, [sp, #4]
    2e46:	9b01      	ldr	r3, [sp, #4]
    2e48:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2e4c:	b002      	add	sp, #8
    2e4e:	4770      	bx	lr

00002e50 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    2e50:	b082      	sub	sp, #8
    2e52:	2300      	movs	r3, #0
    2e54:	9301      	str	r3, [sp, #4]
    2e56:	9b01      	ldr	r3, [sp, #4]
    2e58:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    2e5c:	b002      	add	sp, #8
    2e5e:	4770      	bx	lr

00002e60 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    2e60:	b508      	push	{r3, lr}

  port_lock();
    2e62:	f7ff ffed 	bl	2e40 <port_lock>
}
    2e66:	bd08      	pop	{r3, pc}
    2e68:	f3af 8000 	nop.w
    2e6c:	f3af 8000 	nop.w

00002e70 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    2e70:	b508      	push	{r3, lr}

  port_unlock();
    2e72:	f7ff ffed 	bl	2e50 <port_unlock>
}
    2e76:	bd08      	pop	{r3, pc}
    2e78:	f3af 8000 	nop.w
    2e7c:	f3af 8000 	nop.w

00002e80 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
    2e80:	b510      	push	{r4, lr}
    2e82:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    2e84:	f3ef 8309 	mrs	r3, PSP
    2e88:	461c      	mov	r4, r3
  return(result);
    2e8a:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
    2e8c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
    2e8e:	9b01      	ldr	r3, [sp, #4]
    2e90:	3320      	adds	r3, #32
    2e92:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
    2e94:	9b01      	ldr	r3, [sp, #4]
    2e96:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    2e98:	9b00      	ldr	r3, [sp, #0]
    2e9a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
    2e9e:	f7ff ffe7 	bl	2e70 <port_unlock_from_isr>
}
    2ea2:	b002      	add	sp, #8
    2ea4:	bd10      	pop	{r4, pc}
    2ea6:	bf00      	nop
    2ea8:	f3af 8000 	nop.w
    2eac:	f3af 8000 	nop.w

00002eb0 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
    2eb0:	b510      	push	{r4, lr}
    2eb2:	b082      	sub	sp, #8

  port_lock_from_isr();
    2eb4:	f7ff ffd4 	bl	2e60 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
    2eb8:	4b13      	ldr	r3, [pc, #76]	; (2f08 <_port_irq_epilogue+0x58>)
    2eba:	685b      	ldr	r3, [r3, #4]
    2ebc:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    2ec0:	2b00      	cmp	r3, #0
    2ec2:	d01d      	beq.n	2f00 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    2ec4:	f3ef 8309 	mrs	r3, PSP
    2ec8:	461c      	mov	r4, r3
  return(result);
    2eca:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
    2ecc:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
    2ece:	9b01      	ldr	r3, [sp, #4]
    2ed0:	3b20      	subs	r3, #32
    2ed2:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
    2ed4:	9b01      	ldr	r3, [sp, #4]
    2ed6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    2eda:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
    2edc:	9b01      	ldr	r3, [sp, #4]
    2ede:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    2ee0:	9b00      	ldr	r3, [sp, #0]
    2ee2:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
    2ee6:	f7fe f9ab 	bl	1240 <chSchIsPreemptionRequired>
    2eea:	4603      	mov	r3, r0
    2eec:	2b00      	cmp	r3, #0
    2eee:	d003      	beq.n	2ef8 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    2ef0:	9b01      	ldr	r3, [sp, #4]
    2ef2:	4a06      	ldr	r2, [pc, #24]	; (2f0c <_port_irq_epilogue+0x5c>)
    2ef4:	619a      	str	r2, [r3, #24]
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
    2ef6:	e005      	b.n	2f04 <_port_irq_epilogue+0x54>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    2ef8:	9b01      	ldr	r3, [sp, #4]
    2efa:	4a05      	ldr	r2, [pc, #20]	; (2f10 <_port_irq_epilogue+0x60>)
    2efc:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
    2efe:	e001      	b.n	2f04 <_port_irq_epilogue+0x54>
  }
  port_unlock_from_isr();
    2f00:	f7ff ffb6 	bl	2e70 <port_unlock_from_isr>
}
    2f04:	b002      	add	sp, #8
    2f06:	bd10      	pop	{r4, pc}
    2f08:	e000ed00 	.word	0xe000ed00
    2f0c:	000002a9 	.word	0x000002a9
    2f10:	000002bc 	.word	0x000002bc
    2f14:	f3af 8000 	nop.w
    2f18:	f3af 8000 	nop.w
    2f1c:	f3af 8000 	nop.w

00002f20 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    2f20:	4770      	bx	lr
    2f22:	bf00      	nop
    2f24:	f3af 8000 	nop.w
    2f28:	f3af 8000 	nop.w
    2f2c:	f3af 8000 	nop.w

00002f30 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
    2f30:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    2f32:	f7ff fff5 	bl	2f20 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
    2f36:	f000 facb 	bl	34d0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    2f3a:	4806      	ldr	r0, [pc, #24]	; (2f54 <halInit+0x24>)
    2f3c:	f001 f8a8 	bl	4090 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
    2f40:	f000 f88e 	bl	3060 <adcInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    2f44:	f000 f9e4 	bl	3310 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    2f48:	f001 fba2 	bl	4690 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    2f4c:	f000 f838 	bl	2fc0 <stInit>
#endif
}
    2f50:	bd08      	pop	{r3, pc}
    2f52:	bf00      	nop
    2f54:	00004af0 	.word	0x00004af0
    2f58:	f3af 8000 	nop.w
    2f5c:	f3af 8000 	nop.w

00002f60 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
    2f60:	b082      	sub	sp, #8
    2f62:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
    2f64:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2f68:	9a01      	ldr	r2, [sp, #4]
    2f6a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
    2f6c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2f70:	2200      	movs	r2, #0
    2f72:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
    2f74:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2f78:	2202      	movs	r2, #2
    2f7a:	60da      	str	r2, [r3, #12]
}
    2f7c:	b002      	add	sp, #8
    2f7e:	4770      	bx	lr

00002f80 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
    2f80:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2f84:	2200      	movs	r2, #0
    2f86:	60da      	str	r2, [r3, #12]
}
    2f88:	4770      	bx	lr
    2f8a:	bf00      	nop
    2f8c:	f3af 8000 	nop.w

00002f90 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
    2f90:	b082      	sub	sp, #8
    2f92:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
    2f94:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2f98:	9a01      	ldr	r2, [sp, #4]
    2f9a:	635a      	str	r2, [r3, #52]	; 0x34
}
    2f9c:	b002      	add	sp, #8
    2f9e:	4770      	bx	lr

00002fa0 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
    2fa0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2fa4:	68db      	ldr	r3, [r3, #12]
    2fa6:	f003 0302 	and.w	r3, r3, #2
    2faa:	2b00      	cmp	r3, #0
    2fac:	bf0c      	ite	eq
    2fae:	2300      	moveq	r3, #0
    2fb0:	2301      	movne	r3, #1
    2fb2:	b2db      	uxtb	r3, r3
}
    2fb4:	4618      	mov	r0, r3
    2fb6:	4770      	bx	lr
    2fb8:	f3af 8000 	nop.w
    2fbc:	f3af 8000 	nop.w

00002fc0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
    2fc0:	b508      	push	{r3, lr}

  st_lld_init();
    2fc2:	f000 fe6d 	bl	3ca0 <st_lld_init>
}
    2fc6:	bd08      	pop	{r3, pc}
    2fc8:	f3af 8000 	nop.w
    2fcc:	f3af 8000 	nop.w

00002fd0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
    2fd0:	b500      	push	{lr}
    2fd2:	b083      	sub	sp, #12
    2fd4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
    2fd6:	f7ff ffe3 	bl	2fa0 <st_lld_is_alarm_active>
    2fda:	4603      	mov	r3, r0
    2fdc:	2b00      	cmp	r3, #0
    2fde:	d002      	beq.n	2fe6 <stStartAlarm+0x16>
    2fe0:	4804      	ldr	r0, [pc, #16]	; (2ff4 <stStartAlarm+0x24>)
    2fe2:	f7fd fc4d 	bl	880 <chSysHalt>

  st_lld_start_alarm(abstime);
    2fe6:	9801      	ldr	r0, [sp, #4]
    2fe8:	f7ff ffba 	bl	2f60 <st_lld_start_alarm>
}
    2fec:	b003      	add	sp, #12
    2fee:	f85d fb04 	ldr.w	pc, [sp], #4
    2ff2:	bf00      	nop
    2ff4:	000049b0 	.word	0x000049b0
    2ff8:	f3af 8000 	nop.w
    2ffc:	f3af 8000 	nop.w

00003000 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
    3000:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
    3002:	f7ff ffbd 	bl	2f80 <st_lld_stop_alarm>
}
    3006:	bd08      	pop	{r3, pc}
    3008:	f3af 8000 	nop.w
    300c:	f3af 8000 	nop.w

00003010 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
    3010:	b500      	push	{lr}
    3012:	b083      	sub	sp, #12
    3014:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
    3016:	f7ff ffc3 	bl	2fa0 <st_lld_is_alarm_active>
    301a:	4603      	mov	r3, r0
    301c:	f083 0301 	eor.w	r3, r3, #1
    3020:	b2db      	uxtb	r3, r3
    3022:	2b00      	cmp	r3, #0
    3024:	d002      	beq.n	302c <stSetAlarm+0x1c>
    3026:	4804      	ldr	r0, [pc, #16]	; (3038 <stSetAlarm+0x28>)
    3028:	f7fd fc2a 	bl	880 <chSysHalt>

  st_lld_set_alarm(abstime);
    302c:	9801      	ldr	r0, [sp, #4]
    302e:	f7ff ffaf 	bl	2f90 <st_lld_set_alarm>
}
    3032:	b003      	add	sp, #12
    3034:	f85d fb04 	ldr.w	pc, [sp], #4
    3038:	000049c0 	.word	0x000049c0
    303c:	f3af 8000 	nop.w

00003040 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
    3040:	b500      	push	{lr}
    3042:	b083      	sub	sp, #12
    3044:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
    3046:	9801      	ldr	r0, [sp, #4]
    3048:	f7ff f80a 	bl	2060 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
    304c:	b003      	add	sp, #12
    304e:	f85d fb04 	ldr.w	pc, [sp], #4
    3052:	bf00      	nop
    3054:	f3af 8000 	nop.w
    3058:	f3af 8000 	nop.w
    305c:	f3af 8000 	nop.w

00003060 <adcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void adcInit(void) {
    3060:	b508      	push	{r3, lr}

  adc_lld_init();
    3062:	f000 ff75 	bl	3f50 <adc_lld_init>
}
    3066:	bd08      	pop	{r3, pc}
    3068:	f3af 8000 	nop.w
    306c:	f3af 8000 	nop.w

00003070 <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
    3070:	b500      	push	{lr}
    3072:	b083      	sub	sp, #12
    3074:	9001      	str	r0, [sp, #4]

  adcp->state    = ADC_STOP;
    3076:	9b01      	ldr	r3, [sp, #4]
    3078:	2201      	movs	r2, #1
    307a:	701a      	strb	r2, [r3, #0]
  adcp->config   = NULL;
    307c:	9b01      	ldr	r3, [sp, #4]
    307e:	2200      	movs	r2, #0
    3080:	605a      	str	r2, [r3, #4]
  adcp->samples  = NULL;
    3082:	9b01      	ldr	r3, [sp, #4]
    3084:	2200      	movs	r2, #0
    3086:	609a      	str	r2, [r3, #8]
  adcp->depth    = 0;
    3088:	9b01      	ldr	r3, [sp, #4]
    308a:	2200      	movs	r2, #0
    308c:	60da      	str	r2, [r3, #12]
  adcp->grpp     = NULL;
    308e:	9b01      	ldr	r3, [sp, #4]
    3090:	2200      	movs	r2, #0
    3092:	611a      	str	r2, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
    3094:	9b01      	ldr	r3, [sp, #4]
    3096:	2200      	movs	r2, #0
    3098:	615a      	str	r2, [r3, #20]
#endif
#if ADC_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&adcp->mutex);
    309a:	9b01      	ldr	r3, [sp, #4]
    309c:	3318      	adds	r3, #24
    309e:	4618      	mov	r0, r3
    30a0:	f7ff ffce 	bl	3040 <osalMutexObjectInit>
#endif
#if defined(ADC_DRIVER_EXT_INIT_HOOK)
  ADC_DRIVER_EXT_INIT_HOOK(adcp);
#endif
}
    30a4:	b003      	add	sp, #12
    30a6:	f85d fb04 	ldr.w	pc, [sp], #4
    30aa:	bf00      	nop
    30ac:	f3af 8000 	nop.w

000030b0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    30b0:	b082      	sub	sp, #8
    30b2:	2320      	movs	r3, #32
    30b4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
    30b6:	9b01      	ldr	r3, [sp, #4]
    30b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    30bc:	b002      	add	sp, #8
    30be:	4770      	bx	lr

000030c0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    30c0:	b082      	sub	sp, #8
    30c2:	2300      	movs	r3, #0
    30c4:	9301      	str	r3, [sp, #4]
    30c6:	9b01      	ldr	r3, [sp, #4]
    30c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    30cc:	b002      	add	sp, #8
    30ce:	4770      	bx	lr

000030d0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
    30d0:	b508      	push	{r3, lr}

  port_lock();
    30d2:	f7ff ffed 	bl	30b0 <port_lock>
  _stats_start_measure_crit_thd();
    30d6:	f7fe fd33 	bl	1b40 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
    30da:	f7fd fc39 	bl	950 <_dbg_check_lock>
}
    30de:	bd08      	pop	{r3, pc}

000030e0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
    30e0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
    30e2:	f7fd fc4d 	bl	980 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
    30e6:	f7fe fd33 	bl	1b50 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
    30ea:	4b09      	ldr	r3, [pc, #36]	; (3110 <chSysUnlock+0x30>)
    30ec:	681a      	ldr	r2, [r3, #0]
    30ee:	4b08      	ldr	r3, [pc, #32]	; (3110 <chSysUnlock+0x30>)
    30f0:	429a      	cmp	r2, r3
    30f2:	d00a      	beq.n	310a <chSysUnlock+0x2a>
    30f4:	4b06      	ldr	r3, [pc, #24]	; (3110 <chSysUnlock+0x30>)
    30f6:	699b      	ldr	r3, [r3, #24]
    30f8:	689a      	ldr	r2, [r3, #8]
    30fa:	4b05      	ldr	r3, [pc, #20]	; (3110 <chSysUnlock+0x30>)
    30fc:	681b      	ldr	r3, [r3, #0]
    30fe:	689b      	ldr	r3, [r3, #8]
    3100:	429a      	cmp	r2, r3
    3102:	d202      	bcs.n	310a <chSysUnlock+0x2a>
    3104:	4803      	ldr	r0, [pc, #12]	; (3114 <chSysUnlock+0x34>)
    3106:	f7fd fbbb 	bl	880 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
    310a:	f7ff ffd9 	bl	30c0 <port_unlock>
}
    310e:	bd08      	pop	{r3, pc}
    3110:	20000ac0 	.word	0x20000ac0
    3114:	00004a00 	.word	0x00004a00
    3118:	f3af 8000 	nop.w
    311c:	f3af 8000 	nop.w

00003120 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
    3120:	b082      	sub	sp, #8
    3122:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
    3124:	9b01      	ldr	r3, [sp, #4]
    3126:	9a01      	ldr	r2, [sp, #4]
    3128:	601a      	str	r2, [r3, #0]
}
    312a:	b002      	add	sp, #8
    312c:	4770      	bx	lr
    312e:	bf00      	nop

00003130 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
    3130:	b500      	push	{lr}
    3132:	b083      	sub	sp, #12
    3134:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    3136:	f7fd fcab 	bl	a90 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
    313a:	9b01      	ldr	r3, [sp, #4]
    313c:	689b      	ldr	r3, [r3, #8]
    313e:	2b00      	cmp	r3, #0
    3140:	bf14      	ite	ne
    3142:	2300      	movne	r3, #0
    3144:	2301      	moveq	r3, #1
    3146:	b2db      	uxtb	r3, r3
}
    3148:	4618      	mov	r0, r3
    314a:	b003      	add	sp, #12
    314c:	f85d fb04 	ldr.w	pc, [sp], #4

00003150 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
    3150:	b508      	push	{r3, lr}

  chSysLock();
    3152:	f7ff ffbd 	bl	30d0 <chSysLock>
}
    3156:	bd08      	pop	{r3, pc}
    3158:	f3af 8000 	nop.w
    315c:	f3af 8000 	nop.w

00003160 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
    3160:	b508      	push	{r3, lr}

  chSysUnlock();
    3162:	f7ff ffbd 	bl	30e0 <chSysUnlock>
}
    3166:	bd08      	pop	{r3, pc}
    3168:	f3af 8000 	nop.w
    316c:	f3af 8000 	nop.w

00003170 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    3170:	b500      	push	{lr}
    3172:	b083      	sub	sp, #12
    3174:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
    3176:	9801      	ldr	r0, [sp, #4]
    3178:	f7ff ffd2 	bl	3120 <chEvtObjectInit>
}
    317c:	b003      	add	sp, #12
    317e:	f85d fb04 	ldr.w	pc, [sp], #4
    3182:	bf00      	nop
    3184:	f3af 8000 	nop.w
    3188:	f3af 8000 	nop.w
    318c:	f3af 8000 	nop.w

00003190 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    3190:	b500      	push	{lr}
    3192:	b083      	sub	sp, #12
    3194:	9001      	str	r0, [sp, #4]
    3196:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
    3198:	9801      	ldr	r0, [sp, #4]
    319a:	9900      	ldr	r1, [sp, #0]
    319c:	f7ff f880 	bl	22a0 <chEvtBroadcastFlagsI>
}
    31a0:	b003      	add	sp, #12
    31a2:	f85d fb04 	ldr.w	pc, [sp], #4
    31a6:	bf00      	nop
    31a8:	f3af 8000 	nop.w
    31ac:	f3af 8000 	nop.w

000031b0 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    31b0:	b500      	push	{lr}
    31b2:	b085      	sub	sp, #20
    31b4:	9003      	str	r0, [sp, #12]
    31b6:	9102      	str	r1, [sp, #8]
    31b8:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    31ba:	9b03      	ldr	r3, [sp, #12]
    31bc:	3330      	adds	r3, #48	; 0x30
    31be:	4618      	mov	r0, r3
    31c0:	9902      	ldr	r1, [sp, #8]
    31c2:	9a01      	ldr	r2, [sp, #4]
    31c4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    31c8:	f7ff fc52 	bl	2a70 <chOQWriteTimeout>
    31cc:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
    31ce:	4618      	mov	r0, r3
    31d0:	b005      	add	sp, #20
    31d2:	f85d fb04 	ldr.w	pc, [sp], #4
    31d6:	bf00      	nop
    31d8:	f3af 8000 	nop.w
    31dc:	f3af 8000 	nop.w

000031e0 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    31e0:	b500      	push	{lr}
    31e2:	b085      	sub	sp, #20
    31e4:	9003      	str	r0, [sp, #12]
    31e6:	9102      	str	r1, [sp, #8]
    31e8:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    31ea:	9b03      	ldr	r3, [sp, #12]
    31ec:	330c      	adds	r3, #12
    31ee:	4618      	mov	r0, r3
    31f0:	9902      	ldr	r1, [sp, #8]
    31f2:	9a01      	ldr	r2, [sp, #4]
    31f4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    31f8:	f7ff fb3a 	bl	2870 <chIQReadTimeout>
    31fc:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
    31fe:	4618      	mov	r0, r3
    3200:	b005      	add	sp, #20
    3202:	f85d fb04 	ldr.w	pc, [sp], #4
    3206:	bf00      	nop
    3208:	f3af 8000 	nop.w
    320c:	f3af 8000 	nop.w

00003210 <put>:

static msg_t put(void *ip, uint8_t b) {
    3210:	b500      	push	{lr}
    3212:	b083      	sub	sp, #12
    3214:	9001      	str	r0, [sp, #4]
    3216:	460b      	mov	r3, r1
    3218:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    321c:	9b01      	ldr	r3, [sp, #4]
    321e:	f103 0230 	add.w	r2, r3, #48	; 0x30
    3222:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3226:	4610      	mov	r0, r2
    3228:	4619      	mov	r1, r3
    322a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    322e:	f7ff fba7 	bl	2980 <chOQPutTimeout>
    3232:	4603      	mov	r3, r0
}
    3234:	4618      	mov	r0, r3
    3236:	b003      	add	sp, #12
    3238:	f85d fb04 	ldr.w	pc, [sp], #4
    323c:	f3af 8000 	nop.w

00003240 <get>:

static msg_t get(void *ip) {
    3240:	b500      	push	{lr}
    3242:	b083      	sub	sp, #12
    3244:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    3246:	9b01      	ldr	r3, [sp, #4]
    3248:	330c      	adds	r3, #12
    324a:	4618      	mov	r0, r3
    324c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3250:	f7ff fac6 	bl	27e0 <chIQGetTimeout>
    3254:	4603      	mov	r3, r0
}
    3256:	4618      	mov	r0, r3
    3258:	b003      	add	sp, #12
    325a:	f85d fb04 	ldr.w	pc, [sp], #4
    325e:	bf00      	nop

00003260 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    3260:	b500      	push	{lr}
    3262:	b085      	sub	sp, #20
    3264:	9003      	str	r0, [sp, #12]
    3266:	460b      	mov	r3, r1
    3268:	9201      	str	r2, [sp, #4]
    326a:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    326e:	9b03      	ldr	r3, [sp, #12]
    3270:	f103 0230 	add.w	r2, r3, #48	; 0x30
    3274:	f89d 300b 	ldrb.w	r3, [sp, #11]
    3278:	4610      	mov	r0, r2
    327a:	4619      	mov	r1, r3
    327c:	9a01      	ldr	r2, [sp, #4]
    327e:	f7ff fb7f 	bl	2980 <chOQPutTimeout>
    3282:	4603      	mov	r3, r0
}
    3284:	4618      	mov	r0, r3
    3286:	b005      	add	sp, #20
    3288:	f85d fb04 	ldr.w	pc, [sp], #4
    328c:	f3af 8000 	nop.w

00003290 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    3290:	b500      	push	{lr}
    3292:	b083      	sub	sp, #12
    3294:	9001      	str	r0, [sp, #4]
    3296:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    3298:	9b01      	ldr	r3, [sp, #4]
    329a:	330c      	adds	r3, #12
    329c:	4618      	mov	r0, r3
    329e:	9900      	ldr	r1, [sp, #0]
    32a0:	f7ff fa9e 	bl	27e0 <chIQGetTimeout>
    32a4:	4603      	mov	r3, r0
}
    32a6:	4618      	mov	r0, r3
    32a8:	b003      	add	sp, #12
    32aa:	f85d fb04 	ldr.w	pc, [sp], #4
    32ae:	bf00      	nop

000032b0 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    32b0:	b500      	push	{lr}
    32b2:	b085      	sub	sp, #20
    32b4:	9003      	str	r0, [sp, #12]
    32b6:	9102      	str	r1, [sp, #8]
    32b8:	9201      	str	r2, [sp, #4]
    32ba:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    32bc:	9b03      	ldr	r3, [sp, #12]
    32be:	3330      	adds	r3, #48	; 0x30
    32c0:	4618      	mov	r0, r3
    32c2:	9902      	ldr	r1, [sp, #8]
    32c4:	9a01      	ldr	r2, [sp, #4]
    32c6:	9b00      	ldr	r3, [sp, #0]
    32c8:	f7ff fbd2 	bl	2a70 <chOQWriteTimeout>
    32cc:	4603      	mov	r3, r0
}
    32ce:	4618      	mov	r0, r3
    32d0:	b005      	add	sp, #20
    32d2:	f85d fb04 	ldr.w	pc, [sp], #4
    32d6:	bf00      	nop
    32d8:	f3af 8000 	nop.w
    32dc:	f3af 8000 	nop.w

000032e0 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    32e0:	b500      	push	{lr}
    32e2:	b085      	sub	sp, #20
    32e4:	9003      	str	r0, [sp, #12]
    32e6:	9102      	str	r1, [sp, #8]
    32e8:	9201      	str	r2, [sp, #4]
    32ea:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    32ec:	9b03      	ldr	r3, [sp, #12]
    32ee:	330c      	adds	r3, #12
    32f0:	4618      	mov	r0, r3
    32f2:	9902      	ldr	r1, [sp, #8]
    32f4:	9a01      	ldr	r2, [sp, #4]
    32f6:	9b00      	ldr	r3, [sp, #0]
    32f8:	f7ff faba 	bl	2870 <chIQReadTimeout>
    32fc:	4603      	mov	r3, r0
}
    32fe:	4618      	mov	r0, r3
    3300:	b005      	add	sp, #20
    3302:	f85d fb04 	ldr.w	pc, [sp], #4
    3306:	bf00      	nop
    3308:	f3af 8000 	nop.w
    330c:	f3af 8000 	nop.w

00003310 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
    3310:	b508      	push	{r3, lr}

  sd_lld_init();
    3312:	f001 f975 	bl	4600 <sd_lld_init>
}
    3316:	bd08      	pop	{r3, pc}
    3318:	f3af 8000 	nop.w
    331c:	f3af 8000 	nop.w

00003320 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    3320:	b500      	push	{lr}
    3322:	b087      	sub	sp, #28
    3324:	9005      	str	r0, [sp, #20]
    3326:	9104      	str	r1, [sp, #16]
    3328:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
    332a:	9b05      	ldr	r3, [sp, #20]
    332c:	4a13      	ldr	r2, [pc, #76]	; (337c <sdObjectInit+0x5c>)
    332e:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
    3330:	9b05      	ldr	r3, [sp, #20]
    3332:	3304      	adds	r3, #4
    3334:	4618      	mov	r0, r3
    3336:	f7ff ff1b 	bl	3170 <osalEventObjectInit>
  sdp->state = SD_STOP;
    333a:	9b05      	ldr	r3, [sp, #20]
    333c:	2201      	movs	r2, #1
    333e:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    3340:	9b05      	ldr	r3, [sp, #20]
    3342:	f103 020c 	add.w	r2, r3, #12
    3346:	9b05      	ldr	r3, [sp, #20]
    3348:	3354      	adds	r3, #84	; 0x54
    334a:	9905      	ldr	r1, [sp, #20]
    334c:	9100      	str	r1, [sp, #0]
    334e:	4610      	mov	r0, r2
    3350:	4619      	mov	r1, r3
    3352:	2220      	movs	r2, #32
    3354:	9b04      	ldr	r3, [sp, #16]
    3356:	f7ff f9e3 	bl	2720 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    335a:	9b05      	ldr	r3, [sp, #20]
    335c:	f103 0230 	add.w	r2, r3, #48	; 0x30
    3360:	9b05      	ldr	r3, [sp, #20]
    3362:	3374      	adds	r3, #116	; 0x74
    3364:	9905      	ldr	r1, [sp, #20]
    3366:	9100      	str	r1, [sp, #0]
    3368:	4610      	mov	r0, r2
    336a:	4619      	mov	r1, r3
    336c:	2220      	movs	r2, #32
    336e:	9b03      	ldr	r3, [sp, #12]
    3370:	f7ff fade 	bl	2930 <chOQObjectInit>
}
    3374:	b007      	add	sp, #28
    3376:	f85d fb04 	ldr.w	pc, [sp], #4
    337a:	bf00      	nop
    337c:	000049d0 	.word	0x000049d0

00003380 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    3380:	b500      	push	{lr}
    3382:	b083      	sub	sp, #12
    3384:	9001      	str	r0, [sp, #4]
    3386:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);
    3388:	9b01      	ldr	r3, [sp, #4]
    338a:	2b00      	cmp	r3, #0
    338c:	d102      	bne.n	3394 <sdStart+0x14>
    338e:	480e      	ldr	r0, [pc, #56]	; (33c8 <sdStart+0x48>)
    3390:	f7fd fa76 	bl	880 <chSysHalt>

  osalSysLock();
    3394:	f7ff fedc 	bl	3150 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
    3398:	9b01      	ldr	r3, [sp, #4]
    339a:	7a1b      	ldrb	r3, [r3, #8]
    339c:	2b01      	cmp	r3, #1
    339e:	d006      	beq.n	33ae <sdStart+0x2e>
    33a0:	9b01      	ldr	r3, [sp, #4]
    33a2:	7a1b      	ldrb	r3, [r3, #8]
    33a4:	2b02      	cmp	r3, #2
    33a6:	d002      	beq.n	33ae <sdStart+0x2e>
    33a8:	4807      	ldr	r0, [pc, #28]	; (33c8 <sdStart+0x48>)
    33aa:	f7fd fa69 	bl	880 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
    33ae:	9801      	ldr	r0, [sp, #4]
    33b0:	9900      	ldr	r1, [sp, #0]
    33b2:	f001 f93d 	bl	4630 <sd_lld_start>
  sdp->state = SD_READY;
    33b6:	9b01      	ldr	r3, [sp, #4]
    33b8:	2202      	movs	r2, #2
    33ba:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
    33bc:	f7ff fed0 	bl	3160 <osalSysUnlock>
}
    33c0:	b003      	add	sp, #12
    33c2:	f85d fb04 	ldr.w	pc, [sp], #4
    33c6:	bf00      	nop
    33c8:	000049f0 	.word	0x000049f0
    33cc:	f3af 8000 	nop.w

000033d0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    33d0:	b500      	push	{lr}
    33d2:	b083      	sub	sp, #12
    33d4:	9001      	str	r0, [sp, #4]
    33d6:	460b      	mov	r3, r1
    33d8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
    33dc:	f7fd fb58 	bl	a90 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
    33e0:	9b01      	ldr	r3, [sp, #4]
    33e2:	2b00      	cmp	r3, #0
    33e4:	d102      	bne.n	33ec <sdIncomingDataI+0x1c>
    33e6:	4813      	ldr	r0, [pc, #76]	; (3434 <sdIncomingDataI+0x64>)
    33e8:	f7fd fa4a 	bl	880 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
    33ec:	9b01      	ldr	r3, [sp, #4]
    33ee:	330c      	adds	r3, #12
    33f0:	4618      	mov	r0, r3
    33f2:	f7ff fe9d 	bl	3130 <chIQIsEmptyI>
    33f6:	4603      	mov	r3, r0
    33f8:	2b00      	cmp	r3, #0
    33fa:	d005      	beq.n	3408 <sdIncomingDataI+0x38>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    33fc:	9b01      	ldr	r3, [sp, #4]
    33fe:	3304      	adds	r3, #4
    3400:	4618      	mov	r0, r3
    3402:	2104      	movs	r1, #4
    3404:	f7ff fec4 	bl	3190 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
    3408:	9b01      	ldr	r3, [sp, #4]
    340a:	f103 020c 	add.w	r2, r3, #12
    340e:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3412:	4610      	mov	r0, r2
    3414:	4619      	mov	r1, r3
    3416:	f7ff f9ab 	bl	2770 <chIQPutI>
    341a:	4603      	mov	r3, r0
    341c:	2b00      	cmp	r3, #0
    341e:	da05      	bge.n	342c <sdIncomingDataI+0x5c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    3420:	9b01      	ldr	r3, [sp, #4]
    3422:	3304      	adds	r3, #4
    3424:	4618      	mov	r0, r3
    3426:	2180      	movs	r1, #128	; 0x80
    3428:	f7ff feb2 	bl	3190 <osalEventBroadcastFlagsI>
}
    342c:	b003      	add	sp, #12
    342e:	f85d fb04 	ldr.w	pc, [sp], #4
    3432:	bf00      	nop
    3434:	00004a10 	.word	0x00004a10
    3438:	f3af 8000 	nop.w
    343c:	f3af 8000 	nop.w

00003440 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
    3440:	b082      	sub	sp, #8
    3442:	9001      	str	r0, [sp, #4]
    3444:	9100      	str	r1, [sp, #0]

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
    3446:	4911      	ldr	r1, [pc, #68]	; (348c <nvicEnableVector+0x4c>)
    3448:	9b00      	ldr	r3, [sp, #0]
    344a:	b2db      	uxtb	r3, r3
    344c:	011b      	lsls	r3, r3, #4
    344e:	b2da      	uxtb	r2, r3
    3450:	9b01      	ldr	r3, [sp, #4]
    3452:	440b      	add	r3, r1
    3454:	f503 7340 	add.w	r3, r3, #768	; 0x300
    3458:	701a      	strb	r2, [r3, #0]
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
    345a:	4b0c      	ldr	r3, [pc, #48]	; (348c <nvicEnableVector+0x4c>)
    345c:	9a01      	ldr	r2, [sp, #4]
    345e:	0952      	lsrs	r2, r2, #5
    3460:	9901      	ldr	r1, [sp, #4]
    3462:	f001 011f 	and.w	r1, r1, #31
    3466:	2001      	movs	r0, #1
    3468:	fa00 f101 	lsl.w	r1, r0, r1
    346c:	3260      	adds	r2, #96	; 0x60
    346e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
    3472:	4b06      	ldr	r3, [pc, #24]	; (348c <nvicEnableVector+0x4c>)
    3474:	9a01      	ldr	r2, [sp, #4]
    3476:	0952      	lsrs	r2, r2, #5
    3478:	9901      	ldr	r1, [sp, #4]
    347a:	f001 011f 	and.w	r1, r1, #31
    347e:	2001      	movs	r0, #1
    3480:	fa00 f101 	lsl.w	r1, r0, r1
    3484:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    3488:	b002      	add	sp, #8
    348a:	4770      	bx	lr
    348c:	e000e100 	.word	0xe000e100

00003490 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
    3490:	4b0d      	ldr	r3, [pc, #52]	; (34c8 <hal_lld_backup_domain_init+0x38>)
    3492:	4a0d      	ldr	r2, [pc, #52]	; (34c8 <hal_lld_backup_domain_init+0x38>)
    3494:	6812      	ldr	r2, [r2, #0]
    3496:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    349a:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
    349c:	4b0b      	ldr	r3, [pc, #44]	; (34cc <hal_lld_backup_domain_init+0x3c>)
    349e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    34a0:	f403 7340 	and.w	r3, r3, #768	; 0x300
    34a4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    34a8:	d006      	beq.n	34b8 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
    34aa:	4b08      	ldr	r3, [pc, #32]	; (34cc <hal_lld_backup_domain_init+0x3c>)
    34ac:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    34b0:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
    34b2:	4b06      	ldr	r3, [pc, #24]	; (34cc <hal_lld_backup_domain_init+0x3c>)
    34b4:	2200      	movs	r2, #0
    34b6:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
    34b8:	4b03      	ldr	r3, [pc, #12]	; (34c8 <hal_lld_backup_domain_init+0x38>)
    34ba:	4a03      	ldr	r2, [pc, #12]	; (34c8 <hal_lld_backup_domain_init+0x38>)
    34bc:	6852      	ldr	r2, [r2, #4]
    34be:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    34c2:	605a      	str	r2, [r3, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
    34c4:	4770      	bx	lr
    34c6:	bf00      	nop
    34c8:	40007000 	.word	0x40007000
    34cc:	40023800 	.word	0x40023800

000034d0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
    34d0:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
    34d2:	4b17      	ldr	r3, [pc, #92]	; (3530 <hal_lld_init+0x60>)
    34d4:	691b      	ldr	r3, [r3, #16]
    34d6:	4b16      	ldr	r3, [pc, #88]	; (3530 <hal_lld_init+0x60>)
    34d8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    34dc:	611a      	str	r2, [r3, #16]
    34de:	4b14      	ldr	r3, [pc, #80]	; (3530 <hal_lld_init+0x60>)
    34e0:	2200      	movs	r2, #0
    34e2:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
    34e4:	4b12      	ldr	r3, [pc, #72]	; (3530 <hal_lld_init+0x60>)
    34e6:	695b      	ldr	r3, [r3, #20]
    34e8:	4b11      	ldr	r3, [pc, #68]	; (3530 <hal_lld_init+0x60>)
    34ea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    34ee:	615a      	str	r2, [r3, #20]
    34f0:	4b0f      	ldr	r3, [pc, #60]	; (3530 <hal_lld_init+0x60>)
    34f2:	2200      	movs	r2, #0
    34f4:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
    34f6:	4b0e      	ldr	r3, [pc, #56]	; (3530 <hal_lld_init+0x60>)
    34f8:	4a0d      	ldr	r2, [pc, #52]	; (3530 <hal_lld_init+0x60>)
    34fa:	6a12      	ldr	r2, [r2, #32]
    34fc:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
    3500:	621a      	str	r2, [r3, #32]
    3502:	4b0b      	ldr	r3, [pc, #44]	; (3530 <hal_lld_init+0x60>)
    3504:	2200      	movs	r2, #0
    3506:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
    3508:	4b09      	ldr	r3, [pc, #36]	; (3530 <hal_lld_init+0x60>)
    350a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    350c:	4b08      	ldr	r3, [pc, #32]	; (3530 <hal_lld_init+0x60>)
    350e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3512:	625a      	str	r2, [r3, #36]	; 0x24
    3514:	4b06      	ldr	r3, [pc, #24]	; (3530 <hal_lld_init+0x60>)
    3516:	2200      	movs	r2, #0
    3518:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
    351a:	4b05      	ldr	r3, [pc, #20]	; (3530 <hal_lld_init+0x60>)
    351c:	4a04      	ldr	r2, [pc, #16]	; (3530 <hal_lld_init+0x60>)
    351e:	6c12      	ldr	r2, [r2, #64]	; 0x40
    3520:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    3524:	641a      	str	r2, [r3, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
    3526:	f7ff ffb3 	bl	3490 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
    352a:	f000 fb19 	bl	3b60 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
    352e:	bd08      	pop	{r3, pc}
    3530:	40023800 	.word	0x40023800
    3534:	f3af 8000 	nop.w
    3538:	f3af 8000 	nop.w
    353c:	f3af 8000 	nop.w

00003540 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
    3540:	4b40      	ldr	r3, [pc, #256]	; (3644 <stm32_clock_init+0x104>)
    3542:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    3546:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
    3548:	4b3f      	ldr	r3, [pc, #252]	; (3648 <stm32_clock_init+0x108>)
    354a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    354e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
    3550:	4b3c      	ldr	r3, [pc, #240]	; (3644 <stm32_clock_init+0x104>)
    3552:	4a3c      	ldr	r2, [pc, #240]	; (3644 <stm32_clock_init+0x104>)
    3554:	6812      	ldr	r2, [r2, #0]
    3556:	f042 0201 	orr.w	r2, r2, #1
    355a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
    355c:	bf00      	nop
    355e:	4b39      	ldr	r3, [pc, #228]	; (3644 <stm32_clock_init+0x104>)
    3560:	681b      	ldr	r3, [r3, #0]
    3562:	f003 0302 	and.w	r3, r3, #2
    3566:	2b00      	cmp	r3, #0
    3568:	d0f9      	beq.n	355e <stm32_clock_init+0x1e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
    356a:	4b36      	ldr	r3, [pc, #216]	; (3644 <stm32_clock_init+0x104>)
    356c:	4a35      	ldr	r2, [pc, #212]	; (3644 <stm32_clock_init+0x104>)
    356e:	6892      	ldr	r2, [r2, #8]
    3570:	f022 0203 	bic.w	r2, r2, #3
    3574:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
    3576:	4b33      	ldr	r3, [pc, #204]	; (3644 <stm32_clock_init+0x104>)
    3578:	4a32      	ldr	r2, [pc, #200]	; (3644 <stm32_clock_init+0x104>)
    357a:	6892      	ldr	r2, [r2, #8]
    357c:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
    357e:	bf00      	nop
    3580:	4b30      	ldr	r3, [pc, #192]	; (3644 <stm32_clock_init+0x104>)
    3582:	689b      	ldr	r3, [r3, #8]
    3584:	f003 030c 	and.w	r3, r3, #12
    3588:	2b00      	cmp	r3, #0
    358a:	d1f9      	bne.n	3580 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
    358c:	4b2d      	ldr	r3, [pc, #180]	; (3644 <stm32_clock_init+0x104>)
    358e:	4a2d      	ldr	r2, [pc, #180]	; (3644 <stm32_clock_init+0x104>)
    3590:	6812      	ldr	r2, [r2, #0]
    3592:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
    3596:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
    3598:	4b2a      	ldr	r3, [pc, #168]	; (3644 <stm32_clock_init+0x104>)
    359a:	2200      	movs	r2, #0
    359c:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
    359e:	4b29      	ldr	r3, [pc, #164]	; (3644 <stm32_clock_init+0x104>)
    35a0:	4a28      	ldr	r2, [pc, #160]	; (3644 <stm32_clock_init+0x104>)
    35a2:	6812      	ldr	r2, [r2, #0]
    35a4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    35a8:	601a      	str	r2, [r3, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
    35aa:	bf00      	nop
    35ac:	4b25      	ldr	r3, [pc, #148]	; (3644 <stm32_clock_init+0x104>)
    35ae:	681b      	ldr	r3, [r3, #0]
    35b0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    35b4:	2b00      	cmp	r3, #0
    35b6:	d0f9      	beq.n	35ac <stm32_clock_init+0x6c>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
    35b8:	4b22      	ldr	r3, [pc, #136]	; (3644 <stm32_clock_init+0x104>)
    35ba:	4a22      	ldr	r2, [pc, #136]	; (3644 <stm32_clock_init+0x104>)
    35bc:	6f52      	ldr	r2, [r2, #116]	; 0x74
    35be:	f042 0201 	orr.w	r2, r2, #1
    35c2:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
    35c4:	bf00      	nop
    35c6:	4b1f      	ldr	r3, [pc, #124]	; (3644 <stm32_clock_init+0x104>)
    35c8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    35ca:	f003 0302 	and.w	r3, r3, #2
    35ce:	2b00      	cmp	r3, #0
    35d0:	d0f9      	beq.n	35c6 <stm32_clock_init+0x86>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
    35d2:	4b1c      	ldr	r3, [pc, #112]	; (3644 <stm32_clock_init+0x104>)
    35d4:	4a1d      	ldr	r2, [pc, #116]	; (364c <stm32_clock_init+0x10c>)
    35d6:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
    35d8:	4b1a      	ldr	r3, [pc, #104]	; (3644 <stm32_clock_init+0x104>)
    35da:	4a1a      	ldr	r2, [pc, #104]	; (3644 <stm32_clock_init+0x104>)
    35dc:	6812      	ldr	r2, [r2, #0]
    35de:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    35e2:	601a      	str	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
    35e4:	bf00      	nop
    35e6:	4b18      	ldr	r3, [pc, #96]	; (3648 <stm32_clock_init+0x108>)
    35e8:	685b      	ldr	r3, [r3, #4]
    35ea:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    35ee:	2b00      	cmp	r3, #0
    35f0:	d0f9      	beq.n	35e6 <stm32_clock_init+0xa6>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
    35f2:	bf00      	nop
    35f4:	4b13      	ldr	r3, [pc, #76]	; (3644 <stm32_clock_init+0x104>)
    35f6:	681b      	ldr	r3, [r3, #0]
    35f8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    35fc:	2b00      	cmp	r3, #0
    35fe:	d0f9      	beq.n	35f4 <stm32_clock_init+0xb4>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
    3600:	4b10      	ldr	r3, [pc, #64]	; (3644 <stm32_clock_init+0x104>)
    3602:	4a13      	ldr	r2, [pc, #76]	; (3650 <stm32_clock_init+0x110>)
    3604:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
    3606:	4b13      	ldr	r3, [pc, #76]	; (3654 <stm32_clock_init+0x114>)
    3608:	f240 7205 	movw	r2, #1797	; 0x705
    360c:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
    360e:	4b0d      	ldr	r3, [pc, #52]	; (3644 <stm32_clock_init+0x104>)
    3610:	4a0c      	ldr	r2, [pc, #48]	; (3644 <stm32_clock_init+0x104>)
    3612:	6892      	ldr	r2, [r2, #8]
    3614:	f042 0202 	orr.w	r2, r2, #2
    3618:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
    361a:	bf00      	nop
    361c:	4b09      	ldr	r3, [pc, #36]	; (3644 <stm32_clock_init+0x104>)
    361e:	689b      	ldr	r3, [r3, #8]
    3620:	f003 030c 	and.w	r3, r3, #12
    3624:	2b08      	cmp	r3, #8
    3626:	d1f9      	bne.n	361c <stm32_clock_init+0xdc>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
    3628:	4b06      	ldr	r3, [pc, #24]	; (3644 <stm32_clock_init+0x104>)
    362a:	4a06      	ldr	r2, [pc, #24]	; (3644 <stm32_clock_init+0x104>)
    362c:	6c52      	ldr	r2, [r2, #68]	; 0x44
    362e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    3632:	645a      	str	r2, [r3, #68]	; 0x44
    3634:	4b03      	ldr	r3, [pc, #12]	; (3644 <stm32_clock_init+0x104>)
    3636:	4a03      	ldr	r2, [pc, #12]	; (3644 <stm32_clock_init+0x104>)
    3638:	6e52      	ldr	r2, [r2, #100]	; 0x64
    363a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    363e:	665a      	str	r2, [r3, #100]	; 0x64
}
    3640:	4770      	bx	lr
    3642:	bf00      	nop
    3644:	40023800 	.word	0x40023800
    3648:	40007000 	.word	0x40007000
    364c:	07405408 	.word	0x07405408
    3650:	38089400 	.word	0x38089400
    3654:	40023c00 	.word	0x40023c00
    3658:	f3af 8000 	nop.w
    365c:	f3af 8000 	nop.w

00003660 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
    3660:	b500      	push	{lr}
    3662:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3664:	f7fe fa3c 	bl	1ae0 <_stats_increase_irq>
    3668:	f7fd f9d2 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
    366c:	4b0c      	ldr	r3, [pc, #48]	; (36a0 <Vector6C+0x40>)
    366e:	681b      	ldr	r3, [r3, #0]
    3670:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3674:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
    3676:	4b0a      	ldr	r3, [pc, #40]	; (36a0 <Vector6C+0x40>)
    3678:	9a01      	ldr	r2, [sp, #4]
    367a:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[0].dma_func)
    367c:	4b09      	ldr	r3, [pc, #36]	; (36a4 <Vector6C+0x44>)
    367e:	681b      	ldr	r3, [r3, #0]
    3680:	2b00      	cmp	r3, #0
    3682:	d006      	beq.n	3692 <Vector6C+0x32>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
    3684:	4b07      	ldr	r3, [pc, #28]	; (36a4 <Vector6C+0x44>)
    3686:	681b      	ldr	r3, [r3, #0]
    3688:	4a06      	ldr	r2, [pc, #24]	; (36a4 <Vector6C+0x44>)
    368a:	6852      	ldr	r2, [r2, #4]
    368c:	4610      	mov	r0, r2
    368e:	9901      	ldr	r1, [sp, #4]
    3690:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3692:	f7fd f9dd 	bl	a50 <_dbg_check_leave_isr>
    3696:	f7ff fc0b 	bl	2eb0 <_port_irq_epilogue>
}
    369a:	b003      	add	sp, #12
    369c:	f85d fb04 	ldr.w	pc, [sp], #4
    36a0:	40026000 	.word	0x40026000
    36a4:	200010c4 	.word	0x200010c4
    36a8:	f3af 8000 	nop.w
    36ac:	f3af 8000 	nop.w

000036b0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
    36b0:	b500      	push	{lr}
    36b2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    36b4:	f7fe fa14 	bl	1ae0 <_stats_increase_irq>
    36b8:	f7fd f9aa 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
    36bc:	4b0d      	ldr	r3, [pc, #52]	; (36f4 <Vector70+0x44>)
    36be:	681b      	ldr	r3, [r3, #0]
    36c0:	099b      	lsrs	r3, r3, #6
    36c2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    36c6:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
    36c8:	4b0a      	ldr	r3, [pc, #40]	; (36f4 <Vector70+0x44>)
    36ca:	9a01      	ldr	r2, [sp, #4]
    36cc:	0192      	lsls	r2, r2, #6
    36ce:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[1].dma_func)
    36d0:	4b09      	ldr	r3, [pc, #36]	; (36f8 <Vector70+0x48>)
    36d2:	689b      	ldr	r3, [r3, #8]
    36d4:	2b00      	cmp	r3, #0
    36d6:	d006      	beq.n	36e6 <Vector70+0x36>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
    36d8:	4b07      	ldr	r3, [pc, #28]	; (36f8 <Vector70+0x48>)
    36da:	689b      	ldr	r3, [r3, #8]
    36dc:	4a06      	ldr	r2, [pc, #24]	; (36f8 <Vector70+0x48>)
    36de:	68d2      	ldr	r2, [r2, #12]
    36e0:	4610      	mov	r0, r2
    36e2:	9901      	ldr	r1, [sp, #4]
    36e4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    36e6:	f7fd f9b3 	bl	a50 <_dbg_check_leave_isr>
    36ea:	f7ff fbe1 	bl	2eb0 <_port_irq_epilogue>
}
    36ee:	b003      	add	sp, #12
    36f0:	f85d fb04 	ldr.w	pc, [sp], #4
    36f4:	40026000 	.word	0x40026000
    36f8:	200010c4 	.word	0x200010c4
    36fc:	f3af 8000 	nop.w

00003700 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
    3700:	b500      	push	{lr}
    3702:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3704:	f7fe f9ec 	bl	1ae0 <_stats_increase_irq>
    3708:	f7fd f982 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
    370c:	4b0d      	ldr	r3, [pc, #52]	; (3744 <Vector74+0x44>)
    370e:	681b      	ldr	r3, [r3, #0]
    3710:	0c1b      	lsrs	r3, r3, #16
    3712:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3716:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
    3718:	4b0a      	ldr	r3, [pc, #40]	; (3744 <Vector74+0x44>)
    371a:	9a01      	ldr	r2, [sp, #4]
    371c:	0412      	lsls	r2, r2, #16
    371e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[2].dma_func)
    3720:	4b09      	ldr	r3, [pc, #36]	; (3748 <Vector74+0x48>)
    3722:	691b      	ldr	r3, [r3, #16]
    3724:	2b00      	cmp	r3, #0
    3726:	d006      	beq.n	3736 <Vector74+0x36>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
    3728:	4b07      	ldr	r3, [pc, #28]	; (3748 <Vector74+0x48>)
    372a:	691b      	ldr	r3, [r3, #16]
    372c:	4a06      	ldr	r2, [pc, #24]	; (3748 <Vector74+0x48>)
    372e:	6952      	ldr	r2, [r2, #20]
    3730:	4610      	mov	r0, r2
    3732:	9901      	ldr	r1, [sp, #4]
    3734:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3736:	f7fd f98b 	bl	a50 <_dbg_check_leave_isr>
    373a:	f7ff fbb9 	bl	2eb0 <_port_irq_epilogue>
}
    373e:	b003      	add	sp, #12
    3740:	f85d fb04 	ldr.w	pc, [sp], #4
    3744:	40026000 	.word	0x40026000
    3748:	200010c4 	.word	0x200010c4
    374c:	f3af 8000 	nop.w

00003750 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
    3750:	b500      	push	{lr}
    3752:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3754:	f7fe f9c4 	bl	1ae0 <_stats_increase_irq>
    3758:	f7fd f95a 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
    375c:	4b0d      	ldr	r3, [pc, #52]	; (3794 <Vector78+0x44>)
    375e:	681b      	ldr	r3, [r3, #0]
    3760:	0d9b      	lsrs	r3, r3, #22
    3762:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3766:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
    3768:	4b0a      	ldr	r3, [pc, #40]	; (3794 <Vector78+0x44>)
    376a:	9a01      	ldr	r2, [sp, #4]
    376c:	0592      	lsls	r2, r2, #22
    376e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[3].dma_func)
    3770:	4b09      	ldr	r3, [pc, #36]	; (3798 <Vector78+0x48>)
    3772:	699b      	ldr	r3, [r3, #24]
    3774:	2b00      	cmp	r3, #0
    3776:	d006      	beq.n	3786 <Vector78+0x36>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
    3778:	4b07      	ldr	r3, [pc, #28]	; (3798 <Vector78+0x48>)
    377a:	699b      	ldr	r3, [r3, #24]
    377c:	4a06      	ldr	r2, [pc, #24]	; (3798 <Vector78+0x48>)
    377e:	69d2      	ldr	r2, [r2, #28]
    3780:	4610      	mov	r0, r2
    3782:	9901      	ldr	r1, [sp, #4]
    3784:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3786:	f7fd f963 	bl	a50 <_dbg_check_leave_isr>
    378a:	f7ff fb91 	bl	2eb0 <_port_irq_epilogue>
}
    378e:	b003      	add	sp, #12
    3790:	f85d fb04 	ldr.w	pc, [sp], #4
    3794:	40026000 	.word	0x40026000
    3798:	200010c4 	.word	0x200010c4
    379c:	f3af 8000 	nop.w

000037a0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
    37a0:	b500      	push	{lr}
    37a2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    37a4:	f7fe f99c 	bl	1ae0 <_stats_increase_irq>
    37a8:	f7fd f932 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
    37ac:	4b0c      	ldr	r3, [pc, #48]	; (37e0 <Vector7C+0x40>)
    37ae:	685b      	ldr	r3, [r3, #4]
    37b0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    37b4:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
    37b6:	4b0a      	ldr	r3, [pc, #40]	; (37e0 <Vector7C+0x40>)
    37b8:	9a01      	ldr	r2, [sp, #4]
    37ba:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[4].dma_func)
    37bc:	4b09      	ldr	r3, [pc, #36]	; (37e4 <Vector7C+0x44>)
    37be:	6a1b      	ldr	r3, [r3, #32]
    37c0:	2b00      	cmp	r3, #0
    37c2:	d006      	beq.n	37d2 <Vector7C+0x32>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
    37c4:	4b07      	ldr	r3, [pc, #28]	; (37e4 <Vector7C+0x44>)
    37c6:	6a1b      	ldr	r3, [r3, #32]
    37c8:	4a06      	ldr	r2, [pc, #24]	; (37e4 <Vector7C+0x44>)
    37ca:	6a52      	ldr	r2, [r2, #36]	; 0x24
    37cc:	4610      	mov	r0, r2
    37ce:	9901      	ldr	r1, [sp, #4]
    37d0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    37d2:	f7fd f93d 	bl	a50 <_dbg_check_leave_isr>
    37d6:	f7ff fb6b 	bl	2eb0 <_port_irq_epilogue>
}
    37da:	b003      	add	sp, #12
    37dc:	f85d fb04 	ldr.w	pc, [sp], #4
    37e0:	40026000 	.word	0x40026000
    37e4:	200010c4 	.word	0x200010c4
    37e8:	f3af 8000 	nop.w
    37ec:	f3af 8000 	nop.w

000037f0 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
    37f0:	b500      	push	{lr}
    37f2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    37f4:	f7fe f974 	bl	1ae0 <_stats_increase_irq>
    37f8:	f7fd f90a 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
    37fc:	4b0d      	ldr	r3, [pc, #52]	; (3834 <Vector80+0x44>)
    37fe:	685b      	ldr	r3, [r3, #4]
    3800:	099b      	lsrs	r3, r3, #6
    3802:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3806:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
    3808:	4b0a      	ldr	r3, [pc, #40]	; (3834 <Vector80+0x44>)
    380a:	9a01      	ldr	r2, [sp, #4]
    380c:	0192      	lsls	r2, r2, #6
    380e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[5].dma_func)
    3810:	4b09      	ldr	r3, [pc, #36]	; (3838 <Vector80+0x48>)
    3812:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3814:	2b00      	cmp	r3, #0
    3816:	d006      	beq.n	3826 <Vector80+0x36>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
    3818:	4b07      	ldr	r3, [pc, #28]	; (3838 <Vector80+0x48>)
    381a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    381c:	4a06      	ldr	r2, [pc, #24]	; (3838 <Vector80+0x48>)
    381e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    3820:	4610      	mov	r0, r2
    3822:	9901      	ldr	r1, [sp, #4]
    3824:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3826:	f7fd f913 	bl	a50 <_dbg_check_leave_isr>
    382a:	f7ff fb41 	bl	2eb0 <_port_irq_epilogue>
}
    382e:	b003      	add	sp, #12
    3830:	f85d fb04 	ldr.w	pc, [sp], #4
    3834:	40026000 	.word	0x40026000
    3838:	200010c4 	.word	0x200010c4
    383c:	f3af 8000 	nop.w

00003840 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
    3840:	b500      	push	{lr}
    3842:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3844:	f7fe f94c 	bl	1ae0 <_stats_increase_irq>
    3848:	f7fd f8e2 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
    384c:	4b0d      	ldr	r3, [pc, #52]	; (3884 <Vector84+0x44>)
    384e:	685b      	ldr	r3, [r3, #4]
    3850:	0c1b      	lsrs	r3, r3, #16
    3852:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3856:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
    3858:	4b0a      	ldr	r3, [pc, #40]	; (3884 <Vector84+0x44>)
    385a:	9a01      	ldr	r2, [sp, #4]
    385c:	0412      	lsls	r2, r2, #16
    385e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[6].dma_func)
    3860:	4b09      	ldr	r3, [pc, #36]	; (3888 <Vector84+0x48>)
    3862:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    3864:	2b00      	cmp	r3, #0
    3866:	d006      	beq.n	3876 <Vector84+0x36>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
    3868:	4b07      	ldr	r3, [pc, #28]	; (3888 <Vector84+0x48>)
    386a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    386c:	4a06      	ldr	r2, [pc, #24]	; (3888 <Vector84+0x48>)
    386e:	6b52      	ldr	r2, [r2, #52]	; 0x34
    3870:	4610      	mov	r0, r2
    3872:	9901      	ldr	r1, [sp, #4]
    3874:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3876:	f7fd f8eb 	bl	a50 <_dbg_check_leave_isr>
    387a:	f7ff fb19 	bl	2eb0 <_port_irq_epilogue>
}
    387e:	b003      	add	sp, #12
    3880:	f85d fb04 	ldr.w	pc, [sp], #4
    3884:	40026000 	.word	0x40026000
    3888:	200010c4 	.word	0x200010c4
    388c:	f3af 8000 	nop.w

00003890 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
    3890:	b500      	push	{lr}
    3892:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3894:	f7fe f924 	bl	1ae0 <_stats_increase_irq>
    3898:	f7fd f8ba 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
    389c:	4b0d      	ldr	r3, [pc, #52]	; (38d4 <VectorFC+0x44>)
    389e:	685b      	ldr	r3, [r3, #4]
    38a0:	0d9b      	lsrs	r3, r3, #22
    38a2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    38a6:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
    38a8:	4b0a      	ldr	r3, [pc, #40]	; (38d4 <VectorFC+0x44>)
    38aa:	9a01      	ldr	r2, [sp, #4]
    38ac:	0592      	lsls	r2, r2, #22
    38ae:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[7].dma_func)
    38b0:	4b09      	ldr	r3, [pc, #36]	; (38d8 <VectorFC+0x48>)
    38b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    38b4:	2b00      	cmp	r3, #0
    38b6:	d006      	beq.n	38c6 <VectorFC+0x36>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
    38b8:	4b07      	ldr	r3, [pc, #28]	; (38d8 <VectorFC+0x48>)
    38ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    38bc:	4a06      	ldr	r2, [pc, #24]	; (38d8 <VectorFC+0x48>)
    38be:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
    38c0:	4610      	mov	r0, r2
    38c2:	9901      	ldr	r1, [sp, #4]
    38c4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    38c6:	f7fd f8c3 	bl	a50 <_dbg_check_leave_isr>
    38ca:	f7ff faf1 	bl	2eb0 <_port_irq_epilogue>
}
    38ce:	b003      	add	sp, #12
    38d0:	f85d fb04 	ldr.w	pc, [sp], #4
    38d4:	40026000 	.word	0x40026000
    38d8:	200010c4 	.word	0x200010c4
    38dc:	f3af 8000 	nop.w

000038e0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
    38e0:	b500      	push	{lr}
    38e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    38e4:	f7fe f8fc 	bl	1ae0 <_stats_increase_irq>
    38e8:	f7fd f892 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
    38ec:	4b0c      	ldr	r3, [pc, #48]	; (3920 <Vector120+0x40>)
    38ee:	681b      	ldr	r3, [r3, #0]
    38f0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    38f4:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
    38f6:	4b0a      	ldr	r3, [pc, #40]	; (3920 <Vector120+0x40>)
    38f8:	9a01      	ldr	r2, [sp, #4]
    38fa:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[8].dma_func)
    38fc:	4b09      	ldr	r3, [pc, #36]	; (3924 <Vector120+0x44>)
    38fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3900:	2b00      	cmp	r3, #0
    3902:	d006      	beq.n	3912 <Vector120+0x32>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
    3904:	4b07      	ldr	r3, [pc, #28]	; (3924 <Vector120+0x44>)
    3906:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3908:	4a06      	ldr	r2, [pc, #24]	; (3924 <Vector120+0x44>)
    390a:	6c52      	ldr	r2, [r2, #68]	; 0x44
    390c:	4610      	mov	r0, r2
    390e:	9901      	ldr	r1, [sp, #4]
    3910:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3912:	f7fd f89d 	bl	a50 <_dbg_check_leave_isr>
    3916:	f7ff facb 	bl	2eb0 <_port_irq_epilogue>
}
    391a:	b003      	add	sp, #12
    391c:	f85d fb04 	ldr.w	pc, [sp], #4
    3920:	40026400 	.word	0x40026400
    3924:	200010c4 	.word	0x200010c4
    3928:	f3af 8000 	nop.w
    392c:	f3af 8000 	nop.w

00003930 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
    3930:	b500      	push	{lr}
    3932:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3934:	f7fe f8d4 	bl	1ae0 <_stats_increase_irq>
    3938:	f7fd f86a 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
    393c:	4b0d      	ldr	r3, [pc, #52]	; (3974 <Vector124+0x44>)
    393e:	681b      	ldr	r3, [r3, #0]
    3940:	099b      	lsrs	r3, r3, #6
    3942:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3946:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
    3948:	4b0a      	ldr	r3, [pc, #40]	; (3974 <Vector124+0x44>)
    394a:	9a01      	ldr	r2, [sp, #4]
    394c:	0192      	lsls	r2, r2, #6
    394e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[9].dma_func)
    3950:	4b09      	ldr	r3, [pc, #36]	; (3978 <Vector124+0x48>)
    3952:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3954:	2b00      	cmp	r3, #0
    3956:	d006      	beq.n	3966 <Vector124+0x36>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
    3958:	4b07      	ldr	r3, [pc, #28]	; (3978 <Vector124+0x48>)
    395a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    395c:	4a06      	ldr	r2, [pc, #24]	; (3978 <Vector124+0x48>)
    395e:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    3960:	4610      	mov	r0, r2
    3962:	9901      	ldr	r1, [sp, #4]
    3964:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3966:	f7fd f873 	bl	a50 <_dbg_check_leave_isr>
    396a:	f7ff faa1 	bl	2eb0 <_port_irq_epilogue>
}
    396e:	b003      	add	sp, #12
    3970:	f85d fb04 	ldr.w	pc, [sp], #4
    3974:	40026400 	.word	0x40026400
    3978:	200010c4 	.word	0x200010c4
    397c:	f3af 8000 	nop.w

00003980 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
    3980:	b500      	push	{lr}
    3982:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3984:	f7fe f8ac 	bl	1ae0 <_stats_increase_irq>
    3988:	f7fd f842 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
    398c:	4b0d      	ldr	r3, [pc, #52]	; (39c4 <Vector128+0x44>)
    398e:	681b      	ldr	r3, [r3, #0]
    3990:	0c1b      	lsrs	r3, r3, #16
    3992:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3996:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
    3998:	4b0a      	ldr	r3, [pc, #40]	; (39c4 <Vector128+0x44>)
    399a:	9a01      	ldr	r2, [sp, #4]
    399c:	0412      	lsls	r2, r2, #16
    399e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[10].dma_func)
    39a0:	4b09      	ldr	r3, [pc, #36]	; (39c8 <Vector128+0x48>)
    39a2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    39a4:	2b00      	cmp	r3, #0
    39a6:	d006      	beq.n	39b6 <Vector128+0x36>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
    39a8:	4b07      	ldr	r3, [pc, #28]	; (39c8 <Vector128+0x48>)
    39aa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    39ac:	4a06      	ldr	r2, [pc, #24]	; (39c8 <Vector128+0x48>)
    39ae:	6d52      	ldr	r2, [r2, #84]	; 0x54
    39b0:	4610      	mov	r0, r2
    39b2:	9901      	ldr	r1, [sp, #4]
    39b4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    39b6:	f7fd f84b 	bl	a50 <_dbg_check_leave_isr>
    39ba:	f7ff fa79 	bl	2eb0 <_port_irq_epilogue>
}
    39be:	b003      	add	sp, #12
    39c0:	f85d fb04 	ldr.w	pc, [sp], #4
    39c4:	40026400 	.word	0x40026400
    39c8:	200010c4 	.word	0x200010c4
    39cc:	f3af 8000 	nop.w

000039d0 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
    39d0:	b500      	push	{lr}
    39d2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    39d4:	f7fe f884 	bl	1ae0 <_stats_increase_irq>
    39d8:	f7fd f81a 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
    39dc:	4b0d      	ldr	r3, [pc, #52]	; (3a14 <Vector12C+0x44>)
    39de:	681b      	ldr	r3, [r3, #0]
    39e0:	0d9b      	lsrs	r3, r3, #22
    39e2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    39e6:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
    39e8:	4b0a      	ldr	r3, [pc, #40]	; (3a14 <Vector12C+0x44>)
    39ea:	9a01      	ldr	r2, [sp, #4]
    39ec:	0592      	lsls	r2, r2, #22
    39ee:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[11].dma_func)
    39f0:	4b09      	ldr	r3, [pc, #36]	; (3a18 <Vector12C+0x48>)
    39f2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    39f4:	2b00      	cmp	r3, #0
    39f6:	d006      	beq.n	3a06 <Vector12C+0x36>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
    39f8:	4b07      	ldr	r3, [pc, #28]	; (3a18 <Vector12C+0x48>)
    39fa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    39fc:	4a06      	ldr	r2, [pc, #24]	; (3a18 <Vector12C+0x48>)
    39fe:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
    3a00:	4610      	mov	r0, r2
    3a02:	9901      	ldr	r1, [sp, #4]
    3a04:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3a06:	f7fd f823 	bl	a50 <_dbg_check_leave_isr>
    3a0a:	f7ff fa51 	bl	2eb0 <_port_irq_epilogue>
}
    3a0e:	b003      	add	sp, #12
    3a10:	f85d fb04 	ldr.w	pc, [sp], #4
    3a14:	40026400 	.word	0x40026400
    3a18:	200010c4 	.word	0x200010c4
    3a1c:	f3af 8000 	nop.w

00003a20 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
    3a20:	b500      	push	{lr}
    3a22:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3a24:	f7fe f85c 	bl	1ae0 <_stats_increase_irq>
    3a28:	f7fc fff2 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
    3a2c:	4b0c      	ldr	r3, [pc, #48]	; (3a60 <Vector130+0x40>)
    3a2e:	685b      	ldr	r3, [r3, #4]
    3a30:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3a34:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
    3a36:	4b0a      	ldr	r3, [pc, #40]	; (3a60 <Vector130+0x40>)
    3a38:	9a01      	ldr	r2, [sp, #4]
    3a3a:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[12].dma_func)
    3a3c:	4b09      	ldr	r3, [pc, #36]	; (3a64 <Vector130+0x44>)
    3a3e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    3a40:	2b00      	cmp	r3, #0
    3a42:	d006      	beq.n	3a52 <Vector130+0x32>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
    3a44:	4b07      	ldr	r3, [pc, #28]	; (3a64 <Vector130+0x44>)
    3a46:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    3a48:	4a06      	ldr	r2, [pc, #24]	; (3a64 <Vector130+0x44>)
    3a4a:	6e52      	ldr	r2, [r2, #100]	; 0x64
    3a4c:	4610      	mov	r0, r2
    3a4e:	9901      	ldr	r1, [sp, #4]
    3a50:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3a52:	f7fc fffd 	bl	a50 <_dbg_check_leave_isr>
    3a56:	f7ff fa2b 	bl	2eb0 <_port_irq_epilogue>
}
    3a5a:	b003      	add	sp, #12
    3a5c:	f85d fb04 	ldr.w	pc, [sp], #4
    3a60:	40026400 	.word	0x40026400
    3a64:	200010c4 	.word	0x200010c4
    3a68:	f3af 8000 	nop.w
    3a6c:	f3af 8000 	nop.w

00003a70 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
    3a70:	b500      	push	{lr}
    3a72:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3a74:	f7fe f834 	bl	1ae0 <_stats_increase_irq>
    3a78:	f7fc ffca 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
    3a7c:	4b0d      	ldr	r3, [pc, #52]	; (3ab4 <Vector150+0x44>)
    3a7e:	685b      	ldr	r3, [r3, #4]
    3a80:	099b      	lsrs	r3, r3, #6
    3a82:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3a86:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
    3a88:	4b0a      	ldr	r3, [pc, #40]	; (3ab4 <Vector150+0x44>)
    3a8a:	9a01      	ldr	r2, [sp, #4]
    3a8c:	0192      	lsls	r2, r2, #6
    3a8e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[13].dma_func)
    3a90:	4b09      	ldr	r3, [pc, #36]	; (3ab8 <Vector150+0x48>)
    3a92:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    3a94:	2b00      	cmp	r3, #0
    3a96:	d006      	beq.n	3aa6 <Vector150+0x36>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
    3a98:	4b07      	ldr	r3, [pc, #28]	; (3ab8 <Vector150+0x48>)
    3a9a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    3a9c:	4a06      	ldr	r2, [pc, #24]	; (3ab8 <Vector150+0x48>)
    3a9e:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
    3aa0:	4610      	mov	r0, r2
    3aa2:	9901      	ldr	r1, [sp, #4]
    3aa4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3aa6:	f7fc ffd3 	bl	a50 <_dbg_check_leave_isr>
    3aaa:	f7ff fa01 	bl	2eb0 <_port_irq_epilogue>
}
    3aae:	b003      	add	sp, #12
    3ab0:	f85d fb04 	ldr.w	pc, [sp], #4
    3ab4:	40026400 	.word	0x40026400
    3ab8:	200010c4 	.word	0x200010c4
    3abc:	f3af 8000 	nop.w

00003ac0 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
    3ac0:	b500      	push	{lr}
    3ac2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3ac4:	f7fe f80c 	bl	1ae0 <_stats_increase_irq>
    3ac8:	f7fc ffa2 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
    3acc:	4b0d      	ldr	r3, [pc, #52]	; (3b04 <Vector154+0x44>)
    3ace:	685b      	ldr	r3, [r3, #4]
    3ad0:	0c1b      	lsrs	r3, r3, #16
    3ad2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3ad6:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
    3ad8:	4b0a      	ldr	r3, [pc, #40]	; (3b04 <Vector154+0x44>)
    3ada:	9a01      	ldr	r2, [sp, #4]
    3adc:	0412      	lsls	r2, r2, #16
    3ade:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[14].dma_func)
    3ae0:	4b09      	ldr	r3, [pc, #36]	; (3b08 <Vector154+0x48>)
    3ae2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    3ae4:	2b00      	cmp	r3, #0
    3ae6:	d006      	beq.n	3af6 <Vector154+0x36>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
    3ae8:	4b07      	ldr	r3, [pc, #28]	; (3b08 <Vector154+0x48>)
    3aea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    3aec:	4a06      	ldr	r2, [pc, #24]	; (3b08 <Vector154+0x48>)
    3aee:	6f52      	ldr	r2, [r2, #116]	; 0x74
    3af0:	4610      	mov	r0, r2
    3af2:	9901      	ldr	r1, [sp, #4]
    3af4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3af6:	f7fc ffab 	bl	a50 <_dbg_check_leave_isr>
    3afa:	f7ff f9d9 	bl	2eb0 <_port_irq_epilogue>
}
    3afe:	b003      	add	sp, #12
    3b00:	f85d fb04 	ldr.w	pc, [sp], #4
    3b04:	40026400 	.word	0x40026400
    3b08:	200010c4 	.word	0x200010c4
    3b0c:	f3af 8000 	nop.w

00003b10 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
    3b10:	b500      	push	{lr}
    3b12:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
    3b14:	f7fd ffe4 	bl	1ae0 <_stats_increase_irq>
    3b18:	f7fc ff7a 	bl	a10 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
    3b1c:	4b0d      	ldr	r3, [pc, #52]	; (3b54 <Vector158+0x44>)
    3b1e:	685b      	ldr	r3, [r3, #4]
    3b20:	0d9b      	lsrs	r3, r3, #22
    3b22:	f003 033d 	and.w	r3, r3, #61	; 0x3d
    3b26:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
    3b28:	4b0a      	ldr	r3, [pc, #40]	; (3b54 <Vector158+0x44>)
    3b2a:	9a01      	ldr	r2, [sp, #4]
    3b2c:	0592      	lsls	r2, r2, #22
    3b2e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[15].dma_func)
    3b30:	4b09      	ldr	r3, [pc, #36]	; (3b58 <Vector158+0x48>)
    3b32:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    3b34:	2b00      	cmp	r3, #0
    3b36:	d006      	beq.n	3b46 <Vector158+0x36>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
    3b38:	4b07      	ldr	r3, [pc, #28]	; (3b58 <Vector158+0x48>)
    3b3a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    3b3c:	4a06      	ldr	r2, [pc, #24]	; (3b58 <Vector158+0x48>)
    3b3e:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
    3b40:	4610      	mov	r0, r2
    3b42:	9901      	ldr	r1, [sp, #4]
    3b44:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
    3b46:	f7fc ff83 	bl	a50 <_dbg_check_leave_isr>
    3b4a:	f7ff f9b1 	bl	2eb0 <_port_irq_epilogue>
}
    3b4e:	b003      	add	sp, #12
    3b50:	f85d fb04 	ldr.w	pc, [sp], #4
    3b54:	40026400 	.word	0x40026400
    3b58:	200010c4 	.word	0x200010c4
    3b5c:	f3af 8000 	nop.w

00003b60 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
    3b60:	b082      	sub	sp, #8
  unsigned i;

  dma_streams_mask = 0U;
    3b62:	4b16      	ldr	r3, [pc, #88]	; (3bbc <dmaInit+0x5c>)
    3b64:	2200      	movs	r2, #0
    3b66:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    3b68:	2300      	movs	r3, #0
    3b6a:	9301      	str	r3, [sp, #4]
    3b6c:	e011      	b.n	3b92 <dmaInit+0x32>
    _stm32_dma_streams[i].stream->CR = 0U;
    3b6e:	4914      	ldr	r1, [pc, #80]	; (3bc0 <dmaInit+0x60>)
    3b70:	9a01      	ldr	r2, [sp, #4]
    3b72:	4613      	mov	r3, r2
    3b74:	005b      	lsls	r3, r3, #1
    3b76:	4413      	add	r3, r2
    3b78:	009b      	lsls	r3, r3, #2
    3b7a:	440b      	add	r3, r1
    3b7c:	681b      	ldr	r3, [r3, #0]
    3b7e:	2200      	movs	r2, #0
    3b80:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
    3b82:	4b10      	ldr	r3, [pc, #64]	; (3bc4 <dmaInit+0x64>)
    3b84:	9a01      	ldr	r2, [sp, #4]
    3b86:	2100      	movs	r1, #0
    3b88:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    3b8c:	9b01      	ldr	r3, [sp, #4]
    3b8e:	3301      	adds	r3, #1
    3b90:	9301      	str	r3, [sp, #4]
    3b92:	9b01      	ldr	r3, [sp, #4]
    3b94:	2b0f      	cmp	r3, #15
    3b96:	d9ea      	bls.n	3b6e <dmaInit+0xe>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
    3b98:	4b0b      	ldr	r3, [pc, #44]	; (3bc8 <dmaInit+0x68>)
    3b9a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3b9e:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
    3ba0:	4b09      	ldr	r3, [pc, #36]	; (3bc8 <dmaInit+0x68>)
    3ba2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3ba6:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
    3ba8:	4b08      	ldr	r3, [pc, #32]	; (3bcc <dmaInit+0x6c>)
    3baa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3bae:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
    3bb0:	4b06      	ldr	r3, [pc, #24]	; (3bcc <dmaInit+0x6c>)
    3bb2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3bb6:	60da      	str	r2, [r3, #12]
}
    3bb8:	b002      	add	sp, #8
    3bba:	4770      	bx	lr
    3bbc:	200010c0 	.word	0x200010c0
    3bc0:	00004a20 	.word	0x00004a20
    3bc4:	200010c4 	.word	0x200010c4
    3bc8:	40026000 	.word	0x40026000
    3bcc:	40026400 	.word	0x40026400

00003bd0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    3bd0:	b082      	sub	sp, #8
    3bd2:	2320      	movs	r3, #32
    3bd4:	9301      	str	r3, [sp, #4]
    3bd6:	9b01      	ldr	r3, [sp, #4]
    3bd8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    3bdc:	b002      	add	sp, #8
    3bde:	4770      	bx	lr

00003be0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    3be0:	b082      	sub	sp, #8
    3be2:	2300      	movs	r3, #0
    3be4:	9301      	str	r3, [sp, #4]
    3be6:	9b01      	ldr	r3, [sp, #4]
    3be8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    3bec:	b002      	add	sp, #8
    3bee:	4770      	bx	lr

00003bf0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    3bf0:	b508      	push	{r3, lr}

  port_lock();
    3bf2:	f7ff ffed 	bl	3bd0 <port_lock>
}
    3bf6:	bd08      	pop	{r3, pc}
    3bf8:	f3af 8000 	nop.w
    3bfc:	f3af 8000 	nop.w

00003c00 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    3c00:	b508      	push	{r3, lr}

  port_unlock();
    3c02:	f7ff ffed 	bl	3be0 <port_unlock>
}
    3c06:	bd08      	pop	{r3, pc}
    3c08:	f3af 8000 	nop.w
    3c0c:	f3af 8000 	nop.w

00003c10 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    3c10:	b508      	push	{r3, lr}

  port_lock_from_isr();
    3c12:	f7ff ffed 	bl	3bf0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    3c16:	f7fd ffa3 	bl	1b60 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    3c1a:	f7fc fec9 	bl	9b0 <_dbg_check_lock_from_isr>
}
    3c1e:	bd08      	pop	{r3, pc}

00003c20 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    3c20:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    3c22:	f7fc fedd 	bl	9e0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    3c26:	f7fd ffa3 	bl	1b70 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    3c2a:	f7ff ffe9 	bl	3c00 <port_unlock_from_isr>
}
    3c2e:	bd08      	pop	{r3, pc}

00003c30 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    3c30:	b508      	push	{r3, lr}

  chSysLockFromISR();
    3c32:	f7ff ffed 	bl	3c10 <chSysLockFromISR>
}
    3c36:	bd08      	pop	{r3, pc}
    3c38:	f3af 8000 	nop.w
    3c3c:	f3af 8000 	nop.w

00003c40 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    3c40:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    3c42:	f7ff ffed 	bl	3c20 <chSysUnlockFromISR>
}
    3c46:	bd08      	pop	{r3, pc}
    3c48:	f3af 8000 	nop.w
    3c4c:	f3af 8000 	nop.w

00003c50 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
    3c50:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
    3c52:	f7fc fe25 	bl	8a0 <chSysTimerHandlerI>
}
    3c56:	bd08      	pop	{r3, pc}
    3c58:	f3af 8000 	nop.w
    3c5c:	f3af 8000 	nop.w

00003c60 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
    3c60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    3c62:	f7fd ff3d 	bl	1ae0 <_stats_increase_irq>
    3c66:	f7fc fed3 	bl	a10 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    3c6a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3c6e:	691b      	ldr	r3, [r3, #16]
    3c70:	f003 0302 	and.w	r3, r3, #2
    3c74:	2b00      	cmp	r3, #0
    3c76:	d009      	beq.n	3c8c <VectorB0+0x2c>
    STM32_ST_TIM->SR = 0U;
    3c78:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3c7c:	2200      	movs	r2, #0
    3c7e:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
    3c80:	f7ff ffd6 	bl	3c30 <osalSysLockFromISR>
    osalOsTimerHandlerI();
    3c84:	f7ff ffe4 	bl	3c50 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
    3c88:	f7ff ffda 	bl	3c40 <osalSysUnlockFromISR>
  }

  OSAL_IRQ_EPILOGUE();
    3c8c:	f7fc fee0 	bl	a50 <_dbg_check_leave_isr>
    3c90:	f7ff f90e 	bl	2eb0 <_port_irq_epilogue>
}
    3c94:	bd08      	pop	{r3, pc}
    3c96:	bf00      	nop
    3c98:	f3af 8000 	nop.w
    3c9c:	f3af 8000 	nop.w

00003ca0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
    3ca0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
    3ca2:	4b19      	ldr	r3, [pc, #100]	; (3d08 <st_lld_init+0x68>)
    3ca4:	4a18      	ldr	r2, [pc, #96]	; (3d08 <st_lld_init+0x68>)
    3ca6:	6c12      	ldr	r2, [r2, #64]	; 0x40
    3ca8:	f042 0201 	orr.w	r2, r2, #1
    3cac:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
    3cae:	4b17      	ldr	r3, [pc, #92]	; (3d0c <st_lld_init+0x6c>)
    3cb0:	4a16      	ldr	r2, [pc, #88]	; (3d0c <st_lld_init+0x6c>)
    3cb2:	6892      	ldr	r2, [r2, #8]
    3cb4:	f042 0201 	orr.w	r2, r2, #1
    3cb8:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
    3cba:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3cbe:	f242 02cf 	movw	r2, #8399	; 0x20cf
    3cc2:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
    3cc4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3cc8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3ccc:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
    3cce:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3cd2:	2200      	movs	r2, #0
    3cd4:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
    3cd6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3cda:	2200      	movs	r2, #0
    3cdc:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
    3cde:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3ce2:	2200      	movs	r2, #0
    3ce4:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
    3ce6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3cea:	2200      	movs	r2, #0
    3cec:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
    3cee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3cf2:	2201      	movs	r2, #1
    3cf4:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
    3cf6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3cfa:	2201      	movs	r2, #1
    3cfc:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
    3cfe:	201c      	movs	r0, #28
    3d00:	2108      	movs	r1, #8
    3d02:	f7ff fb9d 	bl	3440 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    3d06:	bd08      	pop	{r3, pc}
    3d08:	40023800 	.word	0x40023800
    3d0c:	e0042000 	.word	0xe0042000

00003d10 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    3d10:	b082      	sub	sp, #8
    3d12:	2320      	movs	r3, #32
    3d14:	9301      	str	r3, [sp, #4]
    3d16:	9b01      	ldr	r3, [sp, #4]
    3d18:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    3d1c:	b002      	add	sp, #8
    3d1e:	4770      	bx	lr

00003d20 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    3d20:	b082      	sub	sp, #8
    3d22:	2300      	movs	r3, #0
    3d24:	9301      	str	r3, [sp, #4]
    3d26:	9b01      	ldr	r3, [sp, #4]
    3d28:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    3d2c:	b002      	add	sp, #8
    3d2e:	4770      	bx	lr

00003d30 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    3d30:	b508      	push	{r3, lr}

  port_lock();
    3d32:	f7ff ffed 	bl	3d10 <port_lock>
}
    3d36:	bd08      	pop	{r3, pc}
    3d38:	f3af 8000 	nop.w
    3d3c:	f3af 8000 	nop.w

00003d40 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    3d40:	b508      	push	{r3, lr}

  port_unlock();
    3d42:	f7ff ffed 	bl	3d20 <port_unlock>
}
    3d46:	bd08      	pop	{r3, pc}
    3d48:	f3af 8000 	nop.w
    3d4c:	f3af 8000 	nop.w

00003d50 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    3d50:	b508      	push	{r3, lr}

  port_lock_from_isr();
    3d52:	f7ff ffed 	bl	3d30 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    3d56:	f7fd ff03 	bl	1b60 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    3d5a:	f7fc fe29 	bl	9b0 <_dbg_check_lock_from_isr>
}
    3d5e:	bd08      	pop	{r3, pc}

00003d60 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    3d60:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    3d62:	f7fc fe3d 	bl	9e0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    3d66:	f7fd ff03 	bl	1b70 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    3d6a:	f7ff ffe9 	bl	3d40 <port_unlock_from_isr>
}
    3d6e:	bd08      	pop	{r3, pc}

00003d70 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    3d70:	b508      	push	{r3, lr}

  chSysLockFromISR();
    3d72:	f7ff ffed 	bl	3d50 <chSysLockFromISR>
}
    3d76:	bd08      	pop	{r3, pc}
    3d78:	f3af 8000 	nop.w
    3d7c:	f3af 8000 	nop.w

00003d80 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    3d80:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    3d82:	f7ff ffed 	bl	3d60 <chSysUnlockFromISR>
}
    3d86:	bd08      	pop	{r3, pc}
    3d88:	f3af 8000 	nop.w
    3d8c:	f3af 8000 	nop.w

00003d90 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    3d90:	b500      	push	{lr}
    3d92:	b083      	sub	sp, #12
    3d94:	9001      	str	r0, [sp, #4]
    3d96:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
    3d98:	9801      	ldr	r0, [sp, #4]
    3d9a:	9900      	ldr	r1, [sp, #0]
    3d9c:	f7fd fd70 	bl	1880 <chThdResumeI>
}
    3da0:	b003      	add	sp, #12
    3da2:	f85d fb04 	ldr.w	pc, [sp], #4
    3da6:	bf00      	nop
    3da8:	f3af 8000 	nop.w
    3dac:	f3af 8000 	nop.w

00003db0 <Vector88>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
    3db0:	b500      	push	{lr}
    3db2:	b083      	sub	sp, #12
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();
    3db4:	f7fd fe94 	bl	1ae0 <_stats_increase_irq>
    3db8:	f7fc fe2a 	bl	a10 <_dbg_check_enter_isr>

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
    3dbc:	4b58      	ldr	r3, [pc, #352]	; (3f20 <Vector88+0x170>)
    3dbe:	681b      	ldr	r3, [r3, #0]
    3dc0:	9301      	str	r3, [sp, #4]
  ADC1->SR = 0;
    3dc2:	4b57      	ldr	r3, [pc, #348]	; (3f20 <Vector88+0x170>)
    3dc4:	2200      	movs	r2, #0
    3dc6:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    3dc8:	9b01      	ldr	r3, [sp, #4]
    3dca:	f003 0320 	and.w	r3, r3, #32
    3dce:	2b00      	cmp	r3, #0
    3dd0:	d02d      	beq.n	3e2e <Vector88+0x7e>
    3dd2:	4b54      	ldr	r3, [pc, #336]	; (3f24 <Vector88+0x174>)
    3dd4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3dd6:	681b      	ldr	r3, [r3, #0]
    3dd8:	685b      	ldr	r3, [r3, #4]
    3dda:	2b00      	cmp	r3, #0
    3ddc:	d027      	beq.n	3e2e <Vector88+0x7e>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
    3dde:	4b51      	ldr	r3, [pc, #324]	; (3f24 <Vector88+0x174>)
    3de0:	691b      	ldr	r3, [r3, #16]
    3de2:	2b00      	cmp	r3, #0
    3de4:	d023      	beq.n	3e2e <Vector88+0x7e>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
    3de6:	484f      	ldr	r0, [pc, #316]	; (3f24 <Vector88+0x174>)
    3de8:	f000 f8fa 	bl	3fe0 <adc_lld_stop_conversion>
    3dec:	4b4d      	ldr	r3, [pc, #308]	; (3f24 <Vector88+0x174>)
    3dee:	691b      	ldr	r3, [r3, #16]
    3df0:	689b      	ldr	r3, [r3, #8]
    3df2:	2b00      	cmp	r3, #0
    3df4:	d00f      	beq.n	3e16 <Vector88+0x66>
    3df6:	4b4b      	ldr	r3, [pc, #300]	; (3f24 <Vector88+0x174>)
    3df8:	2205      	movs	r2, #5
    3dfa:	701a      	strb	r2, [r3, #0]
    3dfc:	4b49      	ldr	r3, [pc, #292]	; (3f24 <Vector88+0x174>)
    3dfe:	691b      	ldr	r3, [r3, #16]
    3e00:	689b      	ldr	r3, [r3, #8]
    3e02:	4848      	ldr	r0, [pc, #288]	; (3f24 <Vector88+0x174>)
    3e04:	2101      	movs	r1, #1
    3e06:	4798      	blx	r3
    3e08:	4b46      	ldr	r3, [pc, #280]	; (3f24 <Vector88+0x174>)
    3e0a:	781b      	ldrb	r3, [r3, #0]
    3e0c:	2b05      	cmp	r3, #5
    3e0e:	d102      	bne.n	3e16 <Vector88+0x66>
    3e10:	4b44      	ldr	r3, [pc, #272]	; (3f24 <Vector88+0x174>)
    3e12:	2202      	movs	r2, #2
    3e14:	701a      	strb	r2, [r3, #0]
    3e16:	4b43      	ldr	r3, [pc, #268]	; (3f24 <Vector88+0x174>)
    3e18:	2200      	movs	r2, #0
    3e1a:	611a      	str	r2, [r3, #16]
    3e1c:	f7ff ffa8 	bl	3d70 <osalSysLockFromISR>
    3e20:	4841      	ldr	r0, [pc, #260]	; (3f28 <Vector88+0x178>)
    3e22:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3e26:	f7ff ffb3 	bl	3d90 <osalThreadResumeI>
    3e2a:	f7ff ffa9 	bl	3d80 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC1 */

#if STM32_ADC_USE_ADC2
  sr = ADC2->SR;
    3e2e:	4b3f      	ldr	r3, [pc, #252]	; (3f2c <Vector88+0x17c>)
    3e30:	681b      	ldr	r3, [r3, #0]
    3e32:	9301      	str	r3, [sp, #4]
  ADC2->SR = 0;
    3e34:	4b3d      	ldr	r3, [pc, #244]	; (3f2c <Vector88+0x17c>)
    3e36:	2200      	movs	r2, #0
    3e38:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD2.dmastp) > 0)) {
    3e3a:	9b01      	ldr	r3, [sp, #4]
    3e3c:	f003 0320 	and.w	r3, r3, #32
    3e40:	2b00      	cmp	r3, #0
    3e42:	d02d      	beq.n	3ea0 <Vector88+0xf0>
    3e44:	4b3a      	ldr	r3, [pc, #232]	; (3f30 <Vector88+0x180>)
    3e46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3e48:	681b      	ldr	r3, [r3, #0]
    3e4a:	685b      	ldr	r3, [r3, #4]
    3e4c:	2b00      	cmp	r3, #0
    3e4e:	d027      	beq.n	3ea0 <Vector88+0xf0>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD2.grpp != NULL)
    3e50:	4b37      	ldr	r3, [pc, #220]	; (3f30 <Vector88+0x180>)
    3e52:	691b      	ldr	r3, [r3, #16]
    3e54:	2b00      	cmp	r3, #0
    3e56:	d023      	beq.n	3ea0 <Vector88+0xf0>
      _adc_isr_error_code(&ADCD2, ADC_ERR_OVERFLOW);
    3e58:	4835      	ldr	r0, [pc, #212]	; (3f30 <Vector88+0x180>)
    3e5a:	f000 f8c1 	bl	3fe0 <adc_lld_stop_conversion>
    3e5e:	4b34      	ldr	r3, [pc, #208]	; (3f30 <Vector88+0x180>)
    3e60:	691b      	ldr	r3, [r3, #16]
    3e62:	689b      	ldr	r3, [r3, #8]
    3e64:	2b00      	cmp	r3, #0
    3e66:	d00f      	beq.n	3e88 <Vector88+0xd8>
    3e68:	4b31      	ldr	r3, [pc, #196]	; (3f30 <Vector88+0x180>)
    3e6a:	2205      	movs	r2, #5
    3e6c:	701a      	strb	r2, [r3, #0]
    3e6e:	4b30      	ldr	r3, [pc, #192]	; (3f30 <Vector88+0x180>)
    3e70:	691b      	ldr	r3, [r3, #16]
    3e72:	689b      	ldr	r3, [r3, #8]
    3e74:	482e      	ldr	r0, [pc, #184]	; (3f30 <Vector88+0x180>)
    3e76:	2101      	movs	r1, #1
    3e78:	4798      	blx	r3
    3e7a:	4b2d      	ldr	r3, [pc, #180]	; (3f30 <Vector88+0x180>)
    3e7c:	781b      	ldrb	r3, [r3, #0]
    3e7e:	2b05      	cmp	r3, #5
    3e80:	d102      	bne.n	3e88 <Vector88+0xd8>
    3e82:	4b2b      	ldr	r3, [pc, #172]	; (3f30 <Vector88+0x180>)
    3e84:	2202      	movs	r2, #2
    3e86:	701a      	strb	r2, [r3, #0]
    3e88:	4b29      	ldr	r3, [pc, #164]	; (3f30 <Vector88+0x180>)
    3e8a:	2200      	movs	r2, #0
    3e8c:	611a      	str	r2, [r3, #16]
    3e8e:	f7ff ff6f 	bl	3d70 <osalSysLockFromISR>
    3e92:	4828      	ldr	r0, [pc, #160]	; (3f34 <Vector88+0x184>)
    3e94:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3e98:	f7ff ff7a 	bl	3d90 <osalThreadResumeI>
    3e9c:	f7ff ff70 	bl	3d80 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC2 */

#if STM32_ADC_USE_ADC3
  sr = ADC3->SR;
    3ea0:	4b25      	ldr	r3, [pc, #148]	; (3f38 <Vector88+0x188>)
    3ea2:	681b      	ldr	r3, [r3, #0]
    3ea4:	9301      	str	r3, [sp, #4]
  ADC3->SR = 0;
    3ea6:	4b24      	ldr	r3, [pc, #144]	; (3f38 <Vector88+0x188>)
    3ea8:	2200      	movs	r2, #0
    3eaa:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD3.dmastp) > 0)) {
    3eac:	9b01      	ldr	r3, [sp, #4]
    3eae:	f003 0320 	and.w	r3, r3, #32
    3eb2:	2b00      	cmp	r3, #0
    3eb4:	d02d      	beq.n	3f12 <Vector88+0x162>
    3eb6:	4b21      	ldr	r3, [pc, #132]	; (3f3c <Vector88+0x18c>)
    3eb8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3eba:	681b      	ldr	r3, [r3, #0]
    3ebc:	685b      	ldr	r3, [r3, #4]
    3ebe:	2b00      	cmp	r3, #0
    3ec0:	d027      	beq.n	3f12 <Vector88+0x162>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD3.grpp != NULL)
    3ec2:	4b1e      	ldr	r3, [pc, #120]	; (3f3c <Vector88+0x18c>)
    3ec4:	691b      	ldr	r3, [r3, #16]
    3ec6:	2b00      	cmp	r3, #0
    3ec8:	d023      	beq.n	3f12 <Vector88+0x162>
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
    3eca:	481c      	ldr	r0, [pc, #112]	; (3f3c <Vector88+0x18c>)
    3ecc:	f000 f888 	bl	3fe0 <adc_lld_stop_conversion>
    3ed0:	4b1a      	ldr	r3, [pc, #104]	; (3f3c <Vector88+0x18c>)
    3ed2:	691b      	ldr	r3, [r3, #16]
    3ed4:	689b      	ldr	r3, [r3, #8]
    3ed6:	2b00      	cmp	r3, #0
    3ed8:	d00f      	beq.n	3efa <Vector88+0x14a>
    3eda:	4b18      	ldr	r3, [pc, #96]	; (3f3c <Vector88+0x18c>)
    3edc:	2205      	movs	r2, #5
    3ede:	701a      	strb	r2, [r3, #0]
    3ee0:	4b16      	ldr	r3, [pc, #88]	; (3f3c <Vector88+0x18c>)
    3ee2:	691b      	ldr	r3, [r3, #16]
    3ee4:	689b      	ldr	r3, [r3, #8]
    3ee6:	4815      	ldr	r0, [pc, #84]	; (3f3c <Vector88+0x18c>)
    3ee8:	2101      	movs	r1, #1
    3eea:	4798      	blx	r3
    3eec:	4b13      	ldr	r3, [pc, #76]	; (3f3c <Vector88+0x18c>)
    3eee:	781b      	ldrb	r3, [r3, #0]
    3ef0:	2b05      	cmp	r3, #5
    3ef2:	d102      	bne.n	3efa <Vector88+0x14a>
    3ef4:	4b11      	ldr	r3, [pc, #68]	; (3f3c <Vector88+0x18c>)
    3ef6:	2202      	movs	r2, #2
    3ef8:	701a      	strb	r2, [r3, #0]
    3efa:	4b10      	ldr	r3, [pc, #64]	; (3f3c <Vector88+0x18c>)
    3efc:	2200      	movs	r2, #0
    3efe:	611a      	str	r2, [r3, #16]
    3f00:	f7ff ff36 	bl	3d70 <osalSysLockFromISR>
    3f04:	480e      	ldr	r0, [pc, #56]	; (3f40 <Vector88+0x190>)
    3f06:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3f0a:	f7ff ff41 	bl	3d90 <osalThreadResumeI>
    3f0e:	f7ff ff37 	bl	3d80 <osalSysUnlockFromISR>
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
    3f12:	f7fc fd9d 	bl	a50 <_dbg_check_leave_isr>
    3f16:	f7fe ffcb 	bl	2eb0 <_port_irq_epilogue>
}
    3f1a:	b003      	add	sp, #12
    3f1c:	f85d fb04 	ldr.w	pc, [sp], #4
    3f20:	40012000 	.word	0x40012000
    3f24:	20001144 	.word	0x20001144
    3f28:	20001158 	.word	0x20001158
    3f2c:	40012100 	.word	0x40012100
    3f30:	20001178 	.word	0x20001178
    3f34:	2000118c 	.word	0x2000118c
    3f38:	40012200 	.word	0x40012200
    3f3c:	200011ac 	.word	0x200011ac
    3f40:	200011c0 	.word	0x200011c0
    3f44:	f3af 8000 	nop.w
    3f48:	f3af 8000 	nop.w
    3f4c:	f3af 8000 	nop.w

00003f50 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
    3f50:	b508      	push	{r3, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
    3f52:	4814      	ldr	r0, [pc, #80]	; (3fa4 <adc_lld_init+0x54>)
    3f54:	f7ff f88c 	bl	3070 <adcObjectInit>
  ADCD1.adc = ADC1;
    3f58:	4b12      	ldr	r3, [pc, #72]	; (3fa4 <adc_lld_init+0x54>)
    3f5a:	4a13      	ldr	r2, [pc, #76]	; (3fa8 <adc_lld_init+0x58>)
    3f5c:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
    3f5e:	4b11      	ldr	r3, [pc, #68]	; (3fa4 <adc_lld_init+0x54>)
    3f60:	4a12      	ldr	r2, [pc, #72]	; (3fac <adc_lld_init+0x5c>)
    3f62:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
    3f64:	4b0f      	ldr	r3, [pc, #60]	; (3fa4 <adc_lld_init+0x54>)
    3f66:	4a12      	ldr	r2, [pc, #72]	; (3fb0 <adc_lld_init+0x60>)
    3f68:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

#if STM32_ADC_USE_ADC2
  /* Driver initialization.*/
  adcObjectInit(&ADCD2);
    3f6a:	4812      	ldr	r0, [pc, #72]	; (3fb4 <adc_lld_init+0x64>)
    3f6c:	f7ff f880 	bl	3070 <adcObjectInit>
  ADCD2.adc = ADC2;
    3f70:	4b10      	ldr	r3, [pc, #64]	; (3fb4 <adc_lld_init+0x64>)
    3f72:	4a11      	ldr	r2, [pc, #68]	; (3fb8 <adc_lld_init+0x68>)
    3f74:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD2.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC2_DMA_STREAM);
    3f76:	4b0f      	ldr	r3, [pc, #60]	; (3fb4 <adc_lld_init+0x64>)
    3f78:	4a10      	ldr	r2, [pc, #64]	; (3fbc <adc_lld_init+0x6c>)
    3f7a:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD2.dmamode = STM32_DMA_CR_CHSEL(ADC2_DMA_CHANNEL) |
    3f7c:	4b0d      	ldr	r3, [pc, #52]	; (3fb4 <adc_lld_init+0x64>)
    3f7e:	4a10      	ldr	r2, [pc, #64]	; (3fc0 <adc_lld_init+0x70>)
    3f80:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

#if STM32_ADC_USE_ADC3
  /* Driver initialization.*/
  adcObjectInit(&ADCD3);
    3f82:	4810      	ldr	r0, [pc, #64]	; (3fc4 <adc_lld_init+0x74>)
    3f84:	f7ff f874 	bl	3070 <adcObjectInit>
  ADCD3.adc = ADC3;
    3f88:	4b0e      	ldr	r3, [pc, #56]	; (3fc4 <adc_lld_init+0x74>)
    3f8a:	4a0f      	ldr	r2, [pc, #60]	; (3fc8 <adc_lld_init+0x78>)
    3f8c:	629a      	str	r2, [r3, #40]	; 0x28
  ADCD3.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC3_DMA_STREAM);
    3f8e:	4b0d      	ldr	r3, [pc, #52]	; (3fc4 <adc_lld_init+0x74>)
    3f90:	4a0e      	ldr	r2, [pc, #56]	; (3fcc <adc_lld_init+0x7c>)
    3f92:	62da      	str	r2, [r3, #44]	; 0x2c
  ADCD3.dmamode = STM32_DMA_CR_CHSEL(ADC3_DMA_CHANNEL) |
    3f94:	4b0b      	ldr	r3, [pc, #44]	; (3fc4 <adc_lld_init+0x74>)
    3f96:	4a0e      	ldr	r2, [pc, #56]	; (3fd0 <adc_lld_init+0x80>)
    3f98:	631a      	str	r2, [r3, #48]	; 0x30
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
#endif

  /* The shared vector is initialized on driver initialization and never
     disabled because sharing.*/
  nvicEnableVector(STM32_ADC_NUMBER, STM32_ADC_IRQ_PRIORITY);
    3f9a:	2012      	movs	r0, #18
    3f9c:	2106      	movs	r1, #6
    3f9e:	f7ff fa4f 	bl	3440 <nvicEnableVector>
}
    3fa2:	bd08      	pop	{r3, pc}
    3fa4:	20001144 	.word	0x20001144
    3fa8:	40012000 	.word	0x40012000
    3fac:	00004ab0 	.word	0x00004ab0
    3fb0:	00022c16 	.word	0x00022c16
    3fb4:	20001178 	.word	0x20001178
    3fb8:	40012100 	.word	0x40012100
    3fbc:	00004a98 	.word	0x00004a98
    3fc0:	02022c16 	.word	0x02022c16
    3fc4:	200011ac 	.word	0x200011ac
    3fc8:	40012200 	.word	0x40012200
    3fcc:	00004a8c 	.word	0x00004a8c
    3fd0:	04022c16 	.word	0x04022c16
    3fd4:	f3af 8000 	nop.w
    3fd8:	f3af 8000 	nop.w
    3fdc:	f3af 8000 	nop.w

00003fe0 <adc_lld_stop_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
    3fe0:	b082      	sub	sp, #8
    3fe2:	9001      	str	r0, [sp, #4]

  dmaStreamDisable(adcp->dmastp);
    3fe4:	9b01      	ldr	r3, [sp, #4]
    3fe6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3fe8:	681b      	ldr	r3, [r3, #0]
    3fea:	9a01      	ldr	r2, [sp, #4]
    3fec:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    3fee:	6812      	ldr	r2, [r2, #0]
    3ff0:	6812      	ldr	r2, [r2, #0]
    3ff2:	f022 021f 	bic.w	r2, r2, #31
    3ff6:	601a      	str	r2, [r3, #0]
    3ff8:	bf00      	nop
    3ffa:	9b01      	ldr	r3, [sp, #4]
    3ffc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3ffe:	681b      	ldr	r3, [r3, #0]
    4000:	681b      	ldr	r3, [r3, #0]
    4002:	f003 0301 	and.w	r3, r3, #1
    4006:	2b00      	cmp	r3, #0
    4008:	d1f7      	bne.n	3ffa <adc_lld_stop_conversion+0x1a>
    400a:	9b01      	ldr	r3, [sp, #4]
    400c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    400e:	685b      	ldr	r3, [r3, #4]
    4010:	9a01      	ldr	r2, [sp, #4]
    4012:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    4014:	7a12      	ldrb	r2, [r2, #8]
    4016:	213d      	movs	r1, #61	; 0x3d
    4018:	fa01 f202 	lsl.w	r2, r1, r2
    401c:	601a      	str	r2, [r3, #0]
  adcp->adc->CR1 = 0;
    401e:	9b01      	ldr	r3, [sp, #4]
    4020:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4022:	2200      	movs	r2, #0
    4024:	605a      	str	r2, [r3, #4]
  adcp->adc->CR2 = 0;
    4026:	9b01      	ldr	r3, [sp, #4]
    4028:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    402a:	2200      	movs	r2, #0
    402c:	609a      	str	r2, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
    402e:	9b01      	ldr	r3, [sp, #4]
    4030:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4032:	2201      	movs	r2, #1
    4034:	609a      	str	r2, [r3, #8]
}
    4036:	b002      	add	sp, #8
    4038:	4770      	bx	lr
    403a:	bf00      	nop
    403c:	f3af 8000 	nop.w

00004040 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
    4040:	b082      	sub	sp, #8
    4042:	9001      	str	r0, [sp, #4]
    4044:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
    4046:	9b00      	ldr	r3, [sp, #0]
    4048:	685a      	ldr	r2, [r3, #4]
    404a:	9b01      	ldr	r3, [sp, #4]
    404c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
    404e:	9b00      	ldr	r3, [sp, #0]
    4050:	689a      	ldr	r2, [r3, #8]
    4052:	9b01      	ldr	r3, [sp, #4]
    4054:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
    4056:	9b00      	ldr	r3, [sp, #0]
    4058:	68da      	ldr	r2, [r3, #12]
    405a:	9b01      	ldr	r3, [sp, #4]
    405c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
    405e:	9b00      	ldr	r3, [sp, #0]
    4060:	691a      	ldr	r2, [r3, #16]
    4062:	9b01      	ldr	r3, [sp, #4]
    4064:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
    4066:	9b00      	ldr	r3, [sp, #0]
    4068:	695a      	ldr	r2, [r3, #20]
    406a:	9b01      	ldr	r3, [sp, #4]
    406c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
    406e:	9b00      	ldr	r3, [sp, #0]
    4070:	699a      	ldr	r2, [r3, #24]
    4072:	9b01      	ldr	r3, [sp, #4]
    4074:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
    4076:	9b00      	ldr	r3, [sp, #0]
    4078:	681a      	ldr	r2, [r3, #0]
    407a:	9b01      	ldr	r3, [sp, #4]
    407c:	601a      	str	r2, [r3, #0]
}
    407e:	b002      	add	sp, #8
    4080:	4770      	bx	lr
    4082:	bf00      	nop
    4084:	f3af 8000 	nop.w
    4088:	f3af 8000 	nop.w
    408c:	f3af 8000 	nop.w

00004090 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    4090:	b500      	push	{lr}
    4092:	b083      	sub	sp, #12
    4094:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
    4096:	4a24      	ldr	r2, [pc, #144]	; (4128 <_pal_lld_init+0x98>)
    4098:	4b23      	ldr	r3, [pc, #140]	; (4128 <_pal_lld_init+0x98>)
    409a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    409c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    40a0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    40a4:	6313      	str	r3, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
    40a6:	4a20      	ldr	r2, [pc, #128]	; (4128 <_pal_lld_init+0x98>)
    40a8:	4b1f      	ldr	r3, [pc, #124]	; (4128 <_pal_lld_init+0x98>)
    40aa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    40ac:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    40b0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    40b4:	6513      	str	r3, [r2, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
    40b6:	9b01      	ldr	r3, [sp, #4]
    40b8:	481c      	ldr	r0, [pc, #112]	; (412c <_pal_lld_init+0x9c>)
    40ba:	4619      	mov	r1, r3
    40bc:	f7ff ffc0 	bl	4040 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
    40c0:	9b01      	ldr	r3, [sp, #4]
    40c2:	331c      	adds	r3, #28
    40c4:	481a      	ldr	r0, [pc, #104]	; (4130 <_pal_lld_init+0xa0>)
    40c6:	4619      	mov	r1, r3
    40c8:	f7ff ffba 	bl	4040 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
    40cc:	9b01      	ldr	r3, [sp, #4]
    40ce:	3338      	adds	r3, #56	; 0x38
    40d0:	4818      	ldr	r0, [pc, #96]	; (4134 <_pal_lld_init+0xa4>)
    40d2:	4619      	mov	r1, r3
    40d4:	f7ff ffb4 	bl	4040 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
    40d8:	9b01      	ldr	r3, [sp, #4]
    40da:	3354      	adds	r3, #84	; 0x54
    40dc:	4816      	ldr	r0, [pc, #88]	; (4138 <_pal_lld_init+0xa8>)
    40de:	4619      	mov	r1, r3
    40e0:	f7ff ffae 	bl	4040 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
    40e4:	9b01      	ldr	r3, [sp, #4]
    40e6:	3370      	adds	r3, #112	; 0x70
    40e8:	4814      	ldr	r0, [pc, #80]	; (413c <_pal_lld_init+0xac>)
    40ea:	4619      	mov	r1, r3
    40ec:	f7ff ffa8 	bl	4040 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
    40f0:	9b01      	ldr	r3, [sp, #4]
    40f2:	338c      	adds	r3, #140	; 0x8c
    40f4:	4812      	ldr	r0, [pc, #72]	; (4140 <_pal_lld_init+0xb0>)
    40f6:	4619      	mov	r1, r3
    40f8:	f7ff ffa2 	bl	4040 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
    40fc:	9b01      	ldr	r3, [sp, #4]
    40fe:	33a8      	adds	r3, #168	; 0xa8
    4100:	4810      	ldr	r0, [pc, #64]	; (4144 <_pal_lld_init+0xb4>)
    4102:	4619      	mov	r1, r3
    4104:	f7ff ff9c 	bl	4040 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
    4108:	9b01      	ldr	r3, [sp, #4]
    410a:	33c4      	adds	r3, #196	; 0xc4
    410c:	480e      	ldr	r0, [pc, #56]	; (4148 <_pal_lld_init+0xb8>)
    410e:	4619      	mov	r1, r3
    4110:	f7ff ff96 	bl	4040 <initgpio>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
    4114:	9b01      	ldr	r3, [sp, #4]
    4116:	33e0      	adds	r3, #224	; 0xe0
    4118:	480c      	ldr	r0, [pc, #48]	; (414c <_pal_lld_init+0xbc>)
    411a:	4619      	mov	r1, r3
    411c:	f7ff ff90 	bl	4040 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
    4120:	b003      	add	sp, #12
    4122:	f85d fb04 	ldr.w	pc, [sp], #4
    4126:	bf00      	nop
    4128:	40023800 	.word	0x40023800
    412c:	40020000 	.word	0x40020000
    4130:	40020400 	.word	0x40020400
    4134:	40020800 	.word	0x40020800
    4138:	40020c00 	.word	0x40020c00
    413c:	40021000 	.word	0x40021000
    4140:	40021400 	.word	0x40021400
    4144:	40021800 	.word	0x40021800
    4148:	40021c00 	.word	0x40021c00
    414c:	40022000 	.word	0x40022000

00004150 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    4150:	b08e      	sub	sp, #56	; 0x38
    4152:	9003      	str	r0, [sp, #12]
    4154:	9102      	str	r1, [sp, #8]
    4156:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
    4158:	9b01      	ldr	r3, [sp, #4]
    415a:	f003 0303 	and.w	r3, r3, #3
    415e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
    4160:	9b01      	ldr	r3, [sp, #4]
    4162:	f003 0304 	and.w	r3, r3, #4
    4166:	089b      	lsrs	r3, r3, #2
    4168:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
    416a:	9b01      	ldr	r3, [sp, #4]
    416c:	f003 0318 	and.w	r3, r3, #24
    4170:	08db      	lsrs	r3, r3, #3
    4172:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
    4174:	9b01      	ldr	r3, [sp, #4]
    4176:	f003 0360 	and.w	r3, r3, #96	; 0x60
    417a:	095b      	lsrs	r3, r3, #5
    417c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
    417e:	9b01      	ldr	r3, [sp, #4]
    4180:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
    4184:	09db      	lsrs	r3, r3, #7
    4186:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
    4188:	2300      	movs	r3, #0
    418a:	9309      	str	r3, [sp, #36]	; 0x24
  while (TRUE) {
    if ((mask & 1) != 0) {
    418c:	9b02      	ldr	r3, [sp, #8]
    418e:	f003 0301 	and.w	r3, r3, #1
    4192:	2b00      	cmp	r3, #0
    4194:	d054      	beq.n	4240 <_pal_lld_setgroupmode+0xf0>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
    4196:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4198:	f003 0307 	and.w	r3, r3, #7
    419c:	009b      	lsls	r3, r3, #2
    419e:	9a08      	ldr	r2, [sp, #32]
    41a0:	fa02 f303 	lsl.w	r3, r2, r3
    41a4:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
    41a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    41a8:	f003 0307 	and.w	r3, r3, #7
    41ac:	009b      	lsls	r3, r3, #2
    41ae:	220f      	movs	r2, #15
    41b0:	fa02 f303 	lsl.w	r3, r2, r3
    41b4:	9306      	str	r3, [sp, #24]
      if (bit < 8)
    41b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    41b8:	2b07      	cmp	r3, #7
    41ba:	d809      	bhi.n	41d0 <_pal_lld_setgroupmode+0x80>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
    41bc:	9b03      	ldr	r3, [sp, #12]
    41be:	6a1a      	ldr	r2, [r3, #32]
    41c0:	9b06      	ldr	r3, [sp, #24]
    41c2:	43db      	mvns	r3, r3
    41c4:	401a      	ands	r2, r3
    41c6:	9b07      	ldr	r3, [sp, #28]
    41c8:	431a      	orrs	r2, r3
    41ca:	9b03      	ldr	r3, [sp, #12]
    41cc:	621a      	str	r2, [r3, #32]
    41ce:	e008      	b.n	41e2 <_pal_lld_setgroupmode+0x92>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
    41d0:	9b03      	ldr	r3, [sp, #12]
    41d2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    41d4:	9b06      	ldr	r3, [sp, #24]
    41d6:	43db      	mvns	r3, r3
    41d8:	401a      	ands	r2, r3
    41da:	9b07      	ldr	r3, [sp, #28]
    41dc:	431a      	orrs	r2, r3
    41de:	9b03      	ldr	r3, [sp, #12]
    41e0:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
    41e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    41e4:	2201      	movs	r2, #1
    41e6:	fa02 f303 	lsl.w	r3, r2, r3
    41ea:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
    41ec:	9b03      	ldr	r3, [sp, #12]
    41ee:	685a      	ldr	r2, [r3, #4]
    41f0:	9b05      	ldr	r3, [sp, #20]
    41f2:	43db      	mvns	r3, r3
    41f4:	401a      	ands	r2, r3
    41f6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    41f8:	431a      	orrs	r2, r3
    41fa:	9b03      	ldr	r3, [sp, #12]
    41fc:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
    41fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4200:	005b      	lsls	r3, r3, #1
    4202:	2203      	movs	r2, #3
    4204:	fa02 f303 	lsl.w	r3, r2, r3
    4208:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
    420a:	9b03      	ldr	r3, [sp, #12]
    420c:	689a      	ldr	r2, [r3, #8]
    420e:	9b04      	ldr	r3, [sp, #16]
    4210:	43db      	mvns	r3, r3
    4212:	401a      	ands	r2, r3
    4214:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4216:	431a      	orrs	r2, r3
    4218:	9b03      	ldr	r3, [sp, #12]
    421a:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
    421c:	9b03      	ldr	r3, [sp, #12]
    421e:	68da      	ldr	r2, [r3, #12]
    4220:	9b04      	ldr	r3, [sp, #16]
    4222:	43db      	mvns	r3, r3
    4224:	401a      	ands	r2, r3
    4226:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4228:	431a      	orrs	r2, r3
    422a:	9b03      	ldr	r3, [sp, #12]
    422c:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
    422e:	9b03      	ldr	r3, [sp, #12]
    4230:	681a      	ldr	r2, [r3, #0]
    4232:	9b04      	ldr	r3, [sp, #16]
    4234:	43db      	mvns	r3, r3
    4236:	401a      	ands	r2, r3
    4238:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    423a:	431a      	orrs	r2, r3
    423c:	9b03      	ldr	r3, [sp, #12]
    423e:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
    4240:	9b02      	ldr	r3, [sp, #8]
    4242:	085b      	lsrs	r3, r3, #1
    4244:	9302      	str	r3, [sp, #8]
    if (!mask)
    4246:	9b02      	ldr	r3, [sp, #8]
    4248:	2b00      	cmp	r3, #0
    424a:	d100      	bne.n	424e <_pal_lld_setgroupmode+0xfe>
      return;
    424c:	e00f      	b.n	426e <_pal_lld_setgroupmode+0x11e>
    otyper <<= 1;
    424e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4250:	005b      	lsls	r3, r3, #1
    4252:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
    4254:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4256:	009b      	lsls	r3, r3, #2
    4258:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
    425a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    425c:	009b      	lsls	r3, r3, #2
    425e:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
    4260:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4262:	009b      	lsls	r3, r3, #2
    4264:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
    4266:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4268:	3301      	adds	r3, #1
    426a:	9309      	str	r3, [sp, #36]	; 0x24
  }
    426c:	e78e      	b.n	418c <_pal_lld_setgroupmode+0x3c>
}
    426e:	b00e      	add	sp, #56	; 0x38
    4270:	4770      	bx	lr
    4272:	bf00      	nop
    4274:	f3af 8000 	nop.w
    4278:	f3af 8000 	nop.w
    427c:	f3af 8000 	nop.w

00004280 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
    4280:	b082      	sub	sp, #8
    4282:	2320      	movs	r3, #32
    4284:	9301      	str	r3, [sp, #4]
    4286:	9b01      	ldr	r3, [sp, #4]
    4288:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    428c:	b002      	add	sp, #8
    428e:	4770      	bx	lr

00004290 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
    4290:	b082      	sub	sp, #8
    4292:	2300      	movs	r3, #0
    4294:	9301      	str	r3, [sp, #4]
    4296:	9b01      	ldr	r3, [sp, #4]
    4298:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
    429c:	b002      	add	sp, #8
    429e:	4770      	bx	lr

000042a0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
    42a0:	b508      	push	{r3, lr}

  port_lock();
    42a2:	f7ff ffed 	bl	4280 <port_lock>
}
    42a6:	bd08      	pop	{r3, pc}
    42a8:	f3af 8000 	nop.w
    42ac:	f3af 8000 	nop.w

000042b0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
    42b0:	b508      	push	{r3, lr}

  port_unlock();
    42b2:	f7ff ffed 	bl	4290 <port_unlock>
}
    42b6:	bd08      	pop	{r3, pc}
    42b8:	f3af 8000 	nop.w
    42bc:	f3af 8000 	nop.w

000042c0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
    42c0:	b508      	push	{r3, lr}

  port_lock_from_isr();
    42c2:	f7ff ffed 	bl	42a0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
    42c6:	f7fd fc4b 	bl	1b60 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
    42ca:	f7fc fb71 	bl	9b0 <_dbg_check_lock_from_isr>
}
    42ce:	bd08      	pop	{r3, pc}

000042d0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
    42d0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
    42d2:	f7fc fb85 	bl	9e0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
    42d6:	f7fd fc4b 	bl	1b70 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
    42da:	f7ff ffe9 	bl	42b0 <port_unlock_from_isr>
}
    42de:	bd08      	pop	{r3, pc}

000042e0 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
    42e0:	b500      	push	{lr}
    42e2:	b083      	sub	sp, #12
    42e4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
    42e6:	f7fc fbd3 	bl	a90 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    42ea:	9b01      	ldr	r3, [sp, #4]
    42ec:	695a      	ldr	r2, [r3, #20]
    42ee:	9b01      	ldr	r3, [sp, #4]
    42f0:	699b      	ldr	r3, [r3, #24]
    42f2:	429a      	cmp	r2, r3
    42f4:	d105      	bne.n	4302 <chOQIsEmptyI+0x22>
    42f6:	9b01      	ldr	r3, [sp, #4]
    42f8:	689b      	ldr	r3, [r3, #8]
    42fa:	2b00      	cmp	r3, #0
    42fc:	d001      	beq.n	4302 <chOQIsEmptyI+0x22>
    42fe:	2301      	movs	r3, #1
    4300:	e000      	b.n	4304 <chOQIsEmptyI+0x24>
    4302:	2300      	movs	r3, #0
    4304:	f003 0301 	and.w	r3, r3, #1
    4308:	b2db      	uxtb	r3, r3
}
    430a:	4618      	mov	r0, r3
    430c:	b003      	add	sp, #12
    430e:	f85d fb04 	ldr.w	pc, [sp], #4
    4312:	bf00      	nop
    4314:	f3af 8000 	nop.w
    4318:	f3af 8000 	nop.w
    431c:	f3af 8000 	nop.w

00004320 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
    4320:	b508      	push	{r3, lr}

  chSysLockFromISR();
    4322:	f7ff ffcd 	bl	42c0 <chSysLockFromISR>
}
    4326:	bd08      	pop	{r3, pc}
    4328:	f3af 8000 	nop.w
    432c:	f3af 8000 	nop.w

00004330 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
    4330:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
    4332:	f7ff ffcd 	bl	42d0 <chSysUnlockFromISR>
}
    4336:	bd08      	pop	{r3, pc}
    4338:	f3af 8000 	nop.w
    433c:	f3af 8000 	nop.w

00004340 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    4340:	b500      	push	{lr}
    4342:	b083      	sub	sp, #12
    4344:	9001      	str	r0, [sp, #4]
    4346:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
    4348:	9801      	ldr	r0, [sp, #4]
    434a:	9900      	ldr	r1, [sp, #0]
    434c:	f7fd ffa8 	bl	22a0 <chEvtBroadcastFlagsI>
}
    4350:	b003      	add	sp, #12
    4352:	f85d fb04 	ldr.w	pc, [sp], #4
    4356:	bf00      	nop
    4358:	f3af 8000 	nop.w
    435c:	f3af 8000 	nop.w

00004360 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
    4360:	b084      	sub	sp, #16
    4362:	9001      	str	r0, [sp, #4]
    4364:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
    4366:	9b01      	ldr	r3, [sp, #4]
    4368:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    436c:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
    436e:	9b01      	ldr	r3, [sp, #4]
    4370:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    4374:	4b1d      	ldr	r3, [pc, #116]	; (43ec <usart_init+0x8c>)
    4376:	429a      	cmp	r2, r3
    4378:	d005      	beq.n	4386 <usart_init+0x26>
    437a:	9b01      	ldr	r3, [sp, #4]
    437c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    4380:	4b1b      	ldr	r3, [pc, #108]	; (43f0 <usart_init+0x90>)
    4382:	429a      	cmp	r2, r3
    4384:	d107      	bne.n	4396 <usart_init+0x36>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
    4386:	9b00      	ldr	r3, [sp, #0]
    4388:	681b      	ldr	r3, [r3, #0]
    438a:	4a1a      	ldr	r2, [pc, #104]	; (43f4 <usart_init+0x94>)
    438c:	fbb2 f2f3 	udiv	r2, r2, r3
    4390:	9b03      	ldr	r3, [sp, #12]
    4392:	609a      	str	r2, [r3, #8]
    4394:	e006      	b.n	43a4 <usart_init+0x44>
  else
    u->BRR = STM32_PCLK1 / config->speed;
    4396:	9b00      	ldr	r3, [sp, #0]
    4398:	681b      	ldr	r3, [r3, #0]
    439a:	4a17      	ldr	r2, [pc, #92]	; (43f8 <usart_init+0x98>)
    439c:	fbb2 f2f3 	udiv	r2, r2, r3
    43a0:	9b03      	ldr	r3, [sp, #12]
    43a2:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
    43a4:	9b00      	ldr	r3, [sp, #0]
    43a6:	88db      	ldrh	r3, [r3, #6]
    43a8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    43ac:	b29b      	uxth	r3, r3
    43ae:	461a      	mov	r2, r3
    43b0:	9b03      	ldr	r3, [sp, #12]
    43b2:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
    43b4:	9b00      	ldr	r3, [sp, #0]
    43b6:	891b      	ldrh	r3, [r3, #8]
    43b8:	f043 0301 	orr.w	r3, r3, #1
    43bc:	b29b      	uxth	r3, r3
    43be:	461a      	mov	r2, r3
    43c0:	9b03      	ldr	r3, [sp, #12]
    43c2:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
    43c4:	9b00      	ldr	r3, [sp, #0]
    43c6:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
    43c8:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
    43cc:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
    43d0:	b29b      	uxth	r3, r3
    43d2:	461a      	mov	r2, r3
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
    43d4:	9b03      	ldr	r3, [sp, #12]
    43d6:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
    43d8:	9b03      	ldr	r3, [sp, #12]
    43da:	2200      	movs	r2, #0
    43dc:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
    43de:	9b03      	ldr	r3, [sp, #12]
    43e0:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
    43e2:	9b03      	ldr	r3, [sp, #12]
    43e4:	685b      	ldr	r3, [r3, #4]
}
    43e6:	b004      	add	sp, #16
    43e8:	4770      	bx	lr
    43ea:	bf00      	nop
    43ec:	40011000 	.word	0x40011000
    43f0:	40011400 	.word	0x40011400
    43f4:	0501bd00 	.word	0x0501bd00
    43f8:	0280de80 	.word	0x0280de80
    43fc:	f3af 8000 	nop.w

00004400 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
    4400:	b500      	push	{lr}
    4402:	b085      	sub	sp, #20
    4404:	9001      	str	r0, [sp, #4]
    4406:	460b      	mov	r3, r1
    4408:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
    440c:	2300      	movs	r3, #0
    440e:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
    4410:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    4414:	f003 0308 	and.w	r3, r3, #8
    4418:	2b00      	cmp	r3, #0
    441a:	d003      	beq.n	4424 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
    441c:	9b03      	ldr	r3, [sp, #12]
    441e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    4422:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
    4424:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    4428:	f003 0301 	and.w	r3, r3, #1
    442c:	2b00      	cmp	r3, #0
    442e:	d003      	beq.n	4438 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
    4430:	9b03      	ldr	r3, [sp, #12]
    4432:	f043 0320 	orr.w	r3, r3, #32
    4436:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
    4438:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    443c:	f003 0302 	and.w	r3, r3, #2
    4440:	2b00      	cmp	r3, #0
    4442:	d003      	beq.n	444c <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
    4444:	9b03      	ldr	r3, [sp, #12]
    4446:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    444a:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
    444c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    4450:	f003 0304 	and.w	r3, r3, #4
    4454:	2b00      	cmp	r3, #0
    4456:	d003      	beq.n	4460 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
    4458:	9b03      	ldr	r3, [sp, #12]
    445a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    445e:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
    4460:	9b01      	ldr	r3, [sp, #4]
    4462:	3304      	adds	r3, #4
    4464:	4618      	mov	r0, r3
    4466:	9903      	ldr	r1, [sp, #12]
    4468:	f7ff ff6a 	bl	4340 <osalEventBroadcastFlagsI>
}
    446c:	b005      	add	sp, #20
    446e:	f85d fb04 	ldr.w	pc, [sp], #4
    4472:	bf00      	nop
    4474:	f3af 8000 	nop.w
    4478:	f3af 8000 	nop.w
    447c:	f3af 8000 	nop.w

00004480 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
    4480:	b500      	push	{lr}
    4482:	b087      	sub	sp, #28
    4484:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
    4486:	9b01      	ldr	r3, [sp, #4]
    4488:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    448c:	9304      	str	r3, [sp, #16]
  uint16_t cr1 = u->CR1;
    448e:	9b04      	ldr	r3, [sp, #16]
    4490:	68db      	ldr	r3, [r3, #12]
    4492:	f8ad 300e 	strh.w	r3, [sp, #14]
  uint16_t sr = u->SR;
    4496:	9b04      	ldr	r3, [sp, #16]
    4498:	681b      	ldr	r3, [r3, #0]
    449a:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    449e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    44a2:	f403 7380 	and.w	r3, r3, #256	; 0x100
    44a6:	2b00      	cmp	r3, #0
    44a8:	d00e      	beq.n	44c8 <serve_interrupt+0x48>
    osalSysLockFromISR();
    44aa:	f7ff ff39 	bl	4320 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    44ae:	9b01      	ldr	r3, [sp, #4]
    44b0:	3304      	adds	r3, #4
    44b2:	4618      	mov	r0, r3
    44b4:	f44f 7100 	mov.w	r1, #512	; 0x200
    44b8:	f7ff ff42 	bl	4340 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
    44bc:	9b04      	ldr	r3, [sp, #16]
    44be:	f46f 7280 	mvn.w	r2, #256	; 0x100
    44c2:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
    44c4:	f7ff ff34 	bl	4330 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  osalSysLockFromISR();
    44c8:	f7ff ff2a 	bl	4320 <osalSysLockFromISR>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
    44cc:	e01f      	b.n	450e <serve_interrupt+0x8e>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
    44ce:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    44d2:	f003 030f 	and.w	r3, r3, #15
    44d6:	2b00      	cmp	r3, #0
    44d8:	d005      	beq.n	44e6 <serve_interrupt+0x66>
      set_error(sdp, sr);
    44da:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    44de:	9801      	ldr	r0, [sp, #4]
    44e0:	4619      	mov	r1, r3
    44e2:	f7ff ff8d 	bl	4400 <set_error>
    b = u->DR;
    44e6:	9b04      	ldr	r3, [sp, #16]
    44e8:	685b      	ldr	r3, [r3, #4]
    44ea:	f88d 300d 	strb.w	r3, [sp, #13]
    if (sr & USART_SR_RXNE)
    44ee:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    44f2:	f003 0320 	and.w	r3, r3, #32
    44f6:	2b00      	cmp	r3, #0
    44f8:	d005      	beq.n	4506 <serve_interrupt+0x86>
      sdIncomingDataI(sdp, b);
    44fa:	f89d 300d 	ldrb.w	r3, [sp, #13]
    44fe:	9801      	ldr	r0, [sp, #4]
    4500:	4619      	mov	r1, r3
    4502:	f7fe ff65 	bl	33d0 <sdIncomingDataI>
    sr = u->SR;
    4506:	9b04      	ldr	r3, [sp, #16]
    4508:	681b      	ldr	r3, [r3, #0]
    450a:	f8ad 3016 	strh.w	r3, [sp, #22]
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
    450e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    4512:	f003 032f 	and.w	r3, r3, #47	; 0x2f
    4516:	2b00      	cmp	r3, #0
    4518:	d1d9      	bne.n	44ce <serve_interrupt+0x4e>
    b = u->DR;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
  }
  osalSysUnlockFromISR();
    451a:	f7ff ff09 	bl	4330 <osalSysUnlockFromISR>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    451e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    4522:	f003 0380 	and.w	r3, r3, #128	; 0x80
    4526:	2b00      	cmp	r3, #0
    4528:	d024      	beq.n	4574 <serve_interrupt+0xf4>
    452a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    452e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    4532:	2b00      	cmp	r3, #0
    4534:	d01e      	beq.n	4574 <serve_interrupt+0xf4>
    msg_t b;
    osalSysLockFromISR();
    4536:	f7ff fef3 	bl	4320 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
    453a:	9b01      	ldr	r3, [sp, #4]
    453c:	3330      	adds	r3, #48	; 0x30
    453e:	4618      	mov	r0, r3
    4540:	f7fe fa66 	bl	2a10 <chOQGetI>
    4544:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
    4546:	9b02      	ldr	r3, [sp, #8]
    4548:	2b00      	cmp	r3, #0
    454a:	da0e      	bge.n	456a <serve_interrupt+0xea>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    454c:	9b01      	ldr	r3, [sp, #4]
    454e:	3304      	adds	r3, #4
    4550:	4618      	mov	r0, r3
    4552:	2108      	movs	r1, #8
    4554:	f7ff fef4 	bl	4340 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    4558:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    455c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    4560:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    4564:	9b04      	ldr	r3, [sp, #16]
    4566:	60da      	str	r2, [r3, #12]
    4568:	e002      	b.n	4570 <serve_interrupt+0xf0>
    }
    else
      u->DR = b;
    456a:	9a02      	ldr	r2, [sp, #8]
    456c:	9b04      	ldr	r3, [sp, #16]
    456e:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
    4570:	f7ff fede 	bl	4330 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    4574:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    4578:	f003 0340 	and.w	r3, r3, #64	; 0x40
    457c:	2b00      	cmp	r3, #0
    457e:	d01b      	beq.n	45b8 <serve_interrupt+0x138>
    osalSysLockFromISR();
    4580:	f7ff fece 	bl	4320 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
    4584:	9b01      	ldr	r3, [sp, #4]
    4586:	3330      	adds	r3, #48	; 0x30
    4588:	4618      	mov	r0, r3
    458a:	f7ff fea9 	bl	42e0 <chOQIsEmptyI>
    458e:	4603      	mov	r3, r0
    4590:	2b00      	cmp	r3, #0
    4592:	d005      	beq.n	45a0 <serve_interrupt+0x120>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    4594:	9b01      	ldr	r3, [sp, #4]
    4596:	3304      	adds	r3, #4
    4598:	4618      	mov	r0, r3
    459a:	2110      	movs	r1, #16
    459c:	f7ff fed0 	bl	4340 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
    45a0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    45a4:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    45a8:	9b04      	ldr	r3, [sp, #16]
    45aa:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
    45ac:	9b04      	ldr	r3, [sp, #16]
    45ae:	f06f 0240 	mvn.w	r2, #64	; 0x40
    45b2:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
    45b4:	f7ff febc 	bl	4330 <osalSysUnlockFromISR>
  }
}
    45b8:	b007      	add	sp, #28
    45ba:	f85d fb04 	ldr.w	pc, [sp], #4
    45be:	bf00      	nop

000045c0 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
    45c0:	b082      	sub	sp, #8
    45c2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
    45c4:	4b03      	ldr	r3, [pc, #12]	; (45d4 <notify1+0x14>)
    45c6:	4a03      	ldr	r2, [pc, #12]	; (45d4 <notify1+0x14>)
    45c8:	68d2      	ldr	r2, [r2, #12]
    45ca:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    45ce:	60da      	str	r2, [r3, #12]
}
    45d0:	b002      	add	sp, #8
    45d2:	4770      	bx	lr
    45d4:	40011000 	.word	0x40011000
    45d8:	f3af 8000 	nop.w
    45dc:	f3af 8000 	nop.w

000045e0 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
    45e0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
    45e2:	f7fd fa7d 	bl	1ae0 <_stats_increase_irq>
    45e6:	f7fc fa13 	bl	a10 <_dbg_check_enter_isr>

  serve_interrupt(&SD1);
    45ea:	4804      	ldr	r0, [pc, #16]	; (45fc <VectorD4+0x1c>)
    45ec:	f7ff ff48 	bl	4480 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
    45f0:	f7fc fa2e 	bl	a50 <_dbg_check_leave_isr>
    45f4:	f7fe fc5c 	bl	2eb0 <_port_irq_epilogue>
}
    45f8:	bd08      	pop	{r3, pc}
    45fa:	bf00      	nop
    45fc:	200011e0 	.word	0x200011e0

00004600 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
    4600:	b508      	push	{r3, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
    4602:	4805      	ldr	r0, [pc, #20]	; (4618 <sd_lld_init+0x18>)
    4604:	2100      	movs	r1, #0
    4606:	4a05      	ldr	r2, [pc, #20]	; (461c <sd_lld_init+0x1c>)
    4608:	f7fe fe8a 	bl	3320 <sdObjectInit>
  SD1.usart = USART1;
    460c:	4b02      	ldr	r3, [pc, #8]	; (4618 <sd_lld_init+0x18>)
    460e:	4a04      	ldr	r2, [pc, #16]	; (4620 <sd_lld_init+0x20>)
    4610:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
    4614:	bd08      	pop	{r3, pc}
    4616:	bf00      	nop
    4618:	200011e0 	.word	0x200011e0
    461c:	000045c1 	.word	0x000045c1
    4620:	40011000 	.word	0x40011000
    4624:	f3af 8000 	nop.w
    4628:	f3af 8000 	nop.w
    462c:	f3af 8000 	nop.w

00004630 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
    4630:	b500      	push	{lr}
    4632:	b083      	sub	sp, #12
    4634:	9001      	str	r0, [sp, #4]
    4636:	9100      	str	r1, [sp, #0]

  if (config == NULL)
    4638:	9b00      	ldr	r3, [sp, #0]
    463a:	2b00      	cmp	r3, #0
    463c:	d101      	bne.n	4642 <sd_lld_start+0x12>
    config = &default_config;
    463e:	4b0d      	ldr	r3, [pc, #52]	; (4674 <sd_lld_start+0x44>)
    4640:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
    4642:	9b01      	ldr	r3, [sp, #4]
    4644:	7a1b      	ldrb	r3, [r3, #8]
    4646:	2b01      	cmp	r3, #1
    4648:	d10d      	bne.n	4666 <sd_lld_start+0x36>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
    464a:	9a01      	ldr	r2, [sp, #4]
    464c:	4b0a      	ldr	r3, [pc, #40]	; (4678 <sd_lld_start+0x48>)
    464e:	429a      	cmp	r2, r3
    4650:	d109      	bne.n	4666 <sd_lld_start+0x36>
      rccEnableUSART1(FALSE);
    4652:	4b0a      	ldr	r3, [pc, #40]	; (467c <sd_lld_start+0x4c>)
    4654:	4a09      	ldr	r2, [pc, #36]	; (467c <sd_lld_start+0x4c>)
    4656:	6c52      	ldr	r2, [r2, #68]	; 0x44
    4658:	f042 0210 	orr.w	r2, r2, #16
    465c:	645a      	str	r2, [r3, #68]	; 0x44
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    465e:	2025      	movs	r0, #37	; 0x25
    4660:	210c      	movs	r1, #12
    4662:	f7fe feed 	bl	3440 <nvicEnableVector>
      rccEnableUART8(FALSE);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
    4666:	9801      	ldr	r0, [sp, #4]
    4668:	9900      	ldr	r1, [sp, #0]
    466a:	f7ff fe79 	bl	4360 <usart_init>
}
    466e:	b003      	add	sp, #12
    4670:	f85d fb04 	ldr.w	pc, [sp], #4
    4674:	00004ae0 	.word	0x00004ae0
    4678:	200011e0 	.word	0x200011e0
    467c:	40023800 	.word	0x40023800

00004680 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
    4680:	b508      	push	{r3, lr}

  stm32_clock_init();
    4682:	f7fe ff5d 	bl	3540 <stm32_clock_init>
}
    4686:	bd08      	pop	{r3, pc}
    4688:	f3af 8000 	nop.w
    468c:	f3af 8000 	nop.w

00004690 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
    4690:	4770      	bx	lr
    4692:	bf00      	nop
    4694:	f3af 8000 	nop.w
    4698:	f3af 8000 	nop.w
    469c:	f3af 8000 	nop.w
    46a0:	656c6469 	.word	0x656c6469
	...
    46b0:	31235653 	.word	0x31235653
    46b4:	00000000 	.word	0x00000000
    46b8:	32235653 	.word	0x32235653
    46bc:	00000000 	.word	0x00000000
    46c0:	33235653 	.word	0x33235653
    46c4:	00000000 	.word	0x00000000
    46c8:	34235653 	.word	0x34235653
    46cc:	00000000 	.word	0x00000000
    46d0:	35235653 	.word	0x35235653
    46d4:	00000000 	.word	0x00000000
    46d8:	36235653 	.word	0x36235653
    46dc:	00000000 	.word	0x00000000
    46e0:	37235653 	.word	0x37235653
    46e4:	00000000 	.word	0x00000000
    46e8:	38235653 	.word	0x38235653
    46ec:	00000000 	.word	0x00000000
    46f0:	39235653 	.word	0x39235653
    46f4:	00000000 	.word	0x00000000
    46f8:	31235653 	.word	0x31235653
    46fc:	00000030 	.word	0x00000030
    4700:	31235653 	.word	0x31235653
    4704:	00000031 	.word	0x00000031
	...
    4710:	63617473 	.word	0x63617473
    4714:	766f206b 	.word	0x766f206b
    4718:	6c667265 	.word	0x6c667265
    471c:	0000776f 	.word	0x0000776f

00004720 <__func__.6011>:
    4720:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

00004730 <__func__.6628>:
    4730:	54566863 65536f44 00004974 00000000     chVTDoSetI......

00004740 <__func__.6636>:
    4740:	54566863 65526f44 49746573 00000000     chVTDoResetI....

00004750 <__func__.6625>:
    4750:	63536863 61655268 00497964 00000000     chSchReadyI.....

00004760 <__func__.6637>:
    4760:	68546863 65724364 49657461 00000000     chThdCreateI....

00004770 <__func__.5925>:
    4770:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004780 <__func__.6653>:
    4780:	68546863 74655364 6f697250 79746972     chThdSetPriority
	...

000047a0 <__func__.6096>:
    47a0:	68546863 656c5364 00537065 00000000     chThdSleepS.....

000047b0 <__func__.6681>:
    47b0:	68546863 69784564 00005374 00000000     chThdExitS......

000047c0 <__func__.6686>:
    47c0:	68546863 69615764 00000074 00000000     chThdWait.......

000047d0 <__func__.6703>:
    47d0:	68546863 73655264 49656d75 00000000     chThdResumeI....

000047e0 <__func__.6108>:
    47e0:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
    47f0:	00497478 00000000 00000000 00000000     xtI.............

00004800 <__func__.5925>:
    4800:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004810 <__func__.6625>:
    4810:	68546863 6c655264 65736165 00000000     chThdRelease....

00004820 <ch_debug>:
    4820:	6e69616d 18021600 08600404 1814100c     main......`.....
    4830:	2221201c 00000000 00000000 00000000     . !"............

00004840 <__func__.6621>:
    4840:	65536863 6a624f6d 49746365 0074696e     chSemObjectInit.

00004850 <__func__.6652>:
    4850:	65536863 6961576d 6d695474 74756f65     chSemWaitTimeout
    4860:	00000053 00000000 00000000 00000000     S...............

00004870 <__func__.6660>:
    4870:	65536863 6769536d 496c616e 00000000     chSemSignalI....

00004880 <__func__.6620>:
    4880:	744d6863 6a624f78 49746365 0074696e     chMtxObjectInit.

00004890 <__func__.5925>:
    4890:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000048a0 <__func__.6628>:
    48a0:	744d6863 636f4c78 0000536b 00000000     chMtxLockS......

000048b0 <__func__.6651>:
    48b0:	744d6863 6c6e5578 006b636f 00000000     chMtxUnlock.....

000048c0 <__func__.6645>:
    48c0:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
    48d0:	49736761 00000000 00000000 00000000     agsI............

000048e0 <__func__.6662>:
    48e0:	76456863 67695374 496c616e 00000000     chEvtSignalI....

000048f0 <__func__.6622>:
    48f0:	424d6863 656a624f 6e497463 00007469     chMBObjectInit..

00004900 <__func__.5925>:
    4900:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004910 <__func__.6642>:
    4910:	424d6863 74736f50 00000053 00000000     chMBPostS.......

00004920 <__func__.6678>:
    4920:	424d6863 63746546 00005368 00000000     chMBFetchS......

00004930 <__func__.5925>:
    4930:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004940 <__func__.6648>:
    4940:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.

00004950 <__func__.6684>:
    4950:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

00004970 <__func__.5925>:
    4970:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004980 <__func__.6644>:
    4980:	65486863 72467061 00006565 00000000     chHeapFree......

00004990 <__func__.5925>:
    4990:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

000049a0 <__func__.6646>:
    49a0:	6f506863 72466c6f 00496565 00000000     chPoolFreeI.....

000049b0 <__func__.7143>:
    49b0:	74537473 41747261 6d72616c 00000000     stStartAlarm....

000049c0 <__func__.7150>:
    49c0:	65537473 616c4174 00006d72 00000000     stSetAlarm......

000049d0 <vmt>:
    49d0:	000031b1 000031e1 00003211 00003241     .1...1...2..A2..
    49e0:	00003261 00003291 000032b1 000032e1     a2...2...2...2..

000049f0 <__func__.7188>:
    49f0:	74536473 00747261 00000000 00000000     sdStart.........

00004a00 <__func__.5925>:
    4a00:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

00004a10 <__func__.7197>:
    4a10:	6e496473 696d6f63 6144676e 00496174     sdIncomingDataI.

00004a20 <_stm32_dma_streams>:
    4a20:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
    4a30:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
    4a40:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
    4a50:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
    4a60:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
    4a70:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
    4a80:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
    4a90:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
    4aa0:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
    4ab0:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
    4ac0:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
    4ad0:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

00004ae0 <default_config>:
    4ae0:	00002580 40000000 00000000 00000000     .%.....@........

00004af0 <pal_default_config>:
    4af0:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
    4b00:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
    4b10:	00000240 ffffffff 55514515 0000ffff     @........EQU....
    4b20:	04000000 00000040 02208001 00000000     ....@..... .....
    4b30:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
    4b40:	00060600 55000100 00000000 ffffffff     .......U........
    4b50:	00555055 00000fff 00000000 00000000     UPU.............
    4b60:	00000040 00000000 ffffffff 00000000     @...............
    4b70:	0000ffff 00000000 00000000 00000000     ................
    4b80:	00000000 ffffffff 00000000 0000ffff     ................
	...
    4ba0:	ffffffff 00000000 0000ffff 00000000     ................
	...
    4bbc:	ffffffff 00000000 0000ffff 00000000     ................
	...
    4bd8:	ffffffff 00000000 0000ffff 00000000     ................
    4be8:	00000000                                ....
